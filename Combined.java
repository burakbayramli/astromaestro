// commons-lang3-3.13.0.jar is needed for compilation
import java.util.Calendar;
import java.util.Date;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Arrays;
import java.text.*;  // DateFormat etc.
import java.util.*;
import java.net.*;
import java.io.*;
import java.util.StringTokenizer;
import java.util.TimeZone;
import java.math.*;

class AyaInit {
  double t0;
  double ayan_t0;

  AyaInit(double t0, double ayan_t0) {
    this.t0=t0;
    this.ayan_t0=ayan_t0;
  }
}


class CFmt {
  // public:
  // Constructors:

  /**
  * This creates a new instance with a default of 8 as the hexByteCount.
  * @see #setHexByteCnt
  */
  public CFmt() {
    this.hexByteCnt=8;
  }

  /**
  * This creates a new instance with the specified value as hexByteCnt.
  * @param hexByteCnt How many bytes a hexadecimal number will contain
  * maximum (4 or 8).
  * @see #setHexByteCnt
  */
  public CFmt(int hexByteCnt) {
    setHexByteCnt(hexByteCnt);
  }


  // Public Methods: /////////////////////////////////////////////////////////

  /**
  * The Hexadecimal-Byte-Count is ONLY relevant to negative numbers of one of
  * byte, short and int and type of 'o', 'x', 'X', 'p'. It specifies how
  * many bytes maximum a resulting hexadecimal number will contain.<P>
  * Examples:<P>
  * -1 will be displayed with a format of "%x" and hexByteCnt of 4 as:<P>
  * <CODE>
  * ffffffff
  * </CODE><P>
  * and with a hexByteCnt of 8 as:<P>
  * <CODE>
  * ffffffffffffffff
  * </CODE><P>
  * In C the default seems to be 4 bytes, the default here is 8 bytes.
  * Possible values are 4 and 8, other values will NOT change the last value!
  * @param hexByteCnt How many bytes to use for output of negative
  * hexadecimal numbers.
  */
  public void setHexByteCnt(int hexByteCnt) {
    if (hexByteCnt==8 || hexByteCnt==4) {
      this.hexByteCnt=hexByteCnt;
    }
  }

  /**
  * Returns the current value for hexByteCnt.
  * @return the current value of hexByteCnt
  * @see #setHexByteCnt(int)
  */
  public int getHexByteCnt() {
    return this.hexByteCnt;
  }




  // Methods for conversion: /////////////////////////////////////////////////
  // char "c":
  /**
  * Formats a character as specified by the conversion specification.
  * @param conv the conversion specification. It may only contain the
  * character 'c' as conversion character.
  * @param c the char that should become formatted
  * @return A String containing the formatted character
  */
  public String fmt( String conv, char c ) {
    return fmt(conv, new Character(c).toString());
  }


  // Strings "s":
  /**
  * Formats a String as specified by the conversion specification.
  * @param conv the conversion specification. It may only contain the
  * character 's' as conversion character.
  * @param s the String that should become formatted
  * @return A String containing the formatted String
  */
  public String fmt( String conv, String s ) {
    CFmtCvt cv = new CFmtCvt(conv);
    if (cv.type=='c') {
      s=s.substring(0,1);
    } else if (cv.type!='s') {
      return "";
    }

    // Precision:
    if (cv.withPrec && cv.precision<s.length() && cv.type!='c') {
      s=s.substring(0,cv.precision);
    }

    // MinimumFieldWidth:
    if (cv.minimum>320) { cv.minimum=320; }
    String padString=empty;
    if (cv.padChar=='0' && !cv.fMinus) { padString=zeros; }
    if (cv.withMin && s.length()<cv.minimum) {
      if (cv.fMinus) {
        s+=padString.substring(0,cv.minimum-s.length());
      } else {
        s=padString.substring(0,cv.minimum-s.length())+s;
      }
    }

    return s;
  }



  // byte d,i,o,p,u,x,X:
  /**
  * Formats a byte as specified by the conversion specification.
  * @param conv the conversion specification. It may contain the
  * characters 'd', 'i', 'o', 'p', 'u', 'x' and 'X' as conversion
  * characters.
  * @param bval the byte value that should become formatted
  * @return A String containing the formatted byte value
  */
  public String fmt( String conv, byte bval ) {
    return intFmt(conv, (long) bval, 'b');
  }

  // integer d,i,o,p,u,x,X:
  /**
  * Formats an integer as specified by the conversion specification.
  * @param conv the conversion specification. It may contain the
  * characters 'd', 'i', 'o', 'p', 'u', 'x' and 'X' as conversion
  * characters.
  * @param ival the integer value that should become formatted
  * @return A String containing the formatted integer value
  */
  public String fmt( String conv, int ival  ) {
    return intFmt(conv, (long) ival, 'i');
  }

  // long d,i,o,p,u,x,X:
  /**
  * Formats a long value as specified by the conversion specification.
  * @param conv the conversion specification. It may contain the
  * characters 'd', 'i', 'o', 'p', 'u', 'x' and 'X' as conversion
  * characters.
  * @param lval the long value that should become formatted
  * @return A String containing the formatted long value
  */
  public String fmt( String conv, long lval  ) {
    return intFmt(conv, lval, 'l');
  }



  // float f, e, E, g, G:
  /**
  * Formats a float value as specified by the conversion specification.
  * @param conv the conversion specification. It may contain the
  * characters 'f', 'e', 'E', 'g' and 'G' as conversion characters.
  * @param fval the float value that should become formatted
  * @return A String containing the formatted float value
  */
  public String fmt( String conv, float fval  ) {
    return fmt( conv, (double)fval );
  }

  // double f, e, E, g, G:
  /**
  * Formats a double value as specified by the conversion specification.
  * @param conv the conversion specification. It may contain the
  * characters 'f', 'e', 'E', 'g' and 'G' as conversion characters.
  * @param dval the double value that should become formatted
  * @return A String containing the formatted double value
  */
  public String fmt( String conv, double dval  ) {
    CFmtCvt cv = new CFmtCvt(conv);
    boolean isG=false;
    boolean neg=false;
    String res="";

    neg=(Double.doubleToLongBits(dval)&0x8000000000000000L)!=0L;

    if (Double.isNaN(dval)) { res="nan"; }
    if (dval == Double.NEGATIVE_INFINITY ||
        dval == Double.POSITIVE_INFINITY) {
      if (cv.precision<8) { res="Inf";
      } else { res="Infinity";
      }
    }
    if (neg) { dval=-dval; }

    if (res=="") {
      if (!cv.withPrec) { cv.precision=6; cv.withPrec=true; }

      if (cv.type=='g' || cv.type=='G') { isG=true; }

// Rounding is not accurate!!!
double dval_tmp=dval; // postpone rounding
      // Rounding:
      // cv.precision:
      // e, E, f: no. of digits after decimalpoint
      // g, G   : max. no. of significant digits
      int pexp=0;
      int nexp=0;
      if (dval_tmp!=0.) {
        double fd=dval_tmp;
        while (fd>=10.) { fd/=10.; pexp++; }
        while (fd<1.) { fd*=10.; nexp++; }
        if (isG) {
          if (cv.precision==0) { cv.precision++; }
          dval_tmp+=5*Math.pow(10,pexp-nexp-cv.precision);
        } else {
          if (cv.type=='e' || cv.type=='E') { // Exponential number:
            dval_tmp+=5*Math.pow(10,-cv.precision-1+pexp-nexp);
          } else { // Floatingpoint number without exponent:
            dval_tmp+=5*Math.pow(10,-cv.precision-1);
          }
        }
      }

      // Mapping 'g' and 'G' to 'f', 'e' or 'E' and changing the meaning
      // of 'precision' to the meaning of precision in 'f, 'e', 'E'
      // (precision='f', 'e', 'E': Count of digits after the decimalpoint
      //            'g', 'G':      Count of all signifikant digits):
      if (isG) {
        if (dval_tmp!=0. && (dval_tmp<1E-4 || dval_tmp>=Math.pow(10,cv.precision))) {
          if (cv.precision>0) { cv.precision--; } // Digit before decimalpoint
          if (cv.type=='g') { cv.type='e';
          } else { cv.type='E';
          }
        } else {
          cv.precision=cv.precision-pexp-1+nexp;
          cv.type='f';
        }
        if (cv.precision<0) { cv.precision=0; }
      }

      if (cv.type!='f' && cv.type!='e' && cv.type!='E') {
        return "";
      }

      String integer="";
      String mantisse="";
      int exponent=0;
      int i;

      // Zahl zerlegen in Integer-Anteil, Mantisse und Exponenten:
//DevNull.println("\n@@@ "+Long.toBinaryString(Double.doubleToLongBits(dval)));
//      res=Double.toString(dval);
res=dblToString(dval,cv.precision); // Includes rounding!!!
//DevNull.println(">>> "+res);
      exponent=res.indexOf(".")-1;
      integer=res.substring(0,exponent+1);
      mantisse=res.substring(exponent+2);
      if (mantisse.indexOf("E")>=0) {
        exponent+=Integer.parseInt(mantisse.substring(mantisse.indexOf("E")+1));
        mantisse=mantisse.substring(0,mantisse.indexOf("E"));
      }

      // "integer" is supposed to hold all digits
      if (integer.charAt(0)=='0' && dval!=0.) {
        exponent--; i=0;
        integer=integer.substring(1);
        while (i<mantisse.length() && mantisse.charAt(i)=='0') {
          exponent--; i++;
        }
        mantisse=mantisse.substring(i);
      }
      integer+=mantisse;
      mantisse="";

      // Separating integer part and mantissa into the desired forms ('f', 'e')
      if (cv.type=='f') {
        if (exponent<0) {
          mantisse=zeros.substring(0,-exponent-1)+integer;
          integer="0";
        } else {
          if (integer.length()<exponent+1) {
            integer+=zeros.substring(0,exponent+1-integer.length());
          }
          mantisse=integer.substring(exponent+1);
          integer=integer.substring(0,exponent+1);
        }
      } else { // Exponential form
        mantisse=integer.substring(1);
        integer=integer.substring(0,1);
      }

      // Precision:
      if (cv.precision>320) { cv.precision=320; }
      // Count of digits after the decimalpoint:
      int len=mantisse.length();
      if (cv.precision>len && (!isG || cv.fHash)) {
        // Add '0's:
        mantisse+=zeros.substring(0,cv.precision-len);
      } else if (cv.precision<len) {
        // Truncate:
        mantisse=mantisse.substring(0,cv.precision);
      }
      if (isG && !cv.fHash) {
        // Truncate leftover zeros at the end of the mantissa:
        i=mantisse.length()-1;
        while (i>=0 && mantisse.charAt(i)=='0') {
          i--;
        }
        mantisse=mantisse.substring(0,i+1);
      }

      res=integer;
      if (cv.fHash || (cv.withPrec && !isG && cv.precision>0) ||
          (isG && cv.withPrec && mantisse.length()>0 )) {
        res+="."+mantisse;
      }

      if (cv.type=='e' || cv.type=='E') {
        if (cv.type=='e') { res+="e"; } else { res+='E'; }
        if (exponent<0) {
          exponent=-exponent; res+="-";
        } else {
          res+="+";
        }
        if (exponent<10) {
          res+="0";
        }
        res+=Integer.toString(exponent);
      }
    }

    String prefix="";
    if (neg) { prefix="-";
    } else if (cv.fPlus) { prefix="+";
    } else if (cv.fSpace) { prefix=" ";
    }

    if (cv.withMin && cv.padChar=='0') {
      int len=prefix.length();
      // Pad left, before a sign or others will be prefixed!
      if (res.length()+len<cv.minimum && !cv.fMinus) {
        res=zeros.substring(0,cv.minimum-res.length()-len)+res;
      }
    }
    res=prefix+res;


    // MinimumFieldWidth:
    if (cv.withMin) {
      if (res.length()<cv.minimum) {
        if (cv.minimum>320) { cv.minimum=320; }
        if (cv.fMinus) {
          res+=empty.substring(0,cv.minimum-res.length());
        } else {
          String padString=empty;
          if (cv.padChar=='0') { padString=zeros; }
          res=padString.substring(0,cv.minimum-res.length())+res;
        }
      }
    }

    return res;
  } // double







  // Private Methods: ////////////////////////////////////////////////////////
  private String intFmt( String conv, long lval, char baseType ) {
    CFmtCvt cv = new CFmtCvt(conv);
    if (cv.type!='d' && cv.type!='i' && cv.type!='o' && cv.type!='p' &&
        cv.type!='u' && cv.type!='x' && cv.type!='X') {
      return "";
    }
    if (baseType=='l' && cv.type=='u') { return ""; }

    boolean neg=false;
    String res="";
    String padString=empty;

    if (cv.type=='d' || cv.type=='i') { // signed decimal
      if (lval<0) { lval=-lval; neg=true; }
      res=String.valueOf(lval);
    } else if (cv.type=='o') { // unsigned octal
      res=Long.toOctalString(lval);
      if (lval<0 && this.hexByteCnt==4 && baseType!='l') {
        // 1 777 777 777 777 777 777 777 -> 37777777777 [         -1]
        // 1 777 777 777 760 000 000 000 -> 20000000000 [-2147483648]
        if (res.charAt(11)=='7') {
          res="3"+res.substring(12);
        } else {
          res="2"+res.substring(12);
        }
      }
    } else if (cv.type=='u') { // unsigned decimal
      if (lval>=0) {
        res=Long.toString(lval);
      } else { // Negative number to be interpreted as positive
        res=Long.toString(256L*256L*256L*256L+lval);
      }
    } else if (cv.type=='x' || cv.type=='p' || cv.type=='X') {
                                                     // unsigned hexadecimal
      // "p" exists ONLY as "%p" without any modifications and then seems to
      // be identical with "%x"!
      res=Long.toHexString(lval);
      if (cv.type=='p' && (cv.withPrec || cv.withMin || cv.fMinus ||
                                    cv.fPlus || cv.fSpace || cv.fHash)) {
        return "";
      }
      if (this.hexByteCnt==4 && baseType!='l') { res=res.substring(8); }
    }

    // Precision:
    // Minimum count of digits (WITHOUT sign!). Add zeros before the number
    // if necessary.
    if (!cv.withPrec) { cv.precision=1; }
    if (cv.precision>320) { cv.precision=320; }
    if (cv.precision>res.length()) {
      res=zeros.substring(0,cv.precision-res.length())+res;
    } else if (cv.precision==0 && lval==0) {
      res="";
    }

    String prefix="";
    if (cv.type=='d' || cv.type=='i') { // negative / positive
      // Flags:
      if (neg) {
        prefix="-";
      } else if (cv.fPlus) {
        prefix="+";
      } else if (cv.fSpace) {
        prefix=" ";
      }
    } else if (cv.type=='o' && cv.fHash && res.charAt(0)!='0') {
      res="0"+res;
    } else if (cv.fHash && lval!=0 && (cv.type=='x' || cv.type=='X')) {
      prefix="0x";
    }


    // MinimumFieldWidth:
    if (cv.minimum>320) { cv.minimum=320; }
    if (cv.withPrec) { cv.padChar=' '; }
    if (cv.padChar=='0' && !cv.fMinus) { padString=zeros; }
    if (cv.withMin) {
      if (cv.padChar=='0') {
        // First pad, then add sign in front:
        int len=prefix.length();
        if (res.length()+len<cv.minimum) {
          res=padString.substring(0,cv.minimum-res.length()-len)+res;
        }
        res=prefix+res;
      } else {
        // First the sign, then pad the string
        res=prefix+res;
        if (res.length()<cv.minimum) {
          if (cv.fMinus) {
            res+=empty.substring(0,cv.minimum-res.length());
          } else {
            res=empty.substring(0,cv.minimum-res.length())+res;
          }
        }
      }
    } else {
      res=prefix+res;
    }

    if (cv.type=='X') { // ALL letters uppercase
      res=res.toUpperCase();
    }

    return res;
  }

  private int hexByteCnt;

  // 340 chars (how much max.?)
  static private final String empty="                                        "+
        "                                                            "+
        "                                                            "+
        "                                                            "+
        "                                                            "+
        "                                                            ";
  static private final String zeros="0000000000000000000000000000000000000000"+
        "000000000000000000000000000000000000000000000000000000000000"+
        "000000000000000000000000000000000000000000000000000000000000"+
        "000000000000000000000000000000000000000000000000000000000000"+
        "000000000000000000000000000000000000000000000000000000000000"+
        "000000000000000000000000000000000000000000000000000000000000";

  private BigDecimal const2_52=new BigDecimal("2251799813685248");
  private BigDecimal const2=new BigDecimal("2");

  private String dblToString(double d, int prec) {
    long exp, i, lMant;
    boolean nexp=false;

// Fuer positive Zahlen gilt:
// 2^(Exponent+1) + 2^Exponent * Mantisse / 2^51
//
// mit Exponent    = double_bitmap & 0x3ff0000000000000,
// Exp. Vorzeichen = double_bitmap & 0x4000000000000000
// und Mantisse    = double_bitmap & 0x000fffffffffffff
//

    lMant=Double.doubleToLongBits(d)&0x000fffffffffffffL;
    exp =(Double.doubleToLongBits(d)&0x3ff0000000000000L) >> 52;
    nexp=(Double.doubleToLongBits(d)&0x4000000000000000L) == 0L;
    if (nexp) { exp=-1024+exp; }

    BigDecimal mant=new BigDecimal(Long.toString(lMant));
    BigDecimal res=new BigDecimal("0");

    BigDecimal res1;
    if (exp==0 && lMant==0L) {
      res1=new BigDecimal("0");
    } else {
      res1=new BigDecimal("1");
      if (exp>0) {
        for(i=0; i<exp; i++) {
          res1=res1.multiply(const2);
        }
      } else {
        for(i=0; i>exp; i--) {
          res1=res1.divide(const2,50,BigDecimal.ROUND_HALF_UP);
        }
      }
    }

    res=res1.multiply(const2);
    res=res.add(res1.multiply(mant.divide(const2_52,50,BigDecimal.ROUND_HALF_UP)));
    res=res.add((new BigDecimal("5")).movePointLeft(prec+1));

    return res.toString();
  }

} // End of class CFmt




class CFmtCvt { // Interprets a formatting string
  char flag='\0';
  boolean fMinus=false;
  boolean fPlus=false;
  boolean fSpace=false;
  boolean fHash=false;
  char padChar=' ';
  int minimum=0;
  int precision=0;
  boolean longSpec=false; // longSpec does not have any meaning???
  char type='\0';

  boolean withMin=false;
  boolean withPrec=false;
  boolean validConv=false;

  CFmtCvt(String cv) {
    char ch;
    int len=cv.length()-1;

    if (len>=1 && cv.charAt(0)=='%') {
      int i=1;

      type=cv.charAt(len); len--;
      if (cv.charAt(len)=='l') { longSpec=true; len--; }

      // Flags:
      do {
        ch=cv.charAt(i);
        if (ch=='-')      { fMinus=true; }
        else if (ch=='+') { fPlus=true;  }
        else if (ch==' ') { fSpace=true; }
        else if (ch=='#') { fHash=true;  }
        i++;
      } while (i<=len && (ch=='-' || ch=='+' || ch==' ' || ch=='#'));
      i--;

      // Minimum fieldwidth:
      ch=cv.charAt(i);
      if (ch=='0') {
        withMin=true;
        padChar='0';
        withMin=true;
        i++; if (i>len) { return; }
        ch=cv.charAt(i);
      }
      if (Character.isDigit(ch)) {
        withMin=true;
        minimum=Character.digit(ch,10);
        i++; if (i>len) { return; }
        ch=cv.charAt(i);
        while (Character.isDigit(ch)) {
          minimum=10*minimum+Character.digit(ch,10);
          i++; if (i>len) { return; }
          ch=cv.charAt(i);
        }
      }

      // Precision:
      if (ch=='.') {
        withPrec=true;
        i++; if (i>len) { return; }
        ch=cv.charAt(i);
        while (Character.isDigit(ch)) {
          precision=10*precision+Character.digit(ch,10);
          i++; ch=cv.charAt(i);
        }
      }
    }
  }
} // End of class CFmtCvt
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


/**
* This class enables methods to return doubles by reference. We need this
* here, as this is a very direct port from C to Java, where reference
* parameters are used from time to time.
* <P><I><B>You will find the complete documentation for the original
* SwissEphemeris package at <A HREF="http://www.astro.ch/swisseph/sweph_g.htm">
* http://www.astro.ch/swisseph/sweph_g.htm</A>. By far most of the information
* there is directly valid for this port to Java as well.</B></I>
* @version 1.0.0b
*/
class DblObj {
  /**
  * This is the double value that has become wrapped up into a real object.
  */
  public double val;

// //#ifdef TRACE0
//   public DblObj() {
//     DevNull.println(System.currentTimeMillis()+" DblObj()");
//   }
// //#endif /* TRACE0 */

}


class DevNull {

  public static void print(String s) {}

  public static void println(String s) {}

  public static void println() {}

}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class Epsilon {
  /* obliquity of ecliptic */
  double teps, eps, seps, ceps;         /* jd, eps, sin(eps), cos(eps) */

  void clearData() {
    teps=0.0;
    eps=0.0;
    seps=0.0;
    ceps=0.0;
  }


}
/*
   This is an extension to the Java port of the Swiss Ephemeris package
   of Astrodienst AG, Zuerich (Switzerland).

   Thomas Mack, mack@ifis.cs.tu-bs.de, 3rd of December, 2001

*/




class Extensions {

  SwissEph sw;

  Extensions(SwissEph sw) {
    this.sw = sw;
  }




  // transitVal is the longitude or latitude or speed, for which the
  // transit is to be calculated.
  // getTransit() will return the current date and time, when the
  // transit ist occuring on that date. If you really want the next
  // transit AFTER that date, add at least calcTimePrecision(...) to
  // your jdET, as this is the minimum time difference, for which the
  // available precision allows.
  // You can NOT rely on the assumption that you will get realistically
  // differentiable transit values with a time difference of
  // calcTimePrecision(...), but at least it does not make ANY sense
  // to recalculate a transit with a time difference SMALLER than the
  // value returned by calcTimePrecision().
  //
  // A problem:
  // When a transit takes a long time, this means, when the planet
  // stays a long time very near to the transit point, the program
  // may appear to be abitrary in its results. The reason is, that
  // it does not look for the EXACT transit point, but for an area
  // around the exact transit point that is defined by the maximum
  // available precision for the position calculation.

  // You may get many transits for just one planetary transit, as we
  // cannot differentiate transits, when they are in an area of values
  // which is beyond the maximum available precision. E.g., when the
  // sun is in the latitudinal area of 0.0019 to 0.0021 for maybe two
  // days, there is no chance to differentiate between any dates in
  // this area of time: You will get the input date returned as the
  // transit date always, when the input date is in the area of these
  // two days.
  double getTransit(TransitCalculator tc, double jdET, boolean back,
                    double jdMax)
         throws IllegalArgumentException, SwissephException {
//System.err.println(" -- " + (""+jdET).substring(0,Math.min((""+jdET).length(),12)) + " - " + jdMax);
    double max = tc.getMaxSpeed();
    double min = tc.getMinSpeed();

    double jdPlus, jdMinus;
    double lastJD = jdET;

    boolean found = false;
    boolean above;
    double lastVal;
    double val;
    double offset = tc.getOffset();



    boolean xneg = (max < 0);
    boolean mneg = (min < 0);
    if (!xneg && !mneg) { min = max; }
    if (xneg && mneg) { max = min; }

    double degPrec = tc.getDegreePrecision(jdET)/2.; // Divided by two to have a range of +-degPrec
    double timePrec = tc.getTimePrecision(degPrec);


    val = tc.calc(jdET);
    if (offset-val == 0.) { // If not 0.0 but "very small", then
                            // interpolate after another calculation
                            // in the calculation loop below
      return jdET;
    }


    if (max == 0. && min == 0.) { // No possible change in position or speed
      throw new SwissephException(jdET, SwissephException.OUT_OF_TIME_RANGE,
          "No transit possible due to lack of variation of speed or position.");
    }

    while (true) {
      if (tc.rollover) {
        while (val >= tc.rolloverVal) { val -= tc.rolloverVal; }
        while (val < 0.) { val += tc.rolloverVal; }
      }
      above = (val >= offset);

      lastJD = jdET;
      lastVal = val;

      //while (tc.rollover && val<offset) { val += tc.rolloverVal; }
      if (tc.rollover && !above) { val += tc.rolloverVal; }

      // Find next reasonable point to probe.
      if (tc.rollover) {
        // In most cases here we cannot find out for sure if the distance
        // is decreasing or increasing. We take the smaller one of these:
        jdPlus  = Math.min(val-offset,360-val+offset)/Math.abs(max);
        jdMinus = Math.min(val-offset,360-val+offset)/Math.abs(min);
        if (back) {
          jdET -= Math.min(jdPlus,jdMinus);
        } else {
          jdET += Math.min(jdPlus,jdMinus);
        }
      } else { // Latitude, distance and speed calculations...
        //jdPlus = (back?(val-offset):(offset-val))/max;
        //jdMinus = (back?(val-offset):(offset-val))/min;
        jdPlus = (offset-val)/max;
        jdMinus = (offset-val)/min;
        if (back) {
          if (jdPlus >= 0 && jdMinus >= 0) {
            throw new SwissephException(jdET, SwissephException.OUT_OF_TIME_RANGE,
                -1, "No transit in ephemeris time range."); // I mean: No transits possible...
          } else if (jdPlus >= 0) {
            jdET += jdMinus;
          } else { // if (jdMinus >= 0)
            jdET += jdPlus;
          }
        } else {
          if (jdPlus <= 0 && jdMinus <= 0) {
            throw new SwissephException(jdET, SwissephException.OUT_OF_TIME_RANGE,
                -1, "No transit in ephemeris time range."); // I mean: No transits possible...
          } else if (jdPlus <= 0) {
            jdET += jdMinus;
          } else { // if (jdMinus <= 0)
            jdET += jdPlus;
          }
        }
      }


      // Add at least "timePrec" time to the last time:
      if (Math.abs(jdET - lastJD) < timePrec) {
        jdET = lastJD + (back?-timePrec:+timePrec);
      }
      if (jdET == lastJD) {
//System.err.println(" =t " + (""+val).substring(0,Math.min((""+val).length(),12)) + " " + jdET);
        return jdET;
      }
      val = tc.calc(jdET);
      if (tc.rollover && val >= tc.rolloverVal) { val %= tc.rolloverVal; }
      while (tc.rollover && val < 0.) { val += tc.rolloverVal; }

      // Hits the transiting point exactly...:
      if (offset-val == 0.) {
//System.err.println(" =v " + (""+val).substring(0,Math.min((""+val).length(),12)) + " " + jdET);
        return jdET;
      }

      // The planet may have moved forward or backward, in one of these
      // directions it would have crossed the transit point.
      //
      // Whatever distance could have been reached in lesser time (forward or
      // backward move), we take it to be the direction of movement.
      boolean pxway = true;
      if (tc.rollover) {
        double deltadeg1 = val-lastVal;
        if (deltadeg1<0) { deltadeg1+=tc.rolloverVal; }
        double deltadeg2 = lastVal-val;
        if (deltadeg2<0) { deltadeg2+=tc.rolloverVal; }
        pxway = Math.abs(deltadeg1/max)<Math.abs(deltadeg2/min);
      } else {
        pxway = lastVal<=val;
      }

      found = (// transits from higher deg. to lower deg.:
               ( above && val<=offset && !pxway) ||
               // transits from lower deg. to higher deg.:
               (!above && val>=offset &&  pxway)) ||
              (tc.rollover && (
               // transits from above the transit degree via rollover over
               // 0 degrees to a higher degree:
               (offset<lastVal && val>340. && lastVal<20. && !pxway) ||
               // transits from below the transit degree via rollover over
               // 360 degrees to a lower degree:
               (offset>lastVal && val<20. && lastVal>340. &&  pxway) ||
               // transits from below the transit degree via rollover over
               // 0 degrees to a higher degree:
               (offset>val && val>340. && lastVal<20. && !pxway) ||
               // transits from above the transit degree via rollover over
               // 360 degrees to a lower degree:
               (offset<val && val<20. && lastVal>340. &&  pxway))
              );

      if (found) { // Return an interpolated value, but not prior to (after)
                   // the initial time (if backward):
//System.err.println(" :: (" + above + " && " + val + "<=" + offset + " && !" + pxway + ") || " );
        if (tc.rollover) {
          if (tc.rollover && Math.abs(val - lastVal) > 300.) {   // How to do it formally correct???
            // Probably one value is about 359.99 and the other one is in the area of 0.01
            if (val > lastVal) { lastVal += tc.rolloverVal; } else { val += tc.rolloverVal; }
            if (offset < 10.) { offset += tc.rolloverVal; } // How to do it formally correct???
          }
          // offset-lastVal and val-lastVal have to have equal signs
          if (val-lastVal < 0 && offset-lastVal > 0) {
            val += tc.rolloverVal;
          } else if (val-lastVal > 0 && offset-lastVal < 0) {
            offset += tc.rolloverVal;
          }
        }
        double jdRet = lastJD+(jdET-lastJD)*(offset-lastVal)/(val-lastVal);
//System.err.println(" fd " + ("  "+val).substring(1).substring(0,12) + " " + Math.min(jdRet,jdET));
        if (back) {
          return Math.max(jdRet, jdET);
        } else {
          return Math.min(jdRet, jdET);
        }
      }
      if ((back && jdET < jdMax) ||
          (!back && jdET > jdMax)) {
//System.err.println(" ex " + ("  "+val).substring(1).substring(0,12) + " " + jdET);
        throw new SwissephException(jdET, SwissephException.BEYOND_USER_TIME_LIMIT,
            -1, "User time limit of " + jdMax + " has been reached.");
      }
    }
  }




  // The precision of a distance calculation is related to the barycentric
  // distance
  // E.g.: java Swetest -b1.1.0 -p0 -n100000 -fR -bary | sort -n
  protected double maxBaryDist[] = new double[] {
     0.009570999,    // 0 Sun        ==  0                   1.017545559
     1.028809521,    // 1 Moon       ==  1
     0.466604085,    // 2 Mercury    ==  2
     0.728698831,    // 3 Venus      ==  3
     0.728698831,    // 4 Mars       ==  4
     4.955912195,    // 5 Jupiter    ==  5
     8.968685733,    // 6 Saturn     ==  6
    19.893326756,    // 7 Uranus     ==  7
    30.326750627,    // 8 Neptune    ==  8
    41.499626899,    // 9 Pluto      ==  9
     0.002569555,    // m MeanNode   == 10
     0.002774851,    // t TrueNode   == 11
     1.0,            // A Mean Apog. == 12            // Does not vary distance anyway
     0.002782378,    // B Oscu.Apog. == 13
     0.0,            // C Earth      == 14 (skip)
     0.05,           // D Chiron     == 15            // No distance available, is 0.05 good???
    31.901319663,    // E Pholus     == 16
     3.012409508,    // F Ceres      == 17
     3.721614106,    // G Pallas     == 18
     3.326307148,    // H Juno       == 19
     2.570197288,    // I Vesta      == 20
  };



}
/*
   This is an extension to the Java port of the Swiss Ephemeris package
   of Astrodienst AG, Zuerich (Switzerland).

   Thomas Mack, mack@ifis.cs.tu-bs.de, 25th of November, 2004

*/





/**
* Some supportive methods, mainly for internationalization.
* These methods are not available in the original Swiss
* Ephemeris package.
*/
class Extlib {

  SwissEph  sw=new SwissEph();
  SwissLib  sl=new SwissLib();
  SweDate   sde1=new SweDate();
  SweDate   sde2=new SweDate();
  SweDate   sdu1, sdu2;
  SwissData swed=new SwissData();

  double transitVal = 0.;
  SimpleDateFormat df = null;
  String decTimeSeparator = ".";
  String decNumSeparator = ".";
  int secondsIdx = 0;



  /**
  * This class contains some additional method not contained
  * in the original Swiss Ephemeris package.
  * Currently, these methods deal with internationalization
  * primarily.
  */
  public Extlib() { }

  /**
  * This method is for debugging purposes only.
  */
  public static void main(String argv[]) {
    new Extlib();
  }

//////////----------------------

  /**
  * This method returns all available locale strings
  */
  public String[] getLocales() {
    Locale[] locs = DateFormat.getAvailableLocales();
    String[] locStrings = new String[locs.length];

    for (int r=0; r<locs.length; r++) {
      locStrings[r] = locs[r].getLanguage();
      if (locs[r].getCountry().length() > 0) {
        locStrings[r] += "_"+locs[r].getCountry();
      }
    }
    return locStrings;
  }

  /**
  * Returns the requested locale from a locale string.
  * @param locString A String describing the locale as a two letter
  * language code, a two letter language code plus a "_" plus a two
  * letter country code, or null or the empty string. Null or the
  * empty string will return the default locale, all others will
  * return the requested locale.
  * @return The locale
  */
  public Locale getLocale(String locString) {
    String lang = locString;
    String cntry = "";
    if (locString == null || "".equals(locString)) {
      return Locale.getDefault();
    }
    int idx = locString.indexOf("_");
    if (idx >= 0) {
      lang = locString.substring(0,idx);
      cntry = locString.substring(idx+1);
    }
    Locale loc = null;
    if (cntry.equals("")) {
      loc = new Locale(lang);
    } else {
      loc = new Locale(lang, cntry);
    }

    return loc;
  }


  /**
  * Creates a localized date time formatter suitable for tabular output with
  * 4 digit years and UTC timezone. You will format dates like this:<p>
  * <code>&nbsp;&nbsp;&nbsp;
  * SimpleDateFormat sdf = createLocDateTimeFormatter("da_DK", true);<br>
  * &nbsp;&nbsp;&nbsp;SweDate sd = new SweDate(2005,3,27);<br>
  * &nbsp;&nbsp;&nbsp;//...<br>
  * &nbsp;&nbsp;&nbsp;DevNull.println(sdf.format(sd.getDate(0)));<br>
  * </code><p>
  * Years B.C. will be prefixed by a "-". Years are counted including year
  * "0", which differs from normal DateFormat output.
  * @param locString The input locale for which this date time format
  * should be created. See getLocale() for more infos.
  * @return The normalized form of the DateFormat.
  */
  public SimpleDateFormat createLocDateTimeFormatter(String locString, boolean force24h) {

    // Get date format:
    Locale loc = getLocale(locString);
    SimpleDateFormat df = (SimpleDateFormat)DateFormat.getDateTimeInstance(
              java.text.DateFormat.SHORT, java.text.DateFormat.MEDIUM, loc);

    // Revert to UTC:
    df.getCalendar().setTimeZone(TimeZone.getTimeZone("GMT+0"));

    // Change output pattern to our needs, this means 4 letter year etc.:
    String pattern = getNormalizedDatePattern(df.toPattern(), force24h);
    df.applyPattern(pattern);

    return df;
  }

  /**
  * Ensures a date pattern with four letter year, two letter month and day
  * and 24h time format, if requested.
  */
  public String getNormalizedDatePattern(String pattern, boolean force24h) {
    int idx = 0;
//DevNull.println(pattern);

    // force year, month, day, hour, minutes and seconds to appear with two digits:
    final String pats = ("yMdHhms");
    for (int n = 0; n < pats.length(); n++) {
      char ch = pats.charAt(n);
      String out = ch + "" + ch;
      idx = pattern.indexOf(out);
      if (idx < 0) {
        idx = pattern.indexOf(ch);
        if (idx >= 0) {
          pattern = pattern.substring(0,idx) + ch + pattern.substring(idx);
        }
      }
    }
    // force year to appear with four digits:
    idx = pattern.indexOf("yyyy");
    if (idx < 0) {
      idx = pattern.indexOf("yy");
      if (idx >= 0) {
        pattern = pattern.substring(0,idx) + "yy" + pattern.substring(idx);
      }
    }
    // Locale "mk" does not have a "seconds" part in its time pattern
    // (Java 1.4.2 / Linux).
    // Append it after the minutes pattern ("m"):
    if (pattern.indexOf("s") < 0) {
      idx = pattern.indexOf("mm");
      if (idx >= 0) { // If not, it not even has a minutes part???
        // We assume some non-digit char AFTER "mm" as it is the
        // case with "mk" here ("d.M.yy HH:mm:" original, "dd.MM.yyyy HH:mm:"
        // when changed):
        pattern = pattern.substring(0,idx+3) + "ss" + pattern.substring(idx+3);
      }
    }

    if (force24h) {
      idx = pattern.indexOf("a");
      if (idx >= 0) {
        pattern = pattern.substring(0,idx) + pattern.substring(idx+1);
        idx = pattern.indexOf("hh");
        pattern = pattern.substring(0,idx) + "HH" + pattern.substring(idx+2);
      }
    }

    return pattern;
  }

  /**
  * Returns the decimal separator of the NumberFormat
  */
  public String getDecimalSeparator(NumberFormat nf) {
    if (nf instanceof DecimalFormat) {
      return String.valueOf(((DecimalFormat)nf).getDecimalFormatSymbols().getDecimalSeparator());
    }
    return null;
  }

  /**
  * Returns the index in the formatter pattern of the given pattern 'what'
  * recalculated to the APPLIED pattern of the formatter.
  * E.g. for locale zh_HK the pattern is:
  * The index of 'ss' would NOT be 25, which we would get when simply counting in
  * the pattern string, but rather 20, when counting in the resulting string.
  */
  public int getPatternLastIdx(String pattern, String what, SimpleDateFormat dof) {
    // If we want to append fractions of a second, we have to know
    // at which position in the string this is to happen. We can
    // look for the "ss" part in the pattern string, but the pattern
    // can contain string constants delimited by the ' character.
    // Moreover, it can contain patterns expanding to more than
    // one letter when applied to a date and time. This is so far
    // known to be true for the 'a' pattern expanding to AM or PM
    // in english locales and expanding to still different values
    // in other locales.

    int idx = pattern.lastIndexOf(what) + 1;

    // Strip string constant delimiters from found pattern position:
    int last = idx;
    int i = 0;
    while (i < last) {
      if (pattern.charAt(i) == '\'') {
        idx--;
      }
      i++;
    }

    if (pattern.indexOf("a") >= 0 &&
        pattern.indexOf("a") < pattern.indexOf(what)) {
      int len = dof.getDateFormatSymbols().getAmPmStrings()[0].length(); // No input with fractions of a second?
      // We have to know the time when the length of the AM-String is
      // different from the length of the PM-String...
      // We don't care for now...
      idx += len - 1;
    }

    return idx;
  }

} // End of class Extlib
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class FileData {
  final byte SEI_FILE_NMAXPLAN=50;

  String fnam;          /* ephemeris file name */
  int fversion;         /* version number of file */
  String astnam;        /* asteroid name, if asteroid file */
  int sweph_denum;     /* DE number of JPL ephemeris, which this file
                         * is derived from. */
  FilePtr fptr;/* ephemeris file pointer */
  double tfstart;       /* file may be used from this date */
  double tfend;         /*      through this date          */
  int iflg;             /* byte reorder flag and little/bigendian flag */
  short npl;            /* how many planets in file */
  int ipl[] = new int[SEI_FILE_NMAXPLAN]; /* planet numbers */

  void clearData() {
    int j;
    fnam="";
    fversion=0;
    astnam="";
    sweph_denum=0;
    try {
      if (fptr!=null) { fptr.close(); }
    } catch (java.io.IOException e) {
// NBT
    }
    fptr=null;
    tfstart=0.0;
    tfend=0.0;
    iflg=0;
    npl=0;
    for(j=0; j<SEI_FILE_NMAXPLAN; j++) { ipl[j]=0; }
  }

// Attention: read_const() has to be called from "swed.fidat[ifno]", where
// "ifno" has to be the first parameter in read_const:
//  struct FileData *fdp = &swed.fidat[ifno];
//
  /* SWISSEPH
   * reads constants on ephemeris file
   * ifno         file #
   * serr         error string
   */
  int read_const(int ifno, StringBuffer serr, SwissData swed) {
    String s="";
    String s2="";
    String sastnam="";
    int i, ipli, kpl;
    int fendian, freord;
    int lastnam = 19;
//Renamed in JAVA to fptr:// FilePtr fp;
    long lng;
    long ulng; // hat 'unsigned' long hier eine wesentliche Bedeutung?
    long flen, fpos;
    short nplan;
    PlanData pdp;
//Skipped in JAVA:// FileData fdp = swed.fidat[ifno];
    String serr_file_damage = "Ephemeris file "+fnam+" is damaged. ";
//Skipped in JAVA:// int errmsglen = serr_file_damage.length();
    int nbytes_ipl = 2;

    try {
      /*************************************
       * version number of file            *
       *************************************/
      byte b=0;
      char cLast;
      do {
        cLast=(char)b;
        b=fptr.readByte();
        s+=(char)b;
      } while (cLast!='\r' && (char)(b)!='\n' && s.length()<SwissData.AS_MAXCH);

      s=s.trim();
      int offs=0;
      int ver=-1;
      while (!Character.isDigit(s.charAt(offs))) { offs++; }
      try {
        ver=Integer.parseInt(s.substring(offs));
      } catch (NumberFormatException n) {
        DevNull.println(serr_file_damage+" (1)");
        fptr.close();
        throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
            SweConst.ERR, serr);
      }
// Use SwissLib.atoi(...) ?
      fversion=ver;

      /*************************************
       * correct file name?                *
       *************************************/
      b=0; s="";
      do {
        cLast=(char)b;
        b=fptr.readByte();
        s+=(char)b;
      } while (cLast!='\r' && (char)(b)!='\n' && s.length()<SwissData.AS_MAXCH);

      s2=fnam.substring(fnam.lastIndexOf(swed.DIR_GLUE)+1).toLowerCase();
      s=s.trim().toLowerCase();
      if (!s.equals(s2)) {
        // Http addresses will end with '/' independent of DIR_GLUE...
        s2=fnam.substring(fnam.lastIndexOf("/")+1).toLowerCase();
        if (!s.equals(s2)) {
          s2=fnam.substring(fnam.lastIndexOf(swed.DIR_GLUE)+1).toLowerCase();
          //DevNull.println("Ephemeris file name '"+s2+"' is wrong; rename to '"+s+"'");
          fptr.close();
          throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
              SweConst.ERR, serr);
        }
      }
      /*************************************
       * copyright                         *
       *************************************/
      b=0; s="";
      do {
        cLast=(char)b;
        b=fptr.readByte();
        s+=(char)b;
      } while (cLast!='\r' && (char)(b)!='\n' && s.length()<SwissData.AS_MAXCH);

      /****************************************
       * orbital elements, if single asteroid *
       ****************************************/
      // Read up to end of line or AS_MAXCH*2 into var. 's':
      if (ifno == SwephData.SEI_FILE_ANY_AST) {
        b=0; s="";
        do {
          cLast=(char)b;
          b=fptr.readByte();
          s+=(char)b;
        } while (cLast!='\r' && (char)(b)!='\n' && s.length()<SwissData.AS_MAXCH*2);
        /* MPC number and name; will be analyzed below:
         * search "asteroid name" */
        String sp = s;
        // Strip leading white space from 'sp':
        while(Character.isWhitespace(sp.charAt(0))) {
          sp = sp.substring(1);
        }
        // Remove leading numbers from 'sp':
        while(Character.isDigit(sp.charAt(0))) {
          sp = sp.substring(1);
        }
        // Skip next character as well:
        sp = sp.substring(1);
        i = s.length() - sp.length();
        sastnam = sp.substring(0,lastnam+i);
        /* save elements, they are required for swe_plan_pheno() */
        swed.astelem = s;
        /* required for magnitude */
        swed.ast_H = SwissLib.atof(s.substring(35 + i));
        swed.ast_G = SwissLib.atof(s.substring(42 + i));
        if (swed.ast_G == 0) swed.ast_G = 0.15;
        /* diameter in kilometers, not always given: */
        s2 = s.substring(51 + i, 58 + i);
        swed.ast_diam = SwissLib.atof(s2);
        if (swed.ast_diam == 0) {
          /* estimate the diameter from magnitude; assume albedo = 0.15 */
          swed.ast_diam = 1329/Math.sqrt(0.15) * Math.pow(10, -0.2 * swed.ast_H);
        }
      }
      /*************************************
       * one int32 for test of byte order   *
       *************************************/
      int testendian = fptr.readInt();
      /* is byte order correct?            */
lng = 0;
      if (testendian == SwephData.SEI_FILE_TEST_ENDIAN) {
        freord = SwephData.SEI_FILE_NOREORD;
      } else {
        freord = SwephData.SEI_FILE_REORD;
        lng = ((testendian & 0x000000ff) << 24) +
              ((testendian & 0x0000ff00) << 8 ) +
              ((testendian & 0x00ff0000) >> 8 ) +
              ((testendian & 0xff000000) >> 24);
        if (lng != SwephData.SEI_FILE_TEST_ENDIAN) {
          throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
              SweConst.ERR, "File is damaged: byte ordering info not correct.");
        }
      }
      /* is file bigendian or littlendian?
       * test first byte of test integer, which is highest if bigendian */
      if (SwephData.SEI_FILE_TEST_ENDIAN / 16777216 ==
          (testendian & 0x000000ff)) {
        fendian = SwephData.SEI_FILE_BIGENDIAN;
      } else {
        fendian = SwephData.SEI_FILE_LITENDIAN;
      }
      iflg = freord | fendian;
      /*************************************
       * length of file correct?           *
       *************************************/
      lng=(long)read4(fptr, SwephData.SEI_CURR_FPOS, false, freord, fendian);
      if (lng < 0) { lng &= 0xffffffff; }
      fpos=fptr.getFilePointer();
      flen=fptr.length();
      if (lng!=flen) {
        DevNull.println(serr_file_damage+" (2)");
        fptr.close();
        throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
            SweConst.ERR, serr);
      }
//      fptr.seek(flen-1);
      fptr.seek(fpos);
      /**********************************************************
       * DE number of JPL ephemeris which this file is based on *
       **********************************************************/
      sweph_denum = read4(fptr, fpos, false, freord, fendian);
      swed.jpldenum = sweph_denum;
      /*************************************
       * start and end epoch of file       *
       *************************************/
      tfstart=read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      tfend=read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      /*************************************
       * how many planets are in file?     *
       *************************************/
      nplan=read2(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      if (nplan > 256) {
        nbytes_ipl = 4;
        nplan %= 256;
      }
      if (nplan < 1 || nplan > 20) {
        DevNull.println(serr_file_damage+" (3)");
        fptr.close();
        throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
            SweConst.ERR, serr);
      }
      npl = nplan;
      /* which ones?                       */
//do_fread((void *) fdp->ipl, nbytes_ipl, (int) nplan, sizeof(int), fp,...
//          target            how many      count      how many
//                          bytes to read           bytes to write
// nbytes_ipl can be 2 and 4 only...
      if (nbytes_ipl == 2) {
        for(i=0; i<nplan; i++) {
          ipl[i]=(int)(read2(fptr, SwephData.SEI_CURR_FPOS, freord, fendian));
        }
      } else if (nbytes_ipl == 4) {
        for(i=0; i<nplan; i++) {
          ipl[i]=read4(fptr, SwephData.SEI_CURR_FPOS, false, freord, fendian);
        }
      } else { // Can't be???
        DevNull.println(serr_file_damage+" (3b)");
      }
      /*************************************
       * asteroid name                     *
       *************************************/
      if (ifno == SwephData.SEI_FILE_ANY_AST) {
        String sastno;
        int j;
        /* name of asteroid is taken from orbital elements record
         * read above */
        j = 4;      /* old astorb.dat had only 4 characters for MPC# */
        while (sastnam.charAt(j) != ' ' && j < 10) {  /* new astorb.dat has 5 */
          j++;
        }
        sastno=sastnam.substring(0,Math.min(sastnam.length(),j)).trim();
        i = Integer.parseInt(sastno);
        if (i == ipl[0] - SweConst.SE_AST_OFFSET) {
          /* element record is from bowell database */
          astnam=sastnam.substring(Math.min(sastnam.length(),j+1),
                                   Math.min(sastnam.length(),j+1+lastnam));
          /* overread old ast. name field */
          s="";
          for(i=0; i<30; i++) {
            s+=(char)fptr.readByte();
          }
        } else {
          /* older elements record structure: the name
           * is taken from old name field */
          astnam="";
          for(i=0; i<30; i++) {
            astnam+=(char)fptr.readByte();
          }
        }
        astnam=astnam.trim();
      }
      /*************************************
       * check CRC                         *
       *************************************/
      fpos = fptr.getFilePointer();
      /* read CRC from file */
      ulng=(long)(read4(fptr, SwephData.SEI_CURR_FPOS, false, freord, fendian));
      /* read check area from file */
      fptr.seek(0L);
      /* must check that defined length of s is less than fpos */
      if (fpos - 1 > 2 * SwissData.AS_MAXCH) {
        DevNull.println(serr_file_damage+" (4)");
        fptr.close();
        throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
            SweConst.ERR, serr);
      }
      b=0; s="";
byte[] ba=new byte[2*SwissData.AS_MAXCH];
      for(i=0;i<fpos;i++) {
        cLast=(char)b;
        b=fptr.readByte();
//DevNull.println(b);
        ba[i]=b;
        s+=(char)b;
      }
  if ((int)swi_crc32(/*(unsigned char *)*/ ba, (int) fpos) != (int)ulng) {
    System.err.println(serr_file_damage+" (5)");
    fptr.close();
    throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
        SweConst.ERR, serr);
  }
      fptr.seek(fpos+4L);
      /*************************************
       * read general constants            *
       *************************************/
      /* clight, aunit, helgravconst, ratme, sunradius
       * these constants are currently not in use */
      swed.gcdat.clight       = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      swed.gcdat.aunit        = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      swed.gcdat.helgravconst = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      swed.gcdat.ratme        = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      swed.gcdat.sunradius    = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      /*************************************
       * read constants of planets         *
       *************************************/
      for (kpl = 0; kpl < npl; kpl++) {
        /* get SEI_ planet number */
        ipli = ipl[kpl];
        if (ipli >= SweConst.SE_AST_OFFSET) {
          pdp = swed.pldat[SwephData.SEI_ANYBODY];
        } else {
          pdp = swed.pldat[ipli];
        }
        pdp.ibdy = ipli;
        /* file position of planet's index */
        pdp.lndx0=(long)(read4(fptr, SwephData.SEI_CURR_FPOS, false, freord, fendian))&0xffffffffL;
        /* flags: helio/geocentric, rotation, reference ellipse */
        pdp.iflg=fptr.readUnsignedByte();
        /* number of chebyshew coefficients / segment  */
        /* = interpolation order +1                    */
        pdp.ncoe=fptr.readUnsignedByte();
        /* rmax = normalisation factor */
        lng=read4(fptr, SwephData.SEI_CURR_FPOS, false, freord, fendian);
        pdp.rmax = (double)lng / 1000.0;
        /* start and end epoch of planetary ephemeris,   */
        /* segment length, and orbital elements          */
        pdp.tfstart  = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.tfend    = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.dseg     = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.nndx     = (int) ((pdp.tfend - pdp.tfstart + 0.1) /pdp.dseg);
        pdp.telem    = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.prot     = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.dprot    = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.qrot     = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.dqrot    = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.peri     = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.dperi    = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        /* alloc space for chebyshew coefficients */
        /* if reference ellipse is used, read its coefficients */
        if ((pdp.iflg & SwephData.SEI_FLG_ELLIPSE)!=0) {
          if (pdp.refep != null) { /* if switch to other eph. file */
            pdp.refep = null;
            if (pdp.segp != null) {
              pdp.segp = null; /* array of coefficients of ephemeris segment */
            }
          }
          pdp.refep = new double[2*pdp.ncoe];
          for(i=0;i<2*pdp.ncoe;i++) {
            pdp.refep[i]=read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
          }
        }/**/
      }
    } catch (java.io.IOException e) {
      try {
        fptr.close();
      } catch (java.io.IOException e2) {
      }
      DevNull.println(serr_file_damage+" (6)");
      DevNull.println(e.getMessage());
      throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
          SweConst.ERR, serr);
    }
    return SweConst.OK;
  }


  /*
   * The following C code (by Rob Warnock rpw3@sgi.com) does CRC-32 in
   * BigEndian/BigEndian byte/bit order. That is, the data is sent most
   * significant byte first, and each of the bits within a byte is sent most
   * significant bit first, as in FDDI. You will need to twiddle with it to do
   * Ethernet CRC, i.e., BigEndian/LittleEndian byte/bit order.
   *
   * The CRCs this code generates agree with the vendor-supplied Verilog models
   * of several of the popular FDDI "MAC" chips.
   */
  /* unsigned long [...] */
  static long crc32_table[]=null;
  /* Initialized first time "crc32()" is called. If you prefer, you can
   * statically initialize it at compile time. [Another exercise.]
   */

  long swi_crc32(/*unsigned???*/ byte[] buf, int len) {
    int pn;
    /*unsigned*/ long crc;
    if (crc32_table==null) {  /* if not already done, */
      init_crc32();   /* build table */
    }
    crc = 0xffffffffL;       /* preload shift register, per CRC-32 spec */
    for (pn = 0; len > 0; ++pn, --len) {
      crc = ((crc << 8)&0xffffffffL) ^ crc32_table[(int)((crc >> 24) ^ ((long)buf[pn]&0xff))];
    }
    return ~crc;            /* transmit complement, per CRC-32 spec */
  }

  /*
   * Build auxiliary table for parallel byte-at-a-time CRC-32.
   */
  static final int CRC32_POLY=0x04c11db7;    /* AUTODIN II, Ethernet, & FDDI */

  void init_crc32() {
    long i, j;
    long c;
    crc32_table = new long[256];
    for (i = 0; i < 256; ++i) {
      for (c = i << 24, j = 8; j > 0; --j) {
        c = (c & 0x80000000L)!=0 ? (c << 1) ^ CRC32_POLY : (c << 1);
      }
      c=c & 0xffffffffL;
      crc32_table[(int)i] = c;
    }
  }


  short read2(FilePtr fp, long fpos, int freord, int fendian)
      throws java.io.IOException {
    if (fpos >= 0) {
      fp.seek(fpos);
    }
    short val=(short)fp.readShort();

    if (freord != 0) {
      val = (short)(( val << 8 ) +
            ( val >>> 8 ));
    }
    return val;
  }

  int read3(FilePtr fp, long fpos, int freord, int fendian)
      throws java.io.IOException {
    if (fpos >= 0) {
      fp.seek(fpos);
    }
    int val=(int)fp.readUnsignedByte();
    int i2=(int)fp.readShort(); if(i2<0){i2&=0xffff;}
    val=(val<<16)+i2;

    if (freord != 0) {
      val = (( val & 0x000000ff ) << 24) +
            (( val & 0x0000ff00 ) <<  8) +
            (( val & 0x00ff0000 ) >>  8) +
            (( val & 0xff000000 ) >> 24);

      boolean do_shift = ((fendian == SwephData.SEI_FILE_BIGENDIAN && freord != 0) ||
                          (fendian == SwephData.SEI_FILE_LITENDIAN && freord == 0));

      return (do_shift?val>>8:val);
    }
    return val;
  }

  int read4(FilePtr fp, long fpos, boolean unsigned, int freord, int fendian)
      throws java.io.IOException {
    if (fpos >= 0) {
      fp.seek(fpos);
    }
    int val=(int)fp.readInt();

    if (freord != 0) {
      if (unsigned) {
        val = (( val & 0x000000ff ) << 24) +
              (( val & 0x0000ff00 ) <<  8) +
              (( val & 0x00ff0000 ) >>  8) +
              (( val & 0xff000000 ) >> 24);
      } else {
        val = (( val & 0x000000ff ) << 24) +
              (( val & 0x0000ff00 ) <<  8) +
              (( val & 0x00ff0000 ) >>  8) +
              (( val & 0xff000000 ) >>> 24);
      }
    } else {
      if (unsigned && val<0) { val&=0x7fffffff; }
    }

    return val;
  }

  double read8(FilePtr fp, long fpos, int freord, int fendian)
      throws java.io.IOException {
    if (fpos >= 0) {
      fp.seek(fpos);
    }

    long val=Double.doubleToLongBits(fp.readDouble());

    if (freord != 0) {
      val = (( val & 0x00000000000000ffL ) << 56) +
            (( val & 0x000000000000ff00L ) << 40) +
            (( val & 0x0000000000ff0000L ) << 24) +
            (( val & 0x00000000ff000000L ) <<  8) +
            (( val & 0x000000ff00000000L ) >>  8) +
            (( val & 0x0000ff0000000000L ) >> 24) +
            (( val & 0x00ff000000000000L ) >> 40) +
            (( val & 0xff00000000000000L ) >> 56);
    }

    return Double.longBitsToDouble(val);
  }

  /* fetch chebyshew coefficients from sweph file for
   * tjd          time
   * ipli         planet number
   * ifno         file number
   * serr         error string
   */
  int get_new_segment(SwissData swed, double tjd, int ipli, int ifno,
                      StringBuffer serr) {
    int i, j, k, m, n, o, icoord;
    int iseg;
    int fpos;
    int nsizes, nsize[]=new int[6];
    int nco;
    int idbl;
    /* unsigned */ short c[]=new short[4]; // unsigned (byte) ist wichtig?
    PlanData pdp = swed.pldat[ipli];
    FileData fdp = swed.fidat[ifno];
    int freord  = (int) (fdp.iflg & SwephData.SEI_FILE_REORD);
    int fendian = (int) (fdp.iflg & SwephData.SEI_FILE_LITENDIAN);
    /* unsigned long */ long longs[]=new long[SwephData.MAXORD+1]; // unsigned ist wichtig?
    /* compute segment number */


    iseg = (int) ((tjd - pdp.tfstart) / pdp.dseg);
    /*if (tjd - pdp->tfstart < 0)
        return(NOT_AVAILABLE);*/
    pdp.tseg0 = pdp.tfstart + iseg * pdp.dseg;
    pdp.tseg1 = pdp.tseg0 + pdp.dseg;
    /* get file position of coefficients from file */
    fpos = (int)pdp.lndx0 + iseg * 3;
    try {
      fpos = read3(fptr, fpos, freord, fendian);
      fptr.seek(fpos);
      /* clear space of chebyshew coefficients */
      if (pdp.segp == null) {
        pdp.segp = new double[pdp.ncoe*3];
      }
      for(i=0;i<pdp.segp.length;i++) { pdp.segp[i]=0.; }
      /* read coefficients for 3 coordinates */
      for (icoord = 0; icoord < 3; icoord++) {
        idbl = icoord * pdp.ncoe;
        /* first read header */
        /* first bit indicates number of sizes of packed coefficients */
        c[0]=(short)fptr.readUnsignedByte();
        c[1]=(short)fptr.readUnsignedByte();
        if ((c[0] & 128)!=0) {
          nsizes = 6;
          c[2]=(short)fptr.readUnsignedByte();
          c[3]=(short)fptr.readUnsignedByte();
          nsize[0] = (int) c[1] / 16;
          nsize[1] = (int) c[1] % 16;
          nsize[2] = (int) c[2] / 16;
          nsize[3] = (int) c[2] % 16;
          nsize[4] = (int) c[3] / 16;
          nsize[5] = (int) c[3] % 16;
          nco = nsize[0] + nsize[1] + nsize[2] + nsize[3] + nsize[4] + nsize[5];
        } else {
          nsizes = 4;
          nsize[0] = (int) c[0] / 16;
          nsize[1] = (int) c[0] % 16;
          nsize[2] = (int) c[1] / 16;
          nsize[3] = (int) c[1] % 16;
          nco = nsize[0] + nsize[1] + nsize[2] + nsize[3];
        }
        /* there may not be more coefficients than interpolation
         * order + 1 */
        if (nco > pdp.ncoe) {
          if (serr != null) {
            serr.append("error in ephemeris file "+fdp.fnam+": "+nco+
                        " coefficients instead of "+pdp.ncoe+". ");
          }
          throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
              SweConst.ERR, serr);
        }
        /* now unpack */
int kCnt;
        for (i = 0; i < nsizes; i++) {
          if (nsize[i] == 0) {
            continue;
          }
          if (i < 4) {
            j = (4 - i);
            k = nsize[i];
            for(kCnt=0; kCnt<k; kCnt++) {
              switch(j) {
                case 1: longs[kCnt]=(int)fptr.readUnsignedByte();
                        break;
                case 2: longs[kCnt]=(int)read2(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
                        if(longs[kCnt]<0){longs[kCnt]&=0xffff;}
                        break;
                case 3: longs[kCnt]=read3(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
                        if(longs[kCnt]<0){longs[kCnt]&=0xffffff;}
                        break;
                case 4: longs[kCnt]=read4(fptr, SwephData.SEI_CURR_FPOS, false, freord, fendian);
                        if(longs[kCnt]<0){longs[kCnt]&=0xffffffff;}
                        break;
              }
            }
            for (m = 0; m < k; m++, idbl++) {
              if ((longs[m] & 1)!=0) {   /* will be negative */
                pdp.segp[idbl] = -((((longs[m]+1) / 2)&0x7fffffffL) / 1e+9 * pdp.rmax / 2);
              } else {
                pdp.segp[idbl] = ((longs[m] / 2)&0x7fffffffL) / 1e+9 * pdp.rmax / 2;
              }
            }
          } else if (i == 4) {              /* half byte packing */
            j = 1;
            k = (nsize[i] + 1) / 2;
            for(kCnt=0; kCnt<k; kCnt++) {
              longs[kCnt]=(int)fptr.readUnsignedByte();
            }
            for (m = 0, j = 0;
                 m < k && j < nsize[i];
                 m++) {
              for (n = 0, o = 16;
                   n < 2 && j < nsize[i];
                   n++, j++, idbl++, longs[m] %= o, o /= 16) {
                if ((longs[m] & o)!=0) {
                  pdp.segp[idbl] = -(((longs[m]+o) / o / 2) * pdp.rmax /
                                                                    2 / 1e+9);
                } else {
                  pdp.segp[idbl] = (longs[m] / o / 2) * pdp.rmax / 2 / 1e+9;
                }
              }
            }
          } else if (i == 5) {              /* quarter byte packing */
            j = 1;
            k = (nsize[i] + 3) / 4;
            for(kCnt=0; kCnt<k; kCnt++) {
              longs[kCnt]=(int)fptr.readUnsignedByte();
            }
            for (m = 0, j = 0;
                 m < k && j < nsize[i];
                 m++) {
              for (n = 0, o = 64;
                   n < 4 && j < nsize[i];
                   n++, j++, idbl++, longs[m] %= o, o /= 4) {
                if ((longs[m] & o)!=0) {
                  pdp.segp[idbl] = -(((longs[m]+o) / o / 2) * pdp.rmax /
                                                                    2 / 1e+9);
                } else {
                  pdp.segp[idbl] = (longs[m] / o / 2) * pdp.rmax / 2 / 1e+9;
                }
              }
            }
          }
        }
      }
      return SweConst.OK;
    } catch (java.io.IOException e) {
      serr.append("file error in swisseph.FileData: "+e.getMessage());
      throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
          SweConst.ERR, serr);
    }
  }

  /* SWISSEPH
   * reads from a file and, if necessary, reorders bytes
   * targ         target pointer
   * size         size of item to be read
   * count        number of items
   * corrsize     in what size should it be returned
   *              (e.g. 3 byte int -> 4 byte int)
   * fp           file pointer
   * fpos         file position: if (fpos >= 0) then fseek
   * freord       reorder bytes or no
   * fendian      little/bigendian
   * ifno         file number
   * serr         error string
   */


} // Ende der Klasse FileData.


//////////////////////////////////////////////////////////////////////////////
// Anmerkungen: //////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// String fnam;     Fuer Ausgaben von Fehlermeldungen und zum
//                  Zwischenspeichern.
// int fversion;    Wird nicht genutzt, aber aus der Datei ausgelesen.
//                  Sollte zugreifbar sein.
// String astnam;   Wird aus der Datei ausgelesen und in "swe_get_planet_name"
//                  zurueckgeliefert.
// int sweph_denum; Wird aus der Datei ausgelesen und in "sweph"
//                  einmal genutzt (4 Bytes uebrigens):
//                  if (fdp->sweph_denum >= 403 && ipl < SEI_ANYBODY) {
//                    swi_IERS_FK5(xp, xp, 1);
//                    [...]
//                  }
// java.io.RandomAccessFile fptr;
// double tfstart;  Beginn und Ende des Zeitraumes, ueber den die Datei
// double tfend;    Daten enthaelt. Wird ausgewertet.
// int iflg;        Enthaelt zwei Flags in Bit 1 und Bit 2: "little endian /
//                  big endian" und "reorder Bytes". sizeof(long), vermutlich
//                  4 Bytes=int;
// short npl;       Wird aus der Datei mit zwei Bytes ausgelesen. Anzahl der
//                  Planeten in der Datei. Aufgrund dieser Information werden
//                  "npl"-mal Konstanten ueber die Planeten aus der Datei
//                  ausgelesen (PlanData p: p.lndx0; p.iflg; p.ncoe; p.rmax;
//                  p.tfstart bis p.dperi; p.refep und FileData.ipl).
// short ipl[];     2 Bytes==int. Offenbar Nummer der Planeten...

/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/



/**
* This class is meant to be a wrapper to some read functionality of the
* RandomAccessFile class. It adds the ability to read (and search and
* seek) in files using http://... access. This is needed to allow applets
* read access to files, in this case the Swiss Ephemeris and JPL data
* files.
*/
class FilePtr {
  public static final String useragent="swisseph-java-1.70.03(00)";

  private static final int MAX_FAILURES=100;

  RandomAccessFile fp;
  Socket sk;
  InputStream is;
  BufferedOutputStream os;
  String fnamp;
  private long fpos=0;
  private String host;
  private int port;
  private int BUFSIZE=20;
  // Holds max. 1 BUFSIZE byte chunks of read data: startidx, endidx, data:
  private long[] startIdx=new long[1];  // long, as it holds the file pointer pos.
  private long[] endIdx=new long[1];
  private byte[][] data;
  private byte inbuf[];
  private int idx=0; // What to fill next.
  private long savedLength=-1;


  /**
  * Creates a new FilePtr instance. Well, the parameters are rather
  * &quot;funny&quot; for now, but there were reasons for it. I will
  * change it later (hopefully)...<br>
  * If you do not need to read randomly and you have access to the file
  * directly, you should use the BufferedInputStream etc. -classes, as
  * they are MUCH faster than the RandomAccessFile class that is used
  * here.
  */
  public FilePtr(RandomAccessFile fp,
                 Socket sk,
                 InputStream is,
                 BufferedOutputStream os,
                 String fnamp,
                 long fileLength,
                 int bufsize) throws IOException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr(RandomAccessFile, Socket, InputStream, BufferedOutputStream, String, long, int)");
////#ifdef TRACE1
//    DevNull.println("    fp: " + fp + "\n    sk: " + sk + "\n    is: " + is + "\n    os: " + os + "\n    fnamp: " + fnamp + "\n    fileLength: " + fileLength + "\n    bufsize: " + bufsize);
////#endif /* TRACE1 */
////#endif /* TRACE0 */
    this.fp=fp;
    this.sk=sk;
    this.is=is;
    this.os=os;
    this.fnamp=fnamp;
    this.savedLength=fileLength;
    this.BUFSIZE=bufsize;
    data=new byte[BUFSIZE][1];
    inbuf=new byte[BUFSIZE];
    for (int i=0;i<data[0].length;i++) {
      startIdx[i]=-1; // Means: no data at this index.
    }
    if (fp==null) {
      try {
        URL u=new URL(fnamp);
        host=u.getHost();
        port=u.getPort();
        if (port<0) { port=80; } // Default port for http...
      } catch ( MalformedURLException me) {
////#ifdef TRACE0
//        Trace.level--;
////#endif /* TRACE0 */
        throw new IOException("Malformed URL '"+fnamp+"'");
      }
    }
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
  }




  /**
  * Reads one (signed) byte.
  * @return One signed 8 bit byte.
  * @throws IOException if an I/O error occurs.
  * @throws EOFException if the end of file is reached <i>before</i> the
  * byte could be read.
  */
  public byte readByte() throws IOException, EOFException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.readByte()");
////#endif /* TRACE0 */
    if (startIdx[idx]<0 || fpos<startIdx[idx] || fpos>endIdx[idx]) {
      readToBuffer();
    }
    fpos++;
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
    return data[(int)(fpos-1-startIdx[idx])][idx];
  }

  /**
  * Reads one <i>unsigned</i> byte.
  * @return One unsigned 8 bit byte as an integer.
  * @throws IOException if an I/O error occurs.
  * @throws EOFException if the end of file is reached <i>before</i> the
  * byte could be read.
  */
  public int readUnsignedByte() throws IOException, EOFException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.readUnsignedByte()");
//    Trace.level--;
////#endif /* TRACE0 */
    return ((int)readByte()) & 0xff;
  }


  /**
  * Reads a (signed) short value. This is a two byte read (16 bits) with
  * highest byte first.
  * @return A signed 2 byte (16 bit) value as a short.
  * @throws IOException if an I/O error occurs.
  * @throws EOFException if the end of file is reached before the
  * 2 bytes could be read completely.
  */
  public short readShort() throws IOException, EOFException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.readShort()");
//    Trace.level--;
////#endif /* TRACE0 */
    return (short)((readByte()<<8)+readUnsignedByte());
  }

  /**
  * Reads a (signed) integer value. This is a four byte read (32 bits) with
  * highest bytes first.
  * @return A signed 4 byte (32 bit) value as an integer.
  * @throws IOException if an I/O error occurs.
  * @throws EOFException if the end of file is reached before the
  * 4 bytes could be read completely.
  */
  public int readInt() throws IOException, EOFException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.readInt()");
//    Trace.level--;
////#endif /* TRACE0 */
    return (((int)readByte())<<24)+
           (((int)readUnsignedByte())<<16)+
           (((int)readUnsignedByte())<<8)+
           (int)readUnsignedByte();
  }

  /**
  * Reads a double value. This is an 8 byte read (64 bits) with highest
  * bytes first.
  * @return A double value.
  * @throws IOException if an I/O error occurs.
  * @throws EOFException if the end of file is reached before the
  * 8 bytes could be read completely.
  */
  public double readDouble() throws IOException, EOFException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.readDouble()");
////#endif /* TRACE0 */
    long ldb=(((long)readUnsignedByte())<<56)+
             (((long)readUnsignedByte())<<48)+
             (((long)readUnsignedByte())<<40)+
             (((long)readUnsignedByte())<<32)+
             (((long)readUnsignedByte())<<24)+
             (((long)readUnsignedByte())<<16)+
             (((long)readUnsignedByte())<<8)+
             (long)readUnsignedByte();
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
    return Double.longBitsToDouble(ldb);
  }

  /**
  * Reads a complete line from the file. The line is seen to end on a
  * newline character ('\n') or on an end of file. The returned String
  * will include the newline character if any.
  * 
  * @return A String containing a complete line. The line may be 0 characters
  * long.
  * @throws IOException if an I/O error occurs.
  * @throws EOFException if the end of file is reached before even one
  * character (byte) could be read.
  */
  public String readLine() throws IOException, EOFException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.readLine()");
////#endif /* TRACE0 */
    String sout="";
    try {
      char ch;
      while ((ch=(char)readUnsignedByte())!='\n') {
        sout+=ch;
      }
      sout+=ch;
    } catch (EOFException e) {
      if (sout.length()==0) {
////#ifdef TRACE0
//        Trace.level--;
////#endif /* TRACE0 */
        throw e;
      }
    }

////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
    return sout;
  }

  /**
  * Closes the connection to the file. This includes any Streams as well
  * as the Socket and the RandomAccessFile from the constructor.
  * @throws IOException if an I/O error occurs.
  */
  public void close() throws IOException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.close()");
////#endif /* TRACE0 */
    try {
      fnamp="";
      if (fp!=null) { fp.close(); }
      fp=null;
      if (sk!=null) { sk.close(); }
      sk=null;
      is=null;
      os=null;
    } catch (IOException ie) {
      try {
        if (sk!=null) { sk.close(); }
        sk=null;
        is=null;
        os=null;
      } catch (IOException ies) {
////#ifdef TRACE0
//        Trace.level--;
////#endif /* TRACE0 */
        throw ies;
      }
////#ifdef TRACE0
//      Trace.level--;
////#endif /* TRACE0 */
      throw ie;
    }
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
  }

  /**
  * Returns the current position of the file pointer.
  * @return the current position of the file pointer.
  */
  public long getFilePointer() {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.getFilePointer()");
//    Trace.level--;
////#endif /* TRACE0 */
    return fpos;
  }

  /**
  * Returns the length of the file.
  * @return the length of the file in bytes.
  * @throws IOException if an I/O error occurs.
  */
  public long length() throws IOException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.length()");
////#endif /* TRACE0 */
    if (fp!=null && savedLength<0) { savedLength=fp.length(); }
    if (fp!=null || savedLength>=0) {
////#ifdef TRACE0
//          Trace.level--;
////#endif /* TRACE0 */
      return savedLength;
    }

    long len=0;
    String s="HEAD "+fnamp+" HTTP/1.1\r\n"+
             "User-Agent: "+useragent+"\r\n"+
             "Host: "+host+":"+port+"\r\n\r\n";
    String sout = "";
    int failures = 0;
    int rc = 0;
    while (true) {
      try {
        URLwrite(os,s);
        sout=URLread(is);
      } catch (IOException ioe) {
        if (++failures>=MAX_FAILURES) {
////#ifdef TRACE0
//          Trace.level--;
////#endif /* TRACE0 */
          throw new IOException("(java.net.SocketException) "+ioe.getMessage());
        }
        reconnect();
        continue;
      }
      rc=checkHeader(sout);
      if (rc<0) { // What has happened? Invalid header?
        if (++failures>=MAX_FAILURES) {
////#ifdef TRACE0
//          Trace.level--;
////#endif /* TRACE0 */
          throw new IOException("Failed to read a valid / complete header.");
        }
        reconnect();
        continue;
      }
      break;
    }
    int idx=sout.indexOf("Content-Length:");
    if (rc==200 && sout.indexOf("Content-Length:") >= 0) {
      sout=sout.substring(idx+"Content-Length:".length());
      sout=sout.substring(0,sout.indexOf("\n")).trim();
      len=Long.parseLong(sout);
    } else {
////#ifdef TRACE0
//      Trace.level--;
////#endif /* TRACE0 */
      throw new IOException("Can't determine length of (HTTP-)file '"+fnamp+
                            "'. HTTP error code: "+rc);
    }
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
    return len;
  }

  /**
  * Positions the file pointer.
  * @param pos the new position in the file. The position is seen zero based.
  */
  public void seek(long pos) {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.seek()");
//    Trace.level--;
////#endif /* TRACE0 */
    fpos=pos;
  }

  /**
  * Repositions the file pointer by skipping some bytes from the current
  * position.
  * @param count How many bytes to skip.
  * @throws EOFException if the new position would be beyond the end of the
  * file.
  * @throws IOException if an I/O error occurs.
  */
  void skipBytes(int count) throws IOException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.skipBytes(int)");
////#ifdef TRACE1
//    DevNull.println("    count: " + count);
////#endif /* TRACE1 */
////#endif /* TRACE0 */
    if (fpos+count>=length()) {
////#ifdef TRACE0
//      Trace.level--;
////#endif /* TRACE0 */
      throw new EOFException("Filepointer position "+(fpos+count)+" exceeds "+
                             "file length by "+(fpos+count-length()+1)+
                             " byte(s).");
    }
    fpos+=count;
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
  }


// RFC 2068: Response = Status-Line
//                      * ( general-header
//                        | response-header
//                        | entity-header )
//                     CRLF
//                     [ message-body ]
//
// Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
//
// Status-Code should (has to?) be 206
//


  private String URLread(InputStream is) throws IOException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.URLread(InputStream)");
////#ifdef TRACE1
//    DevNull.println("    is: " + is);
////#endif /* TRACE1 */
////#endif /* TRACE0 */
    StringBuffer sret=new StringBuffer("");
    int av = is.read();
    if (av == -1) {
////#ifdef TRACE0
//      Trace.level--;
////#endif /* TRACE0 */
      throw new IOException("No bytes available.");
    }
    sret.append((char)av);
    while (is.available()>0) {
      sret.append((char)is.read());
    }
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
    return sret.toString();
  }

  private void URLwrite(BufferedOutputStream os, String s) throws IOException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.URLwrite(BufferedOutputStream, String)");
////#ifdef TRACE1
//    DevNull.println("    os: " + os + " \n    s: " + s);
////#endif /* TRACE1 */
////#endif /* TRACE0 */
    for(int n=0; n<s.length(); n++) {
      os.write((byte)s.charAt(n));
    }
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
    os.flush();
  }

  // Returns the data part of the html response in String s
  private String htmlStrip(String s) {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.htmlStrip(String)");
////#ifdef TRACE1
//    DevNull.println("    s: " + s);
////#endif /* TRACE1 */
////#endif /* TRACE0 */
    int idx=s.indexOf("\r\n\r\n");
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
    if (idx>=0) {
      return s.substring(idx+4);
    }
    return "";
  }

  // Returns the http return code or -1, if not available
  private int checkHeader(String s) {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.checkHeader(String)");
////#ifdef TRACE1
//    DevNull.println("    s: " + s);
////#endif /* TRACE1 */
////#endif /* TRACE0 */
    try {
      int ix1=s.indexOf(" ");
      int ix2=s.indexOf(" ",ix1+1);
////#ifdef TRACE0
//      Trace.level--;
////#endif /* TRACE0 */
      if (ix1<0 || ix2<0 || ix1<8 || ix1+4!=ix2) { return -1; }
      return Integer.parseInt(s.substring(ix1+1,ix2));
    } catch (NumberFormatException nf) {
////#ifdef TRACE0
//      Trace.level--;
////#endif /* TRACE0 */
      return -1;
    }
  }


  // Reads a chunk of data to the buffer data[][idx]
  private void readToBuffer() throws IOException, EOFException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.readToBuffer()");
////#endif /* TRACE0 */
    // Directly reading a file:
    if (fp!=null) { 
      fp.seek(fpos);
      int cnt=fp.read(inbuf);
// Probably, RandomAccessFile.read(byte[n]) performes n read operations???
      if (cnt==-1) {
////#ifdef TRACE0
//        Trace.level--;
////#endif /* TRACE0 */
        throw new EOFException("Filepointer position "+fpos+" exceeds file"+
                               " length by "+(fpos-length()+1)+" byte(s).");
      }
      for(int n=0;n<cnt;n++) {
        data[n][idx]=inbuf[n];
      } 
      startIdx[idx]=fpos;
      endIdx[idx]=fpos+cnt-1;
////#ifdef TRACE0
//      Trace.level--;
////#endif /* TRACE0 */
      return;
    }

    // Reading via http:
    if (fpos>=length()) {
////#ifdef TRACE0
//      Trace.level--;
////#endif /* TRACE0 */
      throw new EOFException("Filepointer position "+fpos+" exceeds file "+
                             "length by "+(fpos-length()+1)+" byte(s).");
    }
    String s="GET "+fnamp+" HTTP/1.1\r\n"+
             "User-Agent: "+useragent+"\r\n"+
             "Host: "+host+":"+port+"\r\n"+
             "Range: bytes="+fpos+"-"+
                                Math.min(length()-1,fpos+BUFSIZE-1)+"\r\n\r\n";
    String sout="";
    int slen=0;
    int failures=0;
    while (true) {
      try {
        URLwrite(os,s);
        sout=URLread(is);
      } catch (IOException ioe) {
        if (++failures>=MAX_FAILURES) {
////#ifdef TRACE0
//          Trace.level--;
////#endif /* TRACE0 */
          throw new IOException("(java.net.SocketException) "+ioe.getMessage());
        }
        reconnect();
        continue;
      }
      int rc=checkHeader(sout);
      if (rc<0) { // What has happened?
        if (++failures>=MAX_FAILURES) { // Too many failures in a row, abort:
////#ifdef TRACE0
//          Trace.level--;
////#endif /* TRACE0 */
          throw new IOException("Failed to read successfully from address\n'"+
                                fnamp+"'. The http reply from the server was "+
                                sout.length()+
                                " bytes long and it's content is:\n\n"+sout);
        }
        continue;
      }
      sout=htmlStrip(sout); // keep data part of http response only
      slen=sout.length();
      if ((rc!=200 /* OK */ && rc!=206 /* Partial content */) ||
          slen>BUFSIZE ||
          (slen<BUFSIZE && savedLength>=0 && fpos+slen != savedLength)) {
        if (++failures>=MAX_FAILURES) {
////#ifdef TRACE0
//          Trace.level--;
////#endif /* TRACE0 */
          throw new IOException("HTTP read failed with HTTP response "+rc+
                                ". Read "+slen+" bytes, requested "+BUFSIZE+
                                " bytes.");
        }
        continue;
      }
      if (slen==0) { // How is this to happen???
        if (++failures>=MAX_FAILURES) {
////#ifdef TRACE0
//          Trace.level--;
////#endif /* TRACE0 */
          throw new EOFException("Filepointer position "+fpos+" exceeds file "+
                                 "length by "+(fpos-length()+1)+" byte(s).");
        }
        continue;
      }
      break;
    }
    startIdx[idx]=fpos;
    endIdx[idx]=fpos+slen-1;
    for(int n=0;n<slen;n++) {
      data[n][idx]=(byte)sout.charAt(n);
    }
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
  }

  private void reconnect() throws IOException {
////#ifdef TRACE0
//    DevNull.println(System.currentTimeMillis()+" FilePtr.reconnect()");
////#endif /* TRACE0 */
System.err.println("reconnecting...");
    sk.close();
    sk=new Socket(host,port);
    sk.setSoTimeout(5000);
    is=sk.getInputStream();
    os=new BufferedOutputStream(sk.getOutputStream());
  }
}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class GenConst {
 double clight,
        aunit,
        helgravconst,
        ratme,
        sunradius;

}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


/**
* A class to contain all the data that are relevant to houses in astrology.
* Does not seem to be relevant outside this package...
* <P><I><B>You will find the complete documentation for the original
* SwissEphemeris package at <A HREF="http://www.astro.ch/swisseph/sweph_g.htm">
* http://www.astro.ch/swisseph/sweph_g.htm</A>. By far most of the information 
* there is directly valid for this port to Java as well.</B></I>
* @version 1.0.0a
*/
class Houses {
  /**
  * The twelve house cusps from cusp[1] to cusp[12] plus many additional
  * points.
  */
  double cusp[]=new double[37];
  /**
  * The double value of the ascendent.
  */
  double ac;
  /**
  * The double value of the MC (=Medium Coeli = the midpoint of the heaven).
  */
  double mc;
  /**
  * The double value of the vertex.
  */
  double vertex;
  /**
  * The double value of the "equatorial ascendant".
  */
  double equasc;
  /**
  * The double value of the "co-ascendant" (Walter Koch).
  */
  double coasc1;
  /**
  * The double value of the "co-ascendant" (Michael Munkasey).
  */
  double coasc2;
  /**
  * The double value of the "polar ascendant" (Michael Munkasey).
  */
  double polasc;

}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


/**
* This class enables methods to return an integer by reference. We need this
* here, as this is a very direct port from C to Java, where reference
* parameters are used from time to time.
* <P><I><B>You will find the complete documentation for the original
* SwissEphemeris package at <A HREF="http://www.astro.ch/swisseph/sweph_g.htm">
* http://www.astro.ch/swisseph/sweph_g.htm</A>. By far most of the information 
* there is directly valid for this port to Java as well.</B></I>
* @version 1.0.0a
*/
class IntObj {
  /**
  * This is the integer value that has become wrapped up into a real object.
  */
  public int val;

}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class Nut {
  /* nutation */
  double tnut;
  double nutlo[];      /* nutation in longitude and obliquity */
  double snut, cnut;    /* sine and cosine of nutation in obliquity */
  double matrix[][];

  Nut() {
    nutlo = new double[2];
    matrix = new double[3][3];
  }

  void clearData() {
    int i,j;
    tnut=0.0;
    snut=0.0;
    cnut=0.0;
    for(j=0; j<nutlo.length; j++) { nutlo[j]=0.0; }
    for(j=0; j<matrix.length; j++) {
      for(i=0; i<matrix[j].length; i++) {
        matrix[j][i]=0.0;
      }
    }
  }
}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class PlanData {
  double x[]=new double[6]; /* position and speed vectors equatorial J2000 */
  double xreturn[]=new double[24]; /* return positions:
                         * xreturn+0    ecliptic polar coordinates
                         * xreturn+6    ecliptic cartesian coordinates
                         * xreturn+12   equatorial polar coordinates
                         * xreturn+18   equatorial cartesian coordinates
                         */

  /* the following data are read from file only once, immediately after
   * file has been opened */
  int ibdy=0;           /* internal body number */
  int iflg=0;          /* contains several bit flags describing the data:
                         * SEI_FLG_HELIO: true if helio, false if bary
                         * SEI_FLG_ROTATE: TRUE if coefficients are referred
                         *      to coordinate system of orbital plane
                         * SEI_FLG_ELLIPSE: TRUE if reference ellipse */
  int ncoe=0;           /* # of coefficients of ephemeris polynomial,
                           is polynomial order + 1  */
  /* where is the segment index on the file */
  long lndx0=0;         /* file position of begin of planet's index */
  int nndx=0;           /* number of index entries on file: computed */
  double tfstart=0;     /* file contains ephemeris for tfstart thru tfend */
  double tfend=0;       /*      for this particular planet !!!            */
  double dseg=0;        /* segment size (days covered by a polynomial)  */
  /* orbital elements: */
  double telem=0;       /* epoch of elements */
  double prot=0;
  double qrot=0;
  double dprot=0;
  double dqrot=0;
  double rmax=0;        /* normalisation factor of cheby coefficients */
  /* in addition, if reference ellipse is used: */
  double peri=0;
  double dperi=0;
////  double *refep;        /* pointer to cheby coeffs of reference ellipse,
////                         * size of data is 2 x ncoe */
  double refep[]=null;  /* pointer to cheby coeffs of reference ellipse,
                         * size of data is 2 x ncoe */
  /* unpacked segment information, only updated when a segment is read: */
  double tseg0=0, tseg1=0;  /* start and end jd of current segment */
////  double *segp;         /* pointer to unpacked cheby coeffs of segment;
////                         * the size is 3 x ncoe */
  double segp[]=null;   /* pointer to unpacked cheby coeffs of segment;
                         * the size is 3 x ncoe */
  int neval=0;          /* how many coefficients to evaluate. this may
                         * be less than ncoe */
  /* result of most recent data evaluation for this body: */
  double teval=0;       /* time for which previous computation was made */
  int iephe=0;          /* which ephemeris was used */
  int xflgs=0;         /* hel., light-time, aberr., prec. flags etc. */

  PlanData() {
    for(int i=0;i<x.length;i++) { x[i]=0.; } // Really?
    for(int i=0;i<x.length;i++) { xreturn[i]=0.; } // Really?
  }


  void clearData() {
    int j;

    ibdy=0;
    iflg=0;
    ncoe=0;
    lndx0=0;
    nndx=0;
    tfstart=0.0;
    tfend=0.0;
    dseg=0.0;
    telem=0.0;
    prot=0.0;
    qrot=0.0;
    dprot=0.0;
    dqrot=0.0;
    rmax=0.0;
    peri=0.0;
    dperi=0.0;
    tseg0=0.0;
    tseg1=0.0;
    neval=0;
    teval=0.0;
    iephe=0;
    xflgs=0;
    for(j=0; j<x.length; j++) { x[j]=0.0; }
    for(j=0; j<xreturn.length; j++) { xreturn[j]=0.0; }
    refep=null;
    segp=null;
  }
}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class Plantbl {
  short max_harmonic[]=new short[9];
  short max_power_of_t;
  byte[] arg_tbl;
  double[] lon_tbl;
  double[] lat_tbl;
  double[] rad_tbl;
  double distance;

  Plantbl(short[] max_harmonic, short max_power_of_t, byte[] arg_tbl,
          double[] lon_tbl, double[] lat_tbl, double[] rad_tbl,
          double distance) {
    this.max_harmonic=max_harmonic;
    this.max_power_of_t=max_power_of_t;
    this.arg_tbl=arg_tbl;
    this.lon_tbl=lon_tbl;
    this.lat_tbl=lat_tbl;
    this.rad_tbl=rad_tbl;
    this.distance=distance;
  }
}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class SavePositions {
  int ipl;
  double tsave=0.;
  int iflgsave;
  /* position at t = tsave,
   * in ecliptic polar (offset 0),
   *    ecliptic cartesian (offset 6),
   *    equatorial polar (offset 12),
   *    and equatorial cartesian coordinates (offset 18).
   * 6 doubles each for position and speed coordinates.
   */
  double xsaves[]=new double[24];

  void clearData() {
    for (int i=0; i<xsaves.length; i++) {
      xsaves[i]=0.;
    }
    ipl=0; tsave=0.; iflgsave=0;
  }



}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


/**
* A class to contain all the data for sidereal calculations.<P>
* t0(?) / ayan_t0(?) is the epoch at which ayanamsha = 0.
* This should be for internal use only - no necessity to have it outside
* this package. You will set these data via swe_set_sid_mode normally.
* <P><I><B>You will find the complete documentation for the original
* SwissEphemeris package at <A HREF="http://www.astro.ch/swisseph/sweph_g.htm">
* http://www.astro.ch/swisseph/sweph_g.htm</A>. By far most of the information 
* there is directly valid for this port to Java as well.</B></I>
* @see SwissEph#swe_set_sid_mode
* @version 1.0.0a
*/
class SidData {
  int sid_mode=0;
  double ayan_t0=0.;
  double t0=0.;

}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.64.01
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following.
   
   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


/**
* This class initiates the calculation of solar and lunar eclipses, of
* sun risetime and time of sunset, and lastly the calculation of the
* phenomena phase angle, phase, elongation of planet, apparent diameter
* of disc and apparent magnitude of the sun, moon, any planet or asteroid.<BR>
*
* <P><I><B>You will find the complete documentation for the original
* SwissEphemeris package at <A HREF="http://www.astro.ch/swisseph/sweph_g.htm">
* http://www.astro.ch/swisseph/sweph_g.htm</A>. By far most of the information 
* there is directly valid for this port to Java as well.</B></I>
*/
class Swecl {

  SwissEph  sw=null;
  SwissLib  sl=null;
  Swemmoon  sm=null;
  SwissData swed=null;


  private static final double DSUN=(1392000000.0 / SweConst.AUNIT);
  private static final double DMOON=(3476300.0 / SweConst.AUNIT);
  private static final double DEARTH=(6378140.0 * 2 / SweConst.AUNIT);
  private static final double RSUN=(DSUN / 2);
  private static final double RMOON=(DMOON / 2);
  private static final double REARTH=(DEARTH / 2);
  private static final int SEI_OCC_FAST=(16 * 1024);

  private static final double lnlog=Math.log(10);
  private double log10(double x) { return Math.log(x)/lnlog; }


  /**
  * Creates a new instance of this object.
  */
  Swecl() {
    this(null, null, null, null);
    sw=new SwissEph();
    sl=new SwissLib();
    sm=new Swemmoon();
    swed=new SwissData();
  }

  /**
  * Creates a new instance of this object and uses all the given
  * objects, as far as they are not null.
  * @param sw A SwissEph object that might already be available at the time
  * of creation of this object.
  * @param sl A SwissLib object that might already be available at the time
  * of creation of this object.
  * @param sm A Swemmoon object that might already be available at the time
  * of creation of this object.
  * @param swed A SwissData object that might already be available at the time
  * of creation of this object.
  */
  Swecl(SwissEph sw, SwissLib sl, Swemmoon sm, SwissData swed) {
    this.sw=sw;
    this.sl=sl;
    this.sm=sm;
    this.swed=swed;
    if (sw==null) { this.sw=new SwissEph(); }
    if (sl==null) { this.sl=new SwissLib(); }
    if (sm==null) { this.sm=new Swemmoon(); }
    if (swed==null) { this.swed=new SwissData(); }
  }

  /* Computes geographic location and type of solar eclipse
   * for a given tjd
   * iflag:        to indicate ephemeris to be used
   *                        (SEFLG_JPLEPH, SEFLG_SWIEPH, SEFLG_MOSEPH)
   *
   * Algorithms for the central line is taken from Montenbruck, pp. 179ff.,
   * with the exception, that we consider refraction for the maxima of
   * partial and noncentral eclipses.
   * Geographical positions are referred to sea level / the mean ellipsoid.
   *
   * Errors:
   * - from uncertainty of JPL-ephemerides (0.01 arcsec):
   *        about 40 meters
   * - from displacement of shadow points by atmospheric refraction:
   *      a few meters
   * - from deviation of the geoid from the ellipsoid
   *      a few meters
   * - from polar motion
   *      a few meters
   * For geographical locations that are interesting for observation,
   * the error is always < 100 m.
   * However, if the sun is close to the horizon,
   * all of these errors can grow up to a km or more.
   *
   * Function returns:
   * -1 (ERR)        on error (e.g. if swe_calc() for sun or moon fails)
   * 0                if there is no solar eclipse at tjd
   * SE_ECL_TOTAL
   * SE_ECL_ANNULAR
   * SE_ECL_TOTAL | SE_ECL_CENTRAL
   * SE_ECL_TOTAL | SE_ECL_NONCENTRAL
   * SE_ECL_ANNULAR | SE_ECL_CENTRAL
   * SE_ECL_ANNULAR | SE_ECL_NONCENTRAL
   * SE_ECL_PARTIAL
   *
   * geopos[0]:        geographic longitude of central line
   * geopos[1]:        geographic latitude of central line
   *
   * not implemented so far:
   *
   * geopos[2]:        geographic longitude of northern limit of umbra
   * geopos[3]:        geographic latitude of northern limit of umbra
   * geopos[4]:        geographic longitude of southern limit of umbra
   * geopos[5]:        geographic latitude of southern limit of umbra
   * geopos[6]:        geographic longitude of northern limit of penumbra
   * geopos[7]:        geographic latitude of northern limit of penumbra
   * geopos[8]:        geographic longitude of southern limit of penumbra
   * geopos[9]:        geographic latitude of southern limit of penumbra
   *
   * Attention: "northern" and "southern" limits of umbra do not
   * necessarily correspond to the northernmost or southernmost
   * geographic position, where the total, annular, or partial
   * phase is visible at a given time.
   * Imagine a situation in northern summer, when the sun illuminates
   * the northern polar circle. The southernmost point of the core
   * shadow may then touch the north pole, and therefore the
   * northernmost point will be more in the south.
   * Note also that with annular eclipses, the northern edge is
   * usually geographically the southern one. With annular-total
   * ones, the two lines cross, usually twice. The maximum is always
   * total in such cases.
   *
   * attr[0]        fraction of solar diameter covered by moon (magnitude)
   * attr[1]        ratio of lunar diameter to solar one
   * attr[2]        fraction of solar disc covered by moon (obscuration)
   * attr[3]      diameter of core shadow in km
   * attr[4]        azimuth of sun at tjd
   * attr[5]        true altitude of sun above horizon at tjd
   * attr[6]        apparent altitude of sun above horizon at tjd
   * attr[7]        angular distance of moon from sun in degrees
   *         declare as attr[20] at least !
   */
  /**
  * Computes the geographic location for a given time, where a solar
  * eclipse is central (or maximum for a non-central eclipse).
  * <P>Output parameters:<BLOCKQUOTE><P><CODE>
  * geopos[0]:&nbsp;&nbsp;&nbsp;geographic longitude of central line<BR>
  * geopos[1]:&nbsp;&nbsp;&nbsp;geographic latitude of central line<BR>
  * </CODE><P><CODE>
  * attr[0]:&nbsp;&nbsp;&nbsp;fraction of solar diameter covered by moon
  * (magnitude)<BR>
  * attr[1]:&nbsp;&nbsp;&nbsp;ratio of lunar diameter to solar one<BR>
  * attr[2]:&nbsp;&nbsp;&nbsp;fraction of solar disc covered by moon
  * (obscuration)<BR>
  * attr[3]:&nbsp;&nbsp;&nbsp;diameter of core shadow in km<BR>
  * attr[4]:&nbsp;&nbsp;&nbsp;azimuth of sun at tjd<BR>
  * attr[5]:&nbsp;&nbsp;&nbsp;true altitude of sun above horizon at tjd<BR>
  * attr[6]:&nbsp;&nbsp;&nbsp;apparent altitude of sun above horizon at tjd<BR>
  * attr[7]:&nbsp;&nbsp;&nbsp;angular distance of moon from sun in degrees
  * </CODE><P></BLOCKQUOTE>
  * <B>Attention: geopos must be a double[10], attr a double[20]!</B>
  * @param tjd_ut The Julian Day number in UT
  * @param ifl To indicate, which ephemeris to be used (SEFLG_JPLEPH,
  * SEFLG_SWIEPH, SEFLG_MOSEPH)
  * @param geopos An array[10], on return containing the geographic positions.
  * @param attr An array[20], on return containing the attributes of the
  * eclipse as above.
  * @param serr A StringBuffer containing a warning or error message, if
  * something fails.
  * @return -1 (SweConst.ERR), if the calculation failed<BR>
  * 0 (SweConst.OK), if there is no solar eclipse at that time<BR>
  * SweConst.SE_ECL_TOTAL<BR>
  * SweConst.SE_ECL_ANNULAR<BR>
  * SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_CENTRAL<BR>
  * SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_NONCENTRAL<BR>
  * SweConst.SE_ECL_ANNULAR | SweConst.SE_ECL_CENTRAL<BR>
  * SweConst.SE_ECL_ANNULAR | SweConst.SE_ECL_NONCENTRAL<BR>
  * SweConst.SE_ECL_PARTIAL<BR>
  */
  int swe_sol_eclipse_where(double tjd_ut,
                            int ifl,
                            double[] geopos,
                            double[] attr,
                            StringBuffer serr) {
    int retflag, retflag2;
    double dcore[]=new double[10];
    ifl &= SweConst.SEFLG_EPHMASK;
    if ((retflag = eclipse_where(tjd_ut, SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) < 0) {
      return retflag;
    }
    if ((retflag2 = eclipse_how(tjd_ut, SweConst.SE_SUN, null, ifl, geopos[0], geopos[1], 0, attr, serr)) == SweConst.ERR) {
      return retflag2;
    }
    attr[3] = dcore[0];
    return retflag;
  }

  int swe_lun_occult_where(double tjd_ut,
                           int ipl,
                           StringBuffer starname,
                           int ifl,
                           double[] geopos,
                           double[] attr,
                           StringBuffer serr) {
    int retflag, retflag2;
    double dcore[]=new double[10];
    ifl &= SweConst.SEFLG_EPHMASK;
    if ((retflag = eclipse_where(tjd_ut, ipl, starname, ifl, geopos, dcore, serr)) < 0) {
      return retflag;
    }
    if ((retflag2 = eclipse_how(tjd_ut, ipl, starname, ifl, geopos[0], geopos[1], 0, attr, serr)) == SweConst.ERR) {
      return retflag2;
    }
    attr[3] = dcore[0];
    return retflag;
  }

  /* Used by several swe_sol_eclipse_ functions.
   * Like swe_sol_eclipse_where(), but instead of attr[0], it returns:
   *
   * dcore[0]:        core shadow width in km
   * dcore[2]:        distance of shadow axis from geocenter r0
   * dcore[3]:        diameter of core shadow on fundamental plane d0
   * dcore[4]:        diameter of half-shadow on fundamental plane D0
   */
  private int eclipse_where(double tjd_ut, int ipl, StringBuffer starname, int ifl,
                            double[] geopos, double[] dcore, StringBuffer serr) {
    int i;
    int retc = 0, niter = 0;
    double e[]=new double[6], et[]=new double[6], erm[]=new double[6],
           rm[]=new double[6], rs[]=new double[6], rmt[]=new double[6],
           rst[]=new double[6], xs[]=new double[6], xst[]=new double[6];
    double xssv[]=new double[16], x[]=new double[6];
    double lm[]=new double[6], ls[]=new double[6], lx[]=new double[6];
    double dsm, dsmt, d0, D0, s0, r0, d, s, dm;
    double de = 6378140.0 / SweConst.AUNIT;
    double earthobl = 1 - SwephData.EARTH_OBLATENESS;
    double deltat, tjd, sidt;
    double drad;
    double sinf1, sinf2, cosf1, cosf2;
    int iflag, iflag2;
    /* double ecce = Math.sqrt(2 * SwephData.EARTH_OBLATENESS - SwephData.EARTH_OBLATENESS * SwephData.EARTH_OBLATENESS); */
    boolean no_eclipse = false;
    Epsilon oe = swed.oec;
    for (i = 0; i < 10; i++)
      dcore[i] = 0;
    /* nutation need not be in lunar and solar positions,
     * if mean sidereal time will be used */
    iflag = SweConst.SEFLG_SPEED | SweConst.SEFLG_EQUATORIAL | ifl;
    iflag2 = iflag | SweConst.SEFLG_RADIANS;
    iflag  = iflag | SweConst.SEFLG_XYZ;
    deltat = SweDate.getDeltaT(tjd_ut);
    tjd = tjd_ut + deltat;
    /* moon in cartesian coordinates */
    if ((retc = sw.swe_calc(tjd, SweConst.SE_MOON, iflag, rm, serr)) == SweConst.ERR) {
      return retc;
    }
    /* moon in polar coordinates */
    if ((retc = sw.swe_calc(tjd, SweConst.SE_MOON, iflag2, lm, serr)) == SweConst.ERR)
      return retc;
    /* sun in cartesian coordinates */
    if ((retc = calc_planet_star(tjd, ipl, starname, iflag, rs, serr)) == SweConst.ERR)
      return retc;
    /* sun in polar coordinates */
    if ((retc = calc_planet_star(tjd, ipl, starname, iflag2, ls, serr)) == SweConst.ERR)
      return retc;
    /* save sun position */
    for (i = 0; i <= 2; i++)
      rst[i] = rs[i];
    /* save moon position */
    for (i = 0; i <= 2; i++)
      rmt[i] = rm[i];
    if ((iflag & SweConst.SEFLG_NONUT)!=0) {
      sidt = sl.swe_sidtime0(tjd_ut, oe.eps * SwissData.RADTODEG, 0) * 15 *
                                                            SwissData.DEGTORAD;
    } else {
      sidt = sl.swe_sidtime(tjd_ut) * 15 * SwissData.DEGTORAD;
    }
    /*
     * radius of planet disk in AU
     */
    if (starname != null && starname.length() > 0)
      drad = 0;
    else if (ipl < SwephData.NDIAM)
      drad = SwephData.pla_diam[ipl] / 2 / SweConst.AUNIT;
    else if (ipl > SweConst.SE_AST_OFFSET)
      drad = swed.ast_diam / 2 * 1000 / SweConst.AUNIT; /* km -> m -> AU */
    else
      drad = 0;
//iter_where:
    while(true) {
      for (i = 0; i <= 2; i++) {
        rs[i] = rst[i];
        rm[i] = rmt[i];
      }
      /* Account for oblateness of earth:
       * Instead of flattening the earth, we apply the
       * correction to the z coordinate of the moon and
       * the sun. This makes the calculation easier.
       */
      for (i = 0; i <= 2; i++)
        lx[i] = lm[i];
      sl.swi_polcart(lx, rm);
      rm[2] /= earthobl;
      /* distance of moon from geocenter */
      dm = Math.sqrt(sl.square_sum(rm));
      /* Account for oblateness of earth */
      for (i = 0; i <= 2; i++)
        lx[i] = ls[i];
      sl.swi_polcart(lx, rs);
      rs[2] /= earthobl;
      /* sun - moon vector */
      for (i = 0; i <= 2; i++) {
        e[i] = (rm[i] - rs[i]);
        et[i] = (rmt[i] - rst[i]);
      }
      /* distance sun - moon */
      dsm = Math.sqrt(sl.square_sum(e));
      dsmt = Math.sqrt(sl.square_sum(et));
      /* sun - moon unit vector */
      for (i = 0; i <= 2; i++) {
        e[i] /= dsm;
        et[i] /= dsmt;
        erm[i] = rm[i] / dm;
      }
      sinf1 = ((drad - RMOON) / dsm);
      cosf1 = Math.sqrt(1 - sinf1 * sinf1);
      sinf2 = ((drad + RMOON) / dsm);
      cosf2 = Math.sqrt(1 - sinf2 * sinf2);
      /* distance of moon from fundamental plane */
      s0 = -sw.dot_prod(rm, e);
      /* distance of shadow axis from geocenter */
      r0 = Math.sqrt(dm * dm - s0 * s0);
      /* diameter of core shadow on fundamental plane */
      d0 = (s0 / dsm * (drad * 2 - DMOON) - DMOON) / cosf1;
      /* diameter of half-shadow on fundamental plane */
      D0 = (s0 / dsm * (drad * 2 + DMOON) + DMOON) / cosf2;
      dcore[2] = r0;
      dcore[3] = d0;
      dcore[4] = D0;
      dcore[5] = cosf1;
      dcore[6] = cosf2;
      for (i = 2; i < 5; i++)
        dcore[i] *= SweConst.AUNIT / 1000.0;
      /**************************
       * central (total or annular) phase
       **************************/
      retc = 0;
      if (de * cosf1 >= r0) {
        retc |= SweConst.SE_ECL_CENTRAL;
      } else if (r0 <= de * cosf1 + Math.abs(d0) / 2) {
        retc |= SweConst.SE_ECL_NONCENTRAL;
      } else if (r0 <= de * cosf2 + D0 / 2) {
        retc |= (SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_NONCENTRAL);
      } else {
        if (serr != null) {
          serr.setLength(0);
          serr.append("no solar eclipse at tjd = "+tjd);
        }
        for (i = 0; i < 10; i++)
          geopos[i] = 0;
//    *dcore = 0;
        dcore[0] = 0;
        retc = 0;
        d = 0;
        no_eclipse = true;
        /*return retc;*/
      }
      /* distance of shadow point from fundamental plane */
      d = s0 * s0 + de * de - dm * dm;
      if (d > 0) {
        d = Math.sqrt(d);
      } else {
        d = 0;
      }
      /* distance of moon from shadow point on earth */
      s = s0 - d;
      /* next: geographic position of eclipse center.
       * if shadow axis does not touch the earth,
       * place on earth with maximum occultation is computed.
       */
      /* geographic position of eclipse center (maximum) */
      for (i = 0; i <= 2; i++)
        xs[i] = rm[i] + s * e[i];
      /* we need geographic position with correct z, as well */
      for (i = 0; i <= 2; i++)
        xst[i] = xs[i];
      xst[2] *= earthobl;
      sl.swi_cartpol(xst, xst);
      if (niter <= 0) {
        double cosfi = Math.cos(xst[1]);
        double sinfi = Math.sin(xst[1]);
        double eobl = SwephData.EARTH_OBLATENESS;
        double cc= 1 / Math.sqrt(cosfi * cosfi + (1-eobl) * (1-eobl) * sinfi * sinfi);
        double ss= (1-eobl) * (1-eobl) * cc;
        earthobl =  ss;
        niter++;
//      goto iter_where;
        continue;
      }
      sl.swi_polcart(xst, xst);
      /* to longitude and latitude */
      sl.swi_cartpol(xs, xs);
      /* measure from sidereal time at greenwich */
      xs[0] -= sidt;
      xs[0] *= SwissData.RADTODEG;
      xs[1] *= SwissData.RADTODEG;
      xs[0] = sl.swe_degnorm(xs[0]);
      /* west is negative */
      if (xs[0] > 180) {
        xs[0] -= 360;
      }
      xssv[0] = xs[0];
      xssv[1] = xs[1];
      geopos[0] = xs[0];
      geopos[1] = xs[1];
      /* diameter of core shadow:
       * first, distance moon - place of eclipse on earth */
      for (i = 0; i <= 2; i++)
        x[i] = rmt[i] - xst[i];
      s = Math.sqrt(sl.square_sum(x));
      /* diameter of core shadow at place of maximum eclipse */
      dcore[0] = (s / dsmt * ( drad * 2 - DMOON) - DMOON) * cosf1;
      dcore[0] *= SweConst.AUNIT / 1000.0;
      /* diameter of penumbra at place of maximum eclipse */
      dcore[1] = (s / dsmt * ( drad * 2 + DMOON) + DMOON) * cosf2;
      dcore[1] *= SweConst.AUNIT / 1000.0;
      if ((retc & SweConst.SE_ECL_PARTIAL)==0 && !no_eclipse) {
        if (dcore[0] > 0) {
          retc |= SweConst.SE_ECL_ANNULAR;
        } else {
          /*printf("total\n");*/
          retc |= SweConst.SE_ECL_TOTAL;
        }
      }
      break; // while (true) ... [goto iter_where]
    }
    return retc;
  }

  private int calc_planet_star(double tjd_et, int ipl, StringBuffer starname, int iflag, double[] x, StringBuffer serr) {
    int i;
    int retc = SweConst.OK;
    if (starname == null || starname.length() == 0) {
      retc = sw.swe_calc(tjd_et, ipl, iflag, x, serr);
    } else {
      if ((retc = sw.swe_fixstar(starname, tjd_et, iflag, x, serr)) ==
                                                                SweConst.OK) {
        /* fixstars have the standard distance 1.
         * in the occultation routines, this might lead to errors
         * if interpreted as AU distance. To avoid this, we make it very high.
         */
        if ((iflag & SweConst.SEFLG_XYZ)!=0) {
          for (i = 0; i < 3; i++)
            x[i] *= 100000000;
        } else {
          x[2] *= 100000000;
        }
      }
    }
    return retc;
  }

  /* Computes attributes of a solar eclipse for given tjd, geo. longitude,
   * geo. latitude, and geo. height.
   *
   * retflag        SE_ECL_TOTAL or SE_ECL_ANNULAR or SE_ECL_PARTIAL
   *              SE_ECL_NONCENTRAL
   *              if 0, no eclipse is visible at geogr. position.
   *
   * attr[0]        fraction of solar diameter covered by moon (magnitude)
   * attr[1]        ratio of lunar diameter to solar one
   * attr[2]        fraction of solar disc covered by moon (obscuration)
   * attr[3]      diameter of core shadow in km
   * attr[4]        azimuth of sun at tjd
   * attr[5]        true altitude of sun above horizon at tjd
   * attr[6]        apparent altitude of sun above horizon at tjd
   * attr[7]        elongation of moon in degrees
   *         declare as attr[20] at least !
   *
   */
  /**
  * Computes the attributes of a solar eclipse for a given Julian Day,
  * geographic longitude, latitude, and height.
  * <P><CODE>
  * attr[0]:&nbsp;&nbsp;&nbsp;fraction of solar diameter covered by moon
  * (magnitude)<BR>
  * attr[1]:&nbsp;&nbsp;&nbsp;ratio of lunar diameter to solar one<BR>
  * attr[2]:&nbsp;&nbsp;&nbsp;fraction of solar disc covered by moon
  * (obscuration)<BR>
  * attr[3]:&nbsp;&nbsp;&nbsp;diameter of core shadow in km<BR>
  * attr[4]:&nbsp;&nbsp;&nbsp;azimuth of sun at tjd<BR>
  * attr[5]:&nbsp;&nbsp;&nbsp;true altitude of sun above horizon at tjd<BR>
  * attr[6]:&nbsp;&nbsp;&nbsp;apparent altitude of sun above horizon at tjd<BR>
  * attr[7]:&nbsp;&nbsp;&nbsp;angular distance of moon from sun in degrees
  * </CODE><P><B>Attention: geopos must be a double[10], attr a double[20]!</B>
  * @param tjd_ut The Julian Day number in UT
  * @param ifl To indicate, which ephemeris should be used (SEFLG_JPLEPH,
  * SEFLG_SWIEPH or SEFLG_MOSEPH)
  * @param geopos A double[3] containing geographic longitude, latitude and
  * height in meters above sea level in this order.
  * @param attr An array[20], on return containing the attributes of the
  * eclipse as above
  * @param serr A StringBuffer containing a warning or error message, if
  * something fails
  * @return -1 (SweConst.ERR), if the calculation failed<BR>
  * 0, if there is no solar eclipse at that time and location<BR>
  * SweConst.SE_ECL_TOTAL<BR>
  * SweConst.SE_ECL_ANNULAR<BR>
  * SweConst.SE_ECL_PARTIAL
  */
  int swe_sol_eclipse_how(double tjd_ut,
                          int ifl,
                          double[] geopos,
                          double[] attr,
                          StringBuffer serr) {
    int retflag, retflag2;
    double dcore[]=new double[10];
    double geopos2[]=new double[20];
    ifl &= SweConst.SEFLG_EPHMASK;
    if ((retflag = eclipse_how(tjd_ut, SweConst.SE_SUN, null, ifl, geopos[0],
                               geopos[1], geopos[2], attr, serr)) == SweConst.ERR) {
      return retflag;
    }
    if ((retflag2 = eclipse_where(tjd_ut, SweConst.SE_SUN, null, ifl, geopos2,
                                  dcore, serr)) == SweConst.ERR) {
      return retflag2;
    }
    if (retflag!=0) {
      retflag |= (retflag2 & (SweConst.SE_ECL_CENTRAL | SweConst.SE_ECL_NONCENTRAL));
    }
    attr[3] = dcore[0];
    return retflag;
  }

  private int eclipse_how(double tjd_ut, int ipl, StringBuffer starname,
                          int ifl, double geolon, double geolat, double geohgt,
                          double[] attr, StringBuffer serr) {
    int i;
    int retc = 0;
    double te;
    double xs[]=new double[6], xm[]=new double[6], ls[]=new double[6],
           lm[]=new double[6], x1[]=new double[6], x2[]=new double[6];
    double rmoon, rsun, rsplusrm, rsminusrm;
    double dctr;
    double drad;
    int iflag = SweConst.SEFLG_EQUATORIAL | SweConst.SEFLG_TOPOCTR | ifl;
    int iflagcart = iflag | SweConst.SEFLG_XYZ;
    double mdd, eps, sidt, armc, xh[]=new double[6], hmin_appr;
    double lsun, lmoon, lctr, lsunleft, a, b, sc1, sc2;
    for (i = 0; i < 10; i++)
      attr[i] = 0;
    te = tjd_ut + SweDate.getDeltaT(tjd_ut);
    sw.swe_set_topo(geolon, geolat, geohgt);
    if (calc_planet_star(te, ipl, starname, iflag, ls, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    if (sw.swe_calc(te, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    if (calc_planet_star(te, ipl, starname, iflagcart, xs, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    if (sw.swe_calc(te, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    /*
     * radius of planet disk in AU
     */
    if (starname != null && starname.length() > 0)
      drad = 0;
    else if (ipl < SwephData.NDIAM)
      drad = SwephData.pla_diam[ipl] / 2 / SweConst.AUNIT;
    else if (ipl > SweConst.SE_AST_OFFSET)
      drad = swed.ast_diam / 2 * 1000 / SweConst.AUNIT; /* km -> m -> AU */
    else
      drad = 0;
    /*
     * azimuth and altitude of sun or planet
     */
    eps = sl.swi_epsiln(te);
    if ((iflag & SweConst.SEFLG_NONUT)!=0) {
      sidt = sl.swe_sidtime0(tjd_ut, eps * SwissData.RADTODEG, 0) * 15;
    } else {
      sidt = sl.swe_sidtime(tjd_ut) * 15;
    }
    armc = sidt + geolon;
    mdd = sl.swe_degnorm(ls[0] - armc);
    xh[0] = sl.swe_degnorm(mdd - 90);
    xh[1] = ls[1];
    xh[2] = ls[2];
    sl.swe_cotrans(xh, 0, xh, 0, 90 - geolat);   /* azimuth from east, counterclock */
    /* eclipse description */
    rmoon = Math.asin(RMOON / lm[2]) * SwissData.RADTODEG;
    rsun = Math.asin(drad / ls[2]) * SwissData.RADTODEG;
    rsplusrm = rsun + rmoon;
    rsminusrm = rsun - rmoon;
    for (i = 0; i < 3; i++) {
      x1[i] = xs[i] / ls[2];
      x2[i] = xm[i] / lm[2];
    }
    dctr = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
    /*
     * phase
     */
    if (dctr < rsminusrm) {
      retc = SweConst.SE_ECL_ANNULAR;
    } else if (dctr < Math.abs(rsminusrm)) {
      retc = SweConst.SE_ECL_TOTAL;
    } else if (dctr < rsplusrm) {
      retc = SweConst.SE_ECL_PARTIAL;
    } else {
      retc = 0;
      if (serr != null) {
        serr.setLength(0);
        serr.append("no solar eclipse at tjd = "+tjd_ut);
      }
    }
    /*
     * percentage of eclipse
     */
    /*
     * eclipse magnitude:
     * fraction of solar diameter covered by moon
     */
    lsun = Math.asin(rsun / 2 * SwissData.DEGTORAD) * 2;
    lmoon = Math.asin(rmoon / 2 * SwissData.DEGTORAD) * 2;
    lctr = Math.asin(dctr / 2 * SwissData.DEGTORAD) * 2;
    lsunleft = Math.asin((-dctr + rsun + rmoon) * SwissData.DEGTORAD / 2) * 2;
    if (lsun > 0)
      attr[0] = lsunleft / lsun / 2;
    else
      attr[0] = 100;
    /*
     * ratio of diameter of moon to that of sun
     */
    if (lsun > 0)
      attr[1] = lmoon / lsun;
    else
      attr[1] = 0;
    /*
     * obscuration:
     * fraction of solar disc obscured by moon
     */
    if (retc == 0 || lsun == 0) {
      attr[2] = 100;
    } else if (retc == SweConst.SE_ECL_TOTAL || retc == SweConst.SE_ECL_ANNULAR) {
      attr[2] = lmoon * lmoon / lsun / lsun;
    } else {
      a = 2 * lctr * lmoon;
      b = 2 * lctr * lsun;
      if (a < 1e-9) {
        attr[2] = lmoon * lmoon / lsun / lsun;
      } else {
        a = (lctr * lctr + lmoon * lmoon - lsun * lsun) / a;
        if (a > 1) a = 1;
        if (a < -1) a = -1;
        b = (lctr * lctr + lsun * lsun - lmoon * lmoon) / b;
        if (b > 1) b = 1;
        if (b < -1) b = -1;
        a = Math.acos(a);
        b = Math.acos(b);
        sc1 = a * lmoon * lmoon / 2;
        sc2 = b * lsun * lsun / 2;
        sc1 -= (Math.cos(a) * Math.sin(a)) * lmoon * lmoon / 2;
        sc2 -= (Math.cos(b) * Math.sin(b)) * lsun * lsun / 2;
        attr[2] = (sc1 + sc2) * 2 / SwephData.PI / lsun / lsun;
      }
    }
    attr[7] = dctr;
    /* approximate minimum height for visibility, considering
     * refraction and dip
     * 34.4556': refraction at horizon, from Bennets formulae
     * 1.75' / Math.sqrt(geohgt): dip of horizon
     * 0.37' / Math.sqrt(geohgt): refraction between horizon and observer */
    hmin_appr = -(34.4556 + (1.75 + 0.37) * Math.sqrt(geohgt)) / 60;
    if (xh[1] + rsun + Math.abs(hmin_appr) >= 0 && retc!=0) {
      retc |= SweConst.SE_ECL_VISIBLE;        /* eclipse visible */
    }
    attr[4] = sl.swe_degnorm(90 - xh[0]);   /* azimuth, from north, clockwise */
    attr[5] = xh[1]; /* height */
    return retc;
  }

  /* When is the next solar eclipse anywhere on earth?
   *
   * input parameters:
   *
   * tjd_start    start time for search (UT)
   * ifl          ephemeris to be used (SEFLG_SWIEPH, etc.)
   * ifltype      eclipse type to be searched (SE_ECL_TOTAL, etc.)
   *              0, if any type of eclipse is required
   *
   * return values:
   *
   * retflag      SE_ECL_TOTAL or SE_ECL_ANNULAR or SE_ECL_PARTIAL
   *              or SE_ECL_ANNULAR_TOTAL
   *              SE_ECL_CENTRAL
   *              SE_ECL_NONCENTRAL
   *
   * tret[0]      time of maximum eclipse
   * tret[1]      time, when eclipse takes place at local apparent noon
   * tret[2]      time of eclipse begin
   * tret[3]      time of eclipse end
   * tret[4]      time of totality begin
   * tret[5]      time of totality end
   * tret[6]      time of center line begin
   * tret[7]      time of center line end
   * tret[8]      time when annular-total eclipse becomes total
   *                 not implemented so far
   * tret[9]      time when annular-total eclipse becomes annular again
   *                 not implemented so far
   *         declare as tret[10] at least!
   *
   */
  /**
  * Computes the next solar eclipse anywhere on earth.
  * <P>tret is an output parameter with the following meaning:
  * <P><CODE>
  * tret[0]:&nbsp;&nbsp;&nbsp;time of maximum eclipse.<BR>
  * tret[1]:&nbsp;&nbsp;&nbsp;time, when the eclipse takes place at local
  * apparent noon.<BR>
  * tret[2]:&nbsp;&nbsp;&nbsp;time of the begin of the eclipse.<BR>
  * tret[3]:&nbsp;&nbsp;&nbsp;time of the end of the eclipse.<BR>
  * tret[4]:&nbsp;&nbsp;&nbsp;time of the begin of totality.<BR>
  * tret[5]:&nbsp;&nbsp;&nbsp;time of the end of totality.<BR>
  * tret[6]:&nbsp;&nbsp;&nbsp;time of the begin of center line.<BR>
  * tret[7]:&nbsp;&nbsp;&nbsp;time of the end of center line<BR>
  * tret[8]:&nbsp;&nbsp;&nbsp;time, when annular-total eclipse becomes total --
  * <I>Not yet implemented.</I><BR>
  * tret[9]:&nbsp;&nbsp;&nbsp;time, when annular-total eclipse becomes annular
  * again -- <I>Not yet implemented.</I>
  * </CODE><P><B>Attention: tret must be a double[10]!</B>
  * @param tjd_start The Julian Day number in UT, from when to start searching
  * @param ifl To indicate, which ephemeris should be used (SEFLG_JPLEPH,
  * SEFLG_SWIEPH or SEFLG_MOSEPH)
  * @param ifltype SweConst.SE_ECL_TOTAL for total eclipse or 0 for any eclipse
  * @param tret An array[10], on return containing the times of different
  * occasions of the eclipse as above
  * @param backward 1, if search should be done backwards
  * @param serr A StringBuffer containing a warning or error message, if
  * something fails.
  * @return -1 (SweConst.ERR), if the calculation failed<BR>
  * SweConst.SE_ECL_TOTAL<BR>
  * SweConst.SE_ECL_ANNULAR<BR>
  * SweConst.SE_ECL_PARTIAL<BR>
  * SweConst.SE_ECL_ANNULAR_TOTAL<BR>in combination with:<BR>
  * SweConst.SE_ECL_CENTRAL<BR>
  * SweConst.SE_ECL_NONCENTRAL
  */
  int swe_sol_eclipse_when_glob(double tjd_start, int ifl, int ifltype,
                                double tret[], int backward,
                                StringBuffer serr) {
    int i, j, k, m, n, o, i1 = 0, i2 = 0;
    int retflag = 0, retflag2 = 0;
    double de = 6378.140, a;
    double t, tt, tjd, tjds, dt, dta, dtb;
    DblObj dtint=new DblObj();
    double T, T2, T3, T4, K, M, Mm;
    double E, Ff;
    double xs[]=new double[6], xm[]=new double[6],
           ls[]=new double[6], lm[]=new double[6];
    double rmoon, rsun, dcore[]=new double[10];
    double dc[]=new double[3];
    DblObj dctr=new DblObj();
    double twohr = 2.0 / 24.0;
    double tenmin = 10.0 / 24.0 / 60.0;
    DblObj dt1=new DblObj(), dt2=new DblObj();
    double geopos[]=new double[20], attr[]=new double[20];
    double dtstart, dtdiv;
    double xa[]=new double[6], xb[]=new double[6];
    int direction = 1;
    boolean dont_times = false;
    int iflag, iflagcart;
    ifl &= SweConst.SEFLG_EPHMASK;
    iflag = SweConst.SEFLG_EQUATORIAL | ifl;
    iflagcart = iflag | SweConst.SEFLG_XYZ;
    if (ifltype == (SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_CENTRAL)) {
      if (serr != null) {
        serr.setLength(0);
        serr.append("central partial eclipses do not exist");
      }
      return SweConst.ERR;
    }
    if (ifltype == 0) {
      ifltype = SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_ANNULAR
             | SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_ANNULAR_TOTAL
             | SweConst.SE_ECL_NONCENTRAL | SweConst.SE_ECL_CENTRAL;
    }
    if (backward!=0) {
      direction = -1;
    }
    K = (int) ((tjd_start - SwephData.J2000) / 365.2425 * 12.3685);
    K -= direction;
//next_try:
    while(true) {
      retflag = 0;
      dont_times = false;
      for (i = 0; i <= 9; i++)
        tret[i] = 0;
      T = K / 1236.85;
      T2 = T * T; T3 = T2 * T; T4 = T3 * T;
      Ff = sl.swe_degnorm(160.7108 + 390.67050274 * K
                   - 0.0016341 * T2
                   - 0.00000227 * T3
                   + 0.000000011 * T4);
      if (Ff > 180) {
        Ff -= 180;
      }
      if (Ff > 21 && Ff < 159) {    /* no eclipse possible */
        K += direction;
        continue;
      }
      /* approximate time of geocentric maximum eclipse
       * formula from Meeus, German, p. 381 */
      tjd = 2451550.09765 + 29.530588853 * K
                          + 0.0001337 * T2
                          - 0.000000150 * T3
                          + 0.00000000073 * T4;
      M = sl.swe_degnorm(2.5534 + 29.10535669 * K
                          - 0.0000218 * T2
                          - 0.00000011 * T3);
      Mm = sl.swe_degnorm(201.5643 + 385.81693528 * K
                          + 0.1017438 * T2
                          + 0.00001239 * T3
                          + 0.000000058 * T4);
      E = 1 - 0.002516 * T - 0.0000074 * T2;
      M *= SwissData.DEGTORAD;
      Mm *= SwissData.DEGTORAD;
      tjd = tjd - 0.4075 * Math.sin(Mm)
                + 0.1721 * E * Math.sin(M);
      /*
       * time of maximum eclipse (if eclipse) =
       * minimum geocentric angle between sun and moon edges.
       * After this time has been determined, check
       * whether or not an eclipse is taking place with
       * the functions eclipse_where() and _how().
       */
      dtstart = 1;
      if (tjd < 2000000) {
        dtstart = 5;
      }
      dtdiv = 4;
      for (dt = dtstart;
           dt > 0.0001;
           dt /= dtdiv) {
        for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
          if (sw.swe_calc(t, SweConst.SE_SUN, iflag, ls, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_SUN, iflagcart, xs, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          for (m = 0; m < 3; m++) {
            xa[m] = xs[m] / ls[2];
            xb[m] = xm[m] / lm[2];
          }
          dc[i] = Math.acos(sl.swi_dot_prod_unit(xa, xb)) * SwissData.RADTODEG;
          rmoon = Math.asin(RMOON / lm[2]) * SwissData.RADTODEG;
          rsun = Math.asin(RSUN / ls[2]) * SwissData.RADTODEG;
          dc[i] -= (rmoon + rsun);
        }
        find_maximum(dc[0], dc[1], dc[2], dt, dtint, dctr);
        tjd += dtint.val + dt;
      }
      tjds = tjd = tjd - SweDate.getDeltaT(tjd);
      if ((retflag = eclipse_where(tjd, SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
        return retflag;
      }
      retflag2 = retflag;
        /* in extreme cases _where() returns no eclipse, where there is
         * actually a very small one, therefore call _how() with the
         * coordinates returned by _where(): */
      if ((retflag2 = eclipse_how(tjd, SweConst.SE_SUN, null, ifl, geopos[0], geopos[1], 0, attr,
                                                        serr)) == SweConst.ERR) {
        return retflag2;
      }
      if (retflag2 == 0) {
        K += direction;
        continue;
      }
      tret[0] = tjd;
      if ((backward!=0 && tret[0] >= tjd_start - 0.0001)
        || (backward==0 && tret[0] <= tjd_start + 0.0001)) {
        K += direction;
        continue;
      }
      /*
       * eclipse type, SE_ECL_TOTAL, _ANNULAR, etc.
       * SE_ECL_ANNULAR_TOTAL will be discovered later
       */
      if ((retflag = eclipse_where(tjd, SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
        return retflag;
      }
      if (retflag == 0) {   /* can happen with extremely small percentage */
        retflag = SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_NONCENTRAL;
        tret[4] = tret[5] = tjd;    /* fix this ???? */
        dont_times = true;
      }
      /*
       * check whether or not eclipse type found is wanted
       */
      /* non central eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_NONCENTRAL)==0 &&
                                   (retflag & SweConst.SE_ECL_NONCENTRAL)!=0) {
        K += direction;
        continue;
      }
      /* central eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_CENTRAL)==0 &&
                                      (retflag & SweConst.SE_ECL_CENTRAL)!=0) {
        K += direction;
        continue;
      }
      /* non annular eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_ANNULAR)==0 &&
                                      (retflag & SweConst.SE_ECL_ANNULAR)!=0) {
        K += direction;
        continue;
      }
      /* non partial eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_PARTIAL)==0 &&
                                      (retflag & SweConst.SE_ECL_PARTIAL)!=0) {
        K += direction;
        continue;
      }
      /* annular-total eclipse will be discovered later */
      if ((ifltype & (SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_ANNULAR_TOTAL))==0
                    && (retflag & SweConst.SE_ECL_TOTAL)!=0) {
        K += direction;
        continue;
      }
      if (dont_times) {
        break;
      }
      /*
       * n = 0: times of eclipse begin and end
       * n = 1: times of totality begin and end
       * n = 2: times of center line begin and end
       */
      if ((retflag & SweConst.SE_ECL_PARTIAL)!=0) {
        o = 0;
      } else if ((retflag & SweConst.SE_ECL_NONCENTRAL)!=0) {
        o = 1;
      }
      else
        o = 2;
      dta = twohr;
      dtb = tenmin;
      for (n = 0; n <= o; n++) {
        if (n == 0) {
          /*dc[1] = dcore[3] / 2 + de - dcore[1];*/
          i1 = 2; i2 = 3;
        } else if (n == 1) {
          if ((retflag & SweConst.SE_ECL_PARTIAL)!=0) {
            continue;
          }
          i1 = 4; i2 = 5;
        } else if (n == 2) {
          if ((retflag & SweConst.SE_ECL_NONCENTRAL)!=0) {
            continue;
          }
          i1 = 6; i2 = 7;
        }
        for (i = 0, t = tjd - dta; i <= 2; i += 1, t += dta) {
          if ((retflag2 = eclipse_where(t, SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
            return retflag2;
          }
          if (n == 0) {
            dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
          } else if (n == 1) {
            dc[i] = Math.abs(dcore[3]) / 2 + de / dcore[6] - dcore[2];
          } else if (n == 2) {
            dc[i] = de / dcore[6] - dcore[2];
          }
        }
        find_zero(dc[0], dc[1], dc[2], dta, dt1, dt2);
        tret[i1] = tjd + dt1.val + dta;
        tret[i2] = tjd + dt2.val + dta;
        for (m = 0, dt = dtb; m < 3; m++, dt /= 3) {
          for (j = i1; j <= i2; j += (i2 - i1)) {
            for (i = 0, t = tret[j] - dt; i < 2; i++, t += dt) {
              if ((retflag2 = eclipse_where(t, SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
                return retflag2;
              }
              if (n == 0) {
                dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
              } else if (n == 1) {
                dc[i] = Math.abs(dcore[3]) / 2 + de / dcore[6] - dcore[2];
              } else if (n == 2) {
                dc[i] = de / dcore[6] - dcore[2];
              }
            }
            dt1.val = dc[1] / ((dc[1] - dc[0]) / dt);
            tret[j] -= dt1.val;
          }
        }
      }
      /*
       * annular-total eclipses
       */
      if ((retflag & SweConst.SE_ECL_TOTAL)!=0) {
        if ((retflag2 = eclipse_where(tret[0], SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
          return retflag2;
        }
        dc[0] = dcore[0];
        if ((retflag2 = eclipse_where(tret[4], SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
          return retflag2;
        }
        dc[1] = dcore[0];
        if ((retflag2 = eclipse_where(tret[5], SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
          return retflag2;
        }
        dc[2] = dcore[0];
        /* the maximum is always total, and there is either one or
         * to times before and after, when the core shadow becomes
         * zero and totality changes into annularity or vice versa.
         */
        if (dc[0] * dc[1] < 0 || dc[0] * dc[2] < 0) {
          retflag |= SweConst.SE_ECL_ANNULAR_TOTAL;
          retflag &= ~SweConst.SE_ECL_TOTAL;
        }
      }
      /* if eclipse is given but not wanted: */
      if ((ifltype & SweConst.SE_ECL_TOTAL)==0 &&
          (retflag & SweConst.SE_ECL_TOTAL)!=0) {
        K += direction;
        continue;
      }
      /* if annular_total eclipse is given but not wanted: */
      if ((ifltype & SweConst.SE_ECL_ANNULAR_TOTAL)==0 &&
          (retflag & SweConst.SE_ECL_ANNULAR_TOTAL)!=0) {
        K += direction;
        continue;
      }
      /*
       * time of maximum eclipse at local apparent noon
       */
      /* first, find out, if there is a solar transit
       * between begin and end of eclipse */
      k = 2;
      for (i = 0; i < 2; i++) {
        j = i + k;
        tt = tret[j] + SweDate.getDeltaT(tret[j]);
        if (sw.swe_calc(tt, SweConst.SE_SUN, iflag, ls, serr) == SweConst.ERR) {
          return SweConst.ERR;
        }
        if (sw.swe_calc(tt, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR) {
          return SweConst.ERR;
        }
        dc[i] = sl.swe_degnorm(ls[0] - lm[0]);
        if (dc[i] > 180) {
          dc[i] -= 360;
        }
      }
      if (dc[0] * dc[1] >= 0) {     /* no transit */
        tret[1] = 0;
      } else {
        tjd = tjds;
        dt = 0.1;
        dt1.val = (tret[3] - tret[2]) / 2.0;
        if (dt1.val < dt) {
          dt = dt1.val / 2.0;
        }
        for (j = 0;
            dt > 0.01;
            j++, dt /= 3) {
          for (i = 0, t = tjd; i <= 1; i++, t -= dt) {
            tt = t + SweDate.getDeltaT(t);
            if (sw.swe_calc(tt, SweConst.SE_SUN, iflag, ls, serr) ==
                                                                 SweConst.ERR) {
              return SweConst.ERR;
            }
            if (sw.swe_calc(tt, SweConst.SE_MOON, iflag, lm, serr) ==
                                                                 SweConst.ERR) {
              return SweConst.ERR;
            }
            dc[i] = sl.swe_degnorm(ls[0] - lm[0]);
            if (dc[i] > 180) {
              dc[i] -= 360;
            }
            if (dc[i] > 180) {
              dc[i] -= 360;
            }
          }
          a = (dc[1] - dc[0]) / dt;
          if (a < 1e-10) {
            break;
          }
          dt1.val = dc[0] / a;
          tjd += dt1.val;
        }
        tret[1] = tjd;
      }
      break;
    } // while (true)
    return retflag;
    /*
     * the time of maximum occultation is practically identical
     * with the time of maximum core shadow diameter.
     *
     * the time, when duration of totality is maximal,
     * is not an interesting computation either. Near the maximum
     * occulation, the time of totality can be the same by
     * a second for hundreds of kilometers (for 10 minutes
     * or more).
     *
     * for annular eclipses the maximum duration is close to the
     * beginning and the end of the center lines, where is also
     * the minimum of core shadow diameter.
     */
  }

  /* When is the next lunar occultation anywhere on earth?
   * This function also finds solar eclipses, but is less efficient
   * than swe_sol_eclipse_when_glob().
   *
   * input parameters:
   *
   * tjd_start          start time for search (UT)
   * ipl                planet number of occulted body
   * starname           name of occulted star. Must be NULL or "", if a planetary
   *                    occultation is to be calculated. For the use of this
   *                    field, also see swe_fixstar().
   * ifl                      ephemeris to be used (SEFLG_SWIEPH, etc.)
   *                  ephemeris flag. If you want to have only one conjunction
   *                    of the moon with the body tested, add the following flag:
   *                    ifl |= SE_ECL_ONE_TRY. If this flag is not set,
   *                    the function will search for an occultation until it
   *                    finds one. For bodies with ecliptical latitudes > 5,
   *                    the function may search successlessly until it reaches
   *                    the end of the ephemeris.
   *
   * ifltype          eclipse type to be searched (SE_ECL_TOTAL, etc.)
   *                    0, if any type of eclipse is wanted
   *                    this functionality also works with occultations
   *
   * return values:
   *
   * retflag    SE_ECL_TOTAL or SE_ECL_ANNULAR or SE_ECL_PARTIAL
   *              or SE_ECL_ANNULAR_TOTAL
   *              SE_ECL_CENTRAL
   *              SE_ECL_NONCENTRAL
   *
   * tret[0]    time of maximum eclipse
   * tret[1]    time, when eclipse takes place at local apparent noon
   * tret[2]    time of eclipse begin
   * tret[3]    time of eclipse end
   * tret[4]    time of totality begin
   * tret[5]    time of totality end
   * tret[6]    time of center line begin
   * tret[7]    time of center line end
   * tret[8]    time when annular-total eclipse becomes total
   *               not implemented so far
   * tret[9]    time when annular-total eclipse becomes annular again
   *               not implemented so far
   *         declare as tret[10] at least!
   *
   */
  int swe_lun_occult_when_glob(
       double tjd_start, int ipl, StringBuffer starname, int ifl, int ifltype,
       double[] tret, int backward, StringBuffer serr) {
    int i, j, k, m, n, o, i1=0, i2=0;
    int retflag = 0, retflag2 = 0;
    double de = 6378.140, a;
    double t, tt, tjd=0, tjds, dt, dta, dtb;
    DblObj dtint=new DblObj();
    double drad;
    double xs[]=new double[6], xm[]=new double[6], ls[]=new double[6], lm[]=new double[6];
    double rmoon, rsun, dcore[]=new double[10];
    double dc[]=new double[20];
    DblObj dctr=new DblObj();
    double twohr = 2.0 / 24.0;
    double tenmin = 10.0 / 24.0 / 60.0;
    DblObj dt1=new DblObj(), dt2=new DblObj();
    double dadd = 10, dadd2 = 6;
    int nstartpos = 10;
    double geopos[]=new double[20];
    double dtstart, dtdiv;
    int direction = 1;
    int iflag, iflagcart;
    boolean dont_times = false;
    int one_try = backward & SweConst.SE_ECL_ONE_TRY;
    ifl &= SweConst.SEFLG_EPHMASK;
    iflag = SweConst.SEFLG_EQUATORIAL | ifl;
    iflagcart = iflag | SweConst.SEFLG_XYZ;
    backward &= 1L;
    /*
     * initializations
     */
    if (ifltype == (SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_CENTRAL)) {
      if (serr != null) {
        serr.setLength(0);
        serr.append("central partial eclipses do not exist");
      }
      return SweConst.ERR;
    }
    if (ifltype == 0)
      ifltype = SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_ANNULAR | SweConst.SE_ECL_PARTIAL
             | SweConst.SE_ECL_ANNULAR_TOTAL | SweConst.SE_ECL_NONCENTRAL | SweConst.SE_ECL_CENTRAL;
    retflag = 0;
    dont_times = false;
    if ((backward & SEI_OCC_FAST) != 0)
      dont_times = true;
    for (i = 0; i <= 9; i++)
      tret[i] = 0;
    if (backward!=0)
      direction = -1;
    t = tjd_start - direction * 0.001;
    while(true) {
//next_try:
      for (i = 0; i < nstartpos; i++, t += direction * dadd2) {
        if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SweConst.ERR)
            return SweConst.ERR;
        if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR)
            return SweConst.ERR;
        dc[i] = Math.acos(sl.swi_dot_prod_unit(xs, xm)) * SwissData.RADTODEG;
        if (i > 1 && dc[i] > dc[i-1] && dc[i-2] > dc[i-1]) {
          tjd = t - direction * dadd2;
          break;
        } else if (i == nstartpos-1) {
          for (j = 0; j < nstartpos; j++)
            //DevNull.print(dc[j] + " ");
          System.err.println("problem planet");
          System.exit(0);
        }
      }
      /*
       * radius of planet disk in AU
       */
      if (starname != null && starname.length() > 0)
        drad = 0;
      else if (ipl < SwephData.NDIAM)
        drad = SwephData.pla_diam[ipl] / 2 / SweConst.AUNIT;
      else if (ipl > SweConst.SE_AST_OFFSET)
        drad = swed.ast_diam / 2 * 1000 / SweConst.AUNIT; /* km -> m -> AU */
      else
        drad = 0;
      /*
       * time of maximum eclipse (if eclipse) =
       * minimum geocentric angle between sun and moon edges.
       * After this time has been determined, check
       * whether or not an eclipse is taking place with
       * the functions eclipse_where() and _how().
       */
      dtstart = dadd2; /* originally 1 */
      dtdiv = 3;
      for (dt = dtstart;
           dt > 0.0001;
           dt /= dtdiv) {
        for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
          if (calc_planet_star(t, ipl, starname, iflag, ls, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (sw.swe_calc(t, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR)
            return SweConst.ERR;
          dc[i] = Math.acos(sl.swi_dot_prod_unit(xs, xm)) * SwissData.RADTODEG;
          rmoon = Math.asin(RMOON / lm[2]) * SwissData.RADTODEG;
          rsun = Math.asin(drad / ls[2]) * SwissData.RADTODEG;
          dc[i] -= (rmoon + rsun);
        }
        find_maximum(dc[0], dc[1], dc[2], dt, dtint, dctr);
        tjd += dtint.val + dt;
      }
      tjd -= SweDate.getDeltaT(tjd);
      tjds = tjd;
      if ((retflag = eclipse_where(tjd, ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
        return retflag;
      retflag2 = retflag;
        /* in extreme cases _where() returns no eclipse, where there is
         * actually a very small one, therefore call _how() with the
         * coordinates returned by _where(): */
      /* if ((retflag2 = eclipse_how(tjd, ipl, starname, ifl, geopos[0], geopos[1], 0, attr, serr)) == SweConst.ERR)
        return retflag2; */
      if (retflag2 == 0) {
        /* only one try! */
        if (one_try!=0) {
          tret[0] = tjd;
          return 0;
        }
        t= tjd + direction * dadd;
//    goto next_try;
        continue;
      }
      tret[0] = tjd;
      if ((backward!=0 && tret[0] >= tjd_start - 0.0001)
        || (backward==0 && tret[0] <= tjd_start + 0.0001)) {
        t= tjd + direction * dadd;
//    goto next_try;
        continue;
      }
      /*
       * eclipse type, SE_ECL_TOTAL, _ANNULAR, etc.
       * SE_ECL_ANNULAR_TOTAL will be discovered later
       */
      if ((retflag = eclipse_where(tjd, ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
        return retflag;
      if (retflag == 0) { /* can happen with extremely small percentage */
        retflag = SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_NONCENTRAL;
        tret[4] = tret[5] = tjd;  /* fix this ???? */
        retflag = SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_NONCENTRAL;
        tret[4] = tret[5] = tjd;  /* fix this ???? */
        dont_times = true;
      }
      /*
       * check whether or not eclipse type found is wanted
       */
      /* non central eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_NONCENTRAL)==0 && (retflag & SweConst.SE_ECL_NONCENTRAL)!=0) {
        t= tjd + direction * dadd;
//    goto next_try;
        continue;
      }
      /* central eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_CENTRAL)==0 && (retflag & SweConst.SE_ECL_CENTRAL)!=0) {
        t= tjd + direction * dadd;
//    goto next_try;
        continue;
      }
      /* non annular eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_ANNULAR)==0 && (retflag & SweConst.SE_ECL_ANNULAR)!=0) {
        t= tjd + direction * dadd;
//    goto next_try;
        continue;
      }
      /* non partial eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_PARTIAL)==0 && (retflag & SweConst.SE_ECL_PARTIAL)!=0) {
        t= tjd + direction * dadd;
//    goto next_try;
        continue;
      }
      /* annular-total eclipse will be discovered later */
      if ((ifltype & (SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_ANNULAR_TOTAL))==0 && (retflag & SweConst.SE_ECL_TOTAL)!=0) {
        t= tjd + direction * dadd;
//    goto next_try;
        continue;
      }
      if (dont_times)
//        goto end_search_global;
        return retflag;
      /*
       * n = 0: times of eclipse begin and end
       * n = 1: times of totality begin and end
       * n = 2: times of center line begin and end
       */
      if ((retflag & SweConst.SE_ECL_PARTIAL)!=0)
        o = 0;
      else if ((retflag & SweConst.SE_ECL_NONCENTRAL)!=0)
        o = 1;
      else
        o = 2;
      dta = twohr;
      dtb = tenmin;
      for (n = 0; n <= o; n++) {
        if (n == 0) {
          /*dc[1] = dcore[3] / 2 + de - dcore[1];*/
          i1 = 2; i2 = 3;
        } else if (n == 1) {
          if ((retflag & SweConst.SE_ECL_PARTIAL)!=0)
            continue;
          i1 = 4; i2 = 5;
        } else if (n == 2) {
          if ((retflag & SweConst.SE_ECL_NONCENTRAL)!=0)
            continue;
          i1 = 6; i2 = 7;
        }
        for (i = 0, t = tjd - dta; i <= 2; i += 1, t += dta) {
          if ((retflag2 = eclipse_where(t, ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
            return retflag2;
          if (n == 0)
            dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
          else if (n == 1)
            dc[i] = Math.abs(dcore[3]) / 2 + de / dcore[6] - dcore[2];
          else if (n == 2)
            dc[i] = de / dcore[6] - dcore[2];
        }
        find_zero(dc[0], dc[1], dc[2], dta, dt1, dt2);
        tret[i1] = tjd + dt1.val + dta;
        tret[i2] = tjd + dt2.val + dta;
        for (m = 0, dt = dtb; m < 3; m++, dt /= 3) {
          for (j = i1; j <= i2; j += (i2 - i1)) {
            for (i = 0, t = tret[j] - dt; i < 2; i++, t += dt) {
              if ((retflag2 = eclipse_where(t, ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
                return retflag2;
              if (n == 0)
                dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
              else if (n == 1)
                dc[i] = Math.abs(dcore[3]) / 2 + de / dcore[6] - dcore[2];
              else if (n == 2)
                dc[i] = de / dcore[6] - dcore[2];
            }
            dt1.val = dc[1] / ((dc[1] - dc[0]) / dt);
            tret[j] -= dt1.val;
          }
        }
      }
      /*
       * annular-total eclipses
       */
      if ((retflag & SweConst.SE_ECL_TOTAL)!=0) {
        if ((retflag2 = eclipse_where(tret[0], ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
          return retflag2;
        dc[0] = dcore[0];
        if ((retflag2 = eclipse_where(tret[4], ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
          return retflag2;
        dc[1] = dcore[0];
        if ((retflag2 = eclipse_where(tret[5], ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
          return retflag2;
        dc[2] = dcore[0];
        /* the maximum is always total, and there is either one or
         * to times before and after, when the core shadow becomes
         * zero and totality changes into annularity or vice versa.
         */
        if (dc[0] * dc[1] < 0 || dc[0] * dc[2] < 0) {
          retflag |= SweConst.SE_ECL_ANNULAR_TOTAL;
          retflag &= ~SweConst.SE_ECL_TOTAL;
        }
      }
      /* if eclipse is given but not wanted: */
      if ((ifltype & SweConst.SE_ECL_TOTAL)==0 && (retflag & SweConst.SE_ECL_TOTAL)!=0) {
        t= tjd + direction * dadd;
//    goto next_try;
        continue;
      }
      /* if annular_total eclipse is given but not wanted: */
      if ((ifltype & SweConst.SE_ECL_ANNULAR_TOTAL)==0 && (retflag & SweConst.SE_ECL_ANNULAR_TOTAL)!=0) {
        t= tjd + direction * dadd;
//    goto next_try;
        continue;
      }
      /*
       * time of maximum eclipse at local apparent noon
       */
      /* first, find out, if there is a solar transit
       * between begin and end of eclipse */
      k = 2;
      for (i = 0; i < 2; i++) {
        j = i + k;
        tt = tret[j] + SweDate.getDeltaT(tret[j]);
        if (calc_planet_star(tt, ipl, starname, iflag, ls, serr) == SweConst.ERR)
            return SweConst.ERR;
        if (sw.swe_calc(tt, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR)
            return SweConst.ERR;
        dc[i] = sl.swe_degnorm(ls[0] - lm[0]);
        if (dc[i] > 180)
          dc[i] -= 360;
      }
      if (dc[0] * dc[1] >= 0)     /* no transit */
        tret[1] = 0;
      else {
        tjd = tjds;
        dt = 0.1;
        dt1.val = (tret[3] - tret[2]) / 2.0;
        if (dt1.val < dt)
          dt = dt1.val / 2.0;
        for (j = 0;
             dt > 0.01;
             j++, dt /= 3) {
          for (i = 0, t = tjd; i <= 1; i++, t -= dt) {
            tt = t + SweDate.getDeltaT(t);
            if (calc_planet_star(tt, ipl, starname, iflag, ls, serr) == SweConst.ERR)
              return SweConst.ERR;
            if (sw.swe_calc(tt, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR)
              return SweConst.ERR;
            dc[i] = sl.swe_degnorm(ls[0] - lm[0]);
            if (dc[i] > 180)
              dc[i] -= 360;
            if (dc[i] > 180)
              dc[i] -= 360;
          }
          a = (dc[1] - dc[0]) / dt;
          if (a < 1e-10)
            break;
          dt1.val = dc[0] / a;
          tjd += dt1.val;
        }
        tret[1] = tjd;
      }
      break;
    }
//end_search_global:
    return retflag;
    /*
     * the time of maximum occultation is practically identical
     * with the time of maximum core shadow diameter.
     *
     * the time, when duration of totality is maximal,
     * is not an interesting computation either. Near the maximum
     * occulation, the time of totality can be the same by
     * a second for hundreds of kilometers (for 10 minutes
     * or more).
     *
     * for annular eclipses the maximum duration is close to the
     * beginning and the end of the center lines, where is also
     * the minimum of core shadow diameter.
     * beginning and the end of the center lines, where is also
     * the minimum of core shadow diameter.
     */
  }
 
 

  /* When is the next solar eclipse at a given geographical position?
   * Note the uncertainty of Delta T for the remote past and for
   * the future.
   *
   * retflag        SE_ECL_TOTAL or SE_ECL_ANNULAR or SE_ECL_PARTIAL
   *              SE_ECL_VISIBLE,
   *              SE_ECL_MAX_VISIBLE,
   *              SE_ECL_1ST_VISIBLE, SE_ECL_2ND_VISIBLE
   *              SE_ECL_3ST_VISIBLE, SE_ECL_4ND_VISIBLE
   *
   * tret[0]        time of maximum eclipse
   * tret[1]        time of first contact
   * tret[2]        time of second contact
   * tret[3]        time of third contact
   * tret[4]        time of forth contact
   * tret[5]        time of sun rise between first and forth contact
                          (not implemented so far)
   * tret[6]        time of sun set beween first and forth contact
                          (not implemented so far)
   *
   * attr[0]        fraction of solar diameter covered by moon (magnitude)
   * attr[1]        ratio of lunar diameter to solar one
   * attr[2]        fraction of solar disc covered by moon (obscuration)
   * attr[3]      diameter of core shadow in km
   * attr[4]        azimuth of sun at tjd
   * attr[5]        true altitude of sun above horizon at tjd
   * attr[6]        apparent altitude of sun above horizon at tjd
   * attr[7]        elongation of moon in degrees
   *         declare as attr[20] at least !
   */
  /**
  * Computes the next solar eclipse at a given geographical position. Note the
  * uncertainty of Delta T for the remote past and the future.<P>
  * tret is an output parameter with the following meaning:
  * <P><CODE>
  * tret[0]:&nbsp;&nbsp;&nbsp;time of maximum eclipse.<BR>
  * tret[1]:&nbsp;&nbsp;&nbsp;time of first contact.<BR>
  * tret[2]:&nbsp;&nbsp;&nbsp;time of second contact.<BR>
  * tret[3]:&nbsp;&nbsp;&nbsp;time of third contact.<BR>
  * tret[4]:&nbsp;&nbsp;&nbsp;time of forth contact.<BR>
  * tret[5]:&nbsp;&nbsp;&nbsp;time of sun rise between first and forth contact
  * -- <I>Not yet implemented.</I><BR>
  * tret[6]:&nbsp;&nbsp;&nbsp;time of sun set between first and forth contact
  * -- <I>Not yet implemented.</I><BR>
  * </CODE><P>
  * attr is an output parameter with the following meaning:
  * <P><CODE>
  * attr[0]:&nbsp;&nbsp;&nbsp;fraction of solar diameter covered by moon
  * (magnitude).<BR>
  * attr[1]:&nbsp;&nbsp;&nbsp;ratio of lunar diameter to solar one.<BR>
  * attr[2]:&nbsp;&nbsp;&nbsp;fraction of solar disc covered by moon
  * (obscuration).<BR>
  * attr[3]:&nbsp;&nbsp;&nbsp;diameter of core shadow in km.<BR>
  * attr[4]:&nbsp;&nbsp;&nbsp;azimuth of sun at tjd.<BR>
  * attr[5]:&nbsp;&nbsp;&nbsp;true altitude of sun above horizon at tjd.<BR>
  * attr[6]:&nbsp;&nbsp;&nbsp;apparent altitude of sun above horizon at tjd.<BR>
  * attr[7]:&nbsp;&nbsp;&nbsp;elongation of moon in degrees.<BR>
  * </CODE><P><B>Attention: attr must be a double[20]!</B>
  * @param tjd_start The Julian Day number in UT, from when to start searching
  * @param ifl To indicate, which ephemeris should be used (SEFLG_JPLEPH,
  * SEFLG_SWIEPH or SEFLG_MOSEPH)
  * @param geopos An array double[3] containing the longitude, latitude and
  * height of the geographic position
  * @param tret An array[7], on return containing the times of different
  * occasions of the eclipse as specified above
  * @param attr An array[20], on return containing different attributes of
  * the eclipse. See above.
  * @param backward true, if search should be done backwards
  * @param serr A StringBuffer containing a warning or error message, if
  * something fails.
  * @return -1 (SweConst.ERR), if the calculation failed<BR>
  * SweConst.SE_ECL_TOTAL<BR>
  * SweConst.SE_ECL_ANNULAR<BR>
  * SweConst.SE_ECL_PARTIAL<BR>in combination with:<BR>
  * SweConst.SE_ECL_VISIBLE<BR>
  * SweConst.SE_ECL_MAX_VISIBLE<BR>
  * SweConst.SE_ECL_1ST_VISIBLE<BR>
  * SweConst.SE_ECL_2ND_VISIBLE<BR>
  * SweConst.SE_ECL_3RD_VISIBLE<BR>
  * SweConst.SE_ECL_4TH_VISIBLE
  */
  int swe_sol_eclipse_when_loc(double tjd_start, int ifl,
                               double[] geopos, double[] tret,
                               double[] attr, int backward,
                               StringBuffer serr) {
    int retflag = 0, retflag2 = 0;
    double geopos2[]=new double[20], dcore[]=new double[10];
    ifl &= SweConst.SEFLG_EPHMASK;
    if ((retflag = eclipse_when_loc(tjd_start, ifl, geopos, tret, attr,
                                                        backward, serr)) <= 0) {
      return retflag;
    }
    /*
     * diameter of core shadow
     */
    if ((retflag2 = eclipse_where(tret[0], SweConst.SE_SUN, null, ifl, geopos2, dcore, serr)) ==
                                                                SweConst.ERR) {
      return retflag2;
    }
    retflag |= (retflag2 & SweConst.SE_ECL_NONCENTRAL);
    attr[3] = dcore[0];
    return retflag;
  }

  /* Same declaration as swe_sol_eclipse_when_loc().
   * In addition:
   * int32 ipl          planet number of occulted body
   * char* starname     name of occulted star. Must be NULL or "", if a planetary
   *                    occultation is to be calculated. For the use of this
   *                    field, also see swe_fixstar().
   * int32 ifl        ephemeris flag. If you want to have only one conjunction
   *                    of the moon with the body tested, add the following flag:
   *                    ifl |= SE_ECL_ONE_TRY. If this flag is not set,
   *                    the function will search for an occultation until it
   *                    finds one. For bodies with ecliptical latitudes > 5,
   *                    the function may search successlessly until it reaches
   *                    the end of the ephemeris.
   */
  int swe_lun_occult_when_loc(double tjd_start, int ipl, StringBuffer starname, int ifl,
       double[] geopos, double[] tret, double[] attr, int backward, StringBuffer serr) {
    int retflag = 0, retflag2 = 0;
    double geopos2[]=new double[20], dcore[]=new double[10];
    ifl &= SweConst.SEFLG_EPHMASK;
    if ((retflag = occult_when_loc(tjd_start, ipl, starname, ifl, geopos, tret, attr, backward, serr)) <= 0)
      return retflag;
    /*
     * diameter of core shadow
     */
    if ((retflag2 = eclipse_where(tret[0], ipl, starname, ifl, geopos2, dcore, serr)) == SweConst.ERR)
      return retflag2;
    retflag |= (retflag2 & SweConst.SE_ECL_NONCENTRAL);
    attr[3] = dcore[0];
    return retflag;
  }

  private int eclipse_when_loc(double tjd_start, int ifl, double[] geopos,
                               double[] tret, double[] attr, int backward,
                               StringBuffer serr) {
    int i, j, k, m;
    int retflag = 0;
    double t, tjd, dt, K, T, T2, T3, T4, F, M, Mm;
    DblObj dtint=new DblObj();
    double E, Ff, A1, Om;
    double xs[]=new double[6], xm[]=new double[6],
           ls[]=new double[6], lm[]=new double[6],
           x1[]=new double[6], x2[]=new double[6], dm, ds;
    double rmoon, rsun, rsplusrm, rsminusrm;
    double dc[]=new double[3], dctrmin;
    DblObj dctr=new DblObj();
    double twomin = 2.0 / 24.0 / 60.0;
    double tensec = 10.0 / 24.0 / 60.0 / 60.0;
    double twohr = 2.0 / 24.0;
    double tenmin = 10.0 / 24.0 / 60.0;
    DblObj dt1=new DblObj(), dt2=new DblObj();
    double dtdiv, dtstart;
    int iflag = SweConst.SEFLG_EQUATORIAL | SweConst.SEFLG_TOPOCTR | ifl;
    int iflagcart = iflag | SweConst.SEFLG_XYZ;
    sw.swe_set_topo(geopos[0], geopos[1], geopos[2]);
    K = (int) ((tjd_start - SwephData.J2000) / 365.2425 * 12.3685);
    if (backward!=0) {
      K++;
    } else {
      K--;
    }
//next_try:
    while (true) {
      T = K / 1236.85;
      T2 = T * T; T3 = T2 * T; T4 = T3 * T;
      Ff = F = sl.swe_degnorm(160.7108 + 390.67050274 * K
                   - 0.0016341 * T2
                   - 0.00000227 * T3
                   + 0.000000011 * T4);
      if (Ff > 180) {
        Ff -= 180;
      }
      if (Ff > 21 && Ff < 159) {         /* no eclipse possible */
        if (backward!=0) {
          K--;
        } else {
          K++;
        }
        continue;
      }
      /* approximate time of geocentric maximum eclipse.
       * formula from Meeus, German, p. 381 */
      tjd = 2451550.09765 + 29.530588853 * K
                          + 0.0001337 * T2
                          - 0.000000150 * T3
                          + 0.00000000073 * T4;
      M = sl.swe_degnorm(2.5534 + 29.10535669 * K
                          - 0.0000218 * T2
                          - 0.00000011 * T3);
      Mm = sl.swe_degnorm(201.5643 + 385.81693528 * K
                          + 0.1017438 * T2
                          + 0.00001239 * T3
                          + 0.000000058 * T4);
      Om = sl.swe_degnorm(124.7746 - 1.56375580 * K
                          + 0.0020691 * T2
                          + 0.00000215 * T3);
      E = 1 - 0.002516 * T - 0.0000074 * T2;
      A1 = sl.swe_degnorm(299.77 + 0.107408 * K - 0.009173 * T2);
      M *= SwissData.DEGTORAD;
      Mm *= SwissData.DEGTORAD;
      F *= SwissData.DEGTORAD;
      Om *= SwissData.DEGTORAD;
      A1 *= SwissData.DEGTORAD;
      tjd = tjd - 0.4075 * Math.sin(Mm)
                + 0.1721 * E * Math.sin(M);
      sw.swe_set_topo(geopos[0], geopos[1], geopos[2]);
      dtdiv = 2;
      dtstart = 0.5;
      if (tjd < 1900000) { /* because above formula is not good (delta t?) */
        dtstart = 2;
      }
      for (dt = dtstart;
           dt > 0.00001;
           dt /= dtdiv) {
        if (dt < 0.1) {
          dtdiv = 3;
        }
        for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
          /* this takes some time, but is necessary to avoid
           * missing an eclipse */
          if (sw.swe_calc(t, SweConst.SE_SUN, iflagcart, xs, serr) ==
                                                                SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_SUN, iflag, ls, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) ==
                                                                SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          dm = Math.sqrt(sl.square_sum(xm));
          ds = Math.sqrt(sl.square_sum(xs));
          for (k = 0; k < 3; k++) {
            x1[k] = xs[k] / ds /*ls[2]*/;
            x2[k] = xm[k] / dm /*lm[2]*/;
          }
          dc[i] = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
        }
        find_maximum(dc[0], dc[1], dc[2], dt, dtint, dctr);
        tjd += dtint.val + dt;
      }
      if (sw.swe_calc(tjd, SweConst.SE_SUN, iflagcart, xs, serr) ==
                                                                 SweConst.ERR) {
        return SweConst.ERR;
      }
      if (sw.swe_calc(tjd, SweConst.SE_SUN, iflag, ls, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
      if (sw.swe_calc(tjd, SweConst.SE_MOON, iflagcart, xm, serr) ==
                                                                 SweConst.ERR) {
        return SweConst.ERR;
      }
      if (sw.swe_calc(tjd, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
      dctr.val = Math.acos(sl.swi_dot_prod_unit(xs, xm)) * SwissData.RADTODEG;
      rmoon = Math.asin(RMOON / lm[2]) * SwissData.RADTODEG;
      rsun = Math.asin(RSUN / ls[2]) * SwissData.RADTODEG;
      rsplusrm = rsun + rmoon;
      rsminusrm = rsun - rmoon;
      if (dctr.val > rsplusrm) {
        if (backward!=0) {
          K--;
        } else {
          K++;
        }
        continue;
      }
      tret[0] = tjd - SweDate.getDeltaT(tjd);
      if ((backward!=0 && tret[0] >= tjd_start - 0.0001)
        || (backward==0 && tret[0] <= tjd_start + 0.0001)) {
        if (backward!=0) {
          K--;
        } else {
          K++;
        }
        continue;
      }
      if (dctr.val < rsminusrm) {
        retflag = SweConst.SE_ECL_ANNULAR;
      } else if (dctr.val < Math.abs(rsminusrm)) {
        retflag = SweConst.SE_ECL_TOTAL;
      } else if (dctr.val <= rsplusrm) {
        retflag = SweConst.SE_ECL_PARTIAL;
      }
      dctrmin = dctr.val;
      /* contacts 2 and 3 */
      if (dctr.val > Math.abs(rsminusrm)) {/* partial, no 2nd and 3rd contact */
        tret[2] = tret[3] = 0;
      } else {
        dc[1] = Math.abs(rsminusrm) - dctrmin;
        for (i = 0, t = tjd - twomin; i <= 2; i += 2, t = tjd + twomin) {
          if (sw.swe_calc(t, SweConst.SE_SUN, iflagcart, xs, serr) ==
                                                                 SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) ==
                                                                 SweConst.ERR) {
            return SweConst.ERR;
          }
          dm = Math.sqrt(sl.square_sum(xm));
          ds = Math.sqrt(sl.square_sum(xs));
          rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
          rsun = Math.asin(RSUN / ds) * SwissData.RADTODEG;
          rsminusrm = rsun - rmoon;
          for (k = 0; k < 3; k++) {
            x1[k] = xs[k] / ds /*ls[2]*/;
            x2[k] = xm[k] / dm /*lm[2]*/;
          }
          dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
          dc[i] = Math.abs(rsminusrm) - dctr.val;
        }
        find_zero(dc[0], dc[1], dc[2], twomin, dt1, dt2);
        tret[2] = tjd + dt1.val + twomin;
        tret[3] = tjd + dt2.val + twomin;
        for (m = 0, dt = tensec; m < 2; m++, dt /= 10) {
          for (j = 2; j <= 3; j++) {
            if (sw.swe_calc(tret[j], SweConst.SE_SUN,
                            iflagcart | SweConst.SEFLG_SPEED, xs, serr) ==
                                                                 SweConst.ERR) {
              return SweConst.ERR;
            }
            if (sw.swe_calc(tret[j], SweConst.SE_MOON,
                            iflagcart | SweConst.SEFLG_SPEED, xm, serr) ==
                                                                 SweConst.ERR) {
              return SweConst.ERR;
            }
            for (i = 0; i < 2; i++) {
              if (i == 1) {
                for(k = 0; k < 3; k++) {
                  xs[k] -= xs[k+3] * dt;
                  xm[k] -= xm[k+3] * dt;
                }
              }
              dm = Math.sqrt(sl.square_sum(xm));
              ds = Math.sqrt(sl.square_sum(xs));
              rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
              rsun = Math.asin(RSUN / ds) * SwissData.RADTODEG;
              rsminusrm = rsun - rmoon;
              for (k = 0; k < 3; k++) {
                x1[k] = xs[k] / ds /*ls[2]*/;
                x2[k] = xm[k] / dm /*lm[2]*/;
              }
              dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) *
                                                             SwissData.RADTODEG;
              dc[i] = Math.abs(rsminusrm) - dctr.val;
            }
            dt1.val = -dc[0] / ((dc[0] - dc[1]) / dt);
            tret[j] += dt1.val;
          }
        }
        tret[2] -= SweDate.getDeltaT(tret[2]);
        tret[3] -= SweDate.getDeltaT(tret[3]);
      }
      /* contacts 1 and 4 */
      dc[1] = rsplusrm - dctrmin;
      for (i = 0, t = tjd - twohr; i <= 2; i += 2, t = tjd + twohr) {
        if (sw.swe_calc(t, SweConst.SE_SUN, iflagcart, xs, serr) ==
                                                                 SweConst.ERR) {
          return SweConst.ERR;
        }
        if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) ==
                                                                 SweConst.ERR) {
          return SweConst.ERR;
        }
        dm = Math.sqrt(sl.square_sum(xm));
        ds = Math.sqrt(sl.square_sum(xs));
        rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
        rsun = Math.asin(RSUN / ds) * SwissData.RADTODEG;
        rsplusrm = rsun + rmoon;
        for (k = 0; k < 3; k++) {
          x1[k] = xs[k] / ds /*ls[2]*/;
          x2[k] = xm[k] / dm /*lm[2]*/;
        }
        dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
        dc[i] = rsplusrm - dctr.val;
      }
      find_zero(dc[0], dc[1], dc[2], twohr, dt1, dt2);
      tret[1] = tjd + dt1.val + twohr;
      tret[4] = tjd + dt2.val + twohr;
      for (m = 0, dt = tenmin; m < 3; m++, dt /= 10) {
        for (j = 1; j <= 4; j += 3) {
          if (sw.swe_calc(tret[j], SweConst.SE_SUN,
                          iflagcart | SweConst.SEFLG_SPEED, xs, serr) ==
                                                                 SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(tret[j], SweConst.SE_MOON,
                          iflagcart | SweConst.SEFLG_SPEED, xm, serr) ==
                                                                 SweConst.ERR) {
            return SweConst.ERR;
          }
          for (i = 0; i < 2; i++) {
            if (i == 1) {
              for(k = 0; k < 3; k++) {
                xs[k] -= xs[k+3] * dt;
                xm[k] -= xm[k+3] * dt;
              }
            }
            dm = Math.sqrt(sl.square_sum(xm));
            ds = Math.sqrt(sl.square_sum(xs));
            rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
            rsun = Math.asin(RSUN / ds) * SwissData.RADTODEG;
            rsplusrm = rsun + rmoon;
            for (k = 0; k < 3; k++) {
              x1[k] = xs[k] / ds /*ls[2]*/;
              x2[k] = xm[k] / dm /*lm[2]*/;
            }
            dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
            dc[i] = Math.abs(rsplusrm) - dctr.val;
          }
          dt1.val = -dc[0] / ((dc[0] - dc[1]) / dt);
          tret[j] += dt1.val;
        }
      }
      tret[1] -= SweDate.getDeltaT(tret[1]);
      tret[4] -= SweDate.getDeltaT(tret[4]);
      /*
       * visibility of eclipse phases
       */
      for (i = 4; i >= 0; i--) {        /* attr for i = 0 must be kept !!! */
        if (tret[i] == 0) {
          continue;
        }
        if (eclipse_how(tret[i], SweConst.SE_SUN, null, ifl, geopos[0], geopos[1], geopos[2],
                          attr, serr) == SweConst.ERR) {
          return SweConst.ERR;
        }
        /*if (retflag2 & SweConst.SE_ECL_VISIBLE) {} could be wrong for 1st/4th contact*/
        if (attr[5] > 0) {        /* this is save, sun above horizon */
          retflag |= SweConst.SE_ECL_VISIBLE;
          switch(i) {
          case 0: retflag |= SweConst.SE_ECL_MAX_VISIBLE; break;
          case 1: retflag |= SweConst.SE_ECL_1ST_VISIBLE; break;
          case 2: retflag |= SweConst.SE_ECL_2ND_VISIBLE; break;
          case 3: retflag |= SweConst.SE_ECL_3RD_VISIBLE; break;
          case 4: retflag |= SweConst.SE_ECL_4TH_VISIBLE; break;
          default:  break;
          }
        }
      }
      if ((retflag & SweConst.SE_ECL_VISIBLE)==0) {
        if (backward!=0) {
          K--;
        } else {
          K++;
        }
        continue;
      }
      break;
    } // while (true)
    return retflag;
  }

  private int occult_when_loc(double tjd_start, int ipl, StringBuffer starname,
      int ifl, double[] geopos, double[] tret, double[] attr,
      int backward, StringBuffer serr) {
    int i, j, k, m;
    int retflag = 0;
    double t, tjd, dt;
    DblObj dtint=new DblObj();
    double xs[]=new double[6], xm[]=new double[6], ls[]=new double[6], lm[]=new double[6], x1[]=new double[6], x2[]=new double[6], dm, ds;
    double rmoon, rsun, rsplusrm, rsminusrm;
    double dc[]=new double[20], dctrmin;
    DblObj dctr=new DblObj();
    double twomin = 2.0 / 24.0 / 60.0;
    double tensec = 10.0 / 24.0 / 60.0 / 60.0;
    double twohr = 2.0 / 24.0;
    double tenmin = 10.0 / 24.0 / 60.0;
    DblObj dt1=new DblObj(), dt2=new DblObj();
    double dtdiv, dtstart;
    double dadd2 = 6;
    int nstartpos = 10;
    double drad;
    int iflag = SweConst.SEFLG_TOPOCTR | ifl;
    int iflaggeo = iflag & ~SweConst.SEFLG_TOPOCTR;
    int iflagcart = iflag | SweConst.SEFLG_XYZ;
    int iflagcartgeo = iflaggeo | SweConst.SEFLG_XYZ;
    int direction = 1;
    int one_try = backward & SweConst.SE_ECL_ONE_TRY;
    boolean stop_after_this = false;
    backward &= 1L;
    retflag = 0;
    for (i = 0; i <= 9; i++)
      tret[i] = 0;
    if (backward!=0)
      direction = -1;
    t = tjd_start - direction * 0.1;
    tjd = tjd_start;
    while (true) {
//next_try:
      for (i = 0; i < nstartpos; i++, t += direction * dadd2) {
        if (calc_planet_star(t, ipl, starname, iflagcartgeo, xs, serr) == SweConst.ERR)
            return SweConst.ERR;
        if (sw.swe_calc(t, SweConst.SE_MOON, iflagcartgeo, xm, serr) == SweConst.ERR)
            return SweConst.ERR;
        dc[i] = Math.acos(sl.swi_dot_prod_unit(xs, xm)) * SwissData.RADTODEG;
        if (i > 1 && dc[i] > dc[i-1] && dc[i-2] > dc[i-1]) {
          tjd = t - direction*dadd2;
          break;
        } else if (i == nstartpos-1) {
          for (j = 0; j < nstartpos; j++)
              //DevNull.print(dc[j] + " ");
          DevNull.print("swe_lun_occult_when_loc(): problem planet\n");
          return SweConst.ERR;
        }
      }
      /*
       * radius of planet disk in AU
       */
      if (starname != null && starname.length() > 0)
        drad = 0;
      else if (ipl < SwephData.NDIAM)
        drad = SwephData.pla_diam[ipl] / 2 / SweConst.AUNIT;
      else if (ipl > SweConst.SE_AST_OFFSET)
        drad = swed.ast_diam / 2 * 1000 / SweConst.AUNIT; /* km -> m -> AU */
      else
        drad = 0;
      /* now find out, if there is an occultation at our geogr. location */
      dtdiv = 3;
      dtstart = dadd2; /* formerly 0.2 */
      for (dt = dtstart; 
           dt > 0.00001; 
           dt /= dtdiv) {
        if (dt < 0.01) 
          dtdiv = 3;
        for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
          /* this takes some time, but is necessary to avoid
           * missing an eclipse */
          if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (calc_planet_star(t, ipl, starname, iflag, ls, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (sw.swe_calc(t, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (dt < 1 && Math.abs(ls[1] - lm[1]) > 2) {
            if (one_try != 0) {
              stop_after_this = true;
            } else {
              t = tjd + direction * 2;
//goto next_try;
              continue;
            }
          }
          dc[i] = Math.acos(sl.swi_dot_prod_unit(xs, xm)) * SwissData.RADTODEG;
          rmoon = Math.asin(RMOON / lm[2]) * SwissData.RADTODEG;
          rsun = Math.asin(drad / ls[2]) * SwissData.RADTODEG;
          dc[i] -= (rmoon + rsun);
        }
        find_maximum(dc[0], dc[1], dc[2], dt, dtint, dctr);
        tjd += dtint.val + dt;
      }
      if (stop_after_this) { /* has one_try = TRUE */
        tret[0] = tjd;
        return 0;
      }
      if (calc_planet_star(tjd, ipl, starname, iflagcart, xs, serr) == SweConst.ERR)
        return SweConst.ERR;
      if (calc_planet_star(tjd, ipl, starname, iflag, ls, serr) == SweConst.ERR)
        return SweConst.ERR;
      if (sw.swe_calc(tjd, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR)
        return SweConst.ERR;
      if (sw.swe_calc(tjd, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR)
        return SweConst.ERR;
      dctr.val = Math.acos(sl.swi_dot_prod_unit(xs, xm)) * SwissData.RADTODEG;
      rmoon = Math.asin(RMOON / lm[2]) * SwissData.RADTODEG;
      rsun = Math.asin(drad / ls[2]) * SwissData.RADTODEG;
      rsplusrm = rsun + rmoon;
      rsminusrm = rsun - rmoon;
      if (dctr.val > rsplusrm) {
        if (one_try!=0) {
          tret[0] = tjd;
          return 0;
        }
        t = tjd + direction;
//    goto next_try;
        continue;
      }
      tret[0] = tjd - SweDate.getDeltaT(tjd);
      if ((backward!=0 && tret[0] >= tjd_start - 0.0001) 
        || (backward==0 && tret[0] <= tjd_start + 0.0001)) {
          t = tjd + direction;
//    goto next_try;
        continue;
      }
      if (dctr.val < rsminusrm)
        retflag = SweConst.SE_ECL_ANNULAR;
      else if (dctr.val < Math.abs(rsminusrm))
        retflag = SweConst.SE_ECL_TOTAL;
      else if (dctr.val <= rsplusrm)
        retflag = SweConst.SE_ECL_PARTIAL;
      dctrmin = dctr.val;
      /* contacts 2 and 3 */
      if (dctr.val > Math.abs(rsminusrm))  /* partial, no 2nd and 3rd contact */
        tret[2] = tret[3] = 0;
      else {
        dc[1] = Math.abs(rsminusrm) - dctrmin;
        for (i = 0, t = tjd - twomin; i <= 2; i += 2, t = tjd + twomin) {
          if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR)
            return SweConst.ERR;
          dm = Math.sqrt(sl.square_sum(xm));
          ds = Math.sqrt(sl.square_sum(xs));
          rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
          rsun = Math.asin(drad / ds) * SwissData.RADTODEG;
          rsminusrm = rsun - rmoon;
          for (k = 0; k < 3; k++) {
            x1[k] = xs[k] / ds /*ls[2]*/;
            x2[k] = xm[k] / dm /*lm[2]*/;
          }
          dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
          dc[i] = Math.abs(rsminusrm) - dctr.val;
        }
        find_zero(dc[0], dc[1], dc[2], twomin, dt1, dt2);
        tret[2] = tjd + dt1.val + twomin;
        tret[3] = tjd + dt2.val + twomin;
        for (m = 0, dt = tensec; m < 2; m++, dt /= 10) {
          for (j = 2; j <= 3; j++) {
            if (calc_planet_star(tret[j], ipl, starname, iflagcart | SweConst.SEFLG_SPEED, xs, serr) == SweConst.ERR)
              return SweConst.ERR;
            if (sw.swe_calc(tret[j], SweConst.SE_MOON, iflagcart | SweConst.SEFLG_SPEED, xm, serr) == SweConst.ERR)
              return SweConst.ERR;
            for (i = 0; i < 2; i++) {
              if (i == 1) {
                for(k = 0; k < 3; k++) {
                  xs[k] -= xs[k+3] * dt;
                  xm[k] -= xm[k+3] * dt;
                }
              }
              dm = Math.sqrt(sl.square_sum(xm));
              ds = Math.sqrt(sl.square_sum(xs));
              rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
              rsun = Math.asin(drad / ds) * SwissData.RADTODEG;
              rsminusrm = rsun - rmoon;
              for (k = 0; k < 3; k++) {
                x1[k] = xs[k] / ds /*ls[2]*/;
                x2[k] = xm[k] / dm /*lm[2]*/;
              }
              dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
              dc[i] = Math.abs(rsminusrm) - dctr.val;
            }
            dt1.val = -dc[0] / ((dc[0] - dc[1]) / dt);
            tret[j] += dt1.val;
          }
        }
        tret[2] -= SweDate.getDeltaT(tret[2]);
        tret[3] -= SweDate.getDeltaT(tret[3]);
      }
      /* contacts 1 and 4 */
      dc[1] = rsplusrm - dctrmin;
      for (i = 0, t = tjd - twohr; i <= 2; i += 2, t = tjd + twohr) {
        if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SweConst.ERR)
          return SweConst.ERR;
        if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR)
          return SweConst.ERR;
        dm = Math.sqrt(sl.square_sum(xm));
        ds = Math.sqrt(sl.square_sum(xs));
        rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
        rsun = Math.asin(drad / ds) * SwissData.RADTODEG;
        rsplusrm = rsun + rmoon;
        for (k = 0; k < 3; k++) {
          x1[k] = xs[k] / ds /*ls[2]*/;
          x2[k] = xm[k] / dm /*lm[2]*/;
        }
        dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
        dc[i] = rsplusrm - dctr.val;
      }
      find_zero(dc[0], dc[1], dc[2], twohr, dt1, dt2);
      tret[1] = tjd + dt1.val + twohr;
      tret[4] = tjd + dt2.val + twohr;
      for (m = 0, dt = tenmin; m < 3; m++, dt /= 10) {
        for (j = 1; j <= 4; j += 3) {
          if (calc_planet_star(tret[j], ipl, starname, iflagcart | SweConst.SEFLG_SPEED, xs, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (sw.swe_calc(tret[j], SweConst.SE_MOON, iflagcart | SweConst.SEFLG_SPEED, xm, serr) == SweConst.ERR)
            return SweConst.ERR;
          for (i = 0; i < 2; i++) {
            if (i == 1) {
              for(k = 0; k < 3; k++) {
                xs[k] -= xs[k+3] * dt;
                xm[k] -= xm[k+3] * dt;
              }
            }
            dm = Math.sqrt(sl.square_sum(xm));
            ds = Math.sqrt(sl.square_sum(xs));
            rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
            rsun = Math.asin(drad / ds) * SwissData.RADTODEG;
            rsplusrm = rsun + rmoon;
            for (k = 0; k < 3; k++) {
              x1[k] = xs[k] / ds /*ls[2]*/;
              x2[k] = xm[k] / dm /*lm[2]*/;
            }
            dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
            dc[i] = Math.abs(rsplusrm) - dctr.val;
          }
          dt1.val = -dc[0] / ((dc[0] - dc[1]) / dt);
          tret[j] += dt1.val;
        }
      }
      tret[1] -= SweDate.getDeltaT(tret[1]);
      tret[4] -= SweDate.getDeltaT(tret[4]);
      /*  
       * visibility of eclipse phases 
       */
      for (i = 4; i >= 0; i--) {	/* attr for i = 0 must be kept !!! */
        if (tret[i] == 0)
          continue;
        if (eclipse_how(tret[i], ipl, starname, ifl, geopos[0], geopos[1], geopos[2], 
    		attr, serr) == SweConst.ERR)
          return SweConst.ERR;
        /*if (retflag2 & SweConst.SE_ECL_VISIBLE) { could be wrong for 1st/4th contact } */
        if (attr[5] > 0) {	/* this is save, sun above horizon */
          retflag |= SweConst.SE_ECL_VISIBLE;
          switch(i) {
          case 0: retflag |= SweConst.SE_ECL_MAX_VISIBLE; break;
          case 1: retflag |= SweConst.SE_ECL_1ST_VISIBLE; break;
          case 2: retflag |= SweConst.SE_ECL_2ND_VISIBLE; break;
          case 3: retflag |= SweConst.SE_ECL_3RD_VISIBLE; break;
          case 4: retflag |= SweConst.SE_ECL_4TH_VISIBLE; break;
          default:  break;
          }
        }
      }
      if ((retflag & SweConst.SE_ECL_VISIBLE)==0) {
        t = tjd + direction;
//    goto next_try;
        continue;
      }
      break; // next_try
    } // while (true) .. [goto next_try]
    return retflag;
  }

  /*
   * swe_azalt()
   * Computes azimut and height, from either ecliptic or
   * equatorial coordinates
   *
   * input:
   *   tjd_ut
   *   iflag        either SE_ECL2HOR or SE_EQU2HOR
   *   geopos[3]    geograph. longitude, latitude, height above sea
   *   atpress      atmospheric pressure at geopos in millibars (hPa)
   *   attemp       atmospheric temperature in degrees C
   *   xin[2]       input coordinates polar, in degrees
   *
   * Horizontal coordinates are returned in
   *   xaz[3]       xaz[0] = azimuth
   *                xaz[1] = true altitude
   *                xaz[2] = apparent altitude
   *
   * If atpress is not given (= 0), the programm assumes 1013.25 mbar;
   * if a non-zero height above sea is given, atpress is estimated.
   *   geohgt       height of observer above sea (optional)
   */
  /**
  * Computes the azimut and height from either ecliptic or equatorial
  * coordinates.
  * <P>xaz is an output parameter as follows:
  * <P><CODE>
  * xaz[0]:&nbsp;&nbsp;&nbsp;azimuth, i.e. position degree, measured from
  * the south point to west.<BR>
  * xaz[1]:&nbsp;&nbsp;&nbsp;true altitude above horizon in degrees.<BR>
  * xaz[2]:&nbsp;&nbsp;&nbsp;apparent (refracted) altitude above horizon
  * in degrees.
  * </CODE><P>
  * @param tjd_ut time and date in UT
  * @param calc_flag SweConst.SE_ECL2HOR (xin[0] contains ecliptic
  * longitude, xin[1] the ecliptic latitude) or SweConst.SE_EQU2HOR (xin[0] =
  * rectascension, xin[1] = declination)
  * @param geopos An array double[3] containing the longitude, latitude and
  * height of the geographic position
  * @param atpress atmospheric pressure in mBar (hPa). If it is 0, the pressure
  * will be estimated from geopos[2] and attemp.
  * @param attemp atmospheric temperature in degrees Celsius.
  * @param xin double[3] with a content depending on parameter calc_flag.
  * See there. xin[3] does not need to be defined.
  * @param xaz Output parameter: a double[3] returning values as specified
  * above.
  */
  void swe_azalt(double tjd_ut,
                 int calc_flag,
                 double[] geopos,
                 double atpress,
                 double attemp,
                 double[] xin,
                 double[] xaz) {
    int i;
    double x[]=new double[6], xra[]=new double[3];
    double armc = sl.swe_degnorm(sl.swe_sidtime(tjd_ut) * 15 + geopos[0]);
    double mdd, eps_true, tjd_et;
    for (i = 0; i < 2; i++)
      xra[i] = xin[i];
    xra[2] = 1;
    if (calc_flag == SweConst.SE_ECL2HOR) {
          tjd_et = tjd_ut + SweDate.getDeltaT(tjd_ut);
      sw.swe_calc(tjd_et, SweConst.SE_ECL_NUT, 0, x, null);
      eps_true = x[0];
          sl.swe_cotrans(xra, 0, xra, 0, -eps_true);
    }
    mdd = sl.swe_degnorm(xra[0] - armc);
    x[0] = sl.swe_degnorm(mdd - 90);
    x[1] = xra[1];
    x[2] = 1;
    /* azimuth from east, counterclock */
    sl.swe_cotrans(x, 0, x, 0, 90 - geopos[1]);
    /* azimuth from south to west */
    x[0] = sl.swe_degnorm(x[0] + 90);
    xaz[0] = 360 - x[0];
    xaz[1] = x[1];                /* true height */
    if (atpress == 0) {
      /* estimate atmospheric pressure */
      atpress = 1013.25 * Math.pow(1 - 0.0065 * geopos[2] / 288, 5.255);
    }
    xaz[2] = swe_refrac(x[1], atpress, attemp, SweConst.SE_TRUE_TO_APP);
  }

  /*
   * swe_azalt_rev()
   * computes either ecliptical or equatorial coordinates from
   * azimuth and true altitude in degrees.
   * For conversion between true and apparent altitude, there is
   * the function swe_refrac().
   *
   * input:
   *   tjd_ut
   *   iflag        either SE_HOR2ECL or SE_HOR2EQU
   *   xin[2]       azimut and true altitude, in degrees
   */
  /**
  * Computes either ecliptic or equatorial coordinates from azimuth and true
  * altitude. The true altitude might be gained from an apparent altitude by
  * calling swe_refrac.<P>xout is an output parameter containing the ecliptic
  * or equatorial coordinates, depending on the value of the parameter
  * calc_flag.
  * @param tjd_ut time and date in UT
  * @param calc_flag SweConst.SE_HOR2ECL or SweConst.SE_HOR2EQU
  * @param geopos An array double[3] containing the longitude, latitude and
  * height of the geographic position
  * @param xin double[2] with azimuth and true altitude of planet
  * @param xout Output parameter: a double[2] returning either ecliptic or
  * equatorial coordinates depending on parameter 'calc_flag'
  */
  void swe_azalt_rev(double tjd_ut,
                     int calc_flag,
                     double[] geopos,
                     double[] xin,
                     double[] xout) {
    int i;
    double x[]=new double[6], xaz[]=new double[3];
    double geolon = geopos[0];
    double geolat = geopos[1];
    double armc = sl.swe_degnorm(sl.swe_sidtime(tjd_ut) * 15 + geolon);
    double eps_true, tjd_et;
    for (i = 0; i < 2; i++)
      xaz[i] = xin[i];
    xaz[2] = 1;
    /* azimuth is from south, clockwise.
     * we need it from east, counterclock */
    xaz[0] = 360 - xaz[0];
    xaz[0] = sl.swe_degnorm(xaz[0] - 90);
    /* equatorial positions */
    sl.swe_cotrans(xaz, 0, xaz, 0, geolat - 90);
    xaz[0] = sl.swe_degnorm(xaz[0] + armc + 90);
    xout[0] = xaz[0];
    xout[1] = xaz[1];
    /* ecliptic positions */
    if (calc_flag == SweConst.SE_HOR2ECL) {
      tjd_et = tjd_ut + SweDate.getDeltaT(tjd_ut);
      sw.swe_calc(tjd_et, SweConst.SE_ECL_NUT, 0, x, null);
      eps_true = x[0];
      sl.swe_cotrans(xaz, 0, x, 0, eps_true);
      xout[0] = x[0];
      xout[1] = x[1];
    }
  }

  /* swe_refrac()
   * Transforms apparent to true altitude and vice-versa.
   * These formulae do not handle the case when the
   * sun is visible below the geometrical horizon
   * (from a mountain top or an air plane)
   * input:
   * double inalt;        * altitude of object in degrees *
   * double atpress;      * millibars (hectopascal) *
   * double attemp;       * degrees C *
   * int32  calc_flag;    * either SE_CALC_APP_TO_TRUE or
   *                      *        SE_CALC_TRUE_TO_APP
   */
  /**
  * Calculates the true altitude from the apparent altitude or vice versa.
  * @param inalt The true or apparent altitude to be converted
  * @param atpress Atmospheric pressure in mBar (hPa). If it is 0, the pressure
  * will be estimated from attemp on sea level.
  * @param attemp Atmospheric temperature in degrees Celsius.
  * @param calc_flag SweConst.SE_TRUE_TO_APP or SweConst.SE_APP_TO_TRUE
  * @return The converted altitude
  */
  double swe_refrac(double inalt, double atpress, double attemp,
                    int calc_flag) {
    double a, refr;
    double pt_factor = atpress / 1010.0 * 283.0 / (273.0 + attemp);
    double trualt, appalt;
    /* another algorithm, from Meeus, German, p. 114ff.
     */
    if (calc_flag == SweConst.SE_TRUE_TO_APP) {
      trualt = inalt;
      if (trualt > 15) {
        a = Math.tan((90 - trualt) * SwissData.DEGTORAD);
        refr = (58.276 * a - 0.0824 * a * a * a);
        refr *=  pt_factor / 3600.0;
      } else if (trualt > -5) {
        /* the following tan is not defined for a value
         * of trualt near -5.00158 and 89.89158 */
        a = trualt + 10.3 / (trualt + 5.11);
        if (a + 1e-10 >= 90) {
          refr = 0;
        } else {
          refr = 1.02 / Math.tan(a * SwissData.DEGTORAD);
        }
        refr *= pt_factor / 60.0;
      } else {
        refr = 0;
      }
      appalt = trualt;
      if (appalt + refr > 0) {
        appalt += refr;
      }
      return appalt;
    } else { // SE_TRUE_TO_APP
      appalt = inalt;
      if (appalt > 15) {
        a = Math.tan((90 - appalt) * SwissData.DEGTORAD);
        refr = (58.294 * a - 0.0668 * a * a * a);
        refr *=  pt_factor / 3600.0;
      } else {
        /* the following tan is not defined for a value
         * of inalt near -4.3285 and 89.9225 */
        a = appalt + 7.31 / (appalt + 4.4);
        if (a + 1e-10 >= 90) {
          refr = 0;
        } else {
          refr = 1.00 / Math.tan(a * SwissData.DEGTORAD);
          refr -= 0.06 * Math.sin(14.7 * refr + 13);
        }
        refr *= pt_factor / 60.0;
      }
      trualt = appalt;
      if (trualt - refr > 0) {
        trualt -= refr;
      }
      return trualt;
    }
  }

  /* Computes attributes of a lunar eclipse for given tjd and geopos
   *
   * retflag        SE_ECL_TOTAL or SE_ECL_PARTIAL
   *              SE_ECL_PENUMBRAL
   *              if 0, there is no eclipse
   *
   * attr[0]        umbral magnitude at tjd
   * attr[1]      penumbral magnitude
   * attr[7]        distance of moon from opposition in degrees
   *         declare as attr[20] at least !
   *
   */
  /**
  * Computes the attributes of a lunar eclipse for a given Julian Day,
  * geographic longitude, latitude, and height.
  * <BLOCKQUOTE><P><CODE>
  * attr[0]:&nbsp;&nbsp;&nbsp;umbral magnitude at tjd<BR>
  * (magnitude)<BR>
  * attr[1]:&nbsp;&nbsp;&nbsp;penumbral magnitude<BR>
  * attr[4]:&nbsp;&nbsp;&nbsp;azimuth of moon at tjd. <I>Not yet
  * implemented.</I><BR>
  * attr[5]:&nbsp;&nbsp;&nbsp;true altitude of moon above horizon at tjd.
  * <I>Not yet implemented.</I><BR>
  * attr[6]:&nbsp;&nbsp;&nbsp;apparent altitude of moon above horizon at tjd.
  * <I>Not yet implemented.</I><BR>
  * attr[7]:&nbsp;&nbsp;&nbsp;distance of moon from opposition in degrees
  * </CODE><P></BLOCKQUOTE><B>Attention: attr must be a double[20]!</B>
  * @param tjd_ut The Julian Day number in UT
  * @param ifl To indicate, which ephemeris should be used (SEFLG_JPLEPH,
  * SEFLG_SWIEPH or SEFLG_MOSEPH)
  * @param geopos A double[3] containing geographic longitude, latitude and
  * height in meters above sea level in this order.
  * @param attr An array[20], on return containing the attributes of the
  * eclipse as above
  * @param serr A StringBuffer containing a warning or error message, if
  * something fails
  * @return -1 (SweConst.ERR), if the calculation failed<BR>
  * 0, if there is no lunar eclipse at that time and location<BR>
  * SweConst.SE_ECL_TOTAL<BR>
  * SweConst.SE_ECL_PENUMBRAL<BR>
  * SweConst.SE_ECL_PARTIAL
  */
  int swe_lun_eclipse_how(double tjd_ut,
                          int ifl,
                          double[] geopos,
                          double[] attr,
                          StringBuffer serr) {
    double dcore[]=new double[10];
    /* attention: geopos[] is not used so far; may be null */
    // geopos[0] = geopos[0]; /* to shut up mint */
    ifl = ifl & ~SweConst.SEFLG_TOPOCTR;
    return lun_eclipse_how(tjd_ut, ifl, attr, dcore, serr);
  }

  /*
   * attr[]:         see swe_lun_eclipse_how()
   *
   * dcore[0]:        distance of shadow axis from geocenter r0
   * dcore[1]:        diameter of core shadow on fundamental plane d0
   * dcore[2]:        diameter of half-shadow on fundamental plane D0
   */
  private int lun_eclipse_how(double tjd_ut,
                              int ifl,
                              double[] attr,
                              double[] dcore,
                              StringBuffer serr) {
    int i;
    int retc = 0;
    double e[]=new double[6], rm[]=new double[6], rs[]=new double[6];
    double dsm, d0, D0, s0, r0, ds, dm;
    double dctr, x1[]=new double[6], x2[]=new double[6];
    double f1, f2;
    double deltat, tjd;
    double cosf1, cosf2;
    int iflag;
    for (i = 0; i < 10; i++)
      dcore[i] = 0;
    for (i = 0; i < 20; i++)
      attr[i] = 0;
    /* nutation need not be in lunar and solar positions,
     * if mean sidereal time will be used */
    iflag = SweConst.SEFLG_SPEED | SweConst.SEFLG_EQUATORIAL | ifl;
    iflag  = iflag | SweConst.SEFLG_XYZ;
    deltat = SweDate.getDeltaT(tjd_ut);
    tjd = tjd_ut + deltat;
    /* moon in cartesian coordinates */
    if (sw.swe_calc(tjd, SweConst.SE_MOON, iflag, rm, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    /* distance of moon from geocenter */
    dm = Math.sqrt(sl.square_sum(rm));
    /* sun in cartesian coordinates */
    if (sw.swe_calc(tjd, SweConst.SE_SUN, iflag, rs, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    /* distance of sun from geocenter */
    ds = Math.sqrt(sl.square_sum(rs));
    for (i = 0; i < 3; i++) {
      x1[i] = rs[i] / ds;
      x2[i] = rm[i] / dm;
    }
    dctr = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
    /* selenocentric sun */
    for (i = 0; i <= 2; i++)
      rs[i] -= rm[i];
    /* selenocentric earth */
    for (i = 0; i <= 2; i++)
      rm[i] = -rm[i];
    /* sun - earth vector */
    for (i = 0; i <= 2; i++)
      e[i] = (rm[i] - rs[i]);
    /* distance sun - earth */
    dsm = Math.sqrt(sl.square_sum(e));
    /* sun - earth unit vector */
    for (i = 0; i <= 2; i++)
      e[i] /= dsm;
    f1 = ((RSUN - REARTH) / dsm);
    cosf1 = Math.sqrt(1 - f1 * f1);
    f2 = ((RSUN + REARTH) / dsm);
    cosf2 = Math.sqrt(1 - f2 * f2);
    /* distance of earth from fundamental plane */
    s0 = -sw.dot_prod(rm, e);
    /* distance of shadow axis from selenocenter */
    r0 = Math.sqrt(dm * dm - s0 * s0);
    /* diameter of core shadow on fundamental plane */
    d0 = Math.abs(s0 / dsm * (DSUN - DEARTH) - DEARTH) * (1 + 1.0 / 50) / cosf1;
           /* one 50th is added for effect of atmosphere, AA98, L4 */
    /* diameter of half-shadow on fundamental plane */
    D0 = (s0 / dsm * (DSUN + DEARTH) + DEARTH) * (1 + 1.0 / 50) / cosf2;
    d0 /= cosf1;
    D0 /= cosf2;
    dcore[0] = r0;
    dcore[1] = d0;
    dcore[2] = D0;
    dcore[3] = cosf1;
    dcore[4] = cosf2;
    /**************************
     * phase and umbral magnitude
     **************************/
    retc = 0;
    if (d0 / 2 >= r0 + RMOON / cosf1) {
      retc = SweConst.SE_ECL_TOTAL;
      attr[0] = (d0 / 2 - r0 + RMOON) / DMOON;
    } else if (d0 / 2 >= r0 - RMOON / cosf1) {
      retc = SweConst.SE_ECL_PARTIAL;
      attr[0] = (d0 / 2 - r0 + RMOON) / DMOON;
    } else if (D0 / 2 >= r0 - RMOON / cosf2) {
      retc = SweConst.SE_ECL_PENUMBRAL;
      attr[0] = 0;
    } else {
      if (serr != null) {
        serr.setLength(0);
        serr.append("no lunar eclipse at tjd = "+tjd);
      }
    }
    /**************************
     * penumbral magnitude
     **************************/
    attr[1] = (D0 / 2 - r0 + RMOON) / DMOON;
    if (retc != 0) {
      attr[7] = 180 - Math.abs(dctr);
    }
    return retc;
  }

  /* When is the next lunar eclipse?
   *
   * retflag        SE_ECL_TOTAL or SE_ECL_PENUMBRAL or SE_ECL_PARTIAL
   *
   * tret[0]        time of maximum eclipse
   * tret[1]
   * tret[2]        time of partial phase begin (indices consistent with solar eclipses)
   * tret[3]        time of partial phase end
   * tret[4]        time of totality begin
   * tret[5]        time of totality end
   * tret[6]        time of penumbral phase begin
   * tret[7]        time of penumbral phase end
   */
  /**
  * Computes the next lunar eclipse anywhere on earth.
  * <P>tret is an output parameter with the following meaning:
  * <P><CODE>
  * tret[0]:&nbsp;&nbsp;&nbsp;time of maximum eclipse.<BR>
  * tret[1]:&nbsp;&nbsp;&nbsp;<BR>
  * tret[2]:&nbsp;&nbsp;&nbsp;time of the begin of partial phase.<BR>
  * tret[3]:&nbsp;&nbsp;&nbsp;time of the end of partial phaseend.<BR>
  * tret[4]:&nbsp;&nbsp;&nbsp;time of the begin of totality.<BR>
  * tret[5]:&nbsp;&nbsp;&nbsp;time of the end of totality.<BR>
  * tret[6]:&nbsp;&nbsp;&nbsp;time of the begin of center line.<BR>
  * tret[7]:&nbsp;&nbsp;&nbsp;time of the end of center line<BR>
  * </CODE><P><B>Attention: tret must be a double[10]!</B>
  * @param tjd_start The Julian Day number in UT, from when to start searching
  * @param ifl To indicate, which ephemeris should be used (SEFLG_JPLEPH,
  * SEFLG_SWIEPH or SEFLG_MOSEPH)
  * @param ifltype SweConst.SE_ECL_TOTAL for total eclipse or 0 for any eclipse
  * @param tret An array[10], on return containing the times of different
  * occasions of the eclipse as above
  * @param backward true, if search should be done backwards
  * @param serr A StringBuffer containing a warning or error message, if
  * something fails.
  * @return -1 (SweConst.ERR), if the calculation failed<BR>
  * SweConst.SE_ECL_TOTAL<BR>
  * SweConst.SE_ECL_ANNULAR<BR>
  * SweConst.SE_ECL_PARTIAL<BR>
  * SweConst.SE_ECL_ANNULAR_TOTAL<BR>in combination with:<BR>
  * SweConst.SE_ECL_CENTRAL<BR>
  * SweConst.SE_ECL_NONCENTRAL
  */
  int swe_lun_eclipse_when(double tjd_start, int ifl, int ifltype,
                           double[] tret, int backward,
                           StringBuffer serr) {
    int i, j, m, n, o, i1 = 0, i2 = 0;
    int retflag = 0, retflag2 = 0;
    double t, tjd, dt, dta, dtb;
    DblObj dtint=new DblObj();
    double T, T2, T3, T4, K, F, M, Mm;
    double E, Ff, F1, A1, Om;
    double xs[]=new double[6], xm[]=new double[6], dm, ds;
    double rsun, rearth, dcore[]=new double[10];
    double dc[]=new double[3];
    DblObj dctr=new DblObj();
    double twohr = 2.0 / 24.0;
    double tenmin = 10.0 / 24.0 / 60.0;
    DblObj dt1=new DblObj(), dt2=new DblObj();
    double kk;
    double attr[]=new double[20];
    double dtstart, dtdiv;
    double xa[]=new double[6], xb[]=new double[6];
    int direction = 1;
    int iflag;
    int iflagcart;
    ifl &= SweConst.SEFLG_EPHMASK;
    iflag = SweConst.SEFLG_EQUATORIAL | ifl;
    iflagcart = iflag | SweConst.SEFLG_XYZ;
    if (ifltype == 0) {
      ifltype = SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_PENUMBRAL |
                SweConst.SE_ECL_PARTIAL;
    }
    if (backward!=0) {
      direction = -1;
    }
    K = (int) ((tjd_start - SwephData.J2000) / 365.2425 * 12.3685);
    K -= direction;
//next_try:
    while (true) {
      retflag = 0;
      for (i = 0; i <= 9; i++)
        tret[i] = 0;
      kk = K + 0.5;
      T = kk / 1236.85;
      T2 = T * T; T3 = T2 * T; T4 = T3 * T;
      Ff = F = sl.swe_degnorm(160.7108 + 390.67050274 * kk
                   - 0.0016341 * T2
                   - 0.00000227 * T3
                   + 0.000000011 * T4);
      if (Ff > 180) {
        Ff -= 180;
      }
      if (Ff > 21 && Ff < 159) {         /* no eclipse possible */
        K += direction;
        continue;
      }
      /* approximate time of geocentric maximum eclipse
       * formula from Meeus, German, p. 381 */
      tjd = 2451550.09765 + 29.530588853 * kk
                          + 0.0001337 * T2
                          - 0.000000150 * T3
                          + 0.00000000073 * T4;
      M = sl.swe_degnorm(2.5534 + 29.10535669 * kk
                          - 0.0000218 * T2
                          - 0.00000011 * T3);
      Mm = sl.swe_degnorm(201.5643 + 385.81693528 * kk
                          + 0.1017438 * T2
                          + 0.00001239 * T3
                          + 0.000000058 * T4);
      Om = sl.swe_degnorm(124.7746 - 1.56375580 * kk
                          + 0.0020691 * T2
                          + 0.00000215 * T3);
      E = 1 - 0.002516 * T - 0.0000074 * T2;
      A1 = sl.swe_degnorm(299.77 + 0.107408 * kk - 0.009173 * T2);
      M *= SwissData.DEGTORAD;
      Mm *= SwissData.DEGTORAD;
      F *= SwissData.DEGTORAD;
      Om *= SwissData.DEGTORAD;
      F1 = F - 0.02665 * Math.sin(Om) * SwissData.DEGTORAD;
      A1 *= SwissData.DEGTORAD;
      tjd = tjd - 0.4075 * Math.sin(Mm)
                + 0.1721 * E * Math.sin(M)
                + 0.0161 * Math.sin(2 * Mm)
                - 0.0097 * Math.sin(2 * F1)
                + 0.0073 * E * Math.sin(Mm - M)
                - 0.0050 * E * Math.sin(Mm + M)
                - 0.0023 * Math.sin(Mm - 2 * F1)
                + 0.0021 * E * Math.sin(2 * M)
                + 0.0012 * Math.sin(Mm + 2 * F1)
                + 0.0006 * E * Math.sin(2 * Mm + M)
                - 0.0004 * Math.sin(3 * Mm)
                - 0.0003 * E * Math.sin(M + 2 * F1)
                + 0.0003 * Math.sin(A1)
                - 0.0002 * E * Math.sin(M - 2 * F1)
                - 0.0002 * E * Math.sin(2 * Mm - M)
                - 0.0002 * Math.sin(Om);
      /*
       * precise computation:
       * time of maximum eclipse (if eclipse) =
       * minimum selenocentric angle between sun and earth edges.
       * After this time has been determined, check
       * whether or not an eclipse is taking place with
       * the function lun_eclipse_how().
       */
      dtstart = 0.1;
      if (tjd < 2000000) {
        dtstart = 5;
      }
      dtdiv = 4;
      for (j = 0, dt = dtstart;
           dt > 0.001;
           j++, dt /= dtdiv) {
        for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
          if (sw.swe_calc(t, SweConst.SE_SUN, iflagcart, xs, serr) ==
                                                                 SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) ==
                                                                 SweConst.ERR) {
            return SweConst.ERR;
          }
          for (m = 0; m < 3; m++) {
            xs[m] -= xm[m];        /* selenocentric sun */
            xm[m] = -xm[m];        /* selenocentric earth */
          }
          ds = Math.sqrt(sl.square_sum(xs));
          dm = Math.sqrt(sl.square_sum(xm));
          for (m = 0; m < 3; m++) {
            xa[m] = xs[m] / ds;
            xb[m] = xm[m] / dm;
          }
          dc[i] = Math.acos(sl.swi_dot_prod_unit(xa, xb)) * SwissData.RADTODEG;
          rearth = Math.asin(REARTH / dm) * SwissData.RADTODEG;
          rsun = Math.asin(RSUN / ds) * SwissData.RADTODEG;
          dc[i] -= (rearth + rsun);
        }
        find_maximum(dc[0], dc[1], dc[2], dt, dtint, dctr);
        tjd += dtint.val + dt;
      }
      tjd = tjd - SweDate.getDeltaT(tjd);
      if ((retflag = swe_lun_eclipse_how(tjd, ifl, null, attr, serr)) ==
                                                                 SweConst.ERR) {
        return retflag;
      }
      if (retflag == 0) {
        K += direction;
        continue;
      }
      tret[0] = tjd;
      if ((backward!=0 && tret[0] >= tjd_start - 0.0001)
        || (backward==0 && tret[0] <= tjd_start + 0.0001)) {
        K += direction;
        continue;
      }
      /*
       * check whether or not eclipse type found is wanted
       */
      /* non penumbral eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_PENUMBRAL)==0 &&
          (retflag & SweConst.SE_ECL_PENUMBRAL)!=0) {
        K += direction;
        continue;
      }
      /* non partial eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_PARTIAL)==0 &&
          (retflag & SweConst.SE_ECL_PARTIAL)!=0) {
        K += direction;
        continue;
      }
      /* annular-total eclipse will be discovered later */
      if ((ifltype & (SweConst.SE_ECL_TOTAL))==0 &&
          (retflag & SweConst.SE_ECL_TOTAL)!=0) {
        K += direction;
        continue;
      }
      /*
       * n = 0: times of eclipse begin and end
       * n = 1: times of totality begin and end
       * n = 2: times of center line begin and end
       */
      if ((retflag & SweConst.SE_ECL_PENUMBRAL)!=0) {
        o = 0;
      } else if ((retflag & SweConst.SE_ECL_PARTIAL)!=0) {
        o = 1;
      } else {
        o = 2;
      }
      dta = twohr;
      dtb = tenmin;
      for (n = 0; n <= o; n++) {
        if (n == 0) {
          i1 = 6; i2 = 7;
        } else if (n == 1) {
          i1 = 2; i2 = 3;
        } else if (n == 2) {
          i1 = 4; i2 = 5;
        }
        for (i = 0, t = tjd - dta; i <= 2; i += 1, t += dta) {
          if ((retflag2 = lun_eclipse_how(t, ifl, attr, dcore, serr)) ==
                                                                 SweConst.ERR) {
            return retflag2;
          }
          if (n == 0) {
            dc[i] = dcore[2] / 2 + RMOON / dcore[4] - dcore[0];
          } else if (n == 1) {
            dc[i] = dcore[1] / 2 + RMOON / dcore[3] - dcore[0];
          } else if (n == 2) {
            dc[i] = dcore[1] / 2 - RMOON / dcore[3] - dcore[0];
          }
        }
        find_zero(dc[0], dc[1], dc[2], dta, dt1, dt2);
        dtb = (dt1.val + dta) / 2;
        tret[i1] = tjd + dt1.val + dta;
        tret[i2] = tjd + dt2.val + dta;
        for (m = 0, dt = dtb / 2; m < 3; m++, dt /= 2) {
          for (j = i1; j <= i2; j += (i2 - i1)) {
            for (i = 0, t = tret[j] - dt; i < 2; i++, t += dt) {
              if ((retflag2 = lun_eclipse_how(t, ifl, attr, dcore, serr)) ==
                                                                 SweConst.ERR) {
                return retflag2;
              }
              if (n == 0) {
                dc[i] = dcore[2] / 2 + RMOON / dcore[4] - dcore[0];
              } else if (n == 1) {
                dc[i] = dcore[1] / 2 + RMOON / dcore[3] - dcore[0];
              } else if (n == 2) {
                dc[i] = dcore[1] / 2 - RMOON / dcore[3] - dcore[0];
              }
            }
            dt1.val = dc[1] / ((dc[1] - dc[0]) / dt);
            tret[j] -= dt1.val;
          }
        }
      }
      break;
    } // while (true)
    return retflag;
  }

  /*
   * function calculates planetary phenomena
   *
   * attr[0] = phase angle (earth-planet-sun)
   * attr[1] = phase (illumined fraction of disc)
   * attr[2] = elongation of planet
   * attr[3] = apparent diameter of disc
   * attr[4] = apparent magnitude
   *         declare as attr[20] at least !
   *
   * Note: the lunar magnitude is quite a complicated thing,
   * but our algorithm is very simple.
   * The phase of the moon, its distance from the earth and
   * the sun is considered, but no other factors.
   *
   */
  private static final double EULER=2.718281828459;
  private static final int NMAG_ELEM=SweConst.SE_VESTA + 1;

  private static final double mag_elem[][] = {
                  /* DTV-Atlas Astronomie, p. 32 */
                  {-26.86, 0, 0, 0},
                  {-12.55, 0, 0, 0},
                  /* IAU 1986 */
                  {-0.42, 3.80, -2.73, 2.00},
                  {-4.40, 0.09, 2.39, -0.65},
                  {- 1.52, 1.60, 0, 0},   /* Mars */
                  {- 9.40, 0.5, 0, 0},    /* Jupiter */
                  {- 8.88, -2.60, 1.25, 0.044},   /* Saturn */
                  {- 7.19, 0.0, 0, 0},    /* Uranus */
                  {- 6.87, 0.0, 0, 0},    /* Neptune */
                  {- 1.00, 0.0, 0, 0},    /* Pluto */
                  {99, 0, 0, 0},          /* nodes and apogees */
                  {99, 0, 0, 0},
                  {99, 0, 0, 0},
                  {99, 0, 0, 0},
                  {99, 0, 0, 0},          /* Earth */
                  /* from Bowell data base */
                  {6.5, 0.15, 0, 0},      /* Chiron */
                  {7.0, 0.15, 0, 0},      /* Pholus */
                  {3.34, 0.12, 0, 0},     /* Ceres */
                  {4.13, 0.11, 0, 0},     /* Pallas */
                  {5.33, 0.32, 0, 0},     /* Juno */
                  {3.20, 0.32, 0, 0},     /* Vesta */
                  };

  /**
  * Computes phase, phase angel, elongation, apparent diameter and apparent
  * magnitude for sun, moon, all planets and asteroids. This method is
  * identical to swe_pheno_ut() with the one exception that the time
  * has to be given in ET (Ephemeris Time or Dynamical Time). You
  * would get ET by adding deltaT to the UT, e.g.,
  * <CODE>tjd_et&nbsp;+&nbsp;SweDate.getDeltaT(tjd_et)</CODE>.<P>
  * See <A HREF="Swecl.html#swe_pheno_ut(double, int, int, double[], java.lang.StringBuffer)">swe_pheno_ut(...)</A> for missing information.
  */
  int swe_pheno(double tjd, int ipl, int iflag, double[] attr,
                StringBuffer serr) {
    int i;
    double xx[]=new double[6], xx2[]=new double[6], xxs[]=new double[6],
           lbr[]=new double[6], lbr2[]=new double[6], dt = 0, dsm, dd;
    double fac;
    double T, in, om, sinB, u1, u2, du;
    double ph1, ph2, me[]=new double[2];
    int iflagp;
    for (i = 0; i < 20; i++)
      attr[i] = 0;
    /* Ceres - Vesta must be SE_CERES etc., not 10001 etc. */
    if (ipl > SweConst.SE_AST_OFFSET && ipl <= SweConst.SE_AST_OFFSET + 4) {
      ipl = ipl - SweConst.SE_AST_OFFSET - 1 + SweConst.SE_CERES;
    }
    iflag = iflag & (SweConst.SEFLG_EPHMASK |
                     SweConst.SEFLG_TRUEPOS |
                     SweConst.SEFLG_J2000 |
                     SweConst.SEFLG_NONUT |
                     SweConst.SEFLG_NOGDEFL |
                     SweConst.SEFLG_NOABERR |
                     SweConst.SEFLG_TOPOCTR);
    iflagp = iflag & (SweConst.SEFLG_EPHMASK |
                     SweConst.SEFLG_TRUEPOS |
                     SweConst.SEFLG_J2000 |
                     SweConst.SEFLG_NONUT |
                     SweConst.SEFLG_NOABERR);
    iflagp |= SweConst.SEFLG_HELCTR;
    /*
     * geocentric planet
     */
    if (sw.swe_calc(tjd, ipl, iflag | SweConst.SEFLG_XYZ, xx, serr) ==
                                                                 SweConst.ERR) {
      return SweConst.ERR;
    }
    if (sw.swe_calc(tjd, ipl, iflag, lbr, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    /* if moon, we need sun as well, for magnitude */
    if (ipl == SweConst.SE_MOON) {
      if (sw.swe_calc(tjd, SweConst.SE_SUN, iflag | SweConst.SEFLG_XYZ,
                      xxs, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
    }
    if (ipl != SweConst.SE_SUN && ipl != SweConst.SE_EARTH &&
      ipl != SweConst.SE_MEAN_NODE && ipl != SweConst.SE_TRUE_NODE &&
      ipl != SweConst.SE_MEAN_APOG && ipl != SweConst.SE_OSCU_APOG) {
      /*
       * light time planet - earth
       */
      dt = lbr[2] * SweConst.AUNIT / SwephData.CLIGHT / 86400.0;
      if ((iflag & SweConst.SEFLG_TRUEPOS)!=0) {
        dt = 0;
      }
      /*
       * heliocentric planet at tjd - dt
       */
      if (sw.swe_calc(tjd - dt, ipl, iflagp | SweConst.SEFLG_XYZ, xx2, serr) ==
                                                                 SweConst.ERR) {
        return SweConst.ERR;
      }
      if (sw.swe_calc(tjd - dt, ipl, iflagp, lbr2, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
      /*
       * phase angle
       */
      attr[0] = Math.acos(sl.swi_dot_prod_unit(xx, xx2)) * SwissData.RADTODEG;
      /*
       * phase
       */
      attr[1] = (1 + Math.cos(attr[0] * SwissData.DEGTORAD)) / 2;
    }
    /*
     * apparent diameter of disk
     */
    if (ipl < SwephData.NDIAM) {
      dd = SwephData.pla_diam[ipl];
    } else if (ipl > SweConst.SE_AST_OFFSET) {
      dd = swed.ast_diam * 1000;        /* km -> m */
    } else {
      dd = 0;
    }
    if (lbr[2] < dd / 2 / SweConst.AUNIT) {
      attr[3] = 180;  /* assume position on surface of earth */
    } else {
      attr[3] = Math.asin(dd / 2 / SweConst.AUNIT / lbr[2]) * 2 * SwissData.RADTODEG;
    }
    /*
     * apparent magnitude
     */
    if (ipl > SweConst.SE_AST_OFFSET ||
        (ipl < NMAG_ELEM && mag_elem[ipl][0] < 99)) {
      if (ipl == SweConst.SE_SUN) {
        /* ratio apparent diameter : average diameter */
        fac = attr[3] / (Math.asin(SwephData.pla_diam[SweConst.SE_SUN] / 2.0 /
                                            SweConst.AUNIT) * 2 * SwissData.RADTODEG);
        fac *= fac;
        attr[4] = mag_elem[ipl][0] - 2.5 * log10(fac);
      } else if (ipl == SweConst.SE_MOON) {
        /* ratio apparent diameter : average diameter */
        fac = attr[3] / (Math.asin(SwephData.pla_diam[SweConst.SE_MOON] / 2.0 /
                                            384400000.0) * 2 * SwissData.RADTODEG);
        /* distance sun - moon */
        for (i = 0; i < 3; i++)
          xxs[i] -= xx[i];
        dsm = Math.sqrt(sl.square_sum(xxs));
        /* account for phase and distance of moon: */
        fac *= fac * attr[1];
        /* account for distance of sun from moon: */
        fac *= dsm * dsm;
        attr[4] = mag_elem[ipl][0] - 2.5 * log10(fac);
      } else if (ipl == SweConst.SE_SATURN) {
        /* rings are considered according to Meeus, German, p. 329ff. */
        T = (tjd - dt - SwephData.J2000) / 36525.0;
        in = (28.075216 - 0.012998 * T + 0.000004 * T * T) * SwissData.DEGTORAD;
        om = (169.508470 + 1.394681 * T + 0.000412 * T * T) * SwissData.DEGTORAD;
        sinB = Math.abs(Math.sin(in) * Math.cos(lbr[1] * SwissData.DEGTORAD)
                      * Math.sin(lbr[0] * SwissData.DEGTORAD - om)
                      - Math.cos(in) * Math.sin(lbr[1] * SwissData.DEGTORAD));
        u1 = Math.atan2(Math.sin(in) * Math.tan(lbr2[1] * SwissData.DEGTORAD)
                               + Math.cos(in) * Math.sin(lbr2[0] *
                                                          SwissData.DEGTORAD - om),
                          Math.cos(lbr2[0] * SwissData.DEGTORAD - om)) *
                                                                 SwissData.RADTODEG;
        u2 = Math.atan2(Math.sin(in) * Math.tan(lbr[1] * SwissData.DEGTORAD)
                        + Math.cos(in) * Math.sin(lbr[0] * SwissData.DEGTORAD - om),
                          Math.cos(lbr[0] * SwissData.DEGTORAD - om)) *
                                                                 SwissData.RADTODEG;
        du = sl.swe_degnorm(u1 - u2);
        if (du > 10) {
          du = 360 - du;
        }
        attr[4] = 5 * log10(lbr2[2] * lbr[2])
                    + mag_elem[ipl][1] * sinB
                    + mag_elem[ipl][2] * sinB * sinB
                    + mag_elem[ipl][3] * du
                    + mag_elem[ipl][0];
      } else if (ipl < SweConst.SE_CHIRON) {
        attr[4] = 5 * log10(lbr2[2] * lbr[2])
                    + mag_elem[ipl][1] * attr[0] /100.0
                    + mag_elem[ipl][2] * attr[0] * attr[0] / 10000.0
                    + mag_elem[ipl][3] * attr[0] * attr[0] * attr[0] / 1000000.0
                    + mag_elem[ipl][0];
      } else if (ipl < NMAG_ELEM || ipl > SweConst.SE_AST_OFFSET) {/*asteroids*/
        ph1 = Math.pow(EULER, -3.33 *
                        Math.pow(Math.tan(attr[0] * SwissData.DEGTORAD / 2), 0.63));
        ph2 = Math.pow(EULER, -1.87 *
                        Math.pow(Math.tan(attr[0] * SwissData.DEGTORAD / 2), 1.22));
        if (ipl < NMAG_ELEM) {    /* main asteroids */
          me[0] = mag_elem[ipl][0];
          me[1] = mag_elem[ipl][1];
        } else if (ipl == SweConst.SE_AST_OFFSET + 1566) {
                    /* Icarus has elements from JPL database */
                  me[0] = 16.9;
                  me[1] = 0.15;
        } else {      /* other asteroids */
          me[0] = swed.ast_H;
          me[1] = swed.ast_G;
        }
        attr[4] = 5 * log10(lbr2[2] * lbr[2])
            + me[0]
            - 2.5 * log10((1 - me[1]) * ph1 + me[1] * ph2);
      } else { /* ficticious bodies */
        attr[4] = 0;
      }
    }
    if (ipl != SweConst.SE_SUN && ipl != SweConst.SE_EARTH) {
      /*
       * elongation of planet
       */
      if (sw.swe_calc(tjd, SweConst.SE_SUN, iflag | SweConst.SEFLG_XYZ,
                      xx2, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
      if (sw.swe_calc(tjd, SweConst.SE_SUN, iflag, lbr2, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
      attr[2] = Math.acos(sl.swi_dot_prod_unit(xx, xx2)) * SwissData.RADTODEG;
    }
    return SweConst.OK;
  }

  /**
  * Computes phase, phase angel, elongation, apparent diameter and apparent
  * magnitude for sun, moon, all planets and asteroids.
  * @param tjd_ut The Julian Day number in UT (Universal Time).
  * @param ipl The body number to be calculated. See class
  * <A HREF="SweConst.html">SweConst</A> for a list of bodies
  * <P>attr is an output parameter with the following meaning:
  * <P><CODE>
  * attr[0]:&nbsp;&nbsp;&nbsp;phase angle (earth-planet-sun).<BR>
  * attr[1]:&nbsp;&nbsp;&nbsp;phase (illumined fraction of disc).<BR>
  * attr[2]:&nbsp;&nbsp;&nbsp;elongation of planet.<BR>
  * attr[3]:&nbsp;&nbsp;&nbsp;apparent diameter of disc.<BR>
  * attr[4]:&nbsp;&nbsp;&nbsp;apparent magnitude.<BR>
  * </CODE><P><B>Attention: attr must be a double[20]!</B>
  * @param iflag Which ephemeris is to be used (SEFLG_JPLEPH, SEFLG_SWIEPH,
  * SEFLG_MOSEPH). Also allowable flags: SEFLG_TRUEPOS, SEFLG_HELCTR.
  * @param attr A double[20] in which the result is returned. See above for more
  * details.
  * @param serr A StringBuffer containing a warning or error message, if
  * something fails.
  * @return SweConst.OK (0) or SweConst.ERR (-1)
  * @see swisseph.SweConst#OK
  * @see swisseph.SweConst#ERR
  * @see swisseph.SweConst#SEFLG_JPLEPH
  * @see swisseph.SweConst#SEFLG_SWIEPH
  * @see swisseph.SweConst#SEFLG_MOSEPH
  * @see swisseph.SweConst#SEFLG_TRUEPOS
  * @see swisseph.SweConst#SEFLG_HELCTR
  */
  int swe_pheno_ut(double tjd_ut, int ipl, int iflag, double[] attr,
                   StringBuffer serr) {
    return swe_pheno(tjd_ut + SweDate.getDeltaT(tjd_ut), ipl, iflag, attr, serr);
  }

  private int find_maximum(double y00, double y11, double y2, double dx,
                           DblObj dxret, DblObj yret) {
    double a, b, c, x, y;
    c = y11;
    b = (y2 - y00) / 2.0;
    a = (y2 + y00) / 2.0 - c;
    x = -b / 2 / a;
    y = (4 * a * c - b * b) / 4 / a;
    dxret.val = (x - 1) * dx;
    if (yret != null) {
      yret.val = y;
    }
    return SweConst.OK;
  }

  private int find_zero(double y00, double y11, double y2, double dx,
                        DblObj dxret, DblObj dxret2) {
    double a, b, c, x1, x2;
    c = y11;
    b = (y2 - y00) / 2.0;
    a = (y2 + y00) / 2.0 - c;
    if (b * b - 4 * a * c < 0) {
      return SweConst.ERR;
    }
    x1 = (-b + Math.sqrt(b * b - 4 * a * c)) / 2 / a;
    x2 = (-b - Math.sqrt(b * b - 4 * a * c)) / 2 / a;
      dxret.val = (x1 - 1) * dx;
      dxret2.val = (x2 - 1) * dx;
    return SweConst.OK;
  }

  /* rise, set, and meridian transits of sun, moon, planets, and stars
   *
   * tjd_ut       universal time from when on search ought to start
   * ipl          planet number, neglected, if Starname is given
   * starname     pointer to string. if a planet, not a star, is
   *              wanted, starname must be null or ""
   * epheflag     used for ephemeris only
   * rsmi         SE_CALC_RISE, SE_CALC_SET, SE_CALC_MTRANSIT, SE_CALC_ITRANSIT
   *              | SE_BIT_DISC_CENTER      for rises of disc center of body
   *              | SE_BIT_NO_REFRACTION    to neglect refraction
   * geopos       array of doubles for geogr. long., lat. and height above sea
   * atpress      atmospheric pressure
   * attemp       atmospheric temperature
   *
   * return variables:
   * tret         time of rise, set, meridian transits
   * serr[256]        error string
   * function return value -2 means that the body does not rise or set */
  /**
  * Calculates the times of rising, setting and meridian transits for all
  * planets, asteroids, the moon, and the fixed stars.
  * @param tjd_ut The Julian Day number in UT, from when to start searching
  * @param ipl Planet number, if times for planet or moon are to be calculated.
  * @param starname The name of the star, if times for a star should be
  * calculated. It has to be null or the empty string otherwise!
  * @param ifl To indicate, which ephemeris should be used (SEFLG_JPLEPH,
  * SEFLG_SWIEPH or SEFLG_MOSEPH)
  * @param rsmi Specification, what type of calculation is wanted
  * (SE_CALC_RISE, SE_CALC_SET, SE_CALC_MTRANSIT, SE_CALC_ITRANSIT) plus
  * optionally SE_BIT_DISC_CENTER, when the rise time of the disc center
  * of the body is requested and or SE_BIT_NO_REFRACTION for calculation
  * without refraction effects). The calculation method defaults to
  * SE_CALC_RISE.
  * @param geopos An array double[3] containing the longitude, latitude and
  * height of the observer
  * @param atpress atmospheric pressure in mBar (hPa). If it is 0, the pressure
  * will be estimated from geopos[2] and attemp (1013.25 mbar for sea level).
  * When calculating MTRANSIT or ITRANSIT, this parameter is not used.
  * @param attemp atmospheric temperature in degrees Celsius. When
  * calculating MTRANSIT or ITRANSIT, this parameter is not used.
  * @param tret Return value containing the time of rise or whatever was
  * requested
  * @param serr A StringBuffer containing a warning or error message, if
  * something fails 
  * @return SweConst.OK (0) or SweConst.ERR (-1)
  * @see swisseph.SweConst#OK
  * @see swisseph.SweConst#ERR
  * @see swisseph.SweConst#SEFLG_JPLEPH
  * @see swisseph.SweConst#SEFLG_SWIEPH
  * @see swisseph.SweConst#SEFLG_MOSEPH
  * @see swisseph.SweConst#SE_CALC_RISE
  * @see swisseph.SweConst#SE_CALC_SET
  * @see swisseph.SweConst#SE_CALC_MTRANSIT
  * @see swisseph.SweConst#SE_CALC_ITRANSIT
  * @see swisseph.SweConst#SE_BIT_DISC_CENTER
  * @see swisseph.SweConst#SE_BIT_NO_REFRACTION
  * @see swisseph.DblObj
  */
  int swe_rise_trans(double tjd_ut, int ipl, StringBuffer starname,
                     int epheflag, int rsmi, double[] geopos,
                     double atpress, double attemp,
                     DblObj tret, StringBuffer serr) {
    int i, j, k, ii, calc_culm, nculm = -1;
    double tjd_et = tjd_ut + SweDate.getDeltaT(tjd_ut);
    double xc[]=new double[6], xh[][]=new double[20][6], ah[]=new double[6],
           aha;
    double tculm[]=new double[4], tcu, tc[]=new double[20], h[]=new double[20],
           t2[]=new double[6], dc[]=new double[6];
    DblObj dtint=new DblObj();
    DblObj dx=new DblObj();
    double rdi, dd = 0;
    int iflag = epheflag;
    int jmax = 14;
    double t, te, tt, dt, twohrs = 1.0 / 12.0;
    boolean do_fixstar = (starname != null && starname.length() > 0);
    // xh[0][0] = 0; /* to shut up mint */
    iflag &= SweConst.SEFLG_EPHMASK;
    tret.val = 0;
    iflag |= (SweConst.SEFLG_EQUATORIAL | SweConst.SEFLG_TOPOCTR);
    sw.swe_set_topo(geopos[0], geopos[1], geopos[2]);
    if ((rsmi & (SweConst.SE_CALC_MTRANSIT | SweConst.SE_CALC_ITRANSIT))!=0) {
      return calc_mer_trans(tjd_ut, ipl, epheflag, rsmi,
                  geopos, starname,
                  tret, serr);
    }
    if ((rsmi & ( SweConst.SE_CALC_RISE | SweConst.SE_CALC_SET))==0) {
      rsmi |= SweConst.SE_CALC_RISE;
    }
    /* find culmination points within 28 hours from t0 - twohrs.
     * culminations are required in case there are maxima or minima
     * in height slightly above or below the horizon.
     * we do not use meridian transits, because in polar regions
     * the culmination points may considerably deviate from
     * transits. also, there are cases where the moon rises in the
     * western half of the sky for a short time.
     */
    if (do_fixstar) {
      if (sw.swe_fixstar(starname, tjd_et, iflag, xc, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
    }
    for (ii = 0, t = tjd_ut - twohrs; ii <= jmax; ii++, t += twohrs) {
      tc[ii] = t;
      if (!do_fixstar) {
        te = t + SweDate.getDeltaT(t);
        if (sw.swe_calc(te, ipl, iflag, xc, serr) == SweConst.ERR) {
          return SweConst.ERR;
        }
      }
      /* diameter of object in km */
      if (ii == 0) {
        if (do_fixstar) {
          dd = 0;
        } else
               if ((rsmi & SweConst.SE_BIT_DISC_CENTER)!=0) {
          dd = 0;
        } else if (ipl < SwephData.NDIAM) {
          dd = SwephData.pla_diam[ipl];
        } else if (ipl > SweConst.SE_AST_OFFSET) {
          dd = swed.ast_diam * 1000;        /* km -> m */
        } else {
          dd = 0;
        }
      }
      /* apparent radius of disc */
      rdi = Math.asin(dd / 2 / SweConst.AUNIT / xc[2]) * SwissData.RADTODEG;
      /* true height of center of body */
      swe_azalt(t, SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, xh[ii]);
      /* true height of uppermost point of body */
      xh[ii][1] += rdi;
      /* apparent height of uppermost point of body */
      if ((rsmi & SweConst.SE_BIT_NO_REFRACTION)!=0) {
        h[ii] = xh[ii][1];
      } else {
        swe_azalt_rev(t, SweConst.SE_HOR2EQU, geopos, xh[ii], xc);
        swe_azalt(t, SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, xh[ii]);
        h[ii] = xh[ii][2];
      }
      calc_culm = 0;
      if (ii > 1) {
        dc[0] = xh[ii-2][1];
        dc[1] = xh[ii-1][1];
        dc[2] = xh[ii][1];
        if (dc[1] > dc[0] && dc[1] > dc[2]) {
          calc_culm = 1;
        }
        if (dc[1] < dc[0] && dc[1] < dc[2]) {
          calc_culm = 2;
        }
      }
      if (calc_culm!=0) {
        dt = twohrs;
        tcu = t - dt;
        find_maximum(dc[0], dc[1], dc[2], dt, dtint, dx);
        tcu += dtint.val + dt;
        dt /= 3;
        for (; dt > 0.0001; dt /= 3) {
          for (i = 0, tt = tcu - dt; i < 3; tt += dt, i++) {
            te = tt + SweDate.getDeltaT(tt);
            if (!do_fixstar) {
              if (sw.swe_calc(te, ipl, iflag, xc, serr) == SweConst.ERR) {
                return SweConst.ERR;
              }
            }
            swe_azalt(tt, SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, ah);
            dc[i] = ah[1];
          }
          find_maximum(dc[0], dc[1], dc[2], dt, dtint, dx);
          tcu += dtint.val + dt;
        }
        nculm++;
        tculm[nculm] = tcu;
      }
    }
    /* note: there can be a rise or set on the poles, even if
     * there is no culmination. So, we must not leave here
     * in any case. */
    /* insert culminations into array of heights */
    for (i = 0; i <= nculm; i++) {
      for (j = 1; j <= jmax; j++) {
        if (tculm[i] < tc[j]) {
          for (k = jmax; k >= j; k--) {
            tc[k+1] = tc[k];
            h[k+1] = h[k];
          }
          tc[j] = tculm[i];
          if (!do_fixstar) {
            te = tc[j] + SweDate.getDeltaT(tc[j]);
            if (sw.swe_calc(te, ipl, iflag, xc, serr) == SweConst.ERR) {
              return SweConst.ERR;
            }
          }
          /* apparent radius of disc */
          rdi = Math.asin(dd / 2 / SweConst.AUNIT / xc[2]) * SwissData.RADTODEG;
          /* true height of center of body */
          swe_azalt(tc[j], SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, ah);
          /* true height of uppermost point of body */
          ah[1] += rdi;
          /* apparent height of uppermost point of body */
          if ((rsmi & SweConst.SE_BIT_NO_REFRACTION)!=0) {
            h[j] = ah[1];
          } else {
            swe_azalt_rev(tc[j], SweConst.SE_HOR2EQU, geopos, ah, xc);
            swe_azalt(tc[j], SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, ah);
            h[j] = ah[2];
          }
          jmax++;
          break;
        }
      }
    }
    tret.val = 0;
    /* find points with zero height.
     * binary search */
    for (ii = 1; ii <= jmax; ii++) {
      if (h[ii-1] * h[ii] >= 0) {
        continue;
      }
      if (h[ii-1] < h[ii] && ((rsmi & SweConst.SE_CALC_RISE) == 0)) {
        continue;
      }
      if (h[ii-1] > h[ii] && ((rsmi & SweConst.SE_CALC_SET) == 0)) {
        continue;
      }
      dc[0] = h[ii-1];
      dc[1] = h[ii];
      t2[0] = tc[ii-1];
      t2[1] = tc[ii];
      for (i = 0; i < 20; i++) {
        t = (t2[0] + t2[1]) / 2;
        if (!do_fixstar) {
          te = t + SweDate.getDeltaT(t);
          if (sw.swe_calc(te, ipl, iflag, xc, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
        }
        /* apparent radius of disc */
        rdi = Math.asin(dd / 2 / SweConst.AUNIT / xc[2]) * SwissData.RADTODEG;
        /* true height of center of body */
        swe_azalt(t, SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, ah);
        /* true height of uppermost point of body */
        ah[1] += rdi;
        /* apparent height of uppermost point of body */
        if ((rsmi & SweConst.SE_BIT_NO_REFRACTION)!=0) {
          aha = ah[1];
        } else {
          swe_azalt_rev(t, SweConst.SE_HOR2EQU, geopos, ah, xc);
          swe_azalt(t, SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, ah);
          aha = ah[2];
        }
        if (aha * dc[0] <= 0) {
          dc[1] = aha;
          t2[1] = t;
        } else {
          dc[0] = aha;
          t2[0] = t;
        }
      }
      if (t > tjd_ut) {
       tret.val = t;
       return SweConst.OK;
      }
    }
    if (serr!=null)
      serr.append("rise or set not found for planet ").append(ipl);
    return -2; /* no t of rise or set found */
  }

  private int calc_mer_trans(double tjd_ut, int ipl, int epheflag, int rsmi,
                             double[] geopos, StringBuffer starname,
                             DblObj tret, StringBuffer serr) {
    int i;
    double tjd_et = tjd_ut + SweDate.getDeltaT(tjd_ut);
    double armc, armc0, arxc, x0[]=new double[6], x[]=new double[6], t, te;
    double mdd;
    int iflag = epheflag;
    boolean do_fixstar = (starname != null && starname.length() > 0);
    iflag &= SweConst.SEFLG_EPHMASK;
    tret.val = 0;
    iflag |= (SweConst.SEFLG_EQUATORIAL | SweConst.SEFLG_TOPOCTR);
    armc0 = sl.swe_sidtime(tjd_ut) + geopos[0] / 15;
    if (armc0 >= 24) {
      armc0 -= 24;
    }
    if (armc0 < 0) {
      armc0 += 24;
    }
    armc0 *= 15;
    if (do_fixstar) {
      if (sw.swe_fixstar(starname, tjd_et, iflag, x0, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
    } else {
      if (sw.swe_calc(tjd_et, ipl, iflag, x0, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
    }
    /*
     * meridian transits
     */
      x[0] = x0[0];
      x[1] = x0[1];
      t = tjd_ut;
      arxc = armc0;
      if ((rsmi & SweConst.SE_CALC_ITRANSIT)!=0) {
        arxc = sl.swe_degnorm(arxc + 180);
      }
      for (i = 0; i < 4; i++) {
        mdd = sl.swe_degnorm(x[0] - arxc);
        if (i > 0 && mdd > 180) {
          mdd -= 360;
        }
        t += mdd / 361;
        armc = sl.swe_sidtime(t) + geopos[0] / 15;
        if (armc >= 24) {
          armc -= 24;
        }
        if (armc < 0) {
          armc += 24;
        }
        armc *= 15;
        arxc = armc;
        if ((rsmi & SweConst.SE_CALC_ITRANSIT)!=0) {
          arxc = sl.swe_degnorm(arxc + 180);
        }
        if (!do_fixstar) {
  //        te = t + swe_deltat(t);
          te = t + SweDate.getDeltaT(t);
          if (sw.swe_calc(te, ipl, iflag, x, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
        }
      }
    tret.val = t;
    return SweConst.OK;
  }

  /*
  Nodes and apsides of planets and moon

  Planetary nodes can be defined in three different ways:
  a) They can be understood as a direction or as an axis
    defined by the intersection line of two orbital planes.
    E.g., the nodes of Mars are defined by the intersection
    line of Mars' orbital plane with the ecliptic (= the
    Earths orbit heliocentrically or the solar orbit
    geocentrically). However, as Michael Erlewine points
    out in his elaborate web page on this topic
    (http://thenewage.com/resources/articles/interface.html),
    planetary nodes can be defined for any couple of
    planets. E.g. there is also an intersection line for the
    two orbital planes of Mars and Saturn.
    Because such lines are, in principle, infinite, the
    heliocentric and the geocentric positions of the
    planetary nodes will be the same. There are astrologers
    that use such heliocentric planetary nodes in geocentric
    charts.
    The ascending and the descending node will, in this
    case, be in precise opposition.

  b) The planetary nodes can also be understood in a
    different way, not as an axis, but as the two points on a
    planetary orbit that are located precisely on the
    intersection line of the two planes.
    This second definition makes no difference for the moon or
    for heliocentric positions of planets, but it does so for
    geocentric positions. There are two possibilities for
    geocentric planetary nodes based on this definition.
    1) The common solution is that the points on the
      planets orbit are transformed to the geocenter. The
      two points will not be in opposition anymore, or
      they will only roughly be so with the outer planets. The
      advantage of these nodes is that when a planet is in
      conjunction with its node, then its ecliptic latitude
      will be zero. This is not true when a planet is in
      geocentric conjunction with its heliocentric node.
      (And neither is it always true for the inner planets,
      i.e. Mercury and Venus.)
    2) The second possibility that nobody seems to have
      thought of so far: One may compute the points of
      the earth's orbit that lie exactly on another planet's
      orbital plane and transform it to the geocenter. The two
      points will always be in an approximate square.

  c) Third, the planetary nodes could be defined as the
    intersection points of the plane defined by their
    momentary geocentric position and motion with the
    plane of the ecliptic. Such points would move very fast
    around the planetary stations. Here again, as in b)1),
    the planet would cross the ecliptic and its ecliptic
    latitude would be 0 exactly when it were in
    conjunction with one of its nodes.

  The Swiss Ephemeris supports the solutions a) and b) 1).

  Possible definitions for apsides

  a) The planetary apsides can be defined as the perihelion and
    aphelion points on a planetary orbit. For a
    geocentric chart, these points could be transformed
    from the heliocenter to the geocenter.
  b) However, one might consider these points as
    astrologically relevant axes rather than as points on a
    planetary orbit. Again, this would allow heliocentric
    positions in a geocentric chart.

  Note: For the "Dark Moon" or "Lilith", which I usually
  define as the lunar apogee, some astrologers give a
  different definition. They understand it as the second focal
  point of the moon's orbital ellipse. This definition does not
  make a difference for geocentric positions, because the
  apogee and the second focus are in exactly the same geocentric
  direction. However, it makes a difference with topocentric
  positions, because the two points do not have same distance.
  Analogous "black planets" have been proposed: they would be the
  second focal points of the planets' orbital ellipses. The
  heliocentric positions of these "black planets" are identical
  with the heliocentric positions of the aphelia, but geocentric
  positions are not identical, because the focal points are
  much closer to the sun than the aphelia.

  The Swiss Ephemeris allows to compute the "black planets" as well.

  Mean positions

  Mean nodes and apsides can be computed for the Moon, the
  Earth and the planets Mercury - Neptune. They are taken
  from the planetary theory VSOP87. Mean points can not be
  calculated for Pluto and the asteroids, because there is no
  planetary theory for them.

  Osculating nodes and apsides

  Nodes and apsides can also be derived from the osculating
  orbital elements of a body, the paramaters that define an
  ideal unperturbed elliptic (two-body) orbit.
  For astrology, note that this is a simplification and
  idealization.
  Problem with Neptune: Neptune's orbit around the sun does not
  have much in common with an ellipse. There are often two
  perihelia and two aphelia within one revolution. As a result,
  there is a wild oscillation of the osculating perihelion (and
  aphelion).
  In actuality, Neptune's orbit is not heliocentric orbit at all.
  The twofold perihelia and aphelia are an effect of the motion of
  the sun about the solar system barycenter. This motion is
  much faster than the motion of Neptune, and Neptune
  cannot react on such fast displacements of the Sun. As a
  result, Neptune seems to move around the barycenter (or a
  mean sun) rather than around the true sun. In fact,
  Neptune's orbit around the barycenter is therefore closer to
  an ellipse than the his orbit around the sun. The same
  statement is also true for Saturn, Uranus and Pluto, but not
  for Jupiter and the inner planets.

  This fundamental problem about osculating ellipses of
  planetary orbits does of course not only affect the apsides
  but also the nodes.

  Two solutions can be thought of for this problem:
  1) The one would be to interpolate between actual
    passages of the planets through their nodes and
    apsides. However, this works only well with Mercury.
    With all other planets, the supporting points are too far
    apart as to make an accurate interpolation possible.
    This solution is not implemented, here.
  2) The other solution is to compute the apsides of the
    orbit around the barycenter rather than around the sun.
    This procedure makes sense for planets beyond Jupiter,
    it comes closer to the mean apsides and nodes for
    planets that have such points defined. For all other
    transsaturnian planets and asteroids, this solution yields
    a kind of "mean" nodes and apsides. On the other hand,
    the barycentric ellipse does not make any sense for
    inner planets and Jupiter.

  The Swiss Ephemeris supports solution 2) for planets and
  asteroids beyond Jupiter.

  Anyway, neither the heliocentric nor the barycentric ellipse
  is a perfect representation of the nature of a planetary orbit,
  and it will not yield the degree of precision that today's
  astrology is used to.
  The best choice of method will probably be:
  - For Mercury - Neptune: mean nodes and apsides
  - For asteroids that belong to the inner asteroid belt:
  osculating nodes/apsides from a heliocentric ellipse
  - For Pluto and outer asteroids: osculating nodes/apsides
  from a barycentric ellipse

  The Moon is a special case: A "lunar true node" makes
  more sense, because it can be defined without the idea of an
  ellipse, e.g. as the intersection axis of the momentary lunar
  orbital plane with the ecliptic. Or it can be said that the
  momentary motion of the moon points to one of the two
  ecliptic points that are called the "true nodes".  So, these
  points make sense. With planetary nodes, the situation is
  somewhat different, at least if we make a difference
  between heliocentric and geocentric positions. If so, the
  planetary nodes are points on a heliocentric orbital ellipse,
  which are transformed to the geocenter. An ellipse is
  required here, because a solar distance is required. In
  contrast to the planetary nodes, the lunar node does not
  require a distance, therefore manages without the idea of an
  ellipse and does not share its weaknesses.
  On the other hand, the lunar apsides DO require the idea of
  an ellipse. And because the lunar ellipse is actually
  extremely distorted, even more than any other celestial
  ellipse, the "true Lilith" (apogee), for which printed
  ephemerides are available, does not make any sense at all.
  (See the chapter on the lunar node and apogee.)

  Special case: the Earth

  The Earth is another special case. Instead of the motion of
  the Earth herself, the heliocentric motion of the Earth-
  Moon-Barycenter (EMB) is used to determine the
  osculating perihelion.
  There is no node of the earth orbit itself. However, there is
  an axis around which the earth's orbital plane slowly rotates
  due to planetary precession. The position points of this axis
  are not calculated by the Swiss Ephemeris.

  Special case: the Sun

  In addition to the Earth (EMB) apsides, the function
  computes so-to-say "apsides" of the sun, i.e. points on the
  orbit of the Sun where it is closest to and where it is farthest
  from the Earth. These points form an opposition and are
  used by some astrologers, e.g. by the Dutch astrologer
  George Bode or the Swiss astrologer Liduina Schmed. The
  perigee, located at about 13 Capricorn, is called the
  "Black Sun", the other one, in Cancer, the "Diamond".
  So, for a complete set of apsides, one ought to calculate
  them for the Sun and the Earth and all other planets.

  The modes of the Swiss Ephemeris function
  swe_nod_aps()

  The  function swe_nod_aps() can be run in the following
  modes:
  1) Mean positions are given for nodes and apsides of Sun,
    Moon, Earth, and the up to Neptune. Osculating
    positions are given with Pluto and all asteroids. This is
    the default mode.
  2) Osculating positions are returned for nodes and apsides
    of all planets.
  3) Same as 2), but for planets and asteroids beyond
    Jupiter, a barycentric ellipse is used.
  4) Same as 1), but for Pluto and asteroids beyond Jupiter,
    a barycentric ellipse is used.

  In all of these modes, the second focal point of the ellipse
  can be computed instead of the aphelion.
  Like the planetary function swe_calc(), swe_nod_aps() is
  able to return geocentric, topocentric, heliocentric, or
  barycentric position.
   *
   * tjd_ut         julian day, ephemeris time
   * ipl                 planet number
   * iflag         as usual, SEFLG_HELCTR, etc.
   * xnasc         an array of 6 doubles: ascending node
   * xndsc         an array of 6 doubles: ascending node
   * xperi         an array of 6 doubles: perihelion
   * xaphe         an array of 6 doubles: aphelion
   * method        see below
   * serr          error message
   *
   * method        can have the following values:
   *               - 0 or SE_NODBIT_MEAN. MEAN positions are given for
   *                 nodes and apsides of Sun, Moon, Earth, and the
   *                 planets up to Neptune. Osculating positions are
   *                 given with Pluto and all asteroids.
   *               - SE_NODBIT_OSCU. Osculating positions are given
   *                 for all nodes and apsides.
   *               - SE_NODBIT_OSCU_BAR. Osculating nodes and apsides
   *                 are computed from barycentric ellipses, for planets
   *                 beyond Jupiter, but from heliocentric ones for
   *                 ones for Jupiter and inner planets.
   *               - SE_NODBIT_MEAN and SE_NODBIT_OSCU_BAR can be combined.
   *                 The program behaves the same way as with simple
   *                 SE_NODBIT_MEAN, but uses barycentric ellipses for
   *                 planets beyond Neptune and asteroids beyond Jupiter.
   *               - SE_NODBIT_FOCAL can be combined with any of the other
   *                 bits. The second focal points of the ellipses will
   *                 be returned instead of the aphelia.
   */
  /* mean elements for Mercury - Neptune from VSOP87 (mean equinox of date) */
  private static final double el_node[][] = new double[][]
    {{ 48.330893,  1.1861890,  0.00017587,  0.000000211,}, /* Mercury */
    { 76.679920,  0.9011190,  0.00040665, -0.000000080,}, /* Venus   */
    {  0       ,  0        ,  0         ,  0          ,}, /* Earth   */
    { 49.558093,  0.7720923,  0.00001605,  0.000002325,}, /* Mars    */
    {100.464441,  1.0209550,  0.00040117,  0.000000569,}, /* Jupiter */
    {113.665524,  0.8770970, -0.00012067, -0.000002380,}, /* Saturn  */
    { 74.005947,  0.5211258,  0.00133982,  0.000018516,}, /* Uranus  */
    {131.784057,  1.1022057,  0.00026006, -0.000000636,}, /* Neptune */
    };
  private static final double el_peri[][] = new double[][]
    {{ 77.456119,  1.5564775,  0.00029589,  0.000000056,}, /* Mercury */
    {131.563707,  1.4022188, -0.00107337, -0.000005315,}, /* Venus   */
    {102.937348,  1.7195269,  0.00045962,  0.000000499,}, /* Earth   */
    {336.060234,  1.8410331,  0.00013515,  0.000000318,}, /* Mars    */
    { 14.331309,  1.6126668,  0.00103127, -0.000004569,}, /* Jupiter */
    { 93.056787,  1.9637694,  0.00083757,  0.000004899,}, /* Saturn  */
    {173.005159,  1.4863784,  0.00021450,  0.000000433,}, /* Uranus  */
    { 48.123691,  1.4262677,  0.00037918, -0.000000003,}, /* Neptune */
    };
  private static final double el_incl[][] = new double[][]
    {{  7.004986,  0.0018215, -0.00001809,  0.000000053,}, /* Mercury */
    {  3.394662,  0.0010037, -0.00000088, -0.000000007,}, /* Venus   */
    {  0,         0,          0,           0          ,}, /* Earth   */
    {  1.849726, -0.0006010,  0.00001276, -0.000000006,}, /* Mars    */
    {  1.303270, -0.0054966,  0.00000465, -0.000000004,}, /* Jupiter */
    {  2.488878, -0.0037363, -0.00001516,  0.000000089,}, /* Saturn  */
    {  0.773196,  0.0007744,  0.00003749, -0.000000092,}, /* Uranus  */
    {  1.769952, -0.0093082, -0.00000708,  0.000000028,}, /* Neptune */
    };
  private static final double el_ecce[][] = new double[][]
    {{  0.20563175,  0.000020406, -0.0000000284, -0.00000000017,}, /* Mercury */
    {  0.00677188, -0.000047766,  0.0000000975,  0.00000000044,}, /* Venus   */
    {  0.01670862, -0.000042037, -0.0000001236,  0.00000000004,}, /* Earth   */
    {  0.09340062,  0.000090483, -0.0000000806, -0.00000000035,}, /* Mars    */
    {  0.04849485,  0.000163244, -0.0000004719, -0.00000000197,}, /* Jupiter */
    {  0.05550862, -0.000346818, -0.0000006456,  0.00000000338,}, /* Saturn  */
    {  0.04629590, -0.000027337,  0.0000000790,  0.00000000025,}, /* Uranus  */
    {  0.00898809,  0.000006408, -0.0000000008, -0.00000000005,}, /* Neptune */
    };
  private static final double el_sema[][] = new double[][]
    {{  0.387098310,  0.0,  0.0,  0.0,}, /* Mercury */
    {  0.723329820,  0.0,  0.0,  0.0,}, /* Venus   */
    {  1.000001018,  0.0,  0.0,  0.0,}, /* Earth   */
    {  1.523679342,  0.0,  0.0,  0.0,}, /* Mars    */
    {  5.202603191,  0.0000001913,  0.0,  0.0,}, /* Jupiter */
    {  9.554909596,  0.0000021389,  0.0,  0.0,}, /* Saturn  */
    { 19.218446062, -0.0000000372,  0.00000000098,  0.0,}, /* Uranus  */
    { 30.110386869, -0.0000001663,  0.00000000069,  0.0,}, /* Neptune */
    };
  /* Ratios of mass of Sun to masses of the planets */
  private static final double plmass[] = new double[] {
      6023600,        /* Mercury */
       408523.5,      /* Venus */
       328900.5,      /* Earth and Moon */
      3098710,        /* Mars */
         1047.350,    /* Jupiter */
         3498.0,      /* Saturn */
        22960,        /* Uranus */
        19314,        /* Neptune */
    130000000,        /* Pluto */
  };
  private static final int ipl_to_elem[] = new int[]
                                {2, 0, 0, 1, 3, 4, 5, 6, 7, 0, 0, 0, 0, 0, 2,};

  /**
  * Computes planetary nodes and apsides (perihelia, aphelia, second focal
  * points of the orbital ellipses). This method is identical to
  * swe_nod_aps_ut() with the one exception that the time has to be given
  * in ET (Ephemeris Time or Dynamical Time). You would get ET by adding
  * deltaT to the UT, e.g.,
  * <CODE>tjd_et&nbsp;+&nbsp;SweDate.getDeltaT(tjd_et)</CODE>.<P>
  * See <A HREF="Swecl.html#swe_nod_aps_ut(double, int, int, int, double[], double[], double[], double[], java.lang.StringBuffer)">swe_nod_aps_ut(...)</A> for missing information.
  */
  int swe_nod_aps(double tjd_et, int ipl, int iflag,
                  int  method,
                  double[] xnasc, double[] xndsc,
                  double[] xperi, double[] xaphe,
                  StringBuffer serr) {
    int ij, i, j;
    int iplx;
    int ipli;
    int istart, iend;
    int iflJ2000;
    double plm;
    double t = (tjd_et - SwephData.J2000) / 36525, dt;
    double x[]=new double[6], xx[]=new double[24], xp[],
           xobs[]=new double[6], x2000[]=new double[6];
    int xpOffs=0;
    double xpos[][]=new double[3][6], xnorm[]=new double[6];
    double xposm[]=new double[6];
    double xn[][]=new double[3][6], xs[][]=new double[3][6];
    double xq[][]=new double[3][6], xa[][]=new double[3][6];
    double xobs2[]=new double[6], x2[]=new double[6];
    double[] xna, xnd, xpe, xap;
    final int xndOffs = 6, xpeOffs = 12, xapOffs = 18;
    double incl, sema, ecce, parg, ea, vincl, vsema, vecce, pargx, eax;
    PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
    PlanData psbdp = swed.pldat[SwephData.SEI_SUNBARY];
    PlanData pldat=new PlanData();
    double[] xsun = psbdp.x;
    double[] xear = pedp.x;
    double[] ep;
    double Gmsm, dzmin;
    double rxy, rxyz, fac, sgn;
    double sinnode, cosnode, sinincl, cosincl, sinu, cosu, sinE, cosE, cosE2;
    double uu, ny, ny2, c2, v2, pp, ro, ro2, rn, rn2;
    Epsilon oe;
    boolean is_true_nodaps = false;
    boolean do_aberr = (iflag &
                        (SweConst.SEFLG_TRUEPOS | SweConst.SEFLG_NOABERR))==0;
    boolean do_defl = (iflag & SweConst.SEFLG_TRUEPOS)==0 &&
                      (iflag & SweConst.SEFLG_NOGDEFL)==0;
    boolean do_focal_point = (method & SweConst.SE_NODBIT_FOPOINT) != 0;
    boolean ellipse_is_bary = false;
    int iflg0;
    xna = xx; 
    xnd = xx; // xndOffs = 6; 
    xpe = xx; // xpeOffs = 12; 
    xap = xx; // xapOffs = 18;
    // xpos[0][0] = 0; /* to shut up mint */
    /* to get control over the save area: */
    sw.swi_force_app_pos_etc();
    method %= SweConst.SE_NODBIT_FOPOINT;
    ipli = ipl;
    if (ipl == SweConst.SE_SUN) {
      ipli = SweConst.SE_EARTH;
    }
    if (ipl == SweConst.SE_MOON) {
      do_defl = false;
      if ((iflag & SweConst.SEFLG_HELCTR)==0) {
        do_aberr = false;
      }
    }
    iflg0 = (iflag & (SweConst.SEFLG_EPHMASK|SweConst.SEFLG_NONUT)) |
            SweConst.SEFLG_SPEED | SweConst.SEFLG_TRUEPOS;
    if (ipli != SweConst.SE_MOON) {
      iflg0 |= SweConst.SEFLG_HELCTR;
    }
    if (ipl == SweConst.SE_MEAN_NODE || ipl == SweConst.SE_TRUE_NODE ||
            ipl == SweConst.SE_MEAN_APOG || ipl == SweConst.SE_OSCU_APOG ||
            ipl < 0 ||
            (ipl >= SweConst.SE_NPLANETS && ipl <= SweConst.SE_AST_OFFSET)) {
           /*(ipl >= SE_FICT_OFFSET && ipl - SE_FICT_OFFSET < SE_NFICT_ELEM)) */
      if (serr != null) {
        serr.setLength(0);
        serr.append("nodes/apsides for planet "+ipl+
                    " are not implemented");
      }
      if (xnasc != null) {
        for (i = 0; i <= 5; i++)
          xnasc[i] = 0;
      }
      if (xndsc != null) {
        for (i = 0; i <= 5; i++)
          xndsc[i] = 0;
      }
      if (xaphe != null) {
        for (i = 0; i <= 5; i++)
          xaphe[i] = 0;
      }
      if (xperi != null) {
        for (i = 0; i <= 5; i++)
          xperi[i] = 0;
      }
      return SweConst.ERR;
    }
    for (i = 0; i < 24; i++)
      xx[i] = 0;
    /***************************************
     * mean nodes and apsides
     ***************************************/
    /* mean points only for Sun - Neptune */
    if ((method == 0 || (method & SweConst.SE_NODBIT_MEAN)!=0) &&
          ((ipl >= SweConst.SE_SUN && ipl <= SweConst.SE_NEPTUNE) ||
                                                    ipl == SweConst.SE_EARTH)) {
      if (ipl == SweConst.SE_MOON) {
//      sm.swi_mean_lunar_elements(tjd_et, &xna[0], &xna[3], &xpe[0], &xpe[3]);
        DblObj xna0=new DblObj(); xna0.val=xna[0];
        DblObj xna3=new DblObj(); xna3.val=xna[3];
        DblObj xpe0=new DblObj(); xpe0.val=xpe[0+xpeOffs];
        DblObj xpe3=new DblObj(); xpe3.val=xpe[3+xpeOffs];
        sm.swi_mean_lunar_elements(tjd_et, xna0, xna3, xpe0, xpe3);
        xna[0]=xna0.val;
        xna[3]=xna3.val;
        xpe[0+xpeOffs]=xpe0.val;
        xpe[3+xpeOffs]=xpe3.val;
        incl = SwephData.MOON_MEAN_INCL;
        vincl = 0;
        ecce = SwephData.MOON_MEAN_ECC;
        vecce = 0;
        sema = SwephData.MOON_MEAN_DIST / SweConst.AUNIT;
        vsema = 0;
      } else {
        iplx = ipl_to_elem[ipl];
        ep = el_incl[iplx];
        incl = ep[0] + ep[1] * t + ep[2] * t * t + ep[3] * t * t * t;
        vincl = ep[1] / 36525;
        ep = el_sema[iplx];
        sema = ep[0] + ep[1] * t + ep[2] * t * t + ep[3] * t * t * t;
        vsema = ep[1] / 36525;
        ep = el_ecce[iplx];
        ecce = ep[0] + ep[1] * t + ep[2] * t * t + ep[3] * t * t * t;
        vecce = ep[1] / 36525;
        ep = el_node[iplx];
        /* ascending node */
        xna[0] = ep[0] + ep[1] * t + ep[2] * t * t + ep[3] * t * t * t;
        xna[3] = ep[1] / 36525;
        /* perihelion */
        ep = el_peri[iplx];
        xpe[0+xpeOffs] = ep[0] + ep[1] * t + ep[2] * t * t + ep[3] * t * t * t;
        xpe[3+xpeOffs] = ep[1] / 36525;
      }
      /* descending node */
      xnd[0+xndOffs] = sl.swe_degnorm(xna[0] + 180);
      xnd[3+xndOffs] = xna[3];
      /* angular distance of perihelion from node */
      parg = xpe[0+xpeOffs] = sl.swe_degnorm(xpe[0+xpeOffs] - xna[0]);
      pargx = xpe[3+xpeOffs] = sl.swe_degnorm(xpe[0+xpeOffs] + xpe[3+xpeOffs]  - xna[3]);
      /* transform from orbital plane to mean ecliptic of date */
      sl.swe_cotrans(xpe, xpeOffs, xpe, xpeOffs, -incl);
      /* xpe+3 is aux. position, not speed!!! */
      sl.swe_cotrans(xpe, 3+xpeOffs, xpe, 3+xpeOffs, -incl-vincl);
      /* add node again */
      xpe[0+xpeOffs] = sl.swe_degnorm(xpe[0+xpeOffs] + xna[0]);
      /* xpe+3 is aux. position, not speed!!! */
      xpe[3+xpeOffs] = sl.swe_degnorm(xpe[3+xpeOffs] + xna[0] + xna[3]);
      /* speed */
      xpe[3+xpeOffs] = sl.swe_degnorm(xpe[3+xpeOffs] - xpe[0+xpeOffs]);
      /* heliocentric distance of perihelion and aphelion */
      xpe[2+xpeOffs] = sema * (1 - ecce);
      xpe[5+xpeOffs] = (sema + vsema) * (1 - ecce - vecce) - xpe[2+xpeOffs];
      /* aphelion */
      xap[0+xapOffs] = sl.swe_degnorm(xpe[xpeOffs] + 180);
      xap[1+xapOffs] = -xpe[1+xpeOffs];
      xap[3+xapOffs] = xpe[3+xpeOffs];
      xap[4+xapOffs] = -xpe[4+xpeOffs];
      if (do_focal_point) {
        xap[2+xapOffs] = sema * ecce * 2;
        xap[5+xapOffs] = (sema + vsema) * (ecce + vecce) * 2 - xap[2+xapOffs];
      } else {
        xap[2+xapOffs] = sema * (1 + ecce);
        xap[5+xapOffs] = (sema + vsema) * (1 + ecce + vecce) - xap[2+xapOffs];
      }
      /* heliocentric distance of nodes */
      ea = Math.atan(Math.tan(-parg * SwissData.DEGTORAD / 2) *
                                              Math.sqrt((1-ecce)/(1+ecce))) * 2;
      eax = Math.atan(Math.tan(-pargx * SwissData.DEGTORAD / 2) *
                                  Math.sqrt((1-ecce-vecce)/(1+ecce+vecce))) * 2;
      xna[2] = sema * (Math.cos(ea) - ecce) / Math.cos(parg * SwissData.DEGTORAD);
      xna[5] = (sema+vsema) * (Math.cos(eax) - ecce - vecce) /
                                                Math.cos(pargx * SwissData.DEGTORAD);
      xna[5] -= xna[2];
      ea = Math.atan(Math.tan((180 - parg) * SwissData.DEGTORAD / 2) *
                                              Math.sqrt((1-ecce)/(1+ecce))) * 2;
      eax = Math.atan(Math.tan((180 - pargx) * SwissData.DEGTORAD / 2) *
                                  Math.sqrt((1-ecce-vecce)/(1+ecce+vecce))) * 2;
      xnd[2+xndOffs] = sema * (Math.cos(ea) - ecce) / Math.cos((180 - parg) * SwissData.DEGTORAD);
      xnd[5+xndOffs] = (sema+vsema) * (Math.cos(eax) - ecce - vecce) /
                                             Math.cos((180 - pargx) * SwissData.DEGTORAD);
      xnd[5+xndOffs] -= xnd[2+xndOffs];
      /* no light-time correction because speed is extremely small */
      for (i = 0, xp = xx, xpOffs = 0; i < 4; i++, xpOffs += 6) {
        /* to cartesian coordinates */
        xp[0+xpOffs] *= SwissData.DEGTORAD;
        xp[1+xpOffs] *= SwissData.DEGTORAD;
        xp[3+xpOffs] *= SwissData.DEGTORAD;
        xp[4+xpOffs] *= SwissData.DEGTORAD;
        sl.swi_polcart_sp(xp, xpOffs, xp, xpOffs);
      }
    /***************************************
     * "true" or osculating nodes and apsides
     ***************************************/
    } else {
      /* first, we need a heliocentric distance of the planet */
      if (sw.swe_calc(tjd_et, ipli, iflg0, x, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
      iflJ2000 = (iflag & SweConst.SEFLG_EPHMASK)|
                 SweConst.SEFLG_J2000|
                 SweConst.SEFLG_EQUATORIAL|
                 SweConst.SEFLG_XYZ|
                 SweConst.SEFLG_TRUEPOS|
                 SweConst.SEFLG_NONUT|
                 SweConst.SEFLG_SPEED;
      ellipse_is_bary = false;
      if (ipli != SweConst.SE_MOON) {
        if ((method & SweConst.SE_NODBIT_OSCU_BAR)!=0 && x[2] > 6) {
          iflJ2000 |= SweConst.SEFLG_BARYCTR; /* only planets beyond Jupiter */
          ellipse_is_bary = true;
        } else {
          iflJ2000 |= SweConst.SEFLG_HELCTR;
        }
      }
      /* we need three positions and three speeds
       * for three nodes/apsides. from the three node positions,
       * the speed of the node will be computed. */
      if (ipli == SweConst.SE_MOON) {
        dt = SwephData.NODE_CALC_INTV;
        dzmin = 1e-15;
        Gmsm = SwephData.GEOGCONST * (1 + 1 / SwephData.EARTH_MOON_MRAT) /
                            SweConst.AUNIT/SweConst.AUNIT/SweConst.AUNIT*86400.0*86400.0;
      } else {
        if ((ipli >= SweConst.SE_MERCURY && ipli <= SweConst.SE_PLUTO) ||
                                                   ipli == SweConst.SE_EARTH) {
          plm = 1 / plmass[ipl_to_elem[ipl]];
        } else {
          plm = 0;
        }
        dt = SwephData.NODE_CALC_INTV * 10 * x[2];
        dzmin = 1e-15 * dt / SwephData.NODE_CALC_INTV;
        Gmsm = SwephData.HELGRAVCONST * (1 + plm) /
                            SweConst.AUNIT/SweConst.AUNIT/SweConst.AUNIT*86400.0*86400.0;
      }
      if ((iflag & SweConst.SEFLG_SPEED)!=0) {
        istart = 0;
        iend = 2;
      } else {
        istart = iend = 0;
        dt = 0;
      }
      for (i = istart, t = tjd_et - dt; i <= iend; i++, t += dt) {
        if (istart == iend) {
          t = tjd_et;
        }
        if (sw.swe_calc(t, ipli, iflJ2000, xpos[i], serr) == SweConst.ERR) {
          return SweConst.ERR;
        }
        /* the EMB is used instead of the earth */
        if (ipli == SweConst.SE_EARTH) {
          if (sw.swe_calc(t,
                       SweConst.SE_MOON,
                       iflJ2000 & ~(SweConst.SEFLG_BARYCTR|SweConst.SEFLG_HELCTR),
                       xposm, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          for (j = 0; j <= 2; j++)
            xpos[i][j] += xposm[j] / (SwephData.EARTH_MOON_MRAT + 1.0);
        }
        sw.swi_plan_for_osc_elem(iflg0, t, xpos[i]);
      }
      for (i = istart; i <= iend; i++) {
        if (Math.abs(xpos[i][5]) < dzmin) {
          xpos[i][5] = dzmin;
        }
        fac = xpos[i][2] / xpos[i][5];
        sgn = xpos[i][5] / Math.abs(xpos[i][5]);
        for (j = 0; j <= 2; j++) {
          xn[i][j] = (xpos[i][j] - fac * xpos[i][j+3]) * sgn;
          xs[i][j] = -xn[i][j];
        }
      }
      for (i = istart; i <= iend; i++) {
        /* node */
        rxy =  Math.sqrt(xn[i][0] * xn[i][0] + xn[i][1] * xn[i][1]);
        cosnode = xn[i][0] / rxy;
        sinnode = xn[i][1] / rxy;
        /* inclination */
        sl.swi_cross_prod(xpos[i], 0, xpos[i], 3, xnorm, 0);
        rxy =  xnorm[0] * xnorm[0] + xnorm[1] * xnorm[1];
        c2 = (rxy + xnorm[2] * xnorm[2]);
        rxyz = Math.sqrt(c2);
        rxy = Math.sqrt(rxy);
        sinincl = rxy / rxyz;
        cosincl = Math.sqrt(1 - sinincl * sinincl);
        /* argument of latitude */
        cosu = xpos[i][0] * cosnode + xpos[i][1] * sinnode;
        sinu = xpos[i][2] / sinincl;
        uu = Math.atan2(sinu, cosu);
        /* semi-axis */
        rxyz = Math.sqrt(sl.square_sum(xpos[i]));
        v2 = sl.square_sum(xpos[i], 3);
        sema = 1 / (2 / rxyz - v2 / Gmsm);
        /* eccentricity */
        pp = c2 / Gmsm;
        ecce = Math.sqrt(1 - pp / sema);
        /* eccentric anomaly */
        cosE = 1 / ecce * (1 - rxyz / sema);
        sinE = 1 / ecce / Math.sqrt(sema * Gmsm) *
                                        sw.dot_prod(xpos[i], xpos[i], 3);
        /* true anomaly */
        ny = 2 * Math.atan(Math.sqrt((1+ecce)/(1-ecce)) * sinE / (1 + cosE));
        /* distance of perihelion from ascending node */
        xq[i][0] = sl.swi_mod2PI(uu - ny);
        xq[i][1] = 0;                        /* latitude */
        xq[i][2] = sema * (1 - ecce);        /* distance of perihelion */
        /* transformation to ecliptic coordinates */
        sl.swi_polcart(xq[i], xq[i]);
        sl.swi_coortrf2(xq[i], xq[i], -sinincl, cosincl);
        sl.swi_cartpol(xq[i], xq[i]);
        /* adding node, we get perihelion in ecl. coord. */
        xq[i][0] += Math.atan2(sinnode, cosnode);
        xa[i][0] = sl.swi_mod2PI(xq[i][0] + SwephData.PI);
        xa[i][1] = -xq[i][1];
        if (do_focal_point) {
          xa[i][2] = sema * ecce * 2;        /* distance of aphelion */
        } else {
          xa[i][2] = sema * (1 + ecce);        /* distance of aphelion */
        }
        sl.swi_polcart(xq[i], xq[i]);
        sl.swi_polcart(xa[i], xa[i]);
        /* new distance of node from orbital ellipse:
         * true anomaly of node: */
        ny = sl.swi_mod2PI(ny - uu);
        ny2 = sl.swi_mod2PI(ny + SwephData.PI);
        /* eccentric anomaly */
        cosE = Math.cos(2 * Math.atan(Math.tan(ny / 2) /
                                             Math.sqrt((1+ecce) / (1-ecce))));
        cosE2 = Math.cos(2 * Math.atan(Math.tan(ny2 / 2) /
                                             Math.sqrt((1+ecce) / (1-ecce))));
        /* new distance */
        rn = sema * (1 - ecce * cosE);
        rn2 = sema * (1 - ecce * cosE2);
        /* old node distance */
        ro = Math.sqrt(sl.square_sum(xn[i]));
        ro2 = Math.sqrt(sl.square_sum(xs[i]));
        /* correct length of position vector */
        for (j = 0; j <= 2; j++) {
          xn[i][j] *= rn / ro;
          xs[i][j] *= rn2 / ro2;
        }
      }
      for (i = 0; i <= 2; i++) {
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
          xpe[i+xpeOffs] = xq[1][i];
          xpe[i+3+xpeOffs] = (xq[2][i] - xq[0][i]) / dt / 2;
          xap[i+xapOffs] = xa[1][i];
          xap[i+3+xapOffs] = (xa[2][i] - xa[0][i]) / dt / 2;
          xna[i] = xn[1][i];
          xna[i+3] = (xn[2][i] - xn[0][i]) / dt / 2;
          xnd[i+xndOffs] = xs[1][i];
          xnd[i+3+xndOffs] = (xs[2][i] - xs[0][i]) / dt / 2;
        } else {
          xpe[i+xpeOffs] = xq[0][i];
          xpe[i+3+xpeOffs] = 0;
          xap[i+xapOffs] = xa[0][i];
          xap[i+3+xapOffs] = 0;
          xna[i] = xn[0][i];
          xna[i+3] = 0;
          xnd[i+xndOffs] = xs[0][i];
          xnd[i+3+xndOffs] = 0;
        }
      }
      is_true_nodaps = true;
    }
    /* to set the variables required in the save area,
     * i.e. ecliptic, nutation, barycentric sun, earth
     * we compute the planet */
    if (ipli == SweConst.SE_MOON &&
        (iflag & (SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR))!=0) {
      sw.swi_force_app_pos_etc();
      if (sw.swe_calc(tjd_et, SweConst.SE_SUN, iflg0, x, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
    } else {
      if (sw.swe_calc(tjd_et, ipli,
                   iflg0 | (iflag & SweConst.SEFLG_TOPOCTR), x, serr) ==
                                                                SweConst.ERR) {
        return SweConst.ERR;
      }
    }
    /***********************
     * position of observer
     ***********************/
    if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
      /* geocentric position of observer */
      if (sw.swi_get_observer(tjd_et, iflag, false, xobs, serr) != SweConst.OK) {
        return SweConst.ERR;
      }
      /*for (i = 0; i <= 5; i++)
        xobs[i] = swed.topd.xobs[i];*/
    } else {
      for (i = 0; i <= 5; i++)
        xobs[i] = 0;
    }
    if ((iflag & (SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR))!=0) {
      if ((iflag & SweConst.SEFLG_HELCTR)!=0 &&
          (iflag & SweConst.SEFLG_MOSEPH)==0) {
        for (i = 0; i <= 5; i++)
          xobs[i] = xsun[i];
      }
    } else if (ipl == SweConst.SE_SUN && (iflag & SweConst.SEFLG_MOSEPH)==0) {
      for (i = 0; i <= 5; i++)
        xobs[i] = xsun[i];
    } else {
      /* barycentric position of observer */
      for (i = 0; i <= 5; i++)
        xobs[i] += xear[i];
    }
    /* ecliptic obliqity */
    if ((iflag & SweConst.SEFLG_J2000)!=0) {
      oe = swed.oec2000;
    } else {
      oe = swed.oec;
    }
    /*************************************************
     * conversions shared by mean and osculating points
     *************************************************/
    for (ij = 0, xp = xx, xpOffs = 0; ij < 4; ij++, xpOffs += 6) {
      /* no nodes for earth */
      if (ipli == SweConst.SE_EARTH && ij <= 1) {
        for (i = 0; i <= 5; i++)
              xp[i+xpOffs] = 0;
        continue;
      }
      /*********************
       * to equator
       *********************/
      if (is_true_nodaps && (iflag & SweConst.SEFLG_NONUT)==0) {
        sl.swi_coortrf2(xp, xpOffs, xp, xpOffs, -swed.nut.snut, swed.nut.cnut);
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
          sl.swi_coortrf2(xp, 3+xpOffs, xp, 3+xpOffs, -swed.nut.snut, swed.nut.cnut);
        }
      }
      sl.swi_coortrf2(xp, xpOffs, xp, xpOffs, -oe.seps, oe.ceps);
      sl.swi_coortrf2(xp, 3+xpOffs, xp, 3+xpOffs, -oe.seps, oe.ceps);
      if (is_true_nodaps) {
        /****************************
         * to mean ecliptic of date
         ****************************/
        if ((iflag & SweConst.SEFLG_NONUT)==0) {
          sw.swi_nutate(xp, xpOffs, iflag, true);
        }
      }
      /*********************
       * to J2000
       *********************/
      sl.swi_precess(xp, xpOffs, tjd_et, SwephData.J_TO_J2000);
      if ((iflag & SweConst.SEFLG_SPEED)!=0) {
        sw.swi_precess_speed(xp, xpOffs, tjd_et, SwephData.J_TO_J2000);
      }
      /*********************
       * to barycenter
       *********************/
      if (ipli == SweConst.SE_MOON) {
        for (i = 0; i <= 5; i++)
          xp[i+xpOffs] += xear[i];
      } else {
        if ((iflag & SweConst.SEFLG_MOSEPH)==0 && !ellipse_is_bary) {
          for (j = 0; j <= 5; j++)
            xp[j+xpOffs] += xsun[j];
        }
      }
      /*********************
       * to correct center
       *********************/
      for (j = 0; j <= 5; j++)
        xp[j+xpOffs] -= xobs[j];
          /* geocentric perigee/apogee of sun */
      if (ipl == SweConst.SE_SUN &&
          (iflag & (SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR))==0) {
        for (j = 0; j <= 5; j++)
          xp[j+xpOffs] = -xp[j+xpOffs];
      }
      /*********************
       * light deflection
       *********************/
      dt = Math.sqrt(sl.square_sum(xp, xpOffs)) * SweConst.AUNIT / SwephData.CLIGHT / 86400.0;
      if (do_defl) {
        sw.swi_deflect_light(xp, xpOffs, dt, iflag);
      }
      /*********************
       * aberration
       *********************/
      if (do_aberr) {
        sw.swi_aberr_light(xp, xpOffs, xobs, iflag);
        /*
         * Apparent speed is also influenced by
         * the difference of speed of the earth between t and t-dt.
         * Neglecting this would result in an error of several 0.1"
         */
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
          /* get barycentric sun and earth for t-dt into save area */
          if (sw.swe_calc(tjd_et - dt, ipli,
                       iflg0 | (iflag & SweConst.SEFLG_TOPOCTR), x2, serr) ==
                                                                SweConst.ERR) {
            return SweConst.ERR;
          }
          if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            /* geocentric position of observer */
            /* if (sw.swi_get_observer(tjd_et - dt, iflag, false, xobs, serr) != SweConst.OK)
              return SweConst.ERR;*/
            for (i = 0; i <= 5; i++)
              xobs2[i] = swed.topd.xobs[i];
          } else {
            for (i = 0; i <= 5; i++)
              xobs2[i] = 0;
          }
          if ((iflag & (SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR))!=0) {
            if ((iflag & SweConst.SEFLG_HELCTR)!=0 &&
                (iflag & SweConst.SEFLG_MOSEPH)==0) {
              for (i = 0; i <= 5; i++)
                xobs2[i] = xsun[i];
            }
          } else if (ipl == SweConst.SE_SUN && (iflag & SweConst.SEFLG_MOSEPH)==0) {
            for (i = 0; i <= 5; i++)
              xobs2[i] = xsun[i];
          } else {
            /* barycentric position of observer */
            for (i = 0; i <= 5; i++)
              xobs2[i] += xear[i];
          }
          for (i = 3; i <= 5; i++)
            xp[i+xpOffs] += xobs[i] - xobs2[i];
          /* The above call of swe_calc() has destroyed the
           * parts of the save area
           * (i.e. bary sun, earth nutation matrix!).
           * to restore it:
           */
          if (sw.swe_calc(tjd_et, SweConst.SE_SUN,
                       iflg0 | (iflag & SweConst.SEFLG_TOPOCTR), x2, serr) ==
                                                                SweConst.ERR) {
            return SweConst.ERR;
          }
        }
      }
      /*********************
       * precession
       *********************/
      /* save J2000 coordinates; required for sidereal positions */
      for (j = 0; j <= 5; j++)
        x2000[j] = xp[j+xpOffs];
      if ((iflag & SweConst.SEFLG_J2000)==0) {
        sl.swi_precess(xp, xpOffs, tjd_et, SwephData.J2000_TO_J);
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
          sw.swi_precess_speed(xp, xpOffs, tjd_et, SwephData.J2000_TO_J);
        }
      }
      /*********************
       * nutation
       *********************/
      if ((iflag & SweConst.SEFLG_NONUT)==0) {
        sw.swi_nutate(xp, xpOffs, iflag, false);
      }
      /* now we have equatorial cartesian coordinates; keep them */
      for (j = 0; j <= 5; j++)
        pldat.xreturn[18+j] = xp[j+xpOffs];
      /************************************************
       * transformation to ecliptic.                  *
       * with sidereal calc. this will be overwritten *
       * afterwards.                                  *
       ************************************************/
      sl.swi_coortrf2(xp, xpOffs, xp, xpOffs, oe.seps, oe.ceps);
      if ((iflag & SweConst.SEFLG_SPEED)!=0) {
        sl.swi_coortrf2(xp, 3+xpOffs, xp, 3+xpOffs, oe.seps, oe.ceps);
      }
      if ((iflag & SweConst.SEFLG_NONUT)==0) {
        sl.swi_coortrf2(xp, xpOffs, xp, xpOffs, swed.nut.snut, swed.nut.cnut);
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
          sl.swi_coortrf2(xp, 3+xpOffs, xp, 3+xpOffs,
                          swed.nut.snut, swed.nut.cnut);
        }
      }
        /* now we have ecliptic cartesian coordinates */
        for (j = 0; j <= 5; j++)
          pldat.xreturn[6+j] = xp[j+xpOffs];
      /************************************
       * sidereal positions               *
       ************************************/
      if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
        /* project onto ecliptic t0 */
        if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0) {
          if (sw.swi_trop_ra2sid_lon(x2000, pldat.xreturn, 6, pldat.xreturn, 18, iflag, serr) != SweConst.OK) {
            return SweConst.ERR;
          }
        /* project onto solar system equator */
        } else if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
          if (sw.swi_trop_ra2sid_lon_sosy(x2000, pldat.xreturn, 6, pldat.xreturn, 18, iflag, serr) != SweConst.OK) {
            return SweConst.ERR;
        }
        } else {
        /* traditional algorithm */
        sl.swi_cartpol_sp(pldat.xreturn, 6, pldat.xreturn, 0);
        pldat.xreturn[0] -= sw.swe_get_ayanamsa(tjd_et) * SwissData.DEGTORAD;
        sl.swi_polcart_sp(pldat.xreturn, 0, pldat.xreturn, 6);
        }
      }
      if ((iflag & SweConst.SEFLG_XYZ)!=0 &&
          (iflag & SweConst.SEFLG_EQUATORIAL)!=0) {
        for (j = 0; j <= 5; j++)
          xp[j+xpOffs] = pldat.xreturn[18+j];
        continue;
      }
      if ((iflag & SweConst.SEFLG_XYZ)!=0) {
        for (j = 0; j <= 5; j++)
          xp[j+xpOffs] = pldat.xreturn[6+j];
        continue;
      }
      /************************************************
       * transformation to polar coordinates          *
       ************************************************/
      sl.swi_cartpol_sp(pldat.xreturn, 18, pldat.xreturn, 12);
      sl.swi_cartpol_sp(pldat.xreturn, 6, pldat.xreturn, 0);
      /**********************
       * radians to degrees *
       **********************/
      for (j = 0; j < 2; j++) {
        pldat.xreturn[j] *= SwissData.RADTODEG;                /* ecliptic */
        pldat.xreturn[j+3] *= SwissData.RADTODEG;
        pldat.xreturn[j+12] *= SwissData.RADTODEG;        /* equator */
        pldat.xreturn[j+15] *= SwissData.RADTODEG;
      }
      if ((iflag & SweConst.SEFLG_EQUATORIAL)!=0) {
        for (j = 0; j <= 5; j++)
          xp[j+xpOffs] = pldat.xreturn[12+j];
        continue;
      } else {
        for (j = 0; j <= 5; j++)
          xp[j+xpOffs] = pldat.xreturn[j];
        continue;
      }
    }
    for (i = 0; i <= 5; i++) {
      if (i > 2 && (iflag & SweConst.SEFLG_SPEED)==0) {
        xna[i] = xnd[i+xndOffs] = xpe[i+xpeOffs] = xap[i+xapOffs] = 0;
      }
      if (xnasc != null) {
        xnasc[i] = xna[i];
      }
      if (xndsc != null) {
        xndsc[i] = xnd[i+xndOffs];
      }
      if (xperi != null) {
        xperi[i] = xpe[i+xpeOffs];
      }
      if (xaphe != null) {
        xaphe[i] = xap[i+xapOffs];
      }
    }
    return SweConst.OK;
  }

  /**
  * Computes planetary nodes and apsides (perihelia, aphelia, second focal
  * points of the orbital ellipses). This method is identical to
  * swe_nod_aps_ut() with the one exception that the time has to be given
  * in UT (Universal Time) and not in ET (Ephemeris Time or Dynamical Time).
  * @param tjd_ut The time in UT
  * @param ipl Planet number
  * @param iflag Any of the SEFLG_* flags
  * @param method Defines, what kind of calculation is wanted (SE_NODBIT_MEAN,
  * SE_NODBIT_OSCU, SE_NODBIT_OSCU_BAR, SE_NODBIT_FOPOINT)
  * @param xnasc Output parameter of double[6]. On return it contains six
  * doubles for the ascending node
  * @param xndsc Output parameter of double[6]. On return it contains six
  * doubles for the descending node
  * @param xperi Output parameter of double[6]. On return it contains six
  * doubles for the perihelion
  * @param xaphe Output parameter of double[6]. On return it contains six
  * doubles for the aphelion
  * @param serr A StringBuffer containing a warning or error message, if
  * something fails. 
  * @return SweConst.OK (0) or SweConst.ERR (-1)
  * @see Swecl.html#swe_nod_aps(double, int, int, int, double[], double[], double[], double[], java.lang.StringBuffer)
  * @see swisseph.SweConst#OK
  * @see swisseph.SweConst#ERR
  * @see swisseph.SweConst#SE_NODBIT_MEAN
  * @see swisseph.SweConst#SE_NODBIT_OSCU
  * @see swisseph.SweConst#SE_NODBIT_OSCU_BAR
  * @see swisseph.SweConst#SE_NODBIT_FOPOINT
  */
  int swe_nod_aps_ut(double tjd_ut, int ipl, int iflag,
                     int  method,
                     double[] xnasc, double[] xndsc,
                     double[] xperi, double[] xaphe,
                     StringBuffer serr) {
    return swe_nod_aps(tjd_ut + SweDate.getDeltaT(tjd_ut),
                        ipl, iflag, method, xnasc, xndsc, xperi, xaphe,
                        serr);
  }


  /* function finds the gauquelin sector position of a planet or fixed star
   * 
   * if starname != NULL then a star is computed.
   * iflag: use the flags SE_SWIEPH, SE_JPLEPH, SE_MOSEPH, SEFLG_TOPOCTR.
   *
   * imeth defines method:
   *           imeth = 0                  sector from longitude and latitude
   *           imeth = 1                  sector from longitude, with lat = 0
   *           imeth = 2                  sector from rise and set
   *           imeth = 3                  sector from rise and set with refraction
   * rise and set are defined as appearance and disappearance of disc center.
   *
   * geopos is an array of 3 doubles for geo. longitude, geo. latitude, elevation.
   * atpress and attemp are only needed for imeth = 3. If imeth = 3,
   * If imeth=3 and atpress not given (= 0), the programm assumes 1013.25 mbar;
   * if a non-zero height above sea is given in geopos, atpress is estimated.
   * dgsect is return area (pointer to a double)
   * serr is pointer to error string, may be NULL
   */
  int swe_gauquelin_sector(double t_ut, int ipl, StringBuffer starname, int iflag, int imeth, double[] geopos, double atpress, double attemp, DblObj dgsect, StringBuffer serr) {
    DblObj dtmp=new DblObj();
    boolean rise_found = true;
    boolean set_found = true;
    int retval;
    double tret[]=new double[3];
    double t_et, t;
    double x0[]=new double[6];
    double eps, nutlo[]=new double[2], armc;
    int epheflag = iflag & SweConst.SEFLG_EPHMASK;
    boolean do_fixstar = (starname != null && starname.length() > 0);
    int risemeth = SweConst.SE_BIT_DISC_CENTER;
    boolean above_horizon = false;
    /* 
     * geometrically from ecl. longitude and latitude 
     */
    if ((imeth & 2)==0) {
      t_et = t_ut + SweDate.getDeltaT(t_ut);
      eps = sl.swi_epsiln(t_et) * SwissData.RADTODEG;
      sl.swi_nutation(t_et, nutlo);
      nutlo[0] *= SwissData.RADTODEG;
      nutlo[1] *= SwissData.RADTODEG;
      armc = sl.swe_degnorm(sl.swe_sidtime0(t_ut, eps + nutlo[1], nutlo[0]) * 15 + geopos[0]);
      if (do_fixstar) {
        if (sw.swe_fixstar(starname, t_et, iflag, x0, serr) == SweConst.ERR)
  	return SweConst.ERR;
      } else {
        if (sw.swe_calc(t_et, ipl, iflag, x0, serr) == SweConst.ERR)
  	return SweConst.ERR;
      }
      if ((imeth & 1)!=0) 
        x0[1] = 0;
      dgsect.val = sw.swe_house_pos(armc, geopos[1], eps + nutlo[1], 'G', x0, null);
      return SweConst.OK;
    }
    /* 
     * from rise and set times
     */
    if (imeth == 2) 
      risemeth |= SweConst.SE_BIT_NO_REFRACTION;
    /* find the next rising time of the planet or star */
    dtmp.val=tret[0];
    retval = swe_rise_trans(t_ut, ipl, starname, epheflag,
                            SweConst.SE_CALC_RISE|risemeth, geopos, atpress, attemp,
                            dtmp, serr);
    tret[0]=dtmp.val;
    if (retval == SweConst.ERR) {
      return SweConst.ERR; 
    } else if (retval == -2) {
      /* actually, we could return ERR here. However, we
       * keep this variable, in case we implement an algorithm
       * for Gauquelin sector positions of circumpolar bodies.
       * As with the Ludwig Otto procedure with Placidus, one 
       * could replace missing rises or sets by meridian transits,
       * although there are cases where even this is not possible.
       * Sometimes a body both appears and disappears on the western 
       * part of the horizon. Using true culminations rather than meridan
       * transits would not help in any case either, because there are
       * cases where a body does not have a culmination within days,
       * e.g. the sun near the poles.
       */
      rise_found = false;    
    }
    /* find the next setting time of the planet or star */
    dtmp.val=tret[1];
    retval = swe_rise_trans(t_ut, ipl, starname, epheflag,
                            SweConst.SE_CALC_SET|risemeth, geopos, atpress, attemp,
                            dtmp, serr);
    tret[1]=dtmp.val;
    if (retval == SweConst.ERR) {
      return SweConst.ERR; 
    } else if (retval == -2) {
      set_found = false;
    }
    if (tret[0] < tret[1] && rise_found == true) {
      above_horizon = false;
      /* find last set */
      t = t_ut - 1.2;
      if (set_found) t = tret[1] - 1.2;
      set_found = true;
      dtmp.val=tret[1];
      retval = swe_rise_trans(t, ipl, starname, epheflag,
                            SweConst.SE_CALC_SET|risemeth, geopos, atpress, attemp,
                            dtmp, serr);
      tret[1]=dtmp.val;
      if (retval == SweConst.ERR) {
        return SweConst.ERR; 
      } else if (retval == -2) {
        set_found = false;
      }
    } else if (tret[0] >= tret[1] && set_found == true) {
      above_horizon = true;
      /* find last rise */
      t = t_ut - 1.2;
      if (rise_found) t = tret[0] - 1.2;
      rise_found = true;
      dtmp.val=tret[0];
      retval = swe_rise_trans(t, ipl, starname, epheflag,
                            SweConst.SE_CALC_RISE|risemeth, geopos, atpress, attemp,
                            dtmp, serr);
      tret[0]=dtmp.val;
      if (retval == SweConst.ERR) {
        return SweConst.ERR; 
      } else if (retval == -2) {
        rise_found = false;
      }
    }
    if (rise_found && set_found) {
      if (above_horizon) {
        dgsect.val = (t_ut - tret[0]) / (tret[1] - tret[0]) * 18 + 1;
      } else {
        dgsect.val = (t_ut - tret[1]) / (tret[0] - tret[1]) * 18 + 19;
      }
      return SweConst.OK;
    } else {
      dgsect.val = 0;
      if (serr!=null)
        serr.append("rise or set not found for planet ").append(ipl);
      return SweConst.ERR;
    }
  }
} // End of class Swecl
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


/**
* This class contains all the constants that might be interesting to the
* user of the swisseph package.<P>
* All constants are static, so there is no need to instantiate the class.
* <P><I><B>You will find the complete documentation for the original
* SwissEphemeris package at <A HREF="http://www.astro.ch/swisseph/sweph_g.htm">
* http://www.astro.ch/swisseph/sweph_g.htm</A>. By far most of the information 
* there is directly valid for this port to Java as well.</B></I>
* @version 1.0.0a
*/
class SweConst {

////////////////////////////////////////////////////////////////////////////////
//// sweodef.h: ////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
  /**
  * Constant for successful return values. It is equal to 0.
  */
  public static final int OK=0;
  /**
  * Constant for unsuccessful return values. It is equal to -1.
  */
  public static final int ERR=-1;

//////////////////////////////////////////////////////////////////////////////
// swephexp.h: ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
  /*
   * planet numbers for the ipl parameter in swe_calc()
   */
  /**
  * Planet number for the ipl parameter in swe_calc*(). It does not calculate
  * a real planet, but the ecliptic and nutation of that date. Its value is -1.
  */
  public static final int SE_ECL_NUT=-1;

  /**
  * planet number of the sun. It is equal to 0.
  */
  public static final int SE_SUN=0;
  /**
  * planet number of the moon. It is equal to 1.
  */
  public static final int SE_MOON=1;
  /**
  * planet number of mercury. It is equal to 2.
  */
  public static final int SE_MERCURY=2;
  /**
  * planet number of venus. It is equal to 3.
  */
  public static final int SE_VENUS=3;
  /**
  * planet number of mars. It is equal to 4.
  */
  public static final int SE_MARS=4;
  /**
  * planet number of jupiter. It is equal to 5.
  */
  public static final int SE_JUPITER=5;
  /**
  * planet number of saturn. It is equal to 6.
  */
  public static final int SE_SATURN=6;
  /**
  * planet number of uranus. It is equal to 7.
  */
  public static final int SE_URANUS=7;
  /**
  * planet number of neptune. It is equal to 8.
  */
  public static final int SE_NEPTUNE=8;
  /**
  * planet number of pluto. It is equal to 9.
  */
  public static final int SE_PLUTO=9;
  /**
  * (planet) number of the mean moon node. It is equal to 10.
  */
  public static final int SE_MEAN_NODE=10;
  /**
  * (planet) number of the true moon node. It is equal to 11.
  */
  public static final int SE_TRUE_NODE=11;
  /**
  * (planet) number of the mean apogee (== Lilith). It is equal to 12.
  */
  public static final int SE_MEAN_APOG=12;
  /**
  * (planet) number of the osculating apogee. It is equal to 13.
  */
  public static final int SE_OSCU_APOG=13;
  /**
  * planet number of the earth. It is equal to 14.
  */
  public static final int SE_EARTH=14;
  /**
  * planet number of chiron. It is equal to 15.
  */
  public static final int SE_CHIRON=15;
  /**
  * planet number of pholus. It is equal to 16.
  */
  public static final int SE_PHOLUS=16;
  /**
  * planet number of ceres. It is equal to 17.
  */
  public static final int SE_CERES=17;
  /**
  * planet number of pallas. It is equal to 18.
  */
  public static final int SE_PALLAS=18;
  /**
  * planet number of juno. It is equal to 19.
  */
  public static final int SE_JUNO=19;
  /**
  * planet number of vesta. It is equal to 20.
  */
  public static final int SE_VESTA=20;
  /**
  * planet number of the interpolated lunar agopee. It is equal to 21.
  */
  public static final int SE_INTP_APOG=21;
  /**
  * planet number of the interpolated lunar agopee. It is equal to 21.
  */
  public static final int SE_INTP_PERG=22;

  /**
  * Amount of defined planets. It is equal to 23.
  */
  static final int SE_NPLANETS=23;

  /**
  * The offset, where asteroid numbers start. It is equal to 10000.
  */
  public static final int SE_AST_OFFSET=10000;
  public static final int SE_VARUNA  =(SE_AST_OFFSET + 20000);

  static final int SE_FICT_OFFSET=40;
  public static final int SE_FICT_OFFSET_1=39;
  static final int SE_FICT_MAX=999;
  static final int SE_NFICT_ELEM=15;

  static final int SE_COMET_OFFSET=2000;

  static final int SE_NALL_NAT_POINTS=(SE_NPLANETS + SE_NFICT_ELEM);

  /* Hamburger or Uranian "planets" */
  /**
  * The number of the Hamburger or Uranian "planet" cupido. It is equal to 40.
  */
  public static final int SE_CUPIDO=40;
  /**
  * The number of the Hamburger or Uranian "planet" hades. It is equal to 41.
  */
  public static final int SE_HADES=41;
  /**
  * The number of the Hamburger or Uranian "planet" zeus. It is equal to 42.
  */
  public static final int SE_ZEUS=42;
  /**
  * The number of the Hamburger or Uranian "planet" kronos. It is equal to 43.
  */
  public static final int SE_KRONOS=43;
  /**
  * The number of the Hamburger or Uranian "planet" appollon. It is equal to 44.
  */
  public static final int SE_APOLLON=44;
  /**
  * The number of the Hamburger or Uranian "planet" admetos. It is equal to 45.
  */
  public static final int SE_ADMETOS=45;
  /**
  * The number of the Hamburger or Uranian "planet" vulkanus. It is equal to 46.
  */
  public static final int SE_VULKANUS=46;
  /**
  * The number of the Hamburger or Uranian "planet" poseidon. It is equal to 47.
  */
  public static final int SE_POSEIDON=47;
  /* other fictitious bodies */
  /**
  * The "planet" number of the fictitious body isis. It is equal to 48.
  */
  public static final int SE_ISIS=48;
  /**
  * The "planet" number of the fictitious body nibiru. It is equal to 49.
  */
  public static final int SE_NIBIRU=49;
  /**
  * The "planet" number of the fictitious body harrington. It is equal to 50.
  */
  public static final int SE_HARRINGTON=50;
  /**
  * The "planet" number of the fictitious body neptune-leverrier. It is equal to 51.
  */
  public static final int SE_NEPTUNE_LEVERRIER=51;
  /**
  * The "planet" number of the fictitious body neptune-adams. It is equal to 52.
  */
  public static final int SE_NEPTUNE_ADAMS=52;
  /**
  * The "planet" number of the fictitious body pluto-lowell. It is equal to 53.
  */
  public static final int SE_PLUTO_LOWELL=53;
  /**
  * The "planet" number of the fictitious body pluto-pickering. It is equal to 54.
  */
  public static final int SE_PLUTO_PICKERING=54;
  /**
  * The "planet" number of the fictitious body vulcan. It is equal to 55.
  */
  public static final int SE_VULCAN=55;
  /**
  * The "planet" number of the fictitious body &quot;white moon&quot;
  * (== Selena). It is equal to 56.
  */
  public static final int SE_WHITE_MOON=56;
  /**
  * The "planet" number of the fictitious body &quot;Proserpina&quot;.
  * It is equal to 57.
  */
  public static final int SE_PROSERPINA=57;
  /**
  * The "planet" number of the fictitious body &quot;Waldemath&quot;.
  * It is equal to 58.
  */
  public static final int SE_WALDEMATH=58;

  public static final int SE_FIXSTAR=-10;

  /**
  * This is a constant to access the ascendent value in parameter ascmc[]
  * of SwissEph.swe_houses_armc() / SwissEph.swe_houses(). Its value is 0.
  */
  static final int SE_ASC   =0;
  /**
  * This is a constant to access the medium coeli value in parameter ascmc[]
  * of SwissEph.swe_houses_armc() / SwissEph.swe_houses(). Its value is 1.
  */
  static final int SE_MC    =1;
  /**
  * This is a constant to access the value of the sidereal time in parameter
  * ascmc[] of SwissEph.swe_houses_armc() / SwissEph.swe_houses(). Its value
  * is 2.
  */
  static final int SE_ARMC  =2;
  /**
  * This is a constant to access the vertex value in parameter ascmc[]
  * of SwissEph.swe_houses_armc() / SwissEph.swe_houses(). Its value is 3.
  */
  static final int SE_VERTEX=3;
  /**
  * This is a constant to access the value of the &quot;equatorial ascendent&quot;
  * in parameter ascmc[] of SwissEph.swe_houses_armc() / SwissEph.swe_houses().
  * Its value is 4.
  */
  static final int SE_EQUASC=4;
  /**
  * This is a constant to access the value of the &quot;co-ascendant&quot; of
  * W. Koch in parameter ascmc[] of SwissEph.swe_houses_armc() /
  * SwissEph.swe_houses(). Its value is 5.
  */
  static final int SE_COASC1=5;
  /**
  * This is a constant to access the value of the &quot;co-ascendant&quot; of
  * M. Munkasey in parameter ascmc[] of SwissEph.swe_houses_armc() /
  * SwissEph.swe_houses(). Its value is 6.
  */
  static final int SE_COASC2=6;
  /**
  * This is a constant to access the polar ascendent value of M. Munkasey in
  * parameter ascmc[] of SwissEph.swe_houses_armc() / SwissEph.swe_houses().
  * Its value is 7.
  */
  static final int SE_POLASC=7;
  /**
  * This is a constant to know the count of valid parameters in parameter
  * ascmc[] of SwissEph.swe_houses_armc() / SwissEph.swe_houses(). Its value
  * is 8 now, meaning, ascmc[0] to ascmc[7] contain meaningful data, even though
  * ascmc[] has to be of size 10.
  */
  static final int SE_NASCMC=8;

  /*
   * only used for experimenting with various JPL ephemeris files
   * which are available at Astrodienst's internal network
   */
  public static final String SE_FNAME_DE406="de406.eph";
  public static final String SE_FNAME_DE200="de200.eph";
  public static final String SE_FNAME_DFT=SE_FNAME_DE406;

  /*
   * flag bits for parameter iflag in function swe_calc()
   * The flag bits are defined in such a way that iflag = 0 delivers what one
   * usually wants:
   *    - the default ephemeris (SWISS EPHEMERIS) is used,
   *    - apparent geocentric positions referring to the true equinox of date
   *      are returned.
   * If not only coordinates, but also speed values are required, use
   * flag = SEFLG_SPEED.
   *
   * The 'L' behind the number indicates that 32-bit integers (Long) are used.
   */
  /**
  * Calculate the heliocentric position of the planet. This is a constant to be used
  * as a flag to swe_calc() / swe_fixstar().
  */
  public static final int SEFLG_HELCTR=8;     // return heliocentric position
  /**
  * Calculate the true position of the planet versus the apparent position. This is a
  * constant to be used as a flag to swe_calc() / swe_fixstar().
  */
  public static final int SEFLG_TRUEPOS=16;   // return true positions, not apparent
  /**
  * Calculate the position of the planet without considering the precession, i.e.,
  * calculate J2000 equinox. This is a constant to be used as a flag to swe_calc() /
  * swe_fixstar().
  */
  public static final int SEFLG_J2000=32;     // no precession, i.e. give J2000 equinox
  /**
  * Calculate the position of the planet without considering the nutation, i.e.,
  * calculate the mean equinox of the day. This is a constant to be used as a flag to
  * swe_calc() / swe_fixstar().
  */
  public static final int SEFLG_NONUT=64;     // no nutation, i.e. mean equinox of date
  /**
  * Calculate the speed of the planet. This calculation should not be used,
  * as it is slower and less precise than SEFLG_SPEED. This is a constant to be used
  * as a flag to swe_calc() / swe_fixstar().
  * @see #SEFLG_SPEED
  */
  public static final int SEFLG_SPEED3=128;   // speed from 3 positions (do not use
                                       // it, SEFLG_SPEED is faster and more
                                       // precise.)
  /**
  * Calculate the speed of the planet. This is a constant to be used
  * as a flag to swe_calc() / swe_fixstar().
  */
  public static final int SEFLG_SPEED=256;    // high precision speed
  /**
  * Calculate the position of the planet without considering gravitational deflection.
  * This is a constant to be used as a flag to swe_calc() / swe_fixstar().
  */
  public static final int SEFLG_NOGDEFL=512;  // turn off gravitational deflection
  /**
  * Calculate the position of the planet without considering the 'annual' aberration
  * of light. This is a constant to be used as a flag to swe_calc() / swe_fixstar().
  */
  public static final int SEFLG_NOABERR=1024; // turn off 'annual' aberration of light
  /**
  * Calculate the equatorial position of the planet. This is a constant to be used as
  * a flag to swe_calc() / swe_fixstar().
  */
  public static final int SEFLG_EQUATORIAL=2*1024; // equatorial positions are wanted
  /**
  * Return cartesian coordinates instead of polar coordinates. This is a constant to be
  * used as a flag to swe_calc() / swe_fixstar().
  */
  public static final int SEFLG_XYZ=4*1024;     // cartesian, not polar, coordinates
  /**
  * Return coordinates in radians instead of degrees. This is a constant to be used as
  * a flag to swe_calc() / swe_fixstar().
  */
  public static final int SEFLG_RADIANS=8*1024; // coordinates in radians, not degrees
  /**
  * Calculate barycentric positions. This is a constant to be used as a flag to
  * swe_calc() / swe_fixstar().
  */
  public static final int SEFLG_BARYCTR=16*1024; // barycentric positions
  /**
  * Calculate topocentric positions. This is a constant to be used as a flag to
  * swe_calc() / swe_fixstar().
  */
  public static final int SEFLG_TOPOCTR=32*1024; // topocentric positions
  /**
  * Calculate sidereal positions. This is a constant to be used as a flag to
  * swe_calc() / swe_fixstar().
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SEFLG_SIDEREAL=64*1024; // sidereal positions
  /**
  * Calculate in the "International Celestial Reference System." This is a
  * constant to be used as a flag to swe_calc() / swe_fixstar().
  */
  public static final int SEFLG_ICRS=128*1024; // ICRS (DE406 reference frame)

  /**
  * calculate transits over a longitude. This is a constant to be used as a
  * flag to the TransitCalculator constructors.
  * @see swisseph.TCPlanet#TCPlanet(SwissEph, int, int, double)
  * @see swisseph.TCPlanetPlanet#TCPlanetPlanet(SwissEph, int, int, int, double)
  */
  public static final int SEFLG_TRANSIT_LONGITUDE =  128*1024;
  /**
  * calculate transits over a latitude. This is a constant to be used as a
  * flag to the TransitCalculator constructors.
  * @see swisseph.TCPlanet#TCPlanet(SwissEph, int, int, double)
  * @see swisseph.TCPlanetPlanet#TCPlanetPlanet(SwissEph, int, int, int, double)
  */
  public static final int SEFLG_TRANSIT_LATITUDE  =  256*1024;
  /**
  * calculate transits over a distance in AU. This is a constant to be used
  * as a flag to the TransitCalculator constructors.
  * @see swisseph.TCPlanet#TCPlanet(SwissEph, int, int, double)
  * @see swisseph.TCPlanetPlanet#TCPlanetPlanet(SwissEph, int, int, int, double)
  */
  public static final int SEFLG_TRANSIT_DISTANCE  =  512*1024;
  /**
  * calculate transits over a (longitudinal, latitudinal or distance)
  * speed value. This is a constant to be used as a flag the
  * TransitCalculator constructors.
  * @see swisseph.TCPlanet#TCPlanet(SwissEph, int, int, double)
  * @see swisseph.TCPlanetPlanet#TCPlanetPlanet(SwissEph, int, int, int, double)
  */
  public static final int SEFLG_TRANSIT_SPEED     = 1024*1024;
  /**
  * calculate yoga transits, this means consider the SUM of two planets
  * positions or speed instead of the difference. This is a constant to be
  * used as a flag to the TransitCalculator constructors.
  * @see swisseph.TCPlanetPlanet#TCPlanetPlanet(SwissEph, int, int, int, double)
  */
  public static final int SEFLG_YOGA_TRANSIT      = 2048*1024;

  /**
  * Use the calculation routines that use the ephemeris data files of the
  * Solar System Dynamics Group of the Jet Propulsion Laboratory of NASA
  * <A HREF="http://ssd.jpl.nasa.gov/">http://ssd.jpl.nasa.gov/</A>. This
  * requires you to have the ephemeris data files from JPL (DE406: about
  * 9.5&nbsp;MB per 300&nbsp;years). They can be obtained from
  * <A HREF="ftp://navigator.jpl.nasa.gov/pub/ephem/export">
  * ftp://navigator.jpl.nasa.gov/pub/ephem/export</A> (as of December 21, 2000).
  * @see SwissEph#swe_set_ephe_path(java.lang.String)
  */
  public static final int SEFLG_JPLEPH=1;
  /**
  * Use the calculation routines of Swiss Ephemeris from Astrodienst&nbsp;AG
  * Z&uuml;rich <A HREF="http://www.astro.com">http://www.astro.com</A>. This
  * requires you to have the data files for SwissEphemeris available and in
  * the search path for the ephemeris files.<BR>Basically, these routines are
  * identical to the JPL routines, but the data files are <I>much</I> more
  * compressed (about one 10th of the original JPL files), and the exactness
  * is retained to 1/1000 of an arc second.
  * @see SwissEph#swe_set_ephe_path(java.lang.String)
  */
  public static final int SEFLG_SWIEPH=2;
  /**
  * Use the Moshier semi-analytical calculation routines. These routines are
  * the slowest (about 10 times slower than JPL or SWISS EPHEMERIS) and most
  * inaccurate, but they do not require any additional data files.<BR>
  * The accuracy is about 1 arc seconds for the planets and a few arc seconds
  * for the moon. Unfortunately, the deviation for true lunar nodes may be
  * up to one arc minute.
  */
  public static final int SEFLG_MOSEPH=4;
  /**
  * Defines the default method of calculation as SEFLG_SWIEPH.
  * @see swisseph.SweConst#SEFLG_JPLEPH
  * @see swisseph.SweConst#SEFLG_SWIEPH
  * @see swisseph.SweConst#SEFLG_MOSEPH
  */
  public static final int SEFLG_DEFAULTEPH=SEFLG_SWIEPH;
  public static final int SEFLG_EPHMASK=SEFLG_JPLEPH|SEFLG_SWIEPH|SEFLG_MOSEPH;

  public static final int SE_SIDBITS             =256;
  /* for projection onto ecliptic of t0 */
  /**
  * This specifies that sidereal calculations are done via a
  * projection onto the ecliptic at date t0.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDBIT_ECL_T0       =256;
  /* for projection onto solar system plane */
  /**
  * This specifies that sidereal calculations are done via a
  * projection onto the solar system plane.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDBIT_SSY_PLANE    =512;

  /* sidereal modes (ayanamsas) */
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha).
  * Fagan/Bradley is used as default, if nothing other is specified
  * via swe_set_sid_mode.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_FAGAN_BRADLEY  = 0;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * defined by Lahiri.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_LAHIRI         = 1;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * defined by De Luce.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_DELUCE         = 2;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * defined by Raman.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_RAMAN          = 3;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * defined by Ushashashi.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_USHASHASHI     = 4;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * defined by Krishnamurti.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_KRISHNAMURTI   = 5;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * defined by Djwhal Khool.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_DJWHAL_KHUL    = 6;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * defined by Sri Yukteshwar.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_YUKTESHWAR     = 7;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * defined by JN Bhasin.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_JN_BHASIN      = 8;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * defined by Babylonian, Kugler 1.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_BABYL_KUGLER1  = 9;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * defined by Babylonian, Kugler 2.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_BABYL_KUGLER2  =10;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * defined by Babylonian, Kugler 3.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_BABYL_KUGLER3  =11;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * defined by Babylonian, Huber.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_BABYL_HUBER    =12;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * defined by Babylonian, Mercier.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_BABYL_ETPSC    =13;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * defining t0 by Aldebaran at 15 degrees Taurus.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_ALDEBARAN_15TAU=14;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) by
  * defined by Hipparchos.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_HIPPARCHOS     =15;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * defined by Sassanian.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_SASSANIAN      =16;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * defined by the galactic center being at 0 degrees Sagittarius.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_GALCENT_0SAG   =17;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * J2000.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_J2000          =18;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * J1900.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_J1900          =19;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * B1950.
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_B1950          =20;
  /**
  * A constant to be used for specifying the sidereal mode (ayanamsha) as
  * defined by the user in the additional two parameters of swe_set_sid_mode().
  * @see SwissEph#swe_set_sid_mode(int, double, double)
  */
  public static final int SE_SIDM_USER          =255;

  static final int SE_MAX_STNAME=20;    // maximum size of fixstar name;
                                        // the parameter star in swe_fixstar
					// must allow twice this space for
				        // the returned star name.



  /* used for swe_nod_aps(): */
  /**
  * Used for swe_nod_aps(): mean nodes/apsides
  */
  public static final int SE_NODBIT_MEAN    =1; // mean nodes/apsides
  /**
  * Used for swe_nod_aps(): osculating nodes/apsides
  */
  public static final int SE_NODBIT_OSCU    =2; // osculating nodes/apsides
  /**
  * Used for swe_nod_aps(): osculating nodes/apsides, but motion about solar
  * system barycenter is considered
  */
  public static final int SE_NODBIT_OSCU_BAR=4; // same, but motion about solar
                                             // system barycenter is considered
  /**
  * Used for swe_nod_aps(): focal point of orbit instead of aphelion
  */
  public static final int SE_NODBIT_FOPOINT =256; // focal point of orbit
                                                  // instead of aphelion


  /* defines for function swe_split_deg() (in swephlib.c) */
  public static final int SE_SPLIT_DEG_ROUND_SEC =  1;
  public static final int SE_SPLIT_DEG_ROUND_MIN =  2;
  public static final int SE_SPLIT_DEG_ROUND_DEG =  4;
  public static final int SE_SPLIT_DEG_ZODIACAL  =  8;
  public static final int SE_SPLIT_DEG_KEEP_SIGN = 16;

  public static final int SE_SPLIT_DEG_KEEP_DEG  = 32;



  /*
   * ephemeris path
   * this defines where ephemeris files are expected if the function
   * swe_set_ephe_path() is not called by the application.
   * Normally, every application should make this call to define its
   * own place for the ephemeris files.
   */
  /**
   * Ephemeris path.<P>
   * This defines where ephemeris files are expected if the function
   * swe_set_ephe_path() is not called by the application.<P>
   * It is defined as being <CODE>".:./ephe:/users/ephe2/:/users/ephe/"</CODE>.
   * @see SwissEph#swe_set_ephe_path(java.lang.String)
   */
  public static final String SE_EPHE_PATH=".:./ephe:/users/ephe2/:/users/ephe/";
//  public static final String SE_EPHE_PATH=".:./ephe:/users/ephe2/:/users/ephe/:c\\:\\\\ephe:d\\:\\\\ephe:http\\://www.th-mack.de/datafiles";
                        /* At Astrodienst, we maintain two ephemeris areas for
                           the thousands of asteroid files:
                           the short files in /users/ephe/ast*,
                           the long file in /users/ephe2/ast*. */

  static final String SE_STARFILE="fixstars.cat";
  static final String SE_ASTNAMFILE="seasnam.txt";
  /**
  * The name of the file containing the orbital elements of ficticious planets.
  */
  static final String SE_FICTFILE="seorbel.txt";


  /* defines for eclipse computations */

  public static final int SE_ECL_CENTRAL=1;
  public static final int SE_ECL_NONCENTRAL=2;
  public static final int SE_ECL_TOTAL=4;
  /**
  * Annular eclipse. This is an eclipse, where the moon is seen smaller
  * than the sun, so you get a "ring" of the sun around the moon.
  */
  public static final int SE_ECL_ANNULAR=8;
  public static final int SE_ECL_PARTIAL=16;
  public static final int SE_ECL_ANNULAR_TOTAL=32;
  public static final int SE_ECL_PENUMBRAL=64;
  public static final int SE_ECL_VISIBLE=128;
  public static final int SE_ECL_MAX_VISIBLE=256;
  /**
  * This is the time, when the moon touches the sun the first time.
  */
  public static final int SE_ECL_1ST_VISIBLE=512;
  /**
  * This is the time, when the sun completely disappears.
  */
  public static final int SE_ECL_2ND_VISIBLE=1024;
  /**
  * This is the time, when the sun starts to reappear.
  */
  public static final int SE_ECL_3RD_VISIBLE=2048;
  /**
  * This is the time, when the moon and the sun finally separate.
  */
  public static final int SE_ECL_4TH_VISIBLE=4096;
  /**
  * Just check if the next conjunction of the moon with
  * a planet is an occultation; don't search further.
  */
  public static final int SE_ECL_ONE_TRY=32*1024;

  /* for swe_rise_transit() */
  /**
  * Calculate the time of sunrise. This is a constant to be used as a flag to
  * swe_rise_trans().
  */
  public static final int SE_CALC_RISE          = 1;
  /**
  * Calculate the time of sunset. This is a constant to be used as a flag to
  * swe_rise_trans().
  */
  public static final int SE_CALC_SET           = 2;
  /**
  * Calculate the time of the upper meridian transit (southern for northern geo.
  * latitudes). This is a constant to be used as a flag to swe_rise_trans().
  */
  public static final int SE_CALC_MTRANSIT      = 4;
  /**
  * Calculate the time of the lower meridian transit (northern, below the
  * horizon). This is a constant to be used as a flag to swe_rise_trans().
  */
  public static final int SE_CALC_ITRANSIT      = 8;
  /**
  * Add this to SE_CALC_RISE/SET, if rise or set of disc center is requested.
  * This is a constant to be used as a flag to swe_rise_trans().
  * @see swisseph.SwissEph#swe_rise_trans(double, int, java.lang.StringBuffer, int, int, double[], double, double, swisseph.DblObj, java.lang.StringBuffer)
  */
  public static final int SE_BIT_DISC_CENTER   = 256;
                                    /* to be or'ed to SE_CALC_RISE/SET */
                                    /* if rise or set of disc center is */
                                    /* required */
  /**
  * Add this to SE_CALC_RISE/SET, if refraction should not to be considered.
  * This is a constant to be used as a flag to swe_rise_trans().
  * @see swisseph.SwissEph#swe_rise_trans(double, int, java.lang.StringBuffer, int, int, double[], double, double, swisseph.DblObj, java.lang.StringBuffer)
  */
  public static final int SE_BIT_NO_REFRACTION = 512;
                                    /* to be or'ed to SE_CALC_RISE/SET, */
                                    /* if refraction is not to be considered */

  /* for swe_azalt() and swe_azalt_rev() */
  /**
  * This is a constant to be used as a flag to swe_azalt(). It determines the
  * meaning of the contents of parameter xin[]. xin[0]=&nbsp;ecl. long.,
  * xin[1]=&nbsp;ecl. lat.. xin[2]=distance is not required.
  * @see swisseph.SwissEph#swe_azalt(double, int, double[], double, double, double[], double[])
  */
  public static final int SE_ECL2HOR            = 0;
  /**
  * This is a constant to be used as a flag to swe_azalt(). It determines the
  * meaning of the contents of parameter xin[]. xin[0]=&nbsp;rectascension,
  * xin[1]=&nbsp;declination. xin[2]=distance is not required.
  * @see swisseph.SwissEph#swe_azalt(double, int, double[], double, double, double[], double[])
  */
  public static final int SE_EQU2HOR            = 1;
  /**
  * This is a constant to be used as a flag to swe_azalt_rev(). It determines
  * the meaning of the contents of output parameter xout[]. xout[0]=&nbsp;ecl.
  * long., xout[1]=&nbsp;ecl. lat..
  * @see swisseph.SwissEph#swe_azalt_rev(double, int, double[], double[], double[])
  */
  public static final int SE_HOR2ECL            = 0;
  /**
  * This is a constant to be used as a flag to swe_azalt_rev(). It determines
  * the meaning of the contents of output parameter xout[].
  * xout[0]=&nbsp;equatorial long., xout[1]=&nbsp;equatorial lat..
  * @see swisseph.SwissEph#swe_azalt_rev(double, int, double[], double[], double[])
  */
  public static final int SE_HOR2EQU            = 1;

  /* for swe_refrac() */
  /**
  * Calculate the apparent altitude from the true altitude.
  * This is a constant to be used as a flag to swe_refrac().
  * @see swisseph.SwissEph#swe_refrac(double, double, double, int)
  * @see #SE_APP_TO_TRUE
  */
  public static final int SE_TRUE_TO_APP =0;
  /**
  * Calculate the true altitude from the apparent altitude.
  * This is a constant to be used as a flag to swe_refrac().
  * @see #SE_TRUE_TO_APP
  * @see swisseph.SwissEph#swe_refrac(double, double, double, int)
  */
  public static final int SE_APP_TO_TRUE =1;

//  static final int pnoext2int[] = {SwephData.SEI_SUN, SwephData.SEI_MOON,
//    SwephData.SEI_MERCURY, SwephData.SEI_VENUS, SwephData.SEI_MARS,
//    SwephData.SEI_JUPITER, SwephData.SEI_SATURN, SwephData.SEI_URANUS,
//    SwephData.SEI_NEPTUNE, SwephData.SEI_PLUTO, 0, 0, 0, 0, SwephData.SEI_EARTH,
//    SwephData.SEI_CHIRON, SwephData.SEI_PHOLUS, SwephData.SEI_CERES,
//    SwephData.SEI_PALLAS, SwephData.SEI_JUNO, SwephData.SEI_VESTA, };
//

// we always use Astronomical Almanac constants, if available
  public static final double AUNIT=1.4959787066e+11;        // au in meters,
                                                            // AA 1996 K6
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

  /**
  * All variables are static, so there is no sense in instantiating this class.
  */
  private SweConst() {
  }
}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/



/**
* This class is a date class specialized for the use with the swisseph
* package. You will like to use it, if you need a Julian Day number or
* the deltaT for a date or a Julian Day or if like to convert from Gregorian
* to Julian calendar system or vice versa.<P>
* This is a port of the SwissEphemeris package to Java. See
* <A HREF="http://www.astro.ch">Astrodienst Z&uuml;rich</A>
* for more infos and the original authors.
* <P><I><B>You will find the complete documentation for the original
* SwissEphemeris package at <A HREF="http://www.astro.ch/swisseph/sweph_g.htm">
* http://www.astro.ch/swisseph/sweph_g.htm</A>. By far most of the information 
* there is directly valid for this port to Java as well.</B></I>
* @author Thomas Mack / mack@ifis.cs.tu-bs.de
* @version 1.0.0c
*/
class SweDate {

  private static SwissEph sw = new SwissEph();

  /**
  * Constant for weekdays. SUNDAY is equal to 0.
  */
  public static final int SUNDAY=0;
  /**
  * Constant for weekdays. MONDAY is equal to 1.
  */
  public static final int MONDAY=1;
  /**
  * Constant for weekdays. TUESDAY is equal to 2.
  */
  public static final int TUESDAY=2;
  /**
  * Constant for weekdays. WEDNESDAY is equal to 3.
  */
  public static final int WEDNESDAY=3;
  /**
  * Constant for weekdays. THURSDAY is equal to 4.
  */
  public static final int THURSDAY=4;
  /**
  * Constant for weekdays. FRIDAY is equal to 5.
  */
  public static final int FRIDAY=5;
  /**
  * Constant for weekdays. SATURDAY is equal to 6.
  */
  public static final int SATURDAY=6;

  public static final boolean SE_JUL_CAL=false;
  public static final boolean SE_GREG_CAL=true;
  public static final boolean SE_KEEP_DATE=true;
  public static final boolean SE_KEEP_JD=false;


// for delta t: tidal acceleration in the mean motion of the moon

  /**
  * Tidal acceleration value in the mean motion of the moon of DE403 (-25.8).
  */
  public static final double SE_TIDAL_DE403=-25.8;
  /**
  * Tidal acceleration value in the mean motion of the moon of DE404 (-25.8).
  */
  public static final double SE_TIDAL_DE404=-25.8;
  /**
  * Tidal acceleration value in the mean motion of the moon of DE405 (-25.7376).
  */
  public static final double SE_TIDAL_DE405=-25.7376;
  /**
  * Tidal acceleration value in the mean motion of the moon of DE406 (-25.7376).
  */
  public static final double SE_TIDAL_DE406=-25.7376;
  /**
  * Tidal acceleration value in the mean motion of the moon of DE200 (-23.8946).
  */
  public static final double SE_TIDAL_DE200=-23.8946;
  /**
  * Tidal acceleration value in the mean motion of the moon of -26.
  */
  public static final double SE_TIDAL_26=-26.0;
  /**
  * Default tidal acceleration value in the mean motion of the moon (=SE_TIDAL_DE406).
  * @see #SE_TIDAL_DE406
  */
  public static final double SE_TIDAL_DEFAULT=SE_TIDAL_DE406;



  /**
  * The Julian day number of 1970 January 1.0. Useful for conversions
  * from or to a Date object.
  * @see #getDate(long)
  */
  public static final double JD0=2440587.5;          /* 1970 January 1.0 */

  private double tid_acc = SE_TIDAL_DEFAULT;
  private static boolean init_dt_done = false;
  private double jd;
  // JD for the start of the Gregorian calendar system (October 15, 1582):
  private double jdCO = 2299160.5;
  private boolean calType;
  private int year;
  private int month;
  private int day;
  private double hour;
  private double deltaT;
  private boolean deltatIsValid=false;


  //////////////////////////////////////////////////////////////////////////////
  // Constructors //////////////////////////////////////////////////////////////

  // The following constructors keep julian day in favor of date:
  /**
  * This constructs a new SweDate with a default of the current date
  * and time in UTC.
  */
  public SweDate() {
    Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT+0"));
    setFields(cal.get(Calendar.YEAR),
          cal.get(Calendar.MONTH) + 1,
          cal.get(Calendar.DAY_OF_MONTH),
          cal.get(Calendar.HOUR_OF_DAY) +
                cal.get(Calendar.MINUTE)/60. +
                cal.get(Calendar.SECOND)/3600. +
                cal.get(Calendar.MILLISECOND)/3600000.,
          SE_GREG_CAL);
  }
  /**
  * This constructs a new SweDate with the given Julian Day number.
  * The calendar system will be Gregorian after October 15, 1582 or
  * Julian before that date.
  * @param jd Julian Day number
  */
  public SweDate(double jd) {
    initDateFromJD(jd, jdCO<=jd?SE_GREG_CAL:SE_JUL_CAL);
  }
  /**
  * This constructs a new SweDate with the given Julian Day number.
  * The dates will be calculated according to the given calendar system
  * (Gregorian or Julian calendar).
  * @param jd Julian Day number
  * @param calType calendar type (Gregorian or Julian calendar system)
  * @see #SE_GREG_CAL
  * @see #SE_JUL_CAL
  */
  public SweDate(double jd, boolean calType) {
    initDateFromJD(jd, calType);
  }

  /**
  * This constructs a new SweDate with the given date and time. The calendar
  * type is automatically adjusted to Julian calendar system before October 15,
  * 1582, and to Gregorian calendar system after and including that date. The
  * dates from October 5 to October 14, 1582 had been skipped during the
  * conversion to the Gregorian calendar, so we just convert any such date to
  * Julian calendar system even though no such date did exist.
  * @param year The year of the date
  * @param month The month of the date
  * @param day The day-number in a month of that date
  * @param hour The hour of the day
  */
  public SweDate(int year, int month, int day, double hour) {
    setFields(year, month, day, hour);
  }
  /**
  * This constructs a new SweDate with the given date and time. The
  * date numbers will be interpreted according to the given calendar
  * system (Gregorian or Julian calendar).
  * @param year The year of the date
  * @param month The month of the date
  * @param day The day-number of the date
  * @param hour The hour of the day
  * @param calType calendar type (Gregorian or Julian calendar system)
  * @see #SE_GREG_CAL
  * @see #SE_JUL_CAL
  */
  public SweDate(int year, int month, int day, double hour, boolean calType) {
     setFields(year, month, day, hour, calType);
   }
  // End of constructors
  //////////////////////////////////////////////////////////////////////////////


  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
  // Public methods: ///////////////////////////////////////////////////////////


  //////////////////////////////////////////////////////////////////////////////
  // Access to private variables ///////////////////////////////////////////////
  // Read access: //
  /**
  * Queries the Julian Day number of this object.
  * @return Julian Day number
  */
  public double getJulDay() {
    return this.jd;
  }
  /**
  * Queries the Julian Day number of the given date in Gregorian calendar
  * system - this is a static method.
  * @param year The year of the date
  * @param month The month of the date
  * @param day The day-number of the date
  * @param hour The hour of the day
  * @return Julian Day number
  */
  public static double getJulDay(int year, int month, int day, double hour) {
    double sjd = swe_julday(year, month, day, hour, SE_GREG_CAL);
    return sjd;
  }
  /**
  * Queries the Julian Day number of the given date that is interpreted as
  * a date in the given calendar system - this is a static method.
  * @param year The year of the date
  * @param month The month of the date
  * @param day The day-number of the date
  * @param hour The hour of the day
  * @param calType calendar type (Gregorian or Julian calendar system)
  * @return Julian Day number
  * @see #SE_GREG_CAL
  * @see #SE_JUL_CAL
  */
  public static double getJulDay(int year, int month, int day, double hour,
                                 boolean calType) {
    double sjd = swe_julday(year, month, day, hour, calType);
    return sjd;
  }

  // 0=Sunday, 1=Monday etc.
  /**
  * Queries the day of the week, i.e. Sunday to Saturday as represented by
  * an integer. Sunday is represented by 0, Saturday by 6. Any discontinuity
  * in the sequence of weekdays is <b>not</b> taken into account!
  * <B>Attention: the numbers are different from the numbers returned by the
  * java.awt.Calendar class!</B>
  * @return Number of the day of week
  * @see #SUNDAY
  * @see #MONDAY
  * @see #TUESDAY
  * @see #WEDNESDAY
  * @see #THURSDAY
  * @see #FRIDAY
  * @see #SATURDAY
  */
  public int getDayOfWeekNr() {
    return ((int)(this.jd-5.5))%7;
  }
  /**
  * Queries the day of the week of the given Julian Day number (interpreted
  * in the gregorian calendar system!). Sunday is represented by 0, Saturday
  * by 6. Any discontinuity in the sequence of weekdays is <b>not</b> taken
  * into account! <B>Attention: the numbers are different from the numbers
  * returned by the java.awt.Calendar class!</B>
  * @param jd The Julian Day number of the date
  * @return Number of the day of week
  * @see #SUNDAY
  * @see #MONDAY
  * @see #TUESDAY
  * @see #WEDNESDAY
  * @see #THURSDAY
  * @see #FRIDAY
  * @see #SATURDAY
  */
  public static synchronized int getDayOfWeekNr(double jd) {
    return ((int)(jd-5.5))%7;
  }
  /**
  * Queries the day of the week of the given date that is interpreted as
  * being a date in the Gregorian or Julian calendar system depending on
  * the date, the switch from Julian to Gregorian calendar system occured.
  * Sunday is represented by 0, Saturday by 6. Any discontinuity in the
  * sequence of weekdays is <b>not</b> taken into account! <B>Attention:
  * the numbers are different from the numbers returned by the
  * java.awt.Calendar class!</B>
  * @return Number of the day of week
  * @param year The year of the date
  * @param month The month of the date
  * @param day The day-number of the date
  * @see #SUNDAY
  * @see #MONDAY
  * @see #TUESDAY
  * @see #WEDNESDAY
  * @see #THURSDAY
  * @see #FRIDAY
  * @see #SATURDAY
  */
  public static int getDayOfWeekNr(int year, int month, int day) {
    int sdow = ((int)(swe_julday(year, month, day, 0.0, SE_GREG_CAL)-5.5))%7;
    return sdow;
  }

  /**
  * Queries the day of the week of the given date that is interpreted as
  * being a date in the given calendar system. Sunday is represented by 0,
  * Saturday by 6. Any discontinuity in the sequence of weekdays is
  * <b>not</b> taken into account! <B>Attention: the numbers are different
  * from the numbers returned by the java.awt.Calendar class!</B>
  * @return Number of the day of week
  * @param year The year of the date
  * @param month The month of the date
  * @param day The day-number of the date
  * @param calType calendar type (Gregorian or Julian calendar system)
  * @see #SE_GREG_CAL
  * @see #SE_JUL_CAL
  * @see #SUNDAY
  * @see #MONDAY
  * @see #TUESDAY
  * @see #WEDNESDAY
  * @see #THURSDAY
  * @see #FRIDAY
  * @see #SATURDAY
  */
  public static int getDayOfWeekNr(int year, int month, int day,
                                   boolean calType) {
    int sdow = ((int)(swe_julday(year, month, day, 0.0, calType)-5.5))%7;
    return sdow;
  }

  /**
  * Queries the type of calendar in effect - Gregorian or Julian calendar.
  * This will effect what date you will get back for a given Julian Day.
  * @return Calendar type
  * @see #SE_GREG_CAL
  * @see #SE_JUL_CAL
  */
  public boolean getCalendarType() {
    return this.calType;
  }

  /**
  * Queries the year of this SweDate object.
  * @return year
  */
  public int getYear() {
    return this.year;
  }
//  int getYear(double jd /*, boolean calType ?*/) { swe_revjul(jd,calType); }

  /**
  * Queries the month of this SweDate object.
  * @return month <B>Attention:</B> The month ranges from 1 to 12, this is
  * different to the java.util.Calendar class!
  */
  public int getMonth() {
    return this.month;
  }

  /**
  * Queries the day of this SweDate object.
  * @return day number
  */
  public int getDay() {
    return this.day;
  }

  /**
  * Queries the hour of the day of this SweDate object.
  * @return hour
  */
  public double getHour() {
    return this.hour;
  }

  /**
  * Queries the delta T value for the date of this object.
  * @return delta T
  */
  public double getDeltaT() {
    if (deltatIsValid) { return this.deltaT; }
    this.deltaT=calc_deltaT(this.getJulDay());
    deltatIsValid=true;
    return this.deltaT;
  }

  /**
  * Queries the delta T value for the given Julian Day number - this is a
  * static method. Delta T is calculated with a tidal acceleration of
  * SE_TIDAL_DEFAULT.
  * @param tjd Julian Day number
  * @return delta T
  * @see #SE_TIDAL_DEFAULT
  */
  static public double getDeltaT(double tjd) {
    double sdt = calc_deltaT(tjd, SE_TIDAL_DEFAULT);
    return sdt;
  }

  /**
  * This will return a java.util.Date object with the date of this
  * SweDate object. This is needed often in internationalisation of date
  * and time formats. You can add an offset in milliseconds to account for
  * timezones or daylight savings time, as SweDate is meant to be in GMT
  * time always.
  * @param offset An offset in milliseconds to be added to the current
  * date and time.
  */
  public Date getDate(long offset) {
    long millis=(long)((getJulDay()-JD0)*24L*3600L*1000L)+offset;
    return new Date(millis);
  }

  /**
  * This will return a java.util.Date object from a julian day number.
  * @param jd The julian day number for which to create a Date object.
  */
  public static Date getDate(double jd) {
    long millis=(long)((jd-JD0)*24L*3600L*1000L);
    return new Date(millis);
  }
  // End of read access //


  // Write access: //
  /**
  * Sets the new Julian Day for this object. This operation does NOT
  * change the calendar type (Gregorian or Julian calendar). Use methods
  * setCalendarType() or updateCalendarType() for this.
  * @param newJD Julian Day number
  */
  public void setJulDay(double newJD) {
    this.jd=newJD;
    deltatIsValid=false;
    IDate dt=swe_revjul(newJD,this.calType);
    this.year=dt.year;
    this.month=dt.month;
    this.day=dt.day;
    this.hour=dt.hour;
  }

  /**
  * Sets the calendar type for this object.
  * @param newCalType Calendar type (Greogorian or Julian calendar)
  * @param keepDate Determines, if the date or the julian day should
  * be fix in this operation.
  * @see #SE_GREG_CAL
  * @see #SE_JUL_CAL
  * @see #SE_KEEP_DATE
  * @see #SE_KEEP_JD
  */
  public void setCalendarType(boolean newCalType, boolean keepDate) {
    if (this.calType != newCalType) {
      this.calType=newCalType;
      deltatIsValid=false;
      if (keepDate) {
        this.jd=swe_julday(this.year, this.month, this.day,
                           this.hour, this.calType);
      } else {
        IDate dt=swe_revjul(this.jd,newCalType);
        this.year=dt.year;
        this.month=dt.month;
        this.day=dt.day;
        this.hour=dt.hour;
      }
    }
  }

  /**
  * Update the calendar type according to the Gregorian calendar start
  * date and the date of this object.
  */
  public void updateCalendarType() {
    this.calType=(this.jdCO<=this.jd?SE_GREG_CAL:SE_JUL_CAL);;
  }


  // Date:
  /**
  * Sets a new date for this object.
  * @param newYear the year-part of the new date
  * @param newMonth the month-part of the new date [1-12]
  * @param newDay the day-part of the new date [1-31]
  * @param newHour the hour of the new date
  * @return true
  */
  public boolean setDate(int newYear, int newMonth, int newDay,
                         double newHour) {
    this.year=newYear;
    this.month=newMonth;
    this.day=newDay;
    this.hour=newHour;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    return true;
  }

  /**
  * Sets a new date for this object. The input can be checked, if it is a
  * valid date and can be modified, if not. See parameter "check".
  * @param newYear the year-part of the new date
  * @param newMonth the month-part of the new date [1-12]
  * @param newDay the day-part of the new date [1-31]
  * @param newHour the hour of the new date
  * @param check to see, if the new date is a valid date
  * @return true, if check==true, otherwise return true only, if the date is
  * valid
  */
  public boolean setDate(int newYear, int newMonth, int newDay, double newHour,
                         boolean check) {
    this.year=newYear;
    double oldMonth=this.month;
    double oldDay=this.day;
    this.month=newMonth;
    this.day=newDay;
    this.hour=newHour;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    if (check) {
      IDate dt=swe_revjul(this.jd,this.calType);  // -> erzeugt neues Datum
      this.year=dt.year;
      this.month=dt.month;
      this.day=dt.day;
      this.hour=dt.hour;
      return (this.year==newYear && this.month==oldMonth && this.day==oldDay);
    }
    return true;
  }


  // Year:
  /**
  * Sets the year-part of the date.
  * @param newYear The new year
  * @return true
  */
  public boolean setYear(int newYear) {
    this.year=newYear;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    return true;
  }

  /**
  * Sets the year-part of the date. The input can be checked, if the result
  * is a valid date and can be modified, if not. E.g., the date was 29th of
  * february 2000, and the year gets set to 2001. 2001 does not have a
  * 29th of february, so if parameter check is set to true, it will
  * return false and modify the date to 1st of march 2001.
  * @param newYear The new year
  * @param check check, if the resulting new date is a valid date and
  * adjust the values for day, month or year if necessary
  * @return true, if check==true, otherwise return true only, if the date is
  * valid
  */
  public boolean setYear(int newYear, boolean check) {
    this.year=newYear;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    if (check) {
      double oldMonth=this.month;
      double oldDay=this.day;
      IDate dt=swe_revjul(this.jd,this.calType);  // -> erzeugt neues Datum
      this.year=dt.year;
      this.month=dt.month;
      this.day=dt.day;
      this.hour=dt.hour;
      return (this.year==newYear && this.month==oldMonth && this.day==oldDay);
    }
    return true;
  }


  /**
  * Sets the month-part of the date.
  * @param newMonth The new month
  * @return true
  */
  // Monat:
  public boolean setMonth(int newMonth) {
    this.month=newMonth;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    return true;
  }

  /**
  * Sets the year-part of the date. The input can be checked, if the result
  * is a valid date and can be modified, if not.
  * @param newMonth The new year
  * @param check check, if the resulting new date is a valid date and
  * adjust the values for day, month or year if necessary
  * @return true, if check==true, otherwise return true only, if the date is
  * valid
  * @see SweDate#setYear(int, boolean)
  */
  public boolean setMonth(int newMonth, boolean check) {
    this.month=newMonth;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    if (check) {
      double oldYear=this.year;
      double oldDay=this.day;
      IDate dt=swe_revjul(this.jd,this.calType);  // -> erzeugt neues Datum
      this.year=dt.year;
      this.month=dt.month;
      this.day=dt.day;
      this.hour=dt.hour;
      return (this.year==oldYear && this.month==newMonth && this.day==oldDay);
    }
    return true;
  }


  // Tag:
  /**
  * Sets the day-part of the date.
  * @param newDay The new day
  * @return true
  */
  public boolean setDay(int newDay) {
    this.day=newDay;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);
    return true;
  }

  /**
  * Sets the day-part of the date. The input can be checked, if the result
  * is a valid date and can be modified, if not.
  * @param newDay The new day
  * @param check check, if the resulting new date is a valid date and
  * adjust the values for day, month or year if necessary
  * @return true, if check==true, otherwise return true only, if the date is
  * valid
  * @see SweDate#setYear(int, boolean)
  */
  public boolean setDay(int newDay, boolean check) {
    this.day=newDay;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    if (check) {
      double oldYear=this.year;
      double oldMonth=this.month;
      IDate dt=swe_revjul(this.jd,this.calType);  // -> erzeugt neues Datum
      this.year=dt.year;
      this.month=dt.month;
      this.day=dt.day;
      this.hour=dt.hour;
      return (this.year==oldYear && this.month==oldMonth && this.day==newDay);
    }
    return true;
  }


  // Time:
  /**
  * Sets a new hour.
  * @param newHour The new hour
  * @return true
  */
  public boolean setHour(double newHour) {
    this.hour=newHour;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);
    return true;
  }


  // Datum ueberpruefen:
  /**
  * Checks the date to see, if it is a valid date.
  * @return true, if the date is valid, false, if not
  */
  public boolean checkDate() {
    boolean cd = checkDate(this.year, this.month, this.day, this.hour);
    return cd;
  }

  /**
  * Checks the given date to see, if it is a valid date.
  * @param year the year, for which is to be checked
  * @param month the month, for which is to be checked
  * @param day the day, for which is to be checked
  * @return true, if the date is valid, false, if not
  */
  public boolean checkDate(int year, int month, int day) {
    boolean cd = checkDate(year, month, day, 0.0);
    return cd;
  }

  /**
  * Checks the given date to see, if it is a valid date.
  * @param year the year, for which is to be checked
  * @param month the month, for which is to be checked
  * @param day the day, for which is to be checked
  * @param hour the hour, for which is to be checked
  * @return true, if the date is valid, false, if not
  */
  public boolean checkDate(int year, int month, int day, double hour) {
    double jd=swe_julday(year,month,day,hour,SE_GREG_CAL);
    IDate dt=swe_revjul(jd,SE_GREG_CAL);
    return (dt.year==year && dt.month==month && dt.day==day);
  }

  /**
  * Makes the date to be a valid date.
  */
  public void makeValidDate() {
    double jd=swe_julday(this.year,this.month,this.day,this.hour,SE_GREG_CAL);
    IDate dt=swe_revjul(jd,SE_GREG_CAL);
    this.year=dt.year;
    this.month=dt.month;
    this.day=dt.day;
    this.hour=dt.hour;
  }

  /**
  * Returns the julian day number on which the Gregorian calendar system
  * comes to be in effect.
  */
  public double getGregorianChange() {
    return this.jdCO;
  }

  /**
  * Changes the date of the start of the Gregorian calendar system.
  * This method will keep the date and change the julian day number
  * of the date of this SweDate object if required.
  * @param year The year (in Gregorian system) for the new start date
  * @param month The month (in Gregorian system) for the new start date.
  * Adversely to java.util.Calendar, the month is to be given in the
  * range of 1 for January to 12 for December!
  * @param day The day of the month (in Gregorian system, from 1 to 31)
  * for the new start date
  */
  public void setGregorianChange(int year, int month, int day) {
    this.year = year;
    this.month = month;
    this.day = day;
    deltatIsValid = false;
    this.calType = SE_GREG_CAL;
    if (this.year < year ||
        (this.year == year && this.month < month) ||
        (this.year == year && this.month == month && this.day < day)) {
      this.calType = SE_JUL_CAL;
    }
    this.jdCO = swe_julday(year, month, day, 0., SE_GREG_CAL);
    this.jd = swe_julday(this.year, this.month, this.day, this.hour,
                         this.calType);
  }

  /**
  * Changes the date of the start of the Gregorian calendar system.
  * This method will keep the julian day number and change year,
  * month and day of the date of this SweDate object if required.
  * @param newJDCO The julian day number, on which the Gregorian calendar
  * came into effect.
  */
  public void setGregorianChange(double newJDCO) {
    this.jdCO = newJDCO;
    this.calType = (this.jd>=this.jdCO?SE_GREG_CAL:SE_JUL_CAL);
    IDate dt = swe_revjul(this.jd,this.calType);
    this.year = dt.year;
    this.month = dt.month;
    this.day = dt.day;
    this.hour = dt.hour;
  }
  // End of access to private variables ////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  /**
  * Returns the tidal acceleration used in calculations of delta T.
  * @return Tidal acceleration
  */
  public double getTidalAcc() {
    return this.tid_acc;
  }

  /**
  * Sets the tidal acceleration used in calculations of delta T.
  * @param tid_acc tidal acceleration
  * @see #SE_TIDAL_DE403
  * @see #SE_TIDAL_DE404
  * @see #SE_TIDAL_DE405
  * @see #SE_TIDAL_DE406
  * @see #SE_TIDAL_DE200
  * @see #SE_TIDAL_26
  * @see #SE_TIDAL_DEFAULT
  */
  public void setTidalAcc(double tid_acc) {
    this.tid_acc=tid_acc;
  }

  /**
  * Returns the date, calendar type (gregorian / julian), julian day
  * number and the deltaT value of this object.
  * @return Infos about this object
  */
  public String toString() {
    double hour = getHour();
    String h = (int)hour + ":";
    hour = 60 * (hour - (int)hour);
    h += (int)hour + ":";
    hour = 60 * (hour - (int)hour);
    h += hour ;
               
    return "(YYYY/MM/DD) " +
           getYear() + "/" +
           (getMonth()<10?"0":"") + getMonth() + "/" +
           (getDay()<10?"0":"") + getDay() + ", " +
           h + "h " +
           (getCalendarType()?"(greg)":"(jul)") + "\n" +
           "Jul. Day: " + getJulDay() + "; " +
           "DeltaT: " + getDeltaT();
  }

  // End of public methods /////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////////////
  // Private methods: //////////////////////////////////////////////////////////
  private static synchronized double swe_julday(int year, int month, int day,
                                                double hour, boolean calType) {
    double jd;
    double u,u0,u1,u2;
    u = year;
    if (month < 3) { u -=1; }
    u0 = u + 4712.0;
    u1 = month + 1.0;
    if (u1 < 4) { u1 += 12.0; }
    jd = Math.floor(u0*365.25)
       + Math.floor(30.6*u1+0.000001)
       + day + hour/24.0 - 63.5;
    if (calType == SE_GREG_CAL) {
      u2 = Math.floor(Math.abs(u) / 100) - Math.floor(Math.abs(u) / 400);
      if (u < 0.0) {
        u2 = -u2;
      }
      jd = jd - u2 + 2;
      if ((u < 0.0) && (u/100 == Math.floor(u/100)) &&
                          (u/400 != Math.floor(u/400))) {
        jd -=1;
      }
    }
    return jd;
  }


  //////////////////////////////////////////////////////////////////////
  // Erzeugt aus einem jd/calType Jahr, Monat, Tag und Stunde.        //
  // It does NOT change any global variables.                         //
  //////////////////////////////////////////////////////////////////////
  private synchronized IDate swe_revjul (double jd, boolean calType) {
    IDate dt=new IDate();
    double u0,u1,u2,u3,u4;

    u0 = jd + 32082.5;
    if (calType == SE_GREG_CAL) {
      u1 = u0 + Math.floor (u0/36525.0) - Math.floor (u0/146100.0) - 38.0;
      if (jd >= 1830691.5) {
        u1 +=1;
      }
      u0 = u0 + Math.floor (u1/36525.0) - Math.floor (u1/146100.0) - 38.0;
    }
    u2 = Math.floor (u0 + 123.0);
    u3 = Math.floor ( (u2 - 122.2) / 365.25);
    u4 = Math.floor ( (u2 - Math.floor (365.25 * u3) ) / 30.6001);
    dt.month = (int) (u4 - 1.0);
    if (dt.month > 12) {
      dt.month -= 12;
    }
    dt.day = (int) (u2 - Math.floor (365.25 * u3) - Math.floor (30.6001 * u4));
    dt.year = (int) (u3 + Math.floor ( (u4 - 2.0) / 12.0) - 4800);
    dt.hour = (jd - Math.floor (jd + 0.5) + 0.5) * 24.0;
    return dt;
  }

  ////////////////////////////////////////////////////////////////////////////
  /// deltaT:
  ////////////////////////////////////////////////////////////////////////////
  /* DeltaT = Ephemeris Time - Universal Time, in days.
   * 
   * 1620 - today + a couple of years:
   * ---------------------------------
   * The tabulated values of deltaT, in hundredths of a second,
   * were taken from The Astronomical Almanac 1997, page K8.  The program
   * adjusts for a value of secular tidal acceleration ndot = -25.7376.
   * arcsec per century squared, the value used in JPL's DE403 ephemeris.
   * ELP2000 (and DE200) used the value -23.8946.
   * To change ndot, one can
   * either redefine SE_TIDAL_DEFAULT in swephexp.h
   * or use the routine swe_set_tid_acc() before calling Swiss 
   * Ephemeris.
   * Bessel's interpolation formula is implemented to obtain fourth 
   * order interpolated values at intermediate times.
   *
   * -500 - 1620:
   * ---------------------------------
   * For dates between -500 and 1600, the table given by 
   * Stephenson (1997; p. 515) is used, with linear interpolation.
   * This table is based on an assumed value of ndot = -26.
   * The program adjusts for ndot = -25.7376.
   * For 1600 - 1620, a linear interpolation between the last value
   * of the latter and the first value of the former table is made.
   *
   * before -500:
   * ---------------------------------
   * For times before -600, a formula of Stephenson & Morrison (1995) 
   * (S. Stephenson 1997; p. 508) is used: 
   * dt = 35 * t * t - 20 sec, where t is centuries from 1735 AD.
   * For -600 to -500, a transition from this formula to the Stephenson
   * table has been implemented in order to avoid a jump.
   *
   * future:
   * ---------------------------------
   * For the time after the last tabulated value, we use the formula
   * of Stephenson (1997; p. 507), with a modification that avoids a jump
   * at the end of the tabulated period. A linear term is added that
   * makes a slow transition from the table to the formula over a period
   * of 100 years. (Need not be updated, when table will be enlarged.)
   *
   * References:
   *
   * Stephenson, F. R., and L. V. Morrison, "Long-term changes
   * in the rotation of the Earth: 700 B.C. to A.D. 1980,"
   * Philosophical Transactions of the Royal Society of London
   * Series A 313, 47-70 (1984)
   *
   * Borkowski, K. M., "ELP2000-85 and the Dynamical Time
   * - Universal Time relation," Astronomy and Astrophysics
   * 205, L8-L10 (1988)
   * Borkowski's formula is derived from partly doubtful eclipses 
   * going back to 2137 BC and uses lunar position based on tidal 
   * coefficient of -23.9 arcsec/cy^2.
   *
   * Chapront-Touze, Michelle, and Jean Chapront, _Lunar Tables
   * and Programs from 4000 B.C. to A.D. 8000_, Willmann-Bell 1991
   * Their table agrees with the one here, but the entries are
   * rounded to the nearest whole second.
   *
   * Stephenson, F. R., and M. A. Houlden, _Atlas of Historical
   * Eclipse Maps_, Cambridge U. Press (1986)
   *
   * Stephenson, F.R. & Morrison, L.V., "Long-Term Fluctuations in 
   * the Earth's Rotation: 700 BC to AD 1990", Philosophical 
   * Transactions of the Royal Society of London, 
   * Ser. A, 351 (1995), 165-202. 
   *
   * Stephenson, F. Richard, _Historical Eclipses and Earth's 
   * Rotation_, Cambridge U. Press (1997)
   * 
   * Table from AA for 1620 through today
   * Note, Stephenson and Morrison's table starts at the year 1630.
   * The Chapronts' table does not agree with the Almanac prior to 1630.
   * The actual accuracy decreases rapidly prior to 1780.
   *
   * Jean Meeus, Astronomical Algorithms, 2nd edition, 1998.
   * 
   * For a comprehensive collection of publications and formulae, see:
   * http://www.phys.uu.nl/~vgent/astro/deltatime.htm
   * 
   * For future values of delta t, the following data from the 
   * Earth Orientation Department of the US Naval Observatory can be used:
   * (TAI-UTC) from: ftp://maia.usno.navy.mil/ser7/tai-utc.dat
   * (UT1-UTC) from: ftp://maia.usno.navy.mil/ser7/finals.all
   * file description in: ftp://maia.usno.navy.mil/ser7/readme.finals
   * Delta T = TAI-UT1 + 32.184 sec = (TAI-UTC) - (UT1-UTC) + 32.184 sec
   *
   * Last update of table dt[]: Dieter Koch, 31 March 2005.
   * ATTENTION: Whenever updating this table, do not forget to adjust
   * the macros TABEND and TABSIZ !
   */

  private static final int TABSTART=1620;
  private static final int TABEND=2014;
  private static final int TABSIZ=TABEND-TABSTART+1;

  /* we make the table greater for additional values read from external file */
  private static final int TABSIZ_SPACE=TABSIZ+50;

  private static short dt[]=new short[] {
  /* 1620.0 thru 1659.0 */
  12400, 11900, 11500, 11000, 10600, 10200, 9800, 9500, 9100, 8800,
  8500, 8200, 7900, 7700, 7400, 7200, 7000, 6700, 6500, 6300,
  6200, 6000, 5800, 5700, 5500, 5400, 5300, 5100, 5000, 4900,
  4800, 4700, 4600, 4500, 4400, 4300, 4200, 4100, 4000, 3800,
  /* 1660.0 thru 1699.0 */
  3700, 3600, 3500, 3400, 3300, 3200, 3100, 3000, 2800, 2700,
  2600, 2500, 2400, 2300, 2200, 2100, 2000, 1900, 1800, 1700,
  1600, 1500, 1400, 1400, 1300, 1200, 1200, 1100, 1100, 1000,
  1000, 1000, 900, 900, 900, 900, 900, 900, 900, 900,
  /* 1700.0 thru 1739.0 */
  900, 900, 900, 900, 900, 900, 900, 900, 1000, 1000,
  1000, 1000, 1000, 1000, 1000, 1000, 1000, 1100, 1100, 1100,
  1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100,
  1100, 1100, 1100, 1100, 1200, 1200, 1200, 1200, 1200, 1200,
  /* 1740.0 thru 1779.0 */
  1200, 1200, 1200, 1200, 1300, 1300, 1300, 1300, 1300, 1300,
  1300, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1500, 1500,
  1500, 1500, 1500, 1500, 1500, 1600, 1600, 1600, 1600, 1600,
  1600, 1600, 1600, 1600, 1600, 1700, 1700, 1700, 1700, 1700,
  /* 1780.0 thru 1799.0 */
  1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700,
  1700, 1700, 1600, 1600, 1600, 1600, 1500, 1500, 1400, 1400,
  /* 1800.0 thru 1819.0 */
  1370, 1340, 1310, 1290, 1270, 1260, 1250, 1250, 1250, 1250,
  1250, 1250, 1250, 1250, 1250, 1250, 1250, 1240, 1230, 1220,
  /* 1820.0 thru 1859.0 */
  1200, 1170, 1140, 1110, 1060, 1020, 960, 910, 860, 800,
  750, 700, 660, 630, 600, 580, 570, 560, 560, 560,
  570, 580, 590, 610, 620, 630, 650, 660, 680, 690,
  710, 720, 730, 740, 750, 760, 770, 770, 780, 780,
  /* 1860.0 thru 1899.0 */
  788, 782, 754, 697, 640, 602, 541, 410, 292, 182,
  161, 10, -102, -128, -269, -324, -364, -454, -471, -511,
  -540, -542, -520, -546, -546, -579, -563, -564, -580, -566,
  -587, -601, -619, -664, -644, -647, -609, -576, -466, -374,
  /* 1900.0 thru 1939.0 */
  -272, -154, -2, 124, 264, 386, 537, 614, 775, 913,
  1046, 1153, 1336, 1465, 1601, 1720, 1824, 1906, 2025, 2095,
  2116, 2225, 2241, 2303, 2349, 2362, 2386, 2449, 2434, 2408,
  2402, 2400, 2387, 2395, 2386, 2393, 2373, 2392, 2396, 2402,
  /* 1940.0 thru 1979.0 */
   2433, 2483, 2530, 2570, 2624, 2677, 2728, 2778, 2825, 2871,
   2915, 2957, 2997, 3036, 3072, 3107, 3135, 3168, 3218, 3268,
   3315, 3359, 3400, 3447, 3503, 3573, 3654, 3743, 3829, 3920,
   4018, 4117, 4223, 4337, 4449, 4548, 4646, 4752, 4853, 4959,
  /* 1980.0 thru 1999.0 */
   5054, 5138, 5217, 5296, 5379, 5434, 5487, 5532, 5582, 5630,
   5686, 5757, 5831, 5912, 5998, 6078, 6163, 6230, 6297, 6347,
  /* 2000.0 thru 2005.0 */
   6383, 6409, 6430, 6447, 6457, 6469,       
  /* Extrapolated values, 2006 - 2014 */
                                       6481, 6500, 6520, 6550,
   6600, 6650, 6700, 6750, 6800,
  // Add 50 empty elements, see constant TABSIZ_SPACE above!
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  };
  /* Table for -500 through 1600, from Stephenson & Morrison (1995).
   *
   * The first value for -550 has been added from Borkowski
   * in order to make this table fit with the Borkowski formula
   * for times before -550.
   */
//C only://  private static final int TAB2_SIZ=43;
  private static final int TAB2_START=-500;
  private static final int TAB2_END=1600;
  private static short dt2[]=new short[] {
  /* -500  -450  -400  -350  -300  -250  -200  -150  -100   -50*/
    16800,16000,15300,14600,14000,13400,12800,12200,11600,11100,
  /*    0    50   100   150   200   250   300   350   400   450*/
    10600,10100, 9600, 9100, 8600, 8200, 7700, 7200, 6700, 6200,
  /*  500   550   600   650   700   750   800   850   900   950*/
     5700, 5200, 4700, 4300, 3800, 3400, 3000, 2600, 2200, 1900,
  /* 1000  1050  1100  1150  1200  1250  1300  1350  1400  1450*/
     1600, 1350, 1100,  900,  750,  600,  470,  380,  300,  230,
  /* 1500  1550  1600 */
      180,  140,  110,
  };
  /* returns DeltaT (ET - UT) in days
   * double tjd 	= 	julian day in UT
   */
  private synchronized double calc_deltaT(double tjd) {
    double sdt = calc_deltaT(tjd, this.tid_acc);
    return sdt;
  }
  private static synchronized double calc_deltaT(double tjd, double tid_acc) {
    double ans = 0., ans2, ans3;
    double p, B=0., Y=0., dd; // To remove Java warning of "maybe" not initialized
    int d[]=new int[6];
    int i, iy, k;
    /* read additional values from swedelta.txt */
    int tabsiz = init_dt();
    int tabend = TABSTART + tabsiz - 1;
    Y = 2000.0 + (tjd - SwephData.J2000)/365.25;
    /* before -500:
     * formula by Stephenson (1997; p. 508) but adjusted to fit the starting
     * point of table dt2 (Stephenson 1997). */
    if( Y < TAB2_START ) {
      B = (Y - 1735) * 0.01;
      ans = -20 + 35 * B * B;
      ans = adjust_for_tidacc(tid_acc, ans, Y);
      /* transition from formula to table over 100 years */
      if (Y >= TAB2_START - 100) {
        /* starting value of table dt2: */
        ans2 = adjust_for_tidacc(tid_acc, dt2[0], TAB2_START);
        /* value of formula at epoch TAB2_START */
        B = (TAB2_START - 1735) * 0.01;
        ans3 = -20 + 35 * B * B;
        ans3 = adjust_for_tidacc(tid_acc, ans3, Y);
        dd = ans3 - ans2;
        B = (Y - (TAB2_START - 100)) * 0.01;
        /* fit to starting point of table dt2. */
        ans = ans - dd * B;
      }
    }
    /* between -500 and 1600:
     * linear interpolation between values of table dt2 (Stephenson 1997) */
    if (Y >= TAB2_START && Y < TAB2_END) {
      p = Math.floor(Y);
      iy = (int) ((p - TAB2_START) / 50.0);
      dd = (Y - (TAB2_START + 50 * iy)) / 50.0;
      ans = dt2[iy] + (dt2[iy+1] - dt2[iy]) * dd;
      /* correction for tidal acceleration used by our ephemeris */
      ans = adjust_for_tidacc(tid_acc, ans, Y);
    }
    /* between 1600 and 1620:
     * linear interpolation between 
     * end of table dt2 and start of table dt */
    if (Y >= TAB2_END && Y < TABSTART) { 
      B = TABSTART - TAB2_END;
      iy = (TAB2_END - TAB2_START) / 50;
      dd = (Y - TAB2_END) / B;
      ans = dt2[iy] + dd * (dt[0] / 100.0 - dt2[iy]);
      ans = adjust_for_tidacc(tid_acc, ans, Y);
    }
    /* 1620 - today + a few years (tabend):
     * Besselian interpolation from tabulated values in table dt.
     * See AA page K11.
     */
    if (Y >= TABSTART && Y <= tabend) {
      /* Index into the table.
       */
      p = Math.floor(Y);
      iy = (int) (p - TABSTART);
      /* Zeroth order estimate is value at start of year
       */
      ans = dt[iy];
      k = iy + 1;
      if( k >= tabsiz )
        return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend); /* No data, can't go on. */
      /* The fraction of tabulation interval
       */
      p = Y - p;
      /* First order interpolated value
       */
      ans += p*(dt[k] - dt[iy]);
      if( (iy-1 < 0) || (iy+2 >= tabsiz) )
        return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend); /* can't do second differences */
      /* Make table of first differences
       */
      k = iy - 2;
      for( i=0; i<5; i++ ) {
        if( (k < 0) || (k+1 >= tabsiz) ) 
          d[i] = 0;
        else
          d[i] = dt[k+1] - dt[k];
        k += 1;
      }
      /* Compute second differences
       */
      for( i=0; i<4; i++ )
        d[i] = d[i+1] - d[i];
      B = 0.25*p*(p-1.0);
      ans += B*(d[1] + d[2]);
//    printf( "B %.4lf, ans %.4lf\n", B, ans );
      if( iy+2 >= tabsiz )
        return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend);
      /* Compute third differences
       */
      for( i=0; i<3; i++ )
        d[i] = d[i+1] - d[i];
      B = 2.0*B/3.0;
      ans += (p-0.5)*B*d[1];
//    printf( "B %.4lf, ans %.4lf\n", B*(p-0.5), ans );
      if( (iy-2 < 0) || (iy+3 > tabsiz) )
        return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend);
      /* Compute fourth differences
       */
      for( i=0; i<2; i++ )
        d[i] = d[i+1] - d[i];
      B = 0.125*B*(p+1.0)*(p-2.0);
      ans += B*(d[0] + d[1]);
//    printf( "B %.4lf, ans %.4lf\n", B, ans );
    }

    return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend);
  }

  private synchronized static double deltatIsDone(double ans, double Y,
                                                  double B, double tid_acc, int tabsiz, int tabend) {
// //#ifdef TRACE0
//     // Trace.level++; Don't increment here, as the calling method calc_deltat() does not decrement on return!
//     Trace.trace(Trace.level, "SweDate.deltatIsDone(double, double, double, double, int, int)");
// //#endif /* TRACE0 */
    double ans2, ans3, B2, dd;
    if (Y >= TABSTART && Y <= tabend) {
      ans *= 0.01;
      ans = adjust_for_tidacc(tid_acc, ans, Y);
    }
    /* today - :
     * Formula Stephenson (1997; p. 507),
     * with modification to avoid jump at end of AA table,
     * similar to what Meeus 1998 had suggested.
     * Slow transition within 100 years.
     */
    if (Y > tabend) {
      B = 0.01 * (Y - 1820);
      ans = -20 + 31 * B * B;
      /* slow transition from tabulated values to Stephenson formula: */
      if (Y <= tabend+100) {
        B2 = 0.01 * (tabend - 1820);
        ans2 = -20 + 31 * B2 * B2;
        ans3 = dt[tabsiz-1] * 0.01;
        dd = (ans2 - ans3);
        ans += dd * (Y - (tabend + 100)) * 0.01;
      }
    }
    return ans / 86400.0;
  }


  /* Read delta t values from external file.
   * record structure: year(whitespace)delta_t in 0.01 sec.
   */
  private static int init_dt() {
    FilePtr fp = null;
    int year;
    int tab_index;
    int tabsiz;
    int i;
    String s;
    if (!init_dt_done) {
      init_dt_done = true;
      /* no error message if file is missing */
      try {
        if ((fp = sw.swi_fopen(-1, "sedeltat.txt", sw.swed.ephepath, null)) == null) {
          return TABSIZ;  // I think, I could miss this one...
        }
      } catch (SwissephException se) {
        return TABSIZ;
      }
      try {
        while ((s=fp.readLine()) != null) {
          s.trim();
          if (s.length() == 0 || s.charAt(0) == '#') {
            continue;
          }
          year = SwissLib.atoi(s);
          tab_index = year - TABSTART;
          /* table space is limited. no error msg, if exceeded */
          if (tab_index >= TABSIZ_SPACE)
            continue;
          if (s.length() > 4) {
            s = s.substring(4).trim();
          }
          dt[tab_index] = (short)(SwissLib.atoi(s) * 100 + 0.5);
        }
      } catch (java.io.IOException e) {
      }
      try { fp.close(); } catch (java.io.IOException e) {}
    }
    /* find table size */
    tabsiz = 2001 - TABSTART + 1;
    for (i = tabsiz - 1; i < TABSIZ_SPACE; i++) {
      if (dt[i] == 0)
        break;
      else
        tabsiz++;
    }
    tabsiz--;
    return tabsiz;
  }
 
  /* Astronomical Almanac table is corrected by adding the expression
   *     -0.000091 (ndot + 26)(year-1955)^2  seconds
   * to entries prior to 1955 (AA page K8), where ndot is the secular
   * tidal term in the mean motion of the Moon.
   *
   * Entries after 1955 are referred to atomic time standards and
   * are not affected by errors in Lunar or planetary theory.
   */
  private static double adjust_for_tidacc(double tid_acc_local, double ans, double Y) {
    double B;
    if( Y < 1955.0 ) {
      B = (Y - 1955.0);
      ans += -0.000091 * (tid_acc_local + 26.0) * B * B;
    }
    return ans;
  }

  /**
  * Sets the year, month, day, hour, calType and jd fields of this
  * object.
  */
  private void initDateFromJD(double jd, boolean calType) {
    this.jd=jd;
    this.calType=calType;
    IDate dt=swe_revjul(jd, calType);
    this.year=dt.year;
    this.month=dt.month;
    this.day=dt.day;
    this.hour=dt.hour;
  }

  /**
  * Sets the year, month, day, hour, calType and jd fields of this
  * object.
  */
  private void setFields(int year, int month, int day, double hour) {
    // Get year, month, day of jdCO and compare to given date to
    // find out about the calendar system:
    IDate dt=swe_revjul(jdCO,SE_GREG_CAL);
    boolean calType = SE_GREG_CAL;
    if (dt.year > year ||
        (dt.year == year && dt.month > month) ||
        (dt.year == year && dt.month == month && dt.day > day)) {
      calType = SE_JUL_CAL;
    }
    setFields(year, month, day, hour, calType);
  }

  /**
  * Sets the year, month, day, hour, calType and jd fields of this
  * object.
  */
  private void setFields(int year, int month, int day, double hour,
        boolean calType) {
    this.year=year;
    this.month=month;
    this.day=day;
    this.hour=hour;
    this.calType=calType;
    this.jd=swe_julday(year, month, day, hour, calType);
  }

} // end of class SweDate


class IDate {
  public int year;
  public int month;
  public int day;
  public double hour;
}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


/**
* This class does all the calculations that are related to astrological
* houses.
* <P><I><B>You will find the complete documentation for the original
* SwissEphemeris package at <A HREF="http://www.astro.ch/swisseph/sweph_g.htm">
* http://www.astro.ch/swisseph/sweph_g.htm</A>. By far most of the information 
* there is directly valid for this port to Java as well.</B></I>
* @version 1.0.0a
*/
class SweHouse {

  static final double MILLIARCSEC=1.0 / 3600000.0;

  SwissLib sl=null;
  SwissEph sw=null;
  SwissData swed=null;

  /**
  * Constructs a new SweHouse object.
  */
  SweHouse() {
    sl   = new SwissLib();
    sw   = new SwissEph();
    swed = new SwissData();
  }

  /**
  * Constructs a new SweHouse object by using the given objects. If some or
  * all objects are null, they will be automatically instantiated here.
  * @param sl A SwissLib object that might be already available.
  * @param sw A SwissEph object that might be already available.
  * @param swed A SwissData object that might be already available.
  */
  SweHouse(SwissLib sl, SwissEph sw, SwissData swed) {
    this.sl   = sl;
    this.sw   = sw;
    this.swed = swed;
    if (this.sl   ==null) { this.sl   =new SwissLib(); }
    if (this.sw   ==null) { this.sw   =new SwissEph(); }
    if (this.swed ==null) { this.swed =new SwissData(); }
  }


  static final double VERY_SMALL=1E-10;

// Hmmm? Never used anywhere...
//  public double degtocs(double x) {
//    return sl.swe_d2l((x) * SwissData.DEG);
//  }

// Hmmm? Never used anywhere...
//  public double cstodeg(double x) {
//    return (double)((x) * SwissData.CS2DEG);
//  }

  private double sind(double x) {
    return Math.sin(x * SwissData.DEGTORAD);
  }
  private double cosd(double x) {
    return Math.cos(x * SwissData.DEGTORAD);
  }
  private double tand(double x) {
    return Math.tan(x * SwissData.DEGTORAD);
  }
  private double asind(double x) {
    return (Math.asin(x) * SwissData.RADTODEG);
  }
//Never used anywhere//  private double acosd(double x) {
//Never used anywhere//    return (Math.acos(x) * SwissData.RADTODEG);
//Never used anywhere//  }
  private double atand(double x) {
    return (Math.atan(x) * SwissData.RADTODEG);
  }
//Never used anywhere//  private double atan2d(double y, double x) {
//Never used anywhere//    return (Math.atan2(y, x) * SwissData.RADTODEG);
//Never used anywhere//  }



  /* housasp.c
   * cusps are returned in double cusp[13],
   *                           or cusp[37] with house system 'G':
   * cusp[1...12]        houses 1 - 12
   * additional points are returned in ascmc[10].
   * ascmc[0] = ascendant
   * ascmc[1] = mc
   * ascmc[2] = armc
   * ascmc[3] = vertex
   * ascmc[4] = equasc            * "equatorial ascendant" *
   * ascmc[5] = coasc1            * "co-ascendant" (W. Koch) *
   * ascmc[6] = coasc2            * "co-ascendant" (M. Munkasey) *
   * ascmc[7] = polasc            * "polar ascendant" (M. Munkasey) *
   */
  /**
  /**
  * Calculates the house positions and other vital points. The possible
  * house systems (parameter &quot;hsys&quot;) are:<P><CODE><BLOCKQUOTE>
  * (int)'P'&nbsp;&nbsp;Placidus<BR>
  * (int)'K'&nbsp;&nbsp;Koch<BR>
  * (int)'O'&nbsp;&nbsp;Porphyrius<BR>
  * (int)'R'&nbsp;&nbsp;Regiomontanus<BR>
  * (int)'C'&nbsp;&nbsp;Campanus<BR>
  * (int)'A'&nbsp;&nbsp;equal (cusp 1 is ascendent)<BR>
  * (int)'E'&nbsp;&nbsp;equal (cusp 1 is ascendent)<BR>
  * (int)'V'&nbsp;&nbsp;Vehlow equal (asc. in middle of house 1)<BR>
  * (int)'X'&nbsp;&nbsp;axial rotation system/ Meridian houses<BR>
  * (int)'H'&nbsp;&nbsp;azimuthal or horizontal system<BR>
  * (int)'T'&nbsp;&nbsp;Polich/Page ('topocentric' system)<BR>
  * (int)'B'&nbsp;&nbsp;Alcabitius
  * </BLOCKQUOTE></CODE><P>
  * The parameter ascmc is defined as double[10] and will return the
  * following points:<P><CODE><BLOCKQUOTE>
  * ascmc[0] = ascendant<BR>
  * ascmc[1] = mc<BR>
  * ascmc[2] = armc (sidereal time)<BR>
  * ascmc[3] = vertex<BR>
  * ascmc[4] = equatorial ascendant<BR>
  * ascmc[5] = co-ascendant (Walter Koch)<BR>
  * ascmc[6] = co-ascendant (Michael Munkasey)<BR>
  * ascmc[7] = polar ascendant (Michael Munkasey)<BR>
  * ascmc[8] = reserved for future use<BR>
  * ascmc[9] = reserved for future use
  * </BLOCKQUOTE></CODE>
  * 
  * As Koch and Placidus don't work in the polar circle, the calculation is
  * done in that case by swapping MC/IC so that MC is always before AC in
  * the zodiac. Then the quadrants are divided into 3 equal parts.<P>
  * Calculates the house positions and other vital points.<p>
  * <b>Note:</b>This routine is identical to the routine swe_houses_ex() in
  * the original C code, and <b>not</b> to swe_houses()!<p>
  * @param tjd_ut The Julian Day number in UT
  * @param iflag An additional flag for calculation, e.g. 0 or SEFLG_SIDEREAL
  * and / or SEFLG_RADIANS.
  * @param geolat The latitude on earth, for which the calculation has to be
  * done.
  * @param geolong The longitude on earth, for which the calculation has to be
  * done.
  * @param hsys The house system as a character given as an integer.
  * @param cusp The house cusps are returned here in cusp[1...12] for
  * the house 1 to 12. It has to be a double[13].
  * @param ascmc The special points like ascendent etc. are returned here.
  * It has to be a double[10].
  * @see swisseph.SweConst#SEFLG_RADIANS
  * @see swisseph.SweConst#SEFLG_SIDEREAL
  * @see swisseph.SwissEph#swe_set_sid_mode(int, double, double)
  */
  int swe_houses(double tjd_ut,
                 int iflag,
                 double geolat,
                 double geolon,
                 int hsys,
                 double[] cusp,
                 double[] ascmc) {
    return swe_houses(tjd_ut, iflag, geolat, geolon, hsys, cusp, ascmc, 0);
  }
  int swe_houses(double tjd_ut,
                 int iflag,
                 double geolat,
                 double geolon,
                 int hsys,
                 double[] cusp,
                 double[] ascmc,
                 int aOffs) {
    int i, retc = 0;
    double armc, eps_mean, nutlo[]=new double[2];
    double tjde = tjd_ut + SweDate.getDeltaT(tjd_ut);
    SidData sip = swed.sidd;
    int ito;
    if (Character.toUpperCase((char)hsys) == 'G') {
      ito = 36;
    } else {
      ito = 12;
    }
    if ((iflag & SweConst.SEFLG_SIDEREAL)!=0 && !swed.ayana_is_set) {
      sw.swe_set_sid_mode(SweConst.SE_SIDM_FAGAN_BRADLEY, 0, 0);
    }
    eps_mean = sl.swi_epsiln(tjde) * SwissData.RADTODEG;
    sl.swi_nutation(tjde, nutlo);
    for (i = 0; i < 2; i++)
      nutlo[i] *= SwissData.RADTODEG;
      /*houses_to_sidereal(tjde, geolat, hsys, eps, cusp, ascmc, iflag);*/
    armc = sl.swe_degnorm(sl.swe_sidtime0(tjd_ut, eps_mean + nutlo[1], nutlo[0]) * 15 + geolon);
    if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
      if ((sip.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0) {
        retc = sidereal_houses_ecl_t0(tjde, armc, eps_mean + nutlo[1], nutlo, geolat, hsys, cusp, ascmc, aOffs);
      } else if ((sip.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
        retc = sidereal_houses_ssypl(tjde, armc, eps_mean + nutlo[1], nutlo, geolat, hsys, cusp, ascmc, aOffs);
      } else {
        retc = sidereal_houses_trad(tjde, armc, eps_mean + nutlo[1], nutlo[0], geolat, hsys, cusp, ascmc, aOffs);
      }
    } else {
      retc = swe_houses_armc(armc, geolat, eps_mean + nutlo[1], hsys, cusp, ascmc, aOffs);
    }
    if ((iflag & SweConst.SEFLG_RADIANS)!=0) {
      for (i = 1; i <= ito; i++)
        cusp[i] *= SwissData.DEGTORAD;
      for (i = 0; i < SweConst.SE_NASCMC; i++)
        ascmc[i+aOffs] *= SwissData.DEGTORAD;
    }
    return retc;
  }

  /*
   * houses to sidereal
   * ------------------
   * there are two methods:
   * a) the traditional one
   *    houses are computed tropically, then nutation and the ayanamsa
   *    are subtracted.
   * b) the projection on the ecliptic of t0
   *    The house computation is then as follows:
   *
   * Be t the birth date and t0 the epoch at which ayanamsa = 0.
   * 1. Compute the angle between the mean ecliptic at t0 and
   *    the true equator at t.
   *    The intersection point of these two circles we call the
   *    "auxiliary vernal point", and the angle between them the
   *    "auxiliary obliquity".
   * 2. Compute the distance of the auxiliary vernal point from the
   *    vernal point at t. (this is a section on the equator)
   * 3. subtract this value from the armc of t = aux. armc.
   * 4. Compute the axes and houses for this aux. armc and aux. obliquity.
   * 5. Compute the distance between the auxiliary vernal point and the
   *    vernal point at t0 (this is the ayanamsa at t, measured on the
   *    ecliptic of t0)
   * 6. subtract this distance from all house cusps.
   * 7. subtract ayanamsa_t0 from all house cusps.
   */
  private int sidereal_houses_ecl_t0(double tjde,
                                     double armc,
                                     double eps,
                                     double[] nutlo,
                                     double lat,
                                     int hsys,
                                     double[] cusp,
                                     double[] ascmc,
                                     int aOffs) {
    int i, j, retc = SweConst.OK;
    double x[]=new double[6], xvpx[]=new double[6], x2[]=new double[6], epst0,
           xnorm[]=new double[6];
    double rxy, rxyz, c2, epsx, sgn, fac, dvpx, dvpxe;
    double armcx;
    SidData sip = swed.sidd;
    int ito;
    if (Character.toUpperCase((char)hsys) == 'G') {
      ito = 36;
    } else {
      ito = 12;
    }
    /* epsilon at t0 */
    epst0 = sl.swi_epsiln(sip.t0);
    /* cartesian coordinates of an imaginary moving body on the
     * the mean ecliptic of t0; we take the vernal point: */
    x[0] = x[4] = 1;
    x[1] = x[2] = x[3] = x[5] = 0;
    /* to equator */
    sl.swi_coortrf(x, x, -epst0);
    sl.swi_coortrf(x, 3, x, 3, -epst0);
    /* to tjd_et */
    sl.swi_precess(x, sip.t0, SwephData.J_TO_J2000);
    sl.swi_precess(x, tjde, SwephData.J2000_TO_J);
    sl.swi_precess(x, 3, sip.t0, SwephData.J_TO_J2000);
    sl.swi_precess(x, 3, tjde, SwephData.J2000_TO_J);
    /* to true equator of tjd_et */
    sl.swi_coortrf(x, x, (eps - nutlo[1]) * SwissData.DEGTORAD);
    sl.swi_coortrf(x, 3, x, 3, (eps - nutlo[1]) * SwissData.DEGTORAD);
    sl.swi_cartpol_sp(x, 0, x, 0);
    x[0] += nutlo[0] * SwissData.DEGTORAD;
    sl.swi_polcart_sp(x, x);
    sl.swi_coortrf(x, x, -eps * SwissData.DEGTORAD);
    sl.swi_coortrf(x, 3, x, 3, -eps * SwissData.DEGTORAD);
    /* now, we have the moving point precessed to tjd_et.
     * next, we compute the auxiliary epsilon: */
    sl.swi_cross_prod(x, 0, x, 3, xnorm, 0);
    rxy =  xnorm[0] * xnorm[0] + xnorm[1] * xnorm[1];
    c2 = (rxy + xnorm[2] * xnorm[2]);
    rxyz = Math.sqrt(c2);
    rxy = Math.sqrt(rxy);
    epsx = Math.asin(rxy / rxyz) * SwissData.RADTODEG;           /* 1a */
    /* auxiliary vernal point */
    if (Math.abs(x[5]) < 1e-15) {
      x[5] = 1e-15;
    }
    fac = x[2] / x[5];
    sgn = x[5] / Math.abs(x[5]);
    for (j = 0; j <= 2; j++)
      xvpx[j] = (x[j] - fac * x[j+3]) * sgn;      /* 1b */
    /* distance of the auxiliary vernal point from
     * the zero point at tjd_et (a section on the equator): */
    sl.swi_cartpol(xvpx, x2);
    dvpx = x2[0] * SwissData.RADTODEG;                      /* 2 */
    /* auxiliary armc */
    armcx = sl.swe_degnorm(armc - dvpx);        /* 3 */
    /* compute axes and houses: */
    retc = swe_houses_armc(armcx, lat, epsx, hsys, cusp, ascmc, aOffs);  /* 4 */
    /* distance between auxiliary vernal point and
     * vernal point of t0 (a section on the sidereal plane) */
    dvpxe = Math.acos(sl.swi_dot_prod_unit(x, xvpx)) * SwissData.RADTODEG;  /* 5 */
    if (tjde < sip.t0) {
      dvpxe = -dvpxe;
    }
    for (i = 1; i <= ito; i++)                     /* 6, 7 */
      cusp[i] = sl.swe_degnorm(cusp[i] - dvpxe - sip.ayan_t0);
    for (i = 0; i <= SweConst.SE_NASCMC; i++)
      ascmc[aOffs+i] = sl.swe_degnorm(ascmc[aOffs+i] - dvpxe - sip.ayan_t0);
    return retc;
  }

  /*
   * Be t the birth date and t0 the epoch at which ayanamsa = 0.
   * 1. Compute the angle between the solar system rotation plane and
   *    the true equator at t.
   *    The intersection point of these two circles we call the
   *    "auxiliary vernal point", and the angle between them the
   *    "auxiliary obliquity".
   * 2. Compute the distance of the auxiliary vernal point from the
   *    zero point at t. (this is a section on the equator)
   * 3. subtract this value from the armc of t = aux. armc.
   * 4. Compute the axes and houses for this aux. armc and aux. obliquity.
   * 5. Compute the distance between the auxiliary vernal point at t
   *    and the zero point of the solar system plane J2000
   *    (a section measured on the solar system plane)
   * 6. subtract this distance from all house cusps.
   * 7. compute the ayanamsa of J2000 on the solar system plane,
   *    referred to t0
   * 8. subtract ayanamsa_t0 from all house cusps.
   * 9. subtract ayanamsa_2000 from all house cusps.
   */
  private int sidereal_houses_ssypl(double tjde,
                                    double armc,
                                    double eps,
                                    double[] nutlo,
                                    double lat,
                                    int hsys,
                                    double[] cusp,
                                    double[] ascmc,
                                    int aOffs) {
    int i, j, retc = SweConst.OK;
    double x[]=new double[6], x0[]=new double[6], xvpx[]=new double[6],
           x2[]=new double[6], epst0, xnorm[]=new double[6];
    double rxy, rxyz, c2, epsx, eps2000, sgn, fac, dvpx, dvpxe, x00;
    double armcx;
    SidData sip = swed.sidd;
    int ito;
    if (Character.toUpperCase((char)hsys) == 'G') {
      ito = 36;
    } else {
      ito = 12;
    }
    /* epsilon at t0 */
    epst0 = sl.swi_epsiln(sip.t0);
    eps2000 = sl.swi_epsiln(SwephData.J2000);
    /* cartesian coordinates of the zero point on the
     * the solar system rotation plane */
    x[0] = x[4] = 1;
    x[1] = x[2] = x[3] = x[5] = 0;
    /* to ecliptic 2000 */
    sl.swi_coortrf(x, x, -SwephData.SSY_PLANE_INCL);
    sl.swi_coortrf(x, 3, x, 3, -SwephData.SSY_PLANE_INCL);
    sl.swi_cartpol_sp(x, 0, x, 0);
    x[0] += SwephData.SSY_PLANE_NODE_E2000;
    sl.swi_polcart_sp(x, x);
    /* to equator 2000 */
    sl.swi_coortrf(x, x, -eps2000);
    sl.swi_coortrf(x, 3, x, 3, -eps2000);
    /* to mean equator of t */
    sl.swi_precess(x, tjde, SwephData.J2000_TO_J);
    sl.swi_precess(x, 3, tjde, SwephData.J2000_TO_J);
    /* to true equator of t */
    sl.swi_coortrf(x, x, (eps - nutlo[1]) * SwissData.DEGTORAD);
    sl.swi_coortrf(x, 3, x, 3, (eps - nutlo[1]) * SwissData.DEGTORAD);
    sl.swi_cartpol_sp(x, 0, x, 0);
    x[0] += nutlo[0] * SwissData.DEGTORAD;
    sl.swi_polcart_sp(x, x);
    sl.swi_coortrf(x, x, -eps * SwissData.DEGTORAD);
    sl.swi_coortrf(x, 3, x, 3, -eps * SwissData.DEGTORAD);
    /* now, we have the moving point precessed to tjd_et.
     * next, we compute the auxiliary epsilon: */
    sl.swi_cross_prod(x, 0, x, 3, xnorm, 0);
    rxy =  xnorm[0] * xnorm[0] + xnorm[1] * xnorm[1];
    c2 = (rxy + xnorm[2] * xnorm[2]);
    rxyz = Math.sqrt(c2);
    rxy = Math.sqrt(rxy);
    epsx = Math.asin(rxy / rxyz) * SwissData.RADTODEG;           /* 1a */
    /* auxiliary vernal point */
    if (Math.abs(x[5]) < 1e-15) {
      x[5] = 1e-15;
    }
    fac = x[2] / x[5];
    sgn = x[5] / Math.abs(x[5]);
    for (j = 0; j <= 2; j++)
      xvpx[j] = (x[j] - fac * x[j+3]) * sgn;      /* 1b */
    /* distance of the auxiliary vernal point from
     * mean vernal point at tjd_et (a section on the equator): */
    sl.swi_cartpol(xvpx, x2);
    dvpx = x2[0] * SwissData.RADTODEG;                      /* 2 */
    /* auxiliary armc */
    armcx = sl.swe_degnorm(armc - dvpx);        /* 3 */
    /* compute axes and houses: */
    retc = swe_houses_armc(armcx, lat, epsx, hsys, cusp, ascmc, aOffs);  /* 4 */
    /* distance between the auxiliary vernal point at t and
     * the sidereal zero point of 2000 at t
     * (a section on the sidereal plane).
     */
    dvpxe = Math.acos(sl.swi_dot_prod_unit(x, xvpx)) * SwissData.RADTODEG;  /* 5 */
                  /* (always positive for dates after 5400 bc) */
    dvpxe -= SwephData.SSY_PLANE_NODE * SwissData.RADTODEG;
    /* ayanamsa between t0 and J2000, measured on solar system plane: */
    /* position of zero point of t0 */
    x0[0] = 1;
    x0[1] = x0[2] = 0;
    /* zero point of t0 in J2000 system */
    if (sip.t0 != SwephData.J2000) {
      sl.swi_precess(x0, sip.t0, SwephData.J_TO_J2000);
    }
    /* zero point to ecliptic 2000 */
    sl.swi_coortrf(x0, x0, eps2000);
    /* to solar system plane */
    sl.swi_cartpol(x0, x0);
    x0[0] -= SwephData.SSY_PLANE_NODE_E2000;
    sl.swi_polcart(x0, x0);
    sl.swi_coortrf(x0, x0, SwephData.SSY_PLANE_INCL);
    sl.swi_cartpol(x0, x0);
    x0[0] += SwephData.SSY_PLANE_NODE;
    x00 = x0[0] * SwissData.RADTODEG;                       /* 7 */
    for (i = 1; i <= ito; i++)                     /* 6, 8, 9 */
      cusp[i] = sl.swe_degnorm(cusp[i] - dvpxe - sip.ayan_t0 - x00);
    for (i = 0; i <= SweConst.SE_NASCMC; i++)
      ascmc[aOffs+i] = sl.swe_degnorm(ascmc[aOffs+i] - dvpxe - sip.ayan_t0 - x00);
    return retc;
  }

  /* common simplified procedure */
  private int sidereal_houses_trad(double tjde,
                                   double armc,
                                   double eps,
                                   double nutl,
                                   double lat,
                                   int hsys,
                                   double[] cusp,
                                   double[] ascmc,
                                   int aOffs) {
    int i, retc = SweConst.OK;
    double ay;
    int ito;
    if (Character.toUpperCase((char)hsys) == 'G') {
      ito = 36;
    } else {
      ito = 12;
    }
    retc = swe_houses_armc(armc, lat, eps, hsys, cusp, ascmc, aOffs);
    ay = sw.swe_get_ayanamsa(tjde);
    for (i = 1; i <= ito; i++)
      cusp[i] = sl.swe_degnorm(cusp[i] - ay - nutl);
    for (i = 0; i < SweConst.SE_NASCMC; i++) {
      if (i == 2) /* armc */ {
        continue;
      }
      ascmc[aOffs+i] = sl.swe_degnorm(ascmc[aOffs+i] - ay - nutl);
    }
    return retc;
  }

  /*
   * this function is required for very special computations
   * where no date is given for house calculation,
   * e.g. for composite charts or progressive charts.
   * cusps are returned in double cusp[13],
   *                           or cusp[37] with house system 'G'.
   * cusp[1...12] houses 1 - 12
   * additional points are returned in ascmc[10].
   * ascmc[0] = ascendant
   * ascmc[1] = mc
   * ascmc[2] = armc
   * ascmc[3] = vertex
   * ascmc[4] = equasc            * "equatorial ascendant" *
   * ascmc[5] = coasc1            * "co-ascendant" (Walter Koch) *
   * ascmc[6] = coasc2            * "co-ascendant" (Michael Munkasey) *
   * ascmc[7] = polasc            * "polar ascendant" (Michael Munkasey) *
   */
  /**
  * Calculates the house positions and other vital points. You would use
  * this method instead of swe_houses, if you do not have a date available,
  * but just the ARMC (==sidereal time).
  * @param armc The ARMC (==sidereal time)
  * @param geolat The latitude on earth, for which the calculation has to be
  * done.
  * @param eps The ecliptic obliquity (e.g. xx[0] of swe_calc(...))
  * @param hsys The house system as a character given as an integer.
  * @param cusp The house cusps are returned here in cusp[1...12] for
  * the house 1 to 12.
  * @param ascmc The special points like ascendent etc. are returned here.
  * @see #swe_houses(double, int, double, double, int, double[], double[])
  * @see swisseph.SwissEph#swe_calc
  * @return SweConst.OK (==0) or SweConst.ERR (==-1), if an error occured.
  */
  int swe_houses_armc(double armc,
                      double geolat,
                      double eps,
                      int hsys,
                      double cusp[],
                      double ascmc[],
                      int aOffs) {
    Houses h=new Houses();
    int i, retc = 0;
    int ito;
    if (Character.toUpperCase((char)hsys) == 'G') {
      ito = 36;
    } else {
      ito = 12;
    }
    armc = sl.swe_degnorm(armc);
    retc = CalcH(armc,
                 geolat,
                 eps,
                 (char)hsys, 2, h);
    cusp[0] = 0;
    for (i = 1; i <= ito; i++) {
      cusp[i] = h.cusp[i];
    }
    ascmc[aOffs+0] = h.ac;        /* Asc */
    ascmc[aOffs+1] = h.mc;        /* Mid */
    ascmc[aOffs+2] = armc;
    ascmc[aOffs+3] = h.vertex;
    ascmc[aOffs+4] = h.equasc;
    ascmc[aOffs+5] = h.coasc1;  /* "co-ascendant" (Walter Koch) */
    ascmc[aOffs+6] = h.coasc2;  /* "co-ascendant" (Michael Munkasey) */
    ascmc[aOffs+7] = h.polasc;  /* "polar ascendant" (Michael Munkasey) */
    for (i = SweConst.SE_NASCMC; i < 10; i++)
      ascmc[aOffs+i] = 0;
    return retc;
  }

  private int CalcH(double th, double fi, double ekl, char hsy,
                    int iteration_count, Houses hsp )
  /* *********************************************************
   *  Arguments: th = sidereal time (angle 0..360 degrees
   *             hsy = letter code for house system;
   *                   A  equal
   *                   E  equal
   *                   B  Alcabitius
   *                   C  Campanus
   *                   H  horizon / azimut
   *                   K  Koch
   *                   O  Porphyry
   *                   P  Placidus
   *                   R  Regiomontanus
   *                   V  equal Vehlow
   *                   X  axial rotation system/ Meridian houses
   *                   G  36 Gauquelin sectors
   *                   U  Krusinski
   *             fi = geographic latitude
   *             ekl = obliquity of the ecliptic
   *             iteration_count = number of iterations in
   *             Placidus calculation; can be 1 or 2.
   * *********************************************************
   *  Koch and Placidus don't work in the polar circle.
   *  We swap MC/IC so that MC is always before AC in the zodiac
   *  We than divide the quadrants into 3 equal parts.
   * *********************************************************
   *  All angles are expressed in degrees.
   *  Special trigonometric functions sind, cosd etc. are
   *  implemented for arguments in degrees.
   ***********************************************************/
  {
    double tane, tanfi, cosfi, tant, sina, cosa, th2;
    double a, c, f, fh1, fh2, xh1, xh2, rectasc, ad3, acmc, vemc;
    int i, ih, ih2, retc = SweConst.OK;
    double sine, cose;
    double x[] = new double[3], krHorizonLon; /* BK 14.02.2006 */
    cose  = cosd(ekl);
    sine  = sind(ekl);
    tane  = tand(ekl);
    /* north and south poles */
    if (Math.abs(Math.abs(fi) - 90) < VERY_SMALL) {
      if (fi < 0) {
        fi = -90 + VERY_SMALL;
      } else {
        fi = 90 - VERY_SMALL;
      }
    }
    tanfi = tand(fi);
    /* mc */
    if (Math.abs(th - 90) > VERY_SMALL
      && Math.abs(th - 270) > VERY_SMALL) {
      tant = tand(th);
      hsp.mc = atand(tant / cose);
      if (th > 90 && th <= 270) {
        hsp.mc = sl.swe_degnorm(hsp.mc + 180);
      }
    } else {
      if (Math.abs(th - 90) <= VERY_SMALL) {
        hsp.mc = 90;
      } else {
        hsp.mc = 270;
      }
    } /*  if */
    hsp.mc = sl.swe_degnorm(hsp.mc);
    /* ascendant */
    hsp.ac = Asc1 (th + 90, fi, sine, cose);
    hsp.cusp[1] = hsp.ac;
    hsp.cusp[10] = hsp.mc;
    hsy=Character.toUpperCase(hsy);
    switch (hsy) {
      case (int)'A':   /* equal houses */
      case (int)'E':
        /*
         * within polar circle we swap AC/DC if AC is on wrong side
         */
        acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
        if (acmc < 0) {
          hsp.ac = sl.swe_degnorm(hsp.ac + 180);
          hsp.cusp[1] = hsp.ac;
        }
        for (i = 2; i <=12; i++)
          hsp.cusp [i] = sl.swe_degnorm(hsp.cusp [1] + (i-1) * 30);
        break;
      case 'C': /* Campanus houses and Horizon or Azimut system */
      case 'H':
        if (hsy == 'H') {
          if (fi > 0) {
            fi = 90 - fi;
          } else {
            fi = -90 - fi;
          }
          /* equator */
          if (Math.abs(Math.abs(fi) - 90) < VERY_SMALL) {
            if (fi < 0) {
              fi = -90 + VERY_SMALL;
            } else {
              fi = 90 - VERY_SMALL;
            }
          }
          th = sl.swe_degnorm(th + 180);
        }
        fh1 = asind(sind (fi) / 2);
        fh2 = asind(Math.sqrt (3.0) / 2 * sind(fi));
        cosfi = cosd(fi);
        if (Math.abs(cosfi) == 0) {        /* '==' should be save! */
          if (fi > 0) {
            xh1 = xh2 = 90; /* cosfi = VERY_SMALL; */
          } else {
            xh1 = xh2 = 270; /* cosfi = -VERY_SMALL; */
          }
        } else {
          xh1 = atand(Math.sqrt (3.0) / cosfi);
          xh2 = atand(1 / Math.sqrt (3.0) / cosfi);
        }
        hsp.cusp [11] = Asc1 (th + 90 - xh1, fh1, sine, cose);
        hsp.cusp [12] = Asc1 (th + 90 - xh2, fh2, sine, cose);
        if (hsy == 'H') {
          hsp.cusp [1] = Asc1 (th + 90, fi, sine, cose);
        }
        hsp.cusp [2] = Asc1 (th + 90 + xh2, fh2, sine, cose);
        hsp.cusp [3] = Asc1 (th + 90 + xh1, fh1, sine, cose);
        /* within polar circle, when mc sinks below horizon and
         * ascendant changes to western hemisphere, all cusps
         * must be added 180 degrees.
         * houses will be in clockwise direction */
        if (Math.abs(fi) >= 90 - ekl) {  /* within polar circle */
          acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
          if (acmc < 0) {
            hsp.ac = sl.swe_degnorm(hsp.ac + 180);
            hsp.mc = sl.swe_degnorm(hsp.mc + 180);
            for (i = 1; i <= 12; i++)
              hsp.cusp[i] = sl.swe_degnorm(hsp.cusp[i] + 180);
          }
        }
        if (hsy == 'H') {
          for (i = 1; i <= 3; i++)
            hsp.cusp[i] = sl.swe_degnorm(hsp.cusp[i] + 180);
          for (i = 11; i <= 12; i++)
            hsp.cusp[i] = sl.swe_degnorm(hsp.cusp[i] + 180);
          /* restore fi and th */
          if (fi > 0) {
            fi = 90 - fi;
          } else {
            fi = -90 - fi;
          }
          th = sl.swe_degnorm(th + 180);
        }
        break;
      case (int)'K': /* Koch houses */
        if (Math.abs(fi) >= 90 - ekl) {  /* within polar circle */
          retc = SweConst.ERR;
//          goto porphyry;
          makePorphyry(hsp);
          break;
        }
        sina = sind(hsp.mc) * sine / cosd(fi);      /* always << 1,
                                          because fi < polar circle */
        cosa = Math.sqrt(1 - sina * sina);          /* always >> 0 */
        c = atand(tanfi / cosa);
        ad3 = asind(sind(c) * sina) / 3.0;
        hsp.cusp [11] = Asc1 (th + 30 - 2 * ad3, fi, sine, cose);
        hsp.cusp [12] = Asc1 (th + 60 - ad3, fi, sine, cose);
        hsp.cusp [2] = Asc1 (th + 120 + ad3, fi, sine, cose);
        hsp.cusp [3] = Asc1 (th + 150 + 2 * ad3, fi, sine, cose);
        break;
      case (int)'O':   /* Porphyry houses */
//porphyry:
        makePorphyry(hsp);
        break;
      case (int)'R':   /* Regiomontanus houses */
        fh1 = atand (tanfi * 0.5);
        fh2 = atand (tanfi * cosd(30));
        hsp.cusp [11] =  Asc1 (30 + th, fh1, sine, cose);
        hsp.cusp [12] =  Asc1 (60 + th, fh2, sine, cose);
        hsp.cusp [2] =  Asc1 (120 + th, fh2, sine, cose);
        hsp.cusp [3] =  Asc1 (150 + th, fh1, sine, cose);
        /* within polar circle, when mc sinks below horizon and
         * ascendant changes to western hemisphere, all cusps
         * must be added 180 degrees.
         * houses will be in clockwise direction */
        if (Math.abs(fi) >= 90 - ekl) {  /* within polar circle */
          acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
          if (acmc < 0) {
            hsp.ac = sl.swe_degnorm(hsp.ac + 180);
            hsp.mc = sl.swe_degnorm(hsp.mc + 180);
            for (i = 1; i <= 12; i++)
              hsp.cusp[i] = sl.swe_degnorm(hsp.cusp[i] + 180);
          }
        }
        break;
      case (int)'T':   /* 'topocentric' houses */
        fh1 = atand (tanfi / 3.0);
        fh2 = atand (tanfi * 2.0 / 3.0);
        hsp.cusp [11] =  Asc1 (30 + th, fh1, sine, cose);
        hsp.cusp [12] =  Asc1 (60 + th, fh2, sine, cose);
        hsp.cusp [2] =  Asc1 (120 + th, fh2, sine, cose);
        hsp.cusp [3] =  Asc1 (150 + th, fh1, sine, cose);
        /* within polar circle, when mc sinks below horizon and
         * ascendant changes to western hemisphere, all cusps
         * must be added 180 degrees.
         * houses will be in clockwise direction */
        if (Math.abs(fi) >= 90 - ekl) {  /* within polar circle */
          acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
          if (acmc < 0) {
            hsp.ac = sl.swe_degnorm(hsp.ac + 180);
            hsp.mc = sl.swe_degnorm(hsp.mc + 180);
            for (i = 1; i <= 12; i++)
              hsp.cusp[i] = sl.swe_degnorm(hsp.cusp[i] + 180);
          }
        }
        break;
      case 'V':   /* equal houses after Vehlow */
        /*
         * within polar circle we swap AC/DC if AC is on wrong side
         */
        acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
        if (acmc < 0) {
          hsp.ac = sl.swe_degnorm(hsp.ac + 180);
          hsp.cusp[1] = hsp.ac;
        }
        hsp.cusp [1] = sl.swe_degnorm(hsp.ac - 15);
        for (i = 2; i <=12; i++)
          hsp.cusp [i] = sl.swe_degnorm(hsp.cusp [1] + (i-1) * 30);
        break;
      case (int)'X': {
        /*
         * Meridian or axial rotation system:
         * ecliptic points whose rectascensions
         * are armc + n * 30
         */
        int j;
        double a2 = th;
        for (i = 1; i <= 12; i++) {
          j = i + 10;
          if (j > 12) {
            j -= 12;
          }
          a2 = sl.swe_degnorm(a2 + 30);
          if (Math.abs(a2 - 90) > VERY_SMALL
            && Math.abs(a2 - 270) > VERY_SMALL) {
            tant = tand(a2);
            hsp.cusp[j] = atand(tant / cose);
            if (a2 > 90 && a2 <= 270) {
              hsp.cusp[j] = sl.swe_degnorm(hsp.cusp[j] + 180);
            }
          } else {
            if (Math.abs(a2 - 90) <= VERY_SMALL) {
              hsp.cusp[j] = 90;
            } else {
              hsp.cusp[j] = 270;
            }
          } /*  if */
          hsp.cusp[j] = sl.swe_degnorm(hsp.cusp[j]);
        }
        break;
        }
      case (int)'M': {
        /*
         * Morinus
         * points of the equator (armc + n * 30) are transformed
         * into the ecliptic coordinate system
         */
        int j;
        double am = th;
        double xm[] = new double[3];
        for (i = 1; i <= 12; i++) {
          j = i + 10;
          if (j > 12) j -= 12;
          am = sl.swe_degnorm(am + 30);
          xm[0] = am;
          xm[1] = 0;
          sl.swe_cotrans(xm, 0, xm, 0, ekl);
          hsp.cusp[j] = xm[0];
        }
        break;
        }
      case (int)'B': { /* Alcabitius */
        /* created by Alois 17-sep-2000, followed example in Matrix
           electrical library. The code reproduces the example!
           See http://www.astro.com/cgi/adict.cgi query: alcabitius
           in the resuotl page, see program code example.
           I think the Alcabitius code in Walter Pullen's Astrolog 5.40
           is wrong, because he remains in RA and forgets the transform to
           the ecliptic. */
        double dek, r, sna, sda, sn3, sd3;
        acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
        if (acmc < 0) {
          hsp.ac = sl.swe_degnorm(hsp.ac + 180);
          hsp.cusp[1] = hsp.ac;
          acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
        }
        dek = asind(sind(hsp.ac) * sine);        /* declination of Ascendant */
        /* must treat the case fi == 90 or -90 */
        r = -tanfi * tand(dek);
        /* must treat the case of abs(r) > 1; probably does not happen
         * because dek becomes smaller when fi is large, as ac is close to
         * zero Aries/Libra in that case.
         */
        sda = Math.acos(r) * SwissData.RADTODEG; /* semidiurnal arc, measured on equator */
        sna = 180 - sda;          /* complement, seminocturnal arc */
        sd3 = sda / 3;
        sn3 = sna / 3;
        rectasc = sl.swe_degnorm(th + sd3);            /* cusp 11 */
        /* project rectasc onto eclipitic with pole height 0, i.e. along the
        declination circle */
        hsp.cusp [11] = Asc1 (rectasc, 0, sine, cose);
        rectasc = sl.swe_degnorm(th + 2 * sd3);        /* cusp 12 */
        hsp.cusp [12] = Asc1 (rectasc, 0, sine, cose);
        rectasc = sl.swe_degnorm(th + 180 - 2 * sn3);  /* cusp 2 */
        hsp.cusp [2] = Asc1 (rectasc, 0, sine, cose);
        rectasc = sl.swe_degnorm(th + 180 -  sn3);     /* cusp 3 */
        hsp.cusp [3] = Asc1 (rectasc, 0, sine, cose);
        }
        break;
      case (int)'G': {   /* 36 Gauquelin sectors */
        for (i = 1; i <= 36; i++) {
          hsp.cusp[i] = 0;
        }
        if (Math.abs(fi) >= 90 - ekl) {  /* within polar circle */
          retc = SweConst.ERR;
          // goto porphyry;
          makePorphyry(hsp);
        }
        /*************** forth/second quarter ***************/
        /* note: Gauquelin sectors are counted in clockwise direction */
        a = asind(tand(fi) * tane);
        for (ih = 2; ih <= 9; ih++) {
          ih2 = 10 - ih;
          fh1 = atand(sind(a * ih2 / 9) / tane);
          rectasc = sl.swe_degnorm((90 / 9) * ih2 + th);
          tant = tand(asind(sine * sind(Asc1 (rectasc, fh1, sine, cose))));
          if (Math.abs(tant) < VERY_SMALL) {
            hsp.cusp[ih] = rectasc;
          } else {
            /* pole height */
            f = atand(sind(asind(tanfi * tant) * ih2 / 9)  /tant);
            hsp.cusp [ih] = Asc1 (rectasc, f, sine, cose);
            for (i = 1; i <= iteration_count; i++) {
            tant = tand(asind(sine * sind(hsp.cusp[ih])));
            if (Math.abs(tant) < VERY_SMALL) {
              hsp.cusp[ih] = rectasc;
              break;
            }
            /* pole height */
            f = atand(sind(asind(tanfi * tant) * ih2 / 9) / tant);
            hsp.cusp[ih] = Asc1 (rectasc, f, sine, cose);
            }
          }
          hsp.cusp[ih+18] = sl.swe_degnorm(hsp.cusp[ih] + 180);
        }
        /*************** first/third quarter ***************/
        for (ih = 29; ih <= 36; ih++) {
          ih2 = ih - 28;
          fh1 = atand(sind(a * ih2 / 9) / tane);
          rectasc = sl.swe_degnorm(180 - ih2 * 90 / 9 + th);
          tant = tand(asind(sine * sind(Asc1 (rectasc, fh1, sine, cose))));
          if (Math.abs(tant) < VERY_SMALL) {
            hsp.cusp[ih] = rectasc;
          } else {
            f = atand(sind(asind(tanfi * tant) * ih2 / 9) / tant);
            /*  pole height */
            hsp.cusp[ih] = Asc1 (rectasc, f, sine, cose);
            for (i = 1; i <= iteration_count; i++) {
            tant = tand(asind(sine * sind(hsp.cusp[ih])));
            if (Math.abs(tant) < VERY_SMALL) {
              hsp.cusp[ih] = rectasc;
              break;
            }
            f = atand(sind(asind(tanfi * tant) * ih2 / 9) / tant);
            /*  pole height */
            hsp.cusp[ih] = Asc1 (rectasc, f, sine, cose);
            }
          }
          hsp.cusp[ih-18] = sl.swe_degnorm(hsp.cusp[ih] + 180);
        }
        hsp.cusp[1] = hsp.ac;
        hsp.cusp[10] = hsp.mc;
        hsp.cusp[19] = sl.swe_degnorm(hsp.ac + 180);
        hsp.cusp[28] = sl.swe_degnorm(hsp.mc + 180);
        break;
        }
      case 'U': /* Krusinski */
        /*
         * The following code was written by Bogdan Krusinski in 2006.
         * bogdan@astrologia.pl
         *
         * Definition:
         * "Krusinski - house system based on the great circle passing through 
         * ascendant and zenith. This circle is divided into 12 equal parts 
         * (1st cusp is ascendent, 10th cusp is zenith), then the resulting 
         * points are projected onto the ecliptic through meridian circles.
         * The house cusps in space are half-circles perpendicular to the equator
         * and running from the north to the south celestial pole through the
         * resulting cusp points on the house circle. The points where they 
         * cross the ecliptic mark the ecliptic house cusps."
         *
         * Description of the algorithm:
         * Transform into great circle running through Asc and zenit (where arc 
         * between Asc and zenith is always 90 deg), and then return with 
         * house cusps into ecliptic. Eg. solve trigonometrical triangle 
         * with three transformations and two rotations starting from ecliptic. 
         * House cusps in space are meridian circles. 
         *
         * Notes:
         * 1. In this definition we assume MC on ecliptic as point where
         *    half-meridian (from north to south pole) cuts ecliptic,
         *    so MC may be below horizon in arctic regions.
         * 2. Houses could be calculated in all latitudes except the poles 
         *    themselves (-90,90) and points on arctic circle in cases where 
         *    ecliptic is equal to horizon and then ascendant is undefined. 
         *    But ascendant when 'horizon=ecliptic' could be deduced as limes 
         *    from both sides of that point and houses with that provision can 
         *    be computed also there.
         *
         * Starting values for calculations:
         *	   - Asc ecliptic longitude
         *	   - right ascension of MC (RAMC)
         *	   - geographic latitude.
         */
        /*
         * within polar circle we swap AC/DC if AC is on wrong side
         */
        acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
        if (acmc < 0) {
          hsp.ac = sl.swe_degnorm(hsp.ac + 180);
        }
        /* A0. Start point - ecliptic coords of ascendant */
        x[0] = hsp.ac; /* Asc longitude   */
        x[1] = 0.0;     /* Asc declination */
        x[2] = 1.0;     /* Radius to test validity of subsequent transformations. */
        sl.swe_cotrans(x, x, -ekl);      /* A1. Transform into equatorial coords */
        x[0] = x[0] - (th-90);        /* A2. Rotate                           */
        sl.swe_cotrans(x, x, -(90-fi));  /* A3. Transform into horizontal coords */
        krHorizonLon = x[0];          /* ...save asc lon on horizon to get back later with house cusp */
        x[0] = x[0] - x[0];           /* A4. Rotate                           */
        sl.swe_cotrans(x, x, -90);       /* A5. Transform into this house system great circle (asc-zenith) */
        /* As it is house circle now, simple add 30 deg increments... */
        for(i = 0; i < 6; i++) {
          /* B0. Set 'n-th' house cusp. 
           *     Note that IC/MC are also calculated here to check 
           *     if really this is the asc-zenith great circle. */
          x[0] = 30.0*i;
          x[1] = 0.0;
          sl.swe_cotrans(x, x, 90);                 /* B1. Transform back into horizontal coords */
          x[0] = x[0] + krHorizonLon;            /* B2. Rotate back.                          */
          sl.swe_cotrans(x, x, 90-fi);              /* B3. Transform back into equatorial coords */
          x[0] = sl.swe_degnorm(x[0] + (th-90));    /* B4. Rotate back -> RA of house cusp as result. */
          /* B5. Where's this house cusp on ecliptic? */
          /* ... so last but not least - get ecliptic longitude of house cusp: */
          hsp.cusp[i+1] = atand(tand(x[0])/cosd(ekl));
          if (x[0] > 90 && x[0] <= 270)
            hsp.cusp[i+1] = sl.swe_degnorm(hsp.cusp[i+1] + 180);
          hsp.cusp[i+1] = sl.swe_degnorm(hsp.cusp[i+1]);
          hsp.cusp[i+7] = sl.swe_degnorm(hsp.cusp[i+1]+180);
        }
        break;
      default:    /* Placidus houses */
        if (hsy != 'P') {
          System.err.println("swe_houses: make Placidus, unknown key "+hsy);
        }
        if (Math.abs(fi) >= 90 - ekl) {  /* within polar circle */
          retc = SweConst.ERR;
//          goto porphyry;
          makePorphyry(hsp);
          break;
        }
        a = asind(tand(fi) * tane);
        fh1 = atand(sind(a / 3) / tane);
        fh2 = atand(sind(a * 2 / 3) / tane);
        /* ************  house 11 ******************** */
        rectasc = sl.swe_degnorm(30 + th);
        tant = tand(asind(sine * sind(Asc1 (rectasc, fh1, sine, cose))));
        if (Math.abs(tant) < VERY_SMALL) {
          hsp.cusp [11] = rectasc;
        } else {
          /* pole height */
          f = atand(sind(asind(tanfi * tant) / 3)  /tant);
          hsp.cusp [11] = Asc1 (rectasc, f, sine, cose);
          for (i = 1; i <= iteration_count; i++) {
            tant = tand(asind(sine * sind(hsp.cusp [11])));
            if (Math.abs(tant) < VERY_SMALL) {
              hsp.cusp [11] = rectasc;
              break;
            }
            /* pole height */
            f = atand(sind(asind(tanfi * tant) / 3) / tant);
            hsp.cusp [11] = Asc1 (rectasc, f, sine, cose);
          }
        }
        /* ************  house 12 ******************** */
        rectasc = sl.swe_degnorm(60 + th);
        tant = tand(asind(sine*sind(Asc1 (rectasc,  fh2, sine, cose))));
        if (Math.abs(tant) < VERY_SMALL) {
          hsp.cusp [12] = rectasc;
        } else {
          f = atand(sind(asind(tanfi * tant) / 1.5) / tant);
          /*  pole height */
          hsp.cusp [12] = Asc1 (rectasc, f, sine, cose);
          for (i = 1; i <= iteration_count; i++) {
            tant = tand(asind(sine * sind(hsp.cusp [12])));
            if (Math.abs(tant) < VERY_SMALL) {
              hsp.cusp [12] = rectasc;
              break;
            }
            f = atand(sind(asind(tanfi * tant) / 1.5) / tant);
            /*  pole height */
            hsp.cusp [12] = Asc1 (rectasc, f, sine, cose);
          }
        }
        /* ************  house  2 ******************** */
        rectasc = sl.swe_degnorm(120 + th);
        tant = tand(asind(sine * sind(Asc1 (rectasc, fh2, sine, cose))));
        if (Math.abs(tant) < VERY_SMALL) {
          hsp.cusp [2] = rectasc;
        } else {
          f = atand(sind(asind(tanfi * tant) / 1.5) / tant);
          /*  pole height */
          hsp.cusp [2] = Asc1 (rectasc, f, sine, cose);
          for (i = 1; i <= iteration_count; i++) {
            tant = tand(asind(sine * sind(hsp.cusp [2])));
            if (Math.abs(tant) < VERY_SMALL) {
              hsp.cusp [2] = rectasc;
              break;
            }
            f = atand(sind(asind(tanfi * tant) / 1.5) / tant);
            /*  pole height */
            hsp.cusp [2] = Asc1 (rectasc, f, sine, cose);
          }
        }
        /* ************  house  3 ******************** */
        rectasc = sl.swe_degnorm(150 + th);
        tant = tand(asind(sine * sind(Asc1 (rectasc, fh1, sine, cose))));
        if (Math.abs(tant) < VERY_SMALL) {
          hsp.cusp [3] = rectasc;
        } else {
          f = atand(sind(asind(tanfi * tant) / 3) / tant);
          /*  pole height */
          hsp.cusp [3] = Asc1(rectasc, f, sine, cose);
          for (i = 1; i <= iteration_count; i++) {
            tant = tand(asind(sine * sind(hsp.cusp [3])));
            if (Math.abs(tant) < VERY_SMALL) {
              hsp.cusp [3] = rectasc;
              break;
            }
            f = atand(sind(asind(tanfi * tant) / 3) / tant);
            /*  pole height */
            hsp.cusp [3] = Asc1 (rectasc, f, sine, cose);
          }
        }
        break;
    } /* end switch */
    if (hsy != 'G') {
      hsp.cusp [4] = sl.swe_degnorm(hsp.cusp [10] + 180);
      hsp.cusp [5] = sl.swe_degnorm(hsp.cusp [11] + 180);
      hsp.cusp [6] = sl.swe_degnorm(hsp.cusp [12] + 180);
      hsp.cusp [7] = sl.swe_degnorm(hsp.cusp [1] + 180);
      hsp.cusp [8] = sl.swe_degnorm(hsp.cusp [2] + 180);
      hsp.cusp [9] = sl.swe_degnorm(hsp.cusp [3] + 180);
    }
    /* vertex */
    if (fi >= 0) {
      f = 90 - fi;
    } else {
      f = -90 - fi;
    }
    hsp.vertex = Asc1 (th - 90, f, sine, cose);
    /* with tropical latitudes, the vertex behaves strange,
     * in a similar way as the ascendant within the polar
     * circle. we keep it always on the western hemisphere.*/
    if (Math.abs(fi) <= ekl) {
      vemc = sl.swe_difdeg2n(hsp.vertex, hsp.mc);
      if (vemc > 0) {
        hsp.vertex = sl.swe_degnorm(hsp.vertex + 180);
      }
    }
    /*
     * some strange points:
     */
    /* equasc (equatorial ascendant) */
    th2 = sl.swe_degnorm(th + 90);
    if (Math.abs(th2 - 90) > VERY_SMALL
      && Math.abs(th2 - 270) > VERY_SMALL) {
      tant = tand(th2);
      hsp.equasc = atand(tant / cose);
      if (th2 > 90 && th2 <= 270) {
        hsp.equasc = sl.swe_degnorm(hsp.equasc + 180);
      }
    } else {
      if (Math.abs(th2 - 90) <= VERY_SMALL) {
        hsp.equasc = 90;
      } else {
        hsp.equasc = 270;
      }
    } /*  if */
    hsp.equasc = sl.swe_degnorm(hsp.equasc);
    /* "co-ascendant" W. Koch */
    hsp.coasc1 = sl.swe_degnorm(Asc1 (th - 90, fi, sine, cose) + 180);
    /* "co-ascendant" M. Munkasey */
    if (fi >= 0) {
      hsp.coasc2 = Asc1 (th + 90, 90 - fi, sine, cose);
    } else /* southern hemisphere */ {
      hsp.coasc2 = Asc1 (th + 90, -90 - fi, sine, cose);
    }
    /* "polar ascendant" M. Munkasey */
    hsp.polasc = Asc1 (th - 90, fi, sine, cose);
    return retc;
  } /* procedure houses */

  /**
  * This is just a wrapping function to deal with the <CODE>goto</CODE>'s in
  * the original C-Code.
  */
  private void makePorphyry(Houses hsp) {
    /*
     * within polar circle we swap AC/DC if AC is on wrong side
     */
    double acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
    if (acmc < 0) {
      hsp.ac = sl.swe_degnorm(hsp.ac + 180);
      hsp.cusp[1] = hsp.ac;
      acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
    }
    hsp.cusp [2] = sl.swe_degnorm(hsp.ac + (180 - acmc) / 3);
    hsp.cusp [3] = sl.swe_degnorm(hsp.ac + (180 - acmc) / 3 * 2);
    hsp.cusp [11] = sl.swe_degnorm(hsp.mc + acmc / 3);
    hsp.cusp [12] = sl.swe_degnorm(hsp.mc + acmc / 3 * 2);
  }

  /******************************/
  private double Asc1 (double x1, double f, double sine, double cose) {
    int n;
    double ass;
    x1 = sl.swe_degnorm(x1);
    n  = (int) ((x1 / 90) + 1);
    if (n == 1) {
      ass = ( Asc2 (x1, f, sine, cose));
    } else if (n == 2) {
      ass = (180 - Asc2 (180 - x1, - f, sine, cose));
    } else if (n == 3) {
      ass = (180 + Asc2 (x1 - 180, - f, sine, cose));
    } else {
      ass = (360 - Asc2 (360- x1,  f, sine, cose));
    }
    ass = sl.swe_degnorm(ass);
    if (Math.abs(ass - 90) < VERY_SMALL)        /* rounding, e.g.: if */ {
      ass = 90;                           /* fi = 0 & st = 0, ac = 89.999... */
    }
    if (Math.abs(ass - 180) < VERY_SMALL) {
      ass = 180;
    }
    if (Math.abs(ass - 270) < VERY_SMALL)        /* rounding, e.g.: if */ {
      ass = 270;                          /* fi = 0 & st = 0, ac = 89.999... */
    }
    if (Math.abs(ass - 360) < VERY_SMALL) {
      ass = 0;
    }
    return ass;
  }  /* Asc1 */

  private double Asc2 (double x, double f, double sine, double cose) {
    int n;
    double ass, sinx;
    ass = - tand(f) * sine + cose * cosd(x);
    if (Math.abs(ass) < VERY_SMALL) {
      ass = 0;
    }
    sinx = sind(x);
    if (Math.abs(sinx) < VERY_SMALL) {
      sinx = 0;
    }
    if (sinx == 0) {
      if (ass < 0) {
        ass = -VERY_SMALL;
      } else {
        ass = VERY_SMALL;
      }
    } else if (ass == 0) {
      if (sinx < 0) {
        ass = -90;
      } else {
        ass = 90;
      }
    } else {
      ass = atand(sinx / ass);
    }
    if (ass < 0) {
      ass = 180 + ass;
    }
    return (ass);
  } /* Asc2 */


  /* computes the house position of a planet or another point,
   * in degrees: 0 - 30 = 1st house, 30 - 60 = 2nd house, etc.
   * armc         sidereal time in degrees
   * geolat       geographic latitude
   * eps          true ecliptic obliquity
   * hsys         house system character
   * xpin         array of 6 doubles:
   *              only the first two of them are used: ecl. long., lat.
   * serr         error message area
   *
   * house position is returned by function.
   *
   * sidereal house positions:
   *
   * tropical and sidereal house positions of planets are always identical
   * if the traditional method of computing sidereal positions (subtracting
   * the ayanamsha from tropical in order to get sidereal positions) is used.
   *
   * if the sidereal plane is not identical to the ecliptic of date,
   * sidereal and tropical house positions are identical with
   * house systems that are independent on the ecliptic such as:
   * - Campanus
   * - Regiomontanus
   * - Placidus
   * - Azimuth/Horizon
   * - Axial rotation system
   * - "topocentric" system
   *
   * in all these cases call swe_house_pos() with TROPICAL planetary positions.
   *
   * but there are different house positions for ecliptic-dependent systems
   * such as:
   * - equal
   * - Porphyry
   * - Koch
<  * - Krusinski
   *
   * for these cases there is no function.
   */
  /**
  * The function returns a value between 1.0 and 12.999999, indicating in
  * which house a planet is and how far from its cusp it is. With Koch houses,
  * the function sometimes returns 0, if the computation was not possible.
  * @param armc The ARMC (sidereal time)
  * @param geolat The latitude
  * @param eps The ecliptic obliquity (e.g. xx[0] of swe_calc(...))
  * @param hsys The house system. See swe_houses(...) for a description
  * of the possible houses.
  * @param xpin A double[6] containing the ecliptic longitude and latitude of
  * the planet in degrees in xpin[0] and xpin[1]. The other xpin[] values are
  * not used, but the array has to be this size! The values must describe
  * tropical positions.
  * @param serr StringBuffer to contain any error messages or warnings
  * @return A value between 1.0 and 12.999999, indicating in which house a
  * planet is and how far from its cusp it is. Koch may return 0, if the
  * calculation was not possible.
  * #swe_houses
  */
  double swe_house_pos(double armc, double geolat, double eps,
                       int hsys, double xpin[], StringBuffer serr) {
    double xp[]=new double[6], xeq[]=new double[6], ra, de, mdd, mdn, sad, san;
    double hpos, sinad, ad, a, admc, adp, samc, demc, asc, mc, acmc, tant;
    double fh, ra0, tanfi, fac;
    double x[] = new double[3], xasc[] = new double[3], raep, raaz, oblaz, xtemp; /* BK 21.02.2006 */
    double sine = sind(eps);
    double cose = cosd(eps);
    boolean is_above_hor = false;
    if (serr != null) { serr.setLength(0); }
    hsys = Character.toUpperCase((char)hsys);
    xeq[0] = xpin[0];
    xeq[1] = xpin[1];
    xeq[2] = 1;
    sl.swe_cotrans(xpin, 0, xeq, 0, -eps);
    ra = xeq[0];
    de = xeq[1];
    mdd = sl.swe_degnorm(ra - armc);
    mdn = sl.swe_degnorm(mdd + 180);
    if (mdd >= 180) {
      mdd -= 360;
    }
    if (mdn >= 180) {
      mdn -= 360;
    }
    /* xp[0] will contain the house position, a value between 0 and 360 */
    switch(hsys) {
      case (int)'A':
      case (int)'E':
      case (int)'V':
        asc = Asc1 (sl.swe_degnorm(armc + 90), geolat, sine, cose);
        demc = atand(sind(armc) * tand(eps));
        if (geolat >= 0 && 90 - geolat + demc < 0) {
          asc = sl.swe_degnorm(asc + 180);
        }
        if (geolat < 0 && -90 - geolat + demc > 0) {
          asc = sl.swe_degnorm(asc + 180);
        }
        xp[0] = sl.swe_degnorm(xpin[0] - asc);
        if (hsys == 'V') {
          xp[0] = sl.swe_degnorm(xp[0] + 15);
        }
        /* to make sure that a call with a house cusp position returns
         * a value within the house, 0.001" is added */
        xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        hpos = xp[0] / 30.0 + 1;
      break;
      case 'O':
        asc = Asc1 (sl.swe_degnorm(armc + 90), geolat, sine, cose);
        demc = atand(sind(armc) * tand(eps));
        /* mc */
        if (Math.abs(armc - 90) > VERY_SMALL
                && Math.abs(armc - 270) > VERY_SMALL) {
          tant = tand(armc);
          mc = sl.swe_degnorm(atand(tant / cose));
          if (armc > 90 && armc <= 270) {
            mc = sl.swe_degnorm(mc + 180);
          }
        } else {
          if (Math.abs(armc - 90) <= VERY_SMALL) {
            mc = 90;
          } else {
            mc = 270;
          }
        }
        /* while MC is always south,
         * Asc must always be in eastern hemisphere */
        if (geolat >= 0 && 90 - geolat + demc < 0) {
          asc = sl.swe_degnorm(asc + 180);
        }
        if (geolat < 0 && -90 - geolat + demc > 0) {
          asc = sl.swe_degnorm(asc + 180);
        }
        xp[0] = sl.swe_degnorm(xpin[0] - asc);
        /* to make sure that a call with a house cusp position returns
         * a value within the house, 0.001" is added */
        xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        if (xp[0] < 180) {
          hpos = 1;
        } else {
          hpos = 7;
          xp[0] -= 180;
        }
        acmc = sl.swe_difdeg2n(asc, mc);
        if (xp[0] < 180 - acmc) {
          hpos += xp[0] * 3 / (180 - acmc);
        } else {
          hpos += 3 + (xp[0] - 180 + acmc) * 3 / acmc;
        }
      break;
      case 'X': /* Merdidian or axial rotation system */
        hpos = sl.swe_degnorm(mdd - 90) / 30.0 + 1;
      break;
      case (int)'M': { /* Morinus */
        double am = xpin[0];
        if (Math.abs(am - 90) > VERY_SMALL
          && Math.abs(am - 270) > VERY_SMALL) {
          tant = tand(am);
          hpos = atand(tant / cose);
          if (am > 90 && am <= 270) {
            hpos = sl.swe_degnorm(hpos + 180);
          }
        } else {
          if (Math.abs(am - 90) <= VERY_SMALL) {
            hpos = 90;
          } else {
            hpos = 270;
          }
        } /*  if */
        hpos = sl.swe_degnorm(hpos - armc - 90);
        hpos = hpos / 30.0 + 1;
      }
      break;
      case (int)'K':
       demc = atand(sind(armc) * tand(eps));
       /* if body is within circumpolar region, error */
       if (90 - Math.abs(geolat) <= Math.abs(de)) {
         if (serr != null) {
           serr.append("no Koch house position, because planet is circumpolar.");
         }
         xp[0] = 0;
         hpos = 0;        /* Error */
       } else if (90 - Math.abs(geolat) <= Math.abs(demc)) {
         if (serr != null) {
           serr.append("no Koch house position, because mc is circumpolar.");
         }
         xp[0] = 0;
         hpos = 0;        /* Error */
        } else {
          admc = asind(tand(eps) * tand(geolat) * sind(armc));
          adp = asind(tand(geolat) * tand(de));
            samc = 90 + admc;
          if (mdd >= 0) {        /* east */
            xp[0] = sl.swe_degnorm(((mdd - adp + admc) / samc - 1) * 90);
          } else {
            xp[0] = sl.swe_degnorm(((mdd + 180 + adp + admc) / samc + 1) * 90);
          }
          /* to make sure that a call with a house cusp position returns
           * a value within the house, 0.001" is added */
          xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
          hpos = xp[0] / 30.0 + 1;
        }
        break;
      case (int)'C':
        xeq[0] = sl.swe_degnorm(mdd - 90);
        sl.swe_cotrans(xeq, 0, xp, 0, -geolat);
        /* to make sure that a call with a house cusp position returns
         * a value within the house, 0.001" is added */
        xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        hpos = xp[0] / 30.0 + 1;
        break;
      case 'U': /* Krusinski */
        /* Purpose: find point where planet's house circle (meridian)
         * cuts house plane, giving exact planet's house position.
         * Input data: ramc, geolat, asc.
         */
        asc = Asc1 (sl.swe_degnorm(armc + 90), geolat, sine, cose);
        demc = atand(sind(armc) * tand(eps));
        /* while MC is always south, 
         * Asc must always be in eastern hemisphere */
        if (geolat >= 0 && 90 - geolat + demc < 0) {
          asc = sl.swe_degnorm(asc + 180);
        }
        if (geolat < 0 && -90 - geolat + demc > 0) {
          asc = sl.swe_degnorm(asc + 180);
        }
        /*
         * Descr: find the house plane 'asc-zenith' - where it intersects 
         * with equator and at what angle, and then simple find arc 
         * from asc on that plane to planet's meridian intersection 
         * with this plane.
         */
        /* I. find plane of 'asc-zenith' great circle relative to equator: 
         *   solve spherical triangle 'EP-asc-intersection of house circle with equator' */
        /* Ia. Find intersection of house plane with equator: */
        x[0] = asc; x[1] = 0.0; x[2] = 1.0;          /* 1. Start with ascendent on ecliptic     */
        sl.swe_cotrans(x, x, -eps);                     /* 2. Transform asc into equatorial coords */
        raep = sl.swe_degnorm(armc + 90);               /* 3. RA of east point                     */
        x[0] = sl.swe_degnorm(raep - x[0]);             /* 4. Rotation - found arc raas-raep      */
        sl.swe_cotrans(x, x, -(90-geolat));             /* 5. Transform into horizontal coords - arc EP-asc on horizon */
        xtemp = atand(tand(x[0])/cosd((90-geolat))); /* 6. Rotation from horizon on circle perpendicular to equator */
        if (x[0] > 90 && x[0] <= 270)
        xtemp = sl.swe_degnorm(xtemp + 180);
        x[0] = sl.swe_degnorm(xtemp);        
        raaz = sl.swe_degnorm(raep - x[0]); /* result: RA of intersection 'asc-zenith' great circle with equator */
        /* Ib. Find obliquity to equator of 'asc-zenith' house plane: */
        x[0] = raaz; x[1] = 0.0; 
        x[0] = sl.swe_degnorm(raep - x[0]);  /* 1. Rotate start point relative to EP   */
        sl.swe_cotrans(x, x, -(90-geolat));  /* 2. Transform into horizontal coords    */
        x[1] = x[1] + 90;                 /* 3. Add 90 deg do decl - so get the point on house plane most distant from equ. */
        sl.swe_cotrans(x, x, 90-geolat);     /* 4. Rotate back to equator              */
        oblaz = x[1];                     /* 5. Obliquity of house plane to equator */
        /* II. Next find asc and planet position on house plane, 
         *     so to find relative distance of planet from 
         *     coords beginning. */
        /* IIa. Asc on house plane relative to intersection 
         *      of equator with 'asc-zenith' plane. */
        xasc[0] = asc; xasc[1] = 0.0; xasc[2] = 1.0;
        sl.swe_cotrans(xasc, xasc, -eps);
        xasc[0] = sl.swe_degnorm(xasc[0] - raaz);
        xtemp = atand(tand(xasc[0])/cosd(oblaz));
        if (xasc[0] > 90 && xasc[0] <= 270)
        xtemp = sl.swe_degnorm(xtemp + 180);
        xasc[0] = sl.swe_degnorm(xtemp);
        /* IIb. Planet on house plane relative to intersection 
         *      of equator with 'asc-zenith' plane */
        xp[0] = sl.swe_degnorm(xeq[0] - raaz);        /* Rotate on equator  */
        xtemp = atand(tand(xp[0])/cosd(oblaz));    /* Find arc on house plane from equator */
        if (xp[0] > 90 && xp[0] <= 270)
          xtemp = sl.swe_degnorm(xtemp + 180);
        xp[0] = sl.swe_degnorm(xtemp);
        xp[0] = sl.swe_degnorm(xp[0]-xasc[0]); /* find arc between asc and planet, and get planet house position  */
        /* IIc. Distance from planet to house plane on declination circle: */
        x[0] = xeq[0];
        x[1] = xeq[1];
        sl.swe_cotrans(x, x, oblaz);
        xp[1] = xeq[1] - x[1]; /* How many degrees is the point on declination circle from house circle */
        /* to make sure that a call with a house cusp position returns
         * a value within the house, 0.001" is added */
        xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        hpos = xp[0] / 30.0 + 1;
        break;
      case (int)'H':
        xeq[0] = sl.swe_degnorm(mdd - 90);
        sl.swe_cotrans(xeq, 0, xp, 0, 90 - geolat);
        /* to make sure that a call with a house cusp position returns
         * a value within the house, 0.001" is added */
        xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        hpos = xp[0] / 30.0 + 1;
        break;
      case (int)'R':
        if (Math.abs(mdd) < VERY_SMALL) {
          xp[0] = 270;
        } else if (180 - Math.abs(mdd) < VERY_SMALL) {
          xp[0] = 90;
        } else {
          if (90 - Math.abs(geolat) < VERY_SMALL) {
            if (geolat > 0) {
              geolat = 90 - VERY_SMALL;
            } else {
              geolat = -90 + VERY_SMALL;
            }
          }
          if (90 - Math.abs(de) < VERY_SMALL) {
            if (de > 0) {
              de = 90 - VERY_SMALL;
            } else {
              de = -90 + VERY_SMALL;
            }
          }
          a = tand(geolat) * tand(de) + cosd(mdd);
          xp[0] = sl.swe_degnorm(atand(-a / sind(mdd)));
          if (mdd < 0) {
            xp[0] += 180;
          }
          xp[0] = sl.swe_degnorm(xp[0]);
          /* to make sure that a call with a house cusp position returns
           * a value within the house, 0.001" is added */
          xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        }
        hpos = xp[0] / 30.0 + 1;
        break;
      case (int)'T':
        mdd = sl.swe_degnorm(mdd);
        if (de > 90 - VERY_SMALL) {
          de = 90 - VERY_SMALL;
        }
        if (de < -90 + VERY_SMALL) {
          de = -90 + VERY_SMALL;
        }
        sinad = tand(de) * tand(geolat);
        ad = asind(sinad);
        a = sinad + cosd(mdd);
        if (a >= 0) {
          is_above_hor = true;
        }
        /* mirror everything below the horizon to the opposite point
         * above the horizon */
        if (!is_above_hor) {
          ra = sl.swe_degnorm(ra + 180);
          de = -de;
          mdd = sl.swe_degnorm(mdd + 180);
        }
        /* mirror everything on western hemisphere to eastern hemisphere */
        if (mdd > 180) {
          ra = sl.swe_degnorm(armc - mdd);
        }
        /* binary search for "topocentric" position line of body */
        tanfi = tand(geolat);
        fh = geolat;
        ra0 = sl.swe_degnorm(armc + 90);
        xp[1] = 1;
        xeq[1] = de;
        fac = 2;
        while (Math.abs(xp[1]) > 0.000001) {
          if (xp[1] > 0) {
            fh = atand(tand(fh) - tanfi / fac);
            ra0 -= 90 / fac;
          } else {
            fh = atand(tand(fh) + tanfi / fac);
            ra0 += 90 / fac;
          }
          xeq[0] = sl.swe_degnorm(ra - ra0);
          sl.swe_cotrans(xeq, 0, xp, 0, 90 - fh);
          fac *= 2;
        }
        hpos = sl.swe_degnorm(ra0 - armc);
        /* mirror back to west */
        if (mdd > 180) {
          hpos = sl.swe_degnorm(-hpos);
        }
        /* mirror back to below horizon */
        if (!is_above_hor) {
          hpos = sl.swe_degnorm(hpos + 180);
        }
        hpos = sl.swe_degnorm(hpos - 90) / 30 + 1;
        break;
      case (int)'P':
      case (int)'G':
      default:
         /* circumpolar region */
        if (90 - Math.abs(de) <= Math.abs(geolat)) {
          if (de * geolat < 0) {
            xp[0] = sl.swe_degnorm(90 + mdn / 2);
          } else {
            xp[0] = sl.swe_degnorm(270 + mdd / 2);
          }
          if (serr != null) {
            serr.append("Otto Ludwig procedure within circumpolar regions.");
          }
        } else {
          sinad = tand(de) * tand(geolat);
          ad = asind(sinad);
          a = sinad + cosd(mdd);
          if (a >= 0) {
            is_above_hor = true;
          }
          sad = 90 + ad;
          san = 90 - ad;
          if (is_above_hor) {
            xp[0] =  (mdd / sad + 3) * 90;
          } else {
            xp[0] = (mdn / san + 1) * 90;
          }
          /* to make sure that a call with a house cusp position returns
           * a value within the house, 0.001" is added */
          xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        }
        if ((char)hsys == 'G') {
          xp[0] = 360 - xp[0]; /* Gauquelin sectors are in clockwise direction */
          hpos = xp[0] / 10.0 + 1;
        } else {
          hpos = xp[0] / 30.0 + 1;
        }
      break;
    }
    return hpos;
  }
}




class Swemmoon {

 /*
 * Expansions for the geocentric ecliptic longitude,
 * latitude, and distance of the Moon referred to the mean equinox
 * and ecliptic of date.
 *
 * This version of cmoon.c adjusts the ELP2000-85 analytical Lunar
 * theory of Chapront-Touze and Chapront to fit the Jet Propulsion
 * Laboratory's DE404 long ephemeris on the interval from 3000 B.C.
 * to 3000 A.D.
 *
 * The fit is much better in the remote past and future if
 * secular terms are included in the arguments of the oscillatory
 * perturbations.  Such adjustments cannot easily be incorporated
 * into the 1991 lunar tables.  In this program the traditional
 * literal arguments are used instead, with mean elements adjusted
 * for a best fit to the reference ephemeris.
 *
 * This program omits many oscillatory terms from the analytical
 * theory which, if they were included, would yield a much higher
 * accuracy for modern dates.  Detailed statistics of the precision
 * are given in the table below.  Comparing at 64-day intervals
 * over the period -3000 to +3000, the maximum discrepancies noted
 * were 7" longitude, 5" latitude, and 5 x 10^-8 au radius.
 * The expressions used for precession in this comparision were
 * those of Simon et al (1994).
 *
 * The adjusted coefficients were found by an unweighted least squares
 * fit to the numerical ephemeris in the mentioned test interval.
 * The approximation error increases rapidly outside this interval.
 * J. Chapront (1994) has described the basic fitting procedure.
 *
 * A major change from DE200 to DE404 is in the coefficient
 * of tidal acceleration of the Moon, which causes the Moon's
 * longitude to depart by about -0.9" per century squared
 * from DE200.  Uncertainty in this quantity continues to
 * be the limiting factor in long term projections of the Moon's
 * ephemeris.
 *
 * Since the Lunar theory is cast in the ecliptic of date, it makes
 * some difference what formula you use for precession.  The adjustment
 * to DE404 was carried out relative to the mean equinox and ecliptic
 * of date as defined in Williams (1994).  An earlier version of this
 * program used the precession given by Simon et al (1994).  The difference
 * between these two precession formulas amounts to about 12" in Lunar
 * longitude at 3000 B.C.
 *
 *    Maximum deviations between DE404 and this program
 *    in a set of 34274 samples spaced 64 days apart
 *
 *   Interval     Longitude  Latitude  Radius
 *   Julian Year   arc sec   arc sec   10^-8 au
 * -3000 to -2500    5.66      4.66     4.93
 * -2500 to -2000    5.49      3.98     4.56
 * -2000 to -1500    6.98      4.17     4.81
 * -1500 to -1000    5.74      3.53     4.87
 * -1000 to -500     5.95      3.42     4.67
 * -500 to     0     4.94      3.07     4.04
 *    0 to   500     4.42      2.65     4.55
 *  500 to  1000     5.68      3.30     3.99
 * 1000 to  1500     4.32      3.21     3.83
 * 1500 to  2000     2.70      2.69     3.71
 * 2000 to  2500     3.35      2.32     3.85
 * 2500 to  3000     4.62      2.39     4.11
 *
 *
 *
 * References:
 *
 *   James G. Williams, "Contributions to the Earth's obliquity rate,
 *   precession, and nutation,"  Astron. J. 108, 711-724 (1994)
 *
 *   DE403 and DE404 ephemerides by E. M. Standish, X. X. Newhall, and
 *   J. G. Williams are at the JPL computer site navigator.jpl.nasa.gov.
 *
 *   J. L. Simon, P. Bretagnon, J. Chapront, M. Chapront-Touze', G. Francou,
 *   and J. Laskar, "Numerical Expressions for precession formulae and
 *   mean elements for the Moon and the planets," Astronomy and Astrophysics
 *   282, 663-683 (1994)
 *
 *   P. Bretagnon and Francou, G., "Planetary theories in rectangular
 *   and spherical variables. VSOP87 solutions," Astronomy and
 *   Astrophysics 202, 309-315 (1988)
 *
 *   M. Chapront-Touze' and J. Chapront, "ELP2000-85: a semi-analytical
 *   lunar ephemeris adequate for historical times," Astronomy and
 *   Astrophysics 190, 342-352 (1988).
 *
 *   M. Chapront-Touze' and J. Chapront, _Lunar Tables and
 *   Programs from 4000 B.C. to A.D. 8000_, Willmann-Bell (1991)
 *
 *   J. Laskar, "Secular terms of classical planetary theories
 *   using the results of general theory," Astronomy and Astrophysics
 *   157, 59070 (1986)
 *
 *   S. L. Moshier, "Comparison of a 7000-year lunar ephemeris
 *   with analytical theory," Astronomy and Astrophysics 262,
 *   613-616 (1992)
 *
 *   J. Chapront, "Representation of planetary ephemerides by frequency
 *   analysis.  Application to the five outer planets,"  Astronomy and
 *   Astrophysics Suppl. Ser. 109, 181-192 (1994)
 *
 *
 * Entry swi_moshmoon2() returns the geometric position of the Moon
 * relative to the Earth.  Its calling procedure is as follows:
 *
 * double JD;       input Julian Ephemeris Date
 * double pol[3];   output ecliptic polar coordinatees in radians and au
 *                  pol[0] longitude, pol[1] latitude, pol[2] radius
 * swi_moshmoon2( JD, pol );
 *
 * - S. L. Moshier, August, 1991
 * DE200 fit: July, 1992
 * DE404 fit: October, 1995
 *
 * Dieter Koch: adaptation to SWISSEPH, April 1996
 * 18-feb-2006  replaced LP by SWELP because of name collision
 */

  SwissData swed;
  SwissLib sl;

  Swemmoon() {
    this(null,null);
// //#ifdef TRACE0
//     DevNull.println(System.currentTimeMillis()+" Swemmoon()");
// //#endif /* TRACE0 */
  }

  Swemmoon(SwissData swed, SwissLib sl) {
    this.swed=swed;
    this.sl=sl;
    if (this.swed ==null) { this.swed =new SwissData(); }
    if (this.sl   ==null) { this.sl   =new SwissLib(); }
  }


  /* The following coefficients were calculated by a simultaneous least
   * squares fit between the analytical theory and DE404 on the finite
   * interval from -3000 to +3000.
   * The coefficients were estimated from 34,247 Lunar positions.
   */
  static final double z[] = {
    /* The following are scaled in arc seconds, time in Julian centuries.
       They replace the corresponding terms in the mean elements.  */
    -1.312045233711e+01, /* F, t^2 */
    -1.138215912580e-03, /* F, t^3 */
    -9.646018347184e-06, /* F, t^4 */
     3.146734198839e+01, /* l, t^2 */
     4.768357585780e-02, /* l, t^3 */
    -3.421689790404e-04, /* l, t^4 */
    -6.847070905410e+00, /* D, t^2 */
    -5.834100476561e-03, /* D, t^3 */
    -2.905334122698e-04, /* D, t^4 */
    -5.663161722088e+00, /* L, t^2 */
     5.722859298199e-03, /* L, t^3 */
    -8.466472828815e-05, /* L, t^4 */
    /* The following longitude terms are in arc seconds times 10^5.  */
    -8.429817796435e+01, /* t^2 Math.cos(18V - 16E - l) */
    -2.072552484689e+02, /* t^2 Math.sin(18V - 16E - l) */
     7.876842214863e+00, /* t^2 Math.cos(10V - 3E - l) */
     1.836463749022e+00, /* t^2 Math.sin(10V - 3E - l) */
    -1.557471855361e+01, /* t^2 Math.cos(8V - 13E) */
    -2.006969124724e+01, /* t^2 Math.sin(8V - 13E) */
     2.152670284757e+01, /* t^2 Math.cos(4E - 8M + 3J) */
    -6.179946916139e+00, /* t^2 Math.sin(4E - 8M + 3J) */
    -9.070028191196e-01, /* t^2 Math.cos(18V - 16E) */
    -1.270848233038e+01, /* t^2 Math.sin(18V - 16E) */
    -2.145589319058e+00, /* t^2 Math.cos(2J - 5S) */
     1.381936399935e+01, /* t^2 Math.sin(2J - 5S) */
    -1.999840061168e+00, /* t^3 Math.sin(l') */
  };


  /* Perturbation tables
   */
  static final int NLR=118;
  static final short LR[]={
  /*
                 Longitude    Radius
   D  l' l  F    1"  .0001"  1km  .0001km */

   0, 0, 1, 0, 22639, 5858,-20905,-3550,
   2, 0,-1, 0,  4586, 4383, -3699,-1109,
   2, 0, 0, 0,  2369, 9139, -2955,-9676,
   0, 0, 2, 0,   769,  257,  -569,-9251,
   0, 1, 0, 0,  -666,-4171,    48, 8883,
   0, 0, 0, 2,  -411,-5957,    -3,-1483,
   2, 0,-2, 0,   211, 6556,   246, 1585,
   2,-1,-1, 0,   205, 4358,  -152,-1377,
   2, 0, 1, 0,   191, 9562,  -170,-7331,
   2,-1, 0, 0,   164, 7285,  -204,-5860,
   0, 1,-1, 0,  -147,-3213,  -129,-6201,
   1, 0, 0, 0,  -124,-9881,   108, 7427,
   0, 1, 1, 0,  -109,-3803,   104, 7552,
   2, 0, 0,-2,    55, 1771,    10, 3211,
   0, 0, 1, 2,   -45, -996,     0,    0,
   0, 0, 1,-2,    39, 5333,    79, 6606,
   4, 0,-1, 0,    38, 4298,   -34,-7825,
   0, 0, 3, 0,    36, 1238,   -23,-2104,
   4, 0,-2, 0,    30, 7726,   -21,-6363,
   2, 1,-1, 0,   -28,-3971,    24, 2085,
   2, 1, 0, 0,   -24,-3582,    30, 8238,
   1, 0,-1, 0,   -18,-5847,    -8,-3791,
   1, 1, 0, 0,    17, 9545,   -16,-6747,
   2,-1, 1, 0,    14, 5303,   -12,-8314,
   2, 0, 2, 0,    14, 3797,   -10,-4448,
   4, 0, 0, 0,    13, 8991,   -11,-6500,
   2, 0,-3, 0,    13, 1941,    14, 4027,
   0, 1,-2, 0,    -9,-6791,    -7,  -27,
   2, 0,-1, 2,    -9,-3659,     0, 7740,
   2,-1,-2, 0,     8, 6055,    10,  562,
   1, 0, 1, 0,    -8,-4531,     6, 3220,
   2,-2, 0, 0,     8,  502,    -9,-8845,
   0, 1, 2, 0,    -7,-6302,     5, 7509,
   0, 2, 0, 0,    -7,-4475,     1,  657,
   2,-2,-1, 0,     7, 3712,    -4,-9501,
   2, 0, 1,-2,    -6,-3832,     4, 1311,
   2, 0, 0, 2,    -5,-7416,     0,    0,
   4,-1,-1, 0,     4, 3740,    -3,-9580,
   0, 0, 2, 2,    -3,-9976,     0,    0,
   3, 0,-1, 0,    -3,-2097,     3, 2582,
   2, 1, 1, 0,    -2,-9145,     2, 6164,
   4,-1,-2, 0,     2, 7319,    -1,-8970,
   0, 2,-1, 0,    -2,-5679,    -2,-1171,
   2, 2,-1, 0,    -2,-5212,     2, 3536,
   2, 1,-2, 0,     2, 4889,     0, 1437,
   2,-1, 0,-2,     2, 1461,     0, 6571,
   4, 0, 1, 0,     1, 9777,    -1,-4226,
   0, 0, 4, 0,     1, 9337,    -1,-1169,
   4,-1, 0, 0,     1, 8708,    -1,-5714,
   1, 0,-2, 0,    -1,-7530,    -1,-7385,
   2, 1, 0,-2,    -1,-4372,     0,-1357,
   0, 0, 2,-2,    -1,-3726,    -4,-4212,
   1, 1, 1, 0,     1, 2618,     0,-9333,
   3, 0,-2, 0,    -1,-2241,     0, 8624,
   4, 0,-3, 0,     1, 1868,     0,-5142,
   2,-1, 2, 0,     1, 1770,     0,-8488,
   0, 2, 1, 0,    -1,-1617,     1, 1655,
   1, 1,-1, 0,     1,  777,     0, 8512,
   2, 0, 3, 0,     1,  595,     0,-6697,
   2, 0, 1, 2,     0,-9902,     0,    0,
   2, 0,-4, 0,     0, 9483,     0, 7785,
   2,-2, 1, 0,     0, 7517,     0,-6575,
   0, 1,-3, 0,     0,-6694,     0,-4224,
   4, 1,-1, 0,     0,-6352,     0, 5788,
   1, 0, 2, 0,     0,-5840,     0, 3785,
   1, 0, 0,-2,     0,-5833,     0,-7956,
   6, 0,-2, 0,     0, 5716,     0,-4225,
   2, 0,-2,-2,     0,-5606,     0, 4726,
   1,-1, 0, 0,     0,-5569,     0, 4976,
   0, 1, 3, 0,     0,-5459,     0, 3551,
   2, 0,-2, 2,     0,-5357,     0, 7740,
   2, 0,-1,-2,     0, 1790,     8, 7516,
   3, 0, 0, 0,     0, 4042,    -1,-4189,
   2,-1,-3, 0,     0, 4784,     0, 4950,
   2,-1, 3, 0,     0,  932,     0, -585,
   2, 0, 2,-2,     0,-4538,     0, 2840,
   2,-1,-1, 2,     0,-4262,     0,  373,
   0, 0, 0, 4,     0, 4203,     0,    0,
   0, 1, 0, 2,     0, 4134,     0,-1580,
   6, 0,-1, 0,     0, 3945,     0,-2866,
   2,-1, 0, 2,     0,-3821,     0,    0,
   2,-1, 1,-2,     0,-3745,     0, 2094,
   4, 1,-2, 0,     0,-3576,     0, 2370,
   1, 1,-2, 0,     0, 3497,     0, 3323,
   2,-3, 0, 0,     0, 3398,     0,-4107,
   0, 0, 3, 2,     0,-3286,     0,    0,
   4,-2,-1, 0,     0,-3087,     0,-2790,
   0, 1,-1,-2,     0, 3015,     0,    0,
   4, 0,-1,-2,     0, 3009,     0,-3218,
   2,-2,-2, 0,     0, 2942,     0, 3430,
   6, 0,-3, 0,     0, 2925,     0,-1832,
   2, 1, 2, 0,     0,-2902,     0, 2125,
   4, 1, 0, 0,     0,-2891,     0, 2445,
   4,-1, 1, 0,     0, 2825,     0,-2029,
   3, 1,-1, 0,     0, 2737,     0,-2126,
   0, 1, 1, 2,     0, 2634,     0,    0,
   1, 0, 0, 2,     0, 2543,     0,    0,
   3, 0, 0,-2,     0,-2530,     0, 2010,
   2, 2,-2, 0,     0,-2499,     0,-1089,
   2,-3,-1, 0,     0, 2469,     0,-1481,
   3,-1,-1, 0,     0,-2314,     0, 2556,
   4, 0, 2, 0,     0, 2185,     0,-1392,
   4, 0,-1, 2,     0,-2013,     0, 0,
   0, 2,-2, 0,     0,-1931,     0, 0,
   2, 2, 0, 0,     0,-1858,     0, 0,
   2, 1,-3, 0,     0, 1762,     0, 0,
   4, 0,-2, 2,     0,-1698,     0, 0,
   4,-2,-2, 0,     0, 1578,     0,-1083,
   4,-2, 0, 0,     0, 1522,     0,-1281,
   3, 1, 0, 0,     0, 1499,     0,-1077,
   1,-1,-1, 0,     0,-1364,     0, 1141,
   1,-3, 0, 0,     0,-1281,     0, 0,
   6, 0, 0, 0,     0, 1261,     0, -859,
   2, 0, 2, 2,     0,-1239,     0, 0,
   1,-1, 1, 0,     0,-1207,     0, 1100,
   0, 0, 5, 0,     0, 1110,     0, -589,
   0, 3, 0, 0,     0,-1013,     0,  213,
   4,-1,-3, 0,     0,  998,     0, 0,
  };


  static final int NMB=77;
  static final short MB[]={
  /*
                 Latitude
   D  l' l  F    1"  .0001" */

   0, 0, 0, 1,18461, 2387,
   0, 0, 1, 1, 1010, 1671,
   0, 0, 1,-1,  999, 6936,
   2, 0, 0,-1,  623, 6524,
   2, 0,-1, 1,  199, 4837,
   2, 0,-1,-1,  166, 5741,
   2, 0, 0, 1,  117, 2607,
   0, 0, 2, 1,   61, 9120,
   2, 0, 1,-1,   33, 3572,
   0, 0, 2,-1,   31, 7597,
   2,-1, 0,-1,   29, 5766,
   2, 0,-2,-1,   15, 5663,
   2, 0, 1, 1,   15, 1216,
   2, 1, 0,-1,  -12, -941,
   2,-1,-1, 1,    8, 8681,
   2,-1, 0, 1,    7, 9586,
   2,-1,-1,-1,    7, 4346,
   0, 1,-1,-1,   -6,-7314,
   4, 0,-1,-1,    6, 5796,
   0, 1, 0, 1,   -6,-4601,
   0, 0, 0, 3,   -6,-2965,
   0, 1,-1, 1,   -5,-6324,
   1, 0, 0, 1,   -5,-3684,
   0, 1, 1, 1,   -5,-3113,
   0, 1, 1,-1,   -5, -759,
   0, 1, 0,-1,   -4,-8396,
   1, 0, 0,-1,   -4,-8057,
   0, 0, 3, 1,    3, 9841,
   4, 0, 0,-1,    3, 6745,
   4, 0,-1, 1,    2, 9985,
   0, 0, 1,-3,    2, 7986,
   4, 0,-2, 1,    2, 4139,
   2, 0, 0,-3,    2, 1863,
   2, 0, 2,-1,    2, 1462,
   2,-1, 1,-1,    1, 7660,
   2, 0,-2, 1,   -1,-6244,
   0, 0, 3,-1,    1, 5813,
   2, 0, 2, 1,    1, 5198,
   2, 0,-3,-1,    1, 5156,
   2, 1,-1, 1,   -1,-3178,
   2, 1, 0, 1,   -1,-2643,
   4, 0, 0, 1,    1, 1919,
   2,-1, 1, 1,    1, 1346,
   2,-2, 0,-1,    1,  859,
   0, 0, 1, 3,   -1, -194,
   2, 1, 1,-1,    0,-8227,
   1, 1, 0,-1,    0, 8042,
   1, 1, 0, 1,    0, 8026,
   0, 1,-2,-1,    0,-7932,
   2, 1,-1,-1,    0,-7910,
   1, 0, 1, 1,    0,-6674,
   2,-1,-2,-1,    0, 6502,
   0, 1, 2, 1,    0,-6388,
   4, 0,-2,-1,    0, 6337,
   4,-1,-1,-1,    0, 5958,
   1, 0, 1,-1,    0,-5889,
   4, 0, 1,-1,    0, 4734,
   1, 0,-1,-1,    0,-4299,
   4,-1, 0,-1,    0, 4149,
   2,-2, 0, 1,    0, 3835,
   3, 0, 0,-1,    0,-3518,
   4,-1,-1, 1,    0, 3388,
   2, 0,-1,-3,    0, 3291,
   2,-2,-1, 1,    0, 3147,
   0, 1, 2,-1,    0,-3129,
   3, 0,-1,-1,    0,-3052,
   0, 1,-2, 1,    0,-3013,
   2, 0, 1,-3,    0,-2912,
   2,-2,-1,-1,    0, 2686,
   0, 0, 4, 1,    0, 2633,
   2, 0,-3, 1,    0, 2541,
   2, 0,-1, 3,    0,-2448,
   2, 1, 1, 1,    0,-2370,
   4,-1,-2, 1,    0, 2138,
   4, 0, 1, 1,    0, 2126,
   3, 0,-1, 1,    0,-2059,
   4, 1,-1,-1,    0,-1719,
  };

  static final int NLRT=38;
  static final short LRT[]={
  /*
  Multiply by T
                 Longitude    Radius
   D  l' l  F   .1"  .00001" .1km  .00001km */

   0, 1, 0, 0,    16, 7680,    -1,-2302,
   2,-1,-1, 0,    -5,-1642,     3, 8245,
   2,-1, 0, 0,    -4,-1383,     5, 1395,
   0, 1,-1, 0,     3, 7115,     3, 2654,
   0, 1, 1, 0,     2, 7560,    -2,-6396,
   2, 1,-1, 0,     0, 7118,     0,-6068,
   2, 1, 0, 0,     0, 6128,     0,-7754,
   1, 1, 0, 0,     0,-4516,     0, 4194,
   2,-2, 0, 0,     0,-4048,     0, 4970,
   0, 2, 0, 0,     0, 3747,     0, -540,
   2,-2,-1, 0,     0,-3707,     0, 2490,
   2,-1, 1, 0,     0,-3649,     0, 3222,
   0, 1,-2, 0,     0, 2438,     0, 1760,
   2,-1,-2, 0,     0,-2165,     0,-2530,
   0, 1, 2, 0,     0, 1923,     0,-1450,
   0, 2,-1, 0,     0, 1292,     0, 1070,
   2, 2,-1, 0,     0, 1271,     0,-6070,
   4,-1,-1, 0,     0,-1098,     0,  990,
   2, 0, 0, 0,     0, 1073,     0,-1360,
   2, 0,-1, 0,     0,  839,     0, -630,
   2, 1, 1, 0,     0,  734,     0, -660,
   4,-1,-2, 0,     0, -688,     0,  480,
   2, 1,-2, 0,     0, -630,     0,    0,
   0, 2, 1, 0,     0,  587,     0, -590,
   2,-1, 0,-2,     0, -540,     0, -170,
   4,-1, 0, 0,     0, -468,     0,  390,
   2,-2, 1, 0,     0, -378,     0,  330,
   2, 1, 0,-2,     0,  364,     0,    0,
   1, 1, 1, 0,     0, -317,     0,  240,
   2,-1, 2, 0,     0, -295,     0,  210,
   1, 1,-1, 0,     0, -270,     0, -210,
   2,-3, 0, 0,     0, -256,     0,  310,
   2,-3,-1, 0,     0, -187,     0,  110,
   0, 1,-3, 0,     0,  169,     0,  110,
   4, 1,-1, 0,     0,  158,     0, -150,
   4,-2,-1, 0,     0, -155,     0,  140,
   0, 0, 1, 0,     0,  155,     0, -250,
   2,-2,-2, 0,     0, -148,     0, -170,
  };

  static final int NBT=16;
  static final short BT[]={
  /*
  Multiply by T
               Latitude
   D  l' l  F  .00001"  */

   2,-1, 0,-1, -7430,
   2, 1, 0,-1,  3043,
   2,-1,-1, 1, -2229,
   2,-1, 0, 1, -1999,
   2,-1,-1,-1, -1869,
   0, 1,-1,-1,  1696,
   0, 1, 0, 1,  1623,
   0, 1,-1, 1,  1418,
   0, 1, 1, 1,  1339,
   0, 1, 1,-1,  1278,
   0, 1, 0,-1,  1217,
   2,-2, 0,-1,  -547,
   2,-1, 1,-1,  -443,
   2, 1,-1, 1,   331,
   2, 1, 0, 1,   317,
   2, 0, 0,-1,   295,
  };

  static final int NLRT2=25;
  static final short LRT2[]={
  /*
  Multiply by T^2
             Longitude    Radius
   D  l' l  F  .00001" .00001km   */

   0, 1, 0, 0,  487,   -36,
   2,-1,-1, 0, -150,   111,
   2,-1, 0, 0, -120,   149,
   0, 1,-1, 0,  108,    95,
   0, 1, 1, 0,   80,   -77,
   2, 1,-1, 0,   21,   -18,
   2, 1, 0, 0,   20,   -23,
   1, 1, 0, 0,  -13,    12,
   2,-2, 0, 0,  -12,    14,
   2,-1, 1, 0,  -11,     9,
   2,-2,-1, 0,  -11,     7,
   0, 2, 0, 0,   11,     0,
   2,-1,-2, 0,   -6,    -7,
   0, 1,-2, 0,    7,     5,
   0, 1, 2, 0,    6,    -4,
   2, 2,-1, 0,    5,    -3,
   0, 2,-1, 0,    5,     3,
   4,-1,-1, 0,   -3,     3,
   2, 0, 0, 0,    3,    -4,
   4,-1,-2, 0,   -2,     0,
   2, 1,-2, 0,   -2,     0,
   2,-1, 0,-2,   -2,     0,
   2, 1, 1, 0,    2,    -2,
   2, 0,-1, 0,    2,     0,
   0, 2, 1, 0,    2,     0,
  };

  static final int NBT2=12;
  static final short BT2[]={
  /*
  Multiply by T^2
             Latitiude
   D  l' l  F  .00001" */

   2,-1, 0,-1,  -22,
   2, 1, 0,-1,    9,
   2,-1, 0, 1,   -6,
   2,-1,-1, 1,   -6,
   2,-1,-1,-1,   -5,
   0, 1, 0, 1,    5,
   0, 1,-1,-1,    5,
   0, 1, 1, 1,    4,
   0, 1, 1,-1,    4,
   0, 1, 0,-1,    4,
   0, 1,-1, 1,    4,
   2,-2, 0,-1,   -2,
  };

  /* The following times are set up by update() and refer
   * to the same instant.  The distinction between them
   * is required by altaz().
   */
  double ss[][]=new double[5][8];
  double cc[][]=new double[5][8];

  double l;                /* Moon's ecliptic longitude */
  double B;                /* Ecliptic latitude */

  double moonpol[]=new double[3];

  /* Orbit calculation begins.
   */
  double SWELP;
  double M;
  double MP;
  double D;
  double NF;
  double T;
  double T2;

  static double T3;
  static double T4;
  static double f;
  static double g;
  static double Ve;
  static double Ea;
  static double Ma;
  static double Ju;
  static double Sa;
  static double cg;
  static double sg;
  static double l1;
  static double l2;
  static double l3;
  static double l4;

  /* Calculate geometric coordinates of Moon
   * without light time or nutation correction.
   */
  int swi_moshmoon2(double J, double[] pol) {
    int i;
    T = (J-SwephData.J2000)/36525.0;
    T2 = T*T;
    mean_elements();
    mean_elements_pl();
    moon1();
    moon2();
    moon3();
    moon4();
    for( i=0; i<3; i++ )
      pol[i] = moonpol[i];
    return(0);
  }

  /* Moshier's moom
   * tjd          julian day
   * xpm          array of 6 doubles for moon's position and speed vectors
   * serr         pointer to error string
   */
  int swi_moshmoon(double tjd, boolean do_save, double[] xpmret,
                   StringBuffer serr) {
    int i;
    double a, b, x1[]=new double[6], x2[]=new double[6], t;
    double xx[]=new double[6], xpm[];
    PlanData pdp = swed.pldat[SwephData.SEI_MOON];
    String s;
    if (do_save) {
      xpm = pdp.x;
    } else {
      xpm = xx;
    }
    /* allow 0.2 day tolerance so that true node interval fits in */
    if (tjd < SwephData.MOSHLUEPH_START - 0.2 || tjd > SwephData.MOSHLUEPH_END + 0.2) {
      if (serr != null) {
        s="jd "+tjd+" outside Moshier's Moon range "+
          SwephData.MOSHLUEPH_START+" .. "+
          SwephData.MOSHLUEPH_END+" ";
        if (serr.length() + s.length() < SwissData.AS_MAXCH) {
          serr.append(s);
        }
      }
      return(SweConst.ERR);
    }
    /* if moon has already been computed */
    if (tjd == pdp.teval && pdp.iephe == SweConst.SEFLG_MOSEPH) {
      if (xpmret != null) {
        for (i = 0; i <= 5; i++) {
          xpmret[i] = pdp.x[i];
        }
      }
      return(SweConst.OK);
    }
    /* else compute moon */
    swi_moshmoon2(tjd, xpm);
    if (do_save) {
      pdp.teval = tjd;
      pdp.xflgs = -1;
      pdp.iephe = SweConst.SEFLG_MOSEPH;
    }
    /* Moshier moon is referred to ecliptic of date. But we need
     * equatorial positions for several reasons.
     * e.g. computation of earth from emb and moon
     *                  of heliocentric moon
     * Besides, this helps to keep the program structure simpler
     */
    ecldat_equ2000(tjd, xpm);
    /* speed */
    /* from 2 other positions. */
    /* one would be good enough for computation of osculating node,
     * but not for osculating apogee */
    t = tjd + SwephData.MOON_SPEED_INTV;
    swi_moshmoon2(t, x1);
    ecldat_equ2000(t, x1);
    t = tjd - SwephData.MOON_SPEED_INTV;
    swi_moshmoon2(t, x2);
    ecldat_equ2000(t, x2);
    for (i = 0; i <= 2; i++) {
      b = (x1[i] - x2[i]) / 2;
      a = (x1[i] + x2[i]) / 2 - xpm[i];
      xpm[i+3] = (2 * a + b) / SwephData.MOON_SPEED_INTV;
    }
    if (xpmret != null) {
      for (i = 0; i <= 5; i++) {
        xpmret[i] = xpm[i];
      }
    }
    return(SweConst.OK);
  }


  private void moon1() {
    double a;

    sscc( 0, SwephData.STR*D, 6 );
    sscc( 1, SwephData.STR*M,  4 );
    sscc( 2, SwephData.STR*MP, 4 );
    sscc( 3, SwephData.STR*NF, 4 );
    moonpol[0] = 0.0;
    moonpol[1] = 0.0;
    moonpol[2] = 0.0;
    /* terms in T^2, scale 1.0 = 10^-5" */
    chewm( LRT2, NLRT2, 4, 2, moonpol );
    chewm( BT2, NBT2, 4, 4, moonpol );
    f = 18 * Ve - 16 * Ea;
    g = SwephData.STR*(f - MP );  /* 18V - 16E - l */
    cg = Math.cos(g);
    sg = Math.sin(g);
    l = 6.367278 * cg + 12.747036 * sg;  /* t^0 */
    l1 = 23123.70 * cg - 10570.02 * sg;  /* t^1 */
    l2 = z[12] * cg + z[13] * sg;        /* t^2 */
    moonpol[2] += 5.01 * cg + 2.72 * sg;
    g = SwephData.STR * (10.*Ve - 3.*Ea - MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.253102 * cg + 0.503359 * sg;
    l1 += 1258.46 * cg + 707.29 * sg;
    l2 += z[14] * cg + z[15] * sg;
    g = SwephData.STR*(8.*Ve - 13.*Ea);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.187231 * cg - 0.127481 * sg;
    l1 += -319.87 * cg - 18.34 * sg;
    l2 += z[16] * cg + z[17] * sg;
    a = 4.0*Ea - 8.0*Ma + 3.0*Ju;
    g = SwephData.STR * a;
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.866287 * cg + 0.248192 * sg;
    l1 += 41.87 * cg + 1053.97 * sg;
    l2 += z[18] * cg + z[19] * sg;
    g = SwephData.STR*(a - MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.165009 * cg + 0.044176 * sg;
    l1 += 4.67 * cg + 201.55 * sg;
    g = SwephData.STR*f;  /* 18V - 16E */
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.330401 * cg + 0.661362 * sg;
    l1 += 1202.67 * cg - 555.59 * sg;
    l2 += z[20] * cg + z[21] * sg;
    g = SwephData.STR*(f - 2.0*MP );  /* 18V - 16E - 2l */
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.352185 * cg + 0.705041 * sg;
    l1 += 1283.59 * cg - 586.43 * sg;
    g = SwephData.STR * (2.0*Ju - 5.0*Sa);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.034700 * cg + 0.160041 * sg;
    l2 += z[22] * cg + z[23] * sg;
    g = SwephData.STR * (SWELP - NF);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.000116 * cg + 7.063040 * sg;
    l1 +=  298.8 * sg;
    /* T^3 terms */
    sg = Math.sin( SwephData.STR * M );
    /* l3 +=  z[24] * sg;                   moshier! l3 not initialized! */
    l3 =  z[24] * sg;
    l4 = 0;
    g = SwephData.STR * (2.0*D - M);
    sg = Math.sin(g);
    cg = Math.cos(g);
    moonpol[2] +=  -0.2655 * cg * T;
    g = SwephData.STR * (M - MP);
    moonpol[2] +=  -0.1568 * Math.cos( g ) * T;
    g = SwephData.STR * (M + MP);
    moonpol[2] +=  0.1309 * Math.cos( g ) * T;
    g = SwephData.STR * (2.0*(D + M) - MP);
    sg = Math.sin(g);
    cg = Math.cos(g);
    moonpol[2] +=   0.5568 * cg * T;
    l2 += moonpol[0];
    g = SwephData.STR*(2.0*D - M - MP);
    moonpol[2] +=  -0.1910 * Math.cos( g ) * T;
    moonpol[1] *= T;
    moonpol[2] *= T;
    /* terms in T */
    moonpol[0] = 0.0;
    chewm( BT, NBT, 4, 4, moonpol );
    chewm( LRT, NLRT, 4, 1, moonpol );
    g = SwephData.STR*(f - MP - NF - 2355767.6); /* 18V - 16E - l - F */
    moonpol[1] +=  -1127. * Math.sin(g);
    g = SwephData.STR*(f - MP + NF - 235353.6); /* 18V - 16E - l + F */
    moonpol[1] +=  -1123. * Math.sin(g);
    g = SwephData.STR*(Ea + D + 51987.6);
    moonpol[1] +=  1303. * Math.sin(g);
    g = SwephData.STR*SWELP;
    moonpol[1] +=  342. * Math.sin(g);
    g = SwephData.STR*(2.*Ve - 3.*Ea);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l +=  -0.343550 * cg - 0.000276 * sg;
    l1 +=  105.90 * cg + 336.53 * sg;
    g = SwephData.STR*(f - 2.*D); /* 18V - 16E - 2D */
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.074668 * cg + 0.149501 * sg;
    l1 += 271.77 * cg - 124.20 * sg;
    g = SwephData.STR*(f - 2.*D - MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.073444 * cg + 0.147094 * sg;
    l1 += 265.24 * cg - 121.16 * sg;
    g = SwephData.STR*(f + 2.*D - MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.072844 * cg + 0.145829 * sg;
    l1 += 265.18 * cg - 121.29 * sg;
    g = SwephData.STR*(f + 2.*(D - MP));
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.070201 * cg + 0.140542 * sg;
    l1 += 255.36 * cg - 116.79 * sg;
    g = SwephData.STR*(Ea + D - NF);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.288209 * cg - 0.025901 * sg;
    l1 += -63.51 * cg - 240.14 * sg;
    g = SwephData.STR*(2.*Ea - 3.*Ju + 2.*D - MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.077865 * cg + 0.438460 * sg;
    l1 += 210.57 * cg + 124.84 * sg;
    g = SwephData.STR*(Ea - 2.*Ma);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.216579 * cg + 0.241702 * sg;
    l1 += 197.67 * cg + 125.23 * sg;
    g = SwephData.STR*(a + MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.165009 * cg + 0.044176 * sg;
    l1 += 4.67 * cg + 201.55 * sg;
    g = SwephData.STR*(a + 2.*D - MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.133533 * cg + 0.041116 * sg;
    l1 +=  6.95 * cg + 187.07 * sg;
    g = SwephData.STR*(a - 2.*D + MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.133430 * cg + 0.041079 * sg;
    l1 +=  6.28 * cg + 169.08 * sg;
    g = SwephData.STR*(3.*Ve - 4.*Ea);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.175074 * cg + 0.003035 * sg;
    l1 +=  49.17 * cg + 150.57 * sg;
    g = SwephData.STR*(2.*(Ea + D - MP) - 3.*Ju + 213534.);
    l1 +=  158.4 * Math.sin(g);
    l1 += moonpol[0];
    a = 0.1 * T; /* set amplitude scale of 1.0 = 10^-4 arcsec */
    moonpol[1] *= a;
    moonpol[2] *= a;
  }

  void moon2() {
    /* terms in T^0 */
    g = SwephData.STR*(2*(Ea-Ju+D)-MP+648431.172);
    l += 1.14307 * Math.sin(g);
    g = SwephData.STR*(Ve-Ea+648035.568);
    l += 0.82155 * Math.sin(g);
    g = SwephData.STR*(3*(Ve-Ea)+2*D-MP+647933.184);
    l += 0.64371 * Math.sin(g);
    g = SwephData.STR*(Ea-Ju+4424.04);
    l += 0.63880 * Math.sin(g);
    g = SwephData.STR*(SWELP + MP - NF + 4.68);
    l += 0.49331 * Math.sin(g);
    g = SwephData.STR*(SWELP - MP - NF + 4.68);
    l += 0.4914 * Math.sin(g);
    g = SwephData.STR*(SWELP+NF+2.52);
    l += 0.36061 * Math.sin(g);
    g = SwephData.STR*(2.*Ve - 2.*Ea + 736.2);
    l += 0.30154 * Math.sin(g);
    g = SwephData.STR*(2.*Ea - 3.*Ju + 2.*D - 2.*MP + 36138.2);
    l += 0.28282 * Math.sin(g);
    g = SwephData.STR*(2.*Ea - 2.*Ju + 2.*D - 2.*MP + 311.0);
    l += 0.24516 * Math.sin(g);
    g = SwephData.STR*(Ea - Ju - 2.*D + MP + 6275.88);
    l += 0.21117 * Math.sin(g);
    g = SwephData.STR*(2.*(Ea - Ma) - 846.36);
    l += 0.19444 * Math.sin(g);
    g = SwephData.STR*(2.*(Ea - Ju) + 1569.96);
    l -= 0.18457 * Math.sin(g);
    g = SwephData.STR*(2.*(Ea - Ju) - MP - 55.8);
    l += 0.18256 * Math.sin(g);
    g = SwephData.STR*(Ea - Ju - 2.*D + 6490.08);
    l += 0.16499 * Math.sin(g);
    g = SwephData.STR*(Ea - 2.*Ju - 212378.4);
    l += 0.16427 * Math.sin(g);
    g = SwephData.STR*(2.*(Ve - Ea - D) + MP + 1122.48);
    l += 0.16088 * Math.sin(g);
    g = SwephData.STR*(Ve - Ea - MP + 32.04);
    l -= 0.15350 * Math.sin(g);
    g = SwephData.STR*(Ea - Ju - MP + 4488.88);
    l += 0.14346 * Math.sin(g);
    g = SwephData.STR*(2.*(Ve - Ea + D) - MP - 8.64);
    l += 0.13594 * Math.sin(g);
    g = SwephData.STR*(2.*(Ve - Ea - D) + 1319.76);
    l += 0.13432 * Math.sin(g);
    g = SwephData.STR*(Ve - Ea - 2.*D + MP - 56.16);
    l -= 0.13122 * Math.sin(g);
    g = SwephData.STR*(Ve - Ea + MP + 54.36);
    l -= 0.12722 * Math.sin(g);
    g = SwephData.STR*(3.*(Ve - Ea) - MP + 433.8);
    l += 0.12539 * Math.sin(g);
    g = SwephData.STR*(Ea - Ju + MP + 4002.12);
    l += 0.10994 * Math.sin(g);
    g = SwephData.STR*(20.*Ve - 21.*Ea - 2.*D + MP - 317511.72);
    l += 0.10652 * Math.sin(g);
    g = SwephData.STR*(26.*Ve - 29.*Ea - MP + 270002.52);
    l += 0.10490 * Math.sin(g);
    g = SwephData.STR*(3.*Ve - 4.*Ea + D - MP - 322765.56);
    l += 0.10386 * Math.sin(g);
    g = SwephData.STR*(SWELP+648002.556);
    B =  8.04508 * Math.sin(g);
    g = SwephData.STR*(Ea+D+996048.252);
    B += 1.51021 * Math.sin(g);
    g = SwephData.STR*(f - MP + NF + 95554.332);
    B += 0.63037 * Math.sin(g);
    g = SwephData.STR*(f - MP - NF + 95553.792);
    B += 0.63014 * Math.sin(g);
    g = SwephData.STR*(SWELP - MP + 2.9);
    B +=  0.45587 * Math.sin(g);
    g = SwephData.STR*(SWELP + MP + 2.5);
    B +=  -0.41573 * Math.sin(g);
    g = SwephData.STR*(SWELP - 2.0*NF + 3.2);
    B +=  0.32623 * Math.sin(g);
    g = SwephData.STR*(SWELP - 2.0*D + 2.5);
    B +=  0.29855 * Math.sin(g);
  }

  void moon3() {
    /* terms in T^0 */
    moonpol[0] = 0.0;
    chewm( LR, NLR, 4, 1, moonpol );
    chewm( MB, NMB, 4, 3, moonpol );
    l += (((l4 * T + l3) * T + l2) * T + l1) * T * 1.0e-5;
    moonpol[0] = SWELP + l + 1.0e-4 * moonpol[0];
    moonpol[1] = 1.0e-4 * moonpol[1] + B;
    moonpol[2] = 1.0e-4 * moonpol[2] + 385000.52899; /* kilometers */
  }


  /* Compute final ecliptic polar coordinates
   */
  void moon4() {
    moonpol[2] /= SweConst.AUNIT / 1000;
    moonpol[0] = SwephData.STR * mods3600( moonpol[0] );
    moonpol[1] = SwephData.STR * moonpol[1];
    B = moonpol[1];
  }

  /* mean lunar node
   * J            julian day
   * pol          return array for position and velocity
   *              (polar coordinates of ecliptic of date)
   */
  int swi_mean_node(double J, double pol[], StringBuffer serr) {
    return swi_mean_node(J, pol, 0, serr);
  }
  int swi_mean_node(double J, double pol[], int offs, StringBuffer serr) {
    String s;
    T = (J-SwephData.J2000)/36525.0;
    T2 = T*T;
    T3 = T*T2;
    T4 = T2*T2;
    /* with elements from swi_moshmoon2(), which are fitted to jpl-ephemeris */
    if (J < SwephData.MOSHNDEPH_START || J > SwephData.MOSHNDEPH_END) {
      if (serr != null) {
        s="jd "+J+" outside mean node range "+
                SwephData.MOSHNDEPH_START+" .. "+
                SwephData.MOSHNDEPH_END+" ";
        serr.append(s);
      }
      return SweConst.ERR;
    }
    mean_elements();
    /* longitude */
    pol[offs] = sl.swi_mod2PI((SWELP - NF) * SwephData.STR);
    /* latitude */
    pol[offs+1] = 0.0;
    /* distance */
    pol[offs+2] = SwephData.MOON_MEAN_DIST / SweConst.AUNIT; /* or should it be derived from mean
                                      * orbital ellipse? */
    return SweConst.OK;
  }

  /* mean lunar apogee ('dark moon', 'lilith')
   * J            julian day
   * pol          return array for position
   *              (polar coordinates of ecliptic of date)
   * serr         error return string
   */
  int swi_mean_apog(double J, double pol[], StringBuffer serr) {
    return swi_mean_apog(J, pol, 0, serr);
  }
  int swi_mean_apog(double J, double pol[], int offs, StringBuffer serr) {
    double node;
    String s;
    T = (J-SwephData.J2000)/36525.0;
    T2 = T*T;
    T3 = T*T2;
    T4 = T2*T2;
    /* with elements from swi_moshmoon2(), which are fitted to jpl-ephemeris */
    if (J < SwephData.MOSHNDEPH_START || J > SwephData.MOSHNDEPH_END) {
      if (serr != null) {
        s="jd "+J+" outside mean apogee range "+
                SwephData.MOSHNDEPH_START+" .. "+
                SwephData.MOSHNDEPH_END+" ";
        if (serr.length()+s.length() < SwissData.AS_MAXCH) {
          serr.append(s);
        }
      }
      return SweConst.ERR;
    }
    mean_elements();
    pol[offs] = sl.swi_mod2PI((SWELP - MP) * SwephData.STR + SwephData.PI);
    pol[offs+1] = 0;
    pol[offs+2] = SwephData.MOON_MEAN_DIST * (1 + SwephData.MOON_MEAN_ECC) /
                                                 SweConst.AUNIT; /* apogee */
    /* Lilith or Dark Moon is either the empty focal point of the mean
     * lunar ellipse or, for some people, its apogee ("aphelion").
     * This is 180 degrees from the perigee.
     *
     * Since the lunar orbit is not in the ecliptic, the apogee must be
     * projected onto the ecliptic.
     * Joelle de Gravelaine has in her book "Lilith der schwarze Mond"
     * (Astrodata, 1990) an ephemeris which gives noon (12.00) positions
     * but does not project them onto the ecliptic.
     * This results in a mistake of several arc minutes.
     *
     * There is also another problem. The other focal point doesn't
     * coincide with the geocenter but with the barycenter of the
     * earth-moon-system. The difference is about 4700 km. If one
     * took this into account, it would result in an oscillation
     * of the Black Moon. If defined as the apogee, this oscillation
     * would be about +/- 40 arcmin.
     * If defined as the second focus, the effect is very large:
     * +/- 6 deg!
     * We neglect this influence.
     */
    /* apogee is now projected onto ecliptic */
    node = (SWELP - NF) * SwephData.STR;
    pol[offs] = sl.swi_mod2PI(pol[offs] - node);
    sl.swi_polcart(pol, offs, pol, offs);
    sl.swi_coortrf(pol, offs, pol, offs, -SwephData.MOON_MEAN_INCL * SwissData.DEGTORAD);
    sl.swi_cartpol(pol, offs, pol, offs);
    pol[offs] = sl.swi_mod2PI(pol[offs] + node);
    return SweConst.OK;
  }

  /* Program to step through the perturbation table
   */
  void chewm(short[] pt, int nlines, int nangles, int typflg, double[] ans ) {
    int npt=0;
    int i, j, k, k1, m;
    double cu, su, cv, sv, ff;
    for( i=0; i<nlines; i++ ) {
      k1 = 0;
      sv = 0.0;
      cv = 0.0;
      for( m=0; m<nangles; m++ ) {
        j = pt[npt++]; /* multiple angle factor */
        if( j!=0 ) {
          k = j;
          if( j < 0 ) {
            k = -k; /* make angle factor > 0 */
          }
          /* sin, cos (k*angle) from lookup table */
          su = ss[m][k-1];
          cu = cc[m][k-1];
          if( j < 0 ) {
            su = -su; /* negative angle factor */
          }
          if( k1 == 0 ) {
            /* Set sin, cos of first angle. */
            sv = su;
            cv = cu;
            k1 = 1;
          }
          else {
            /* Combine angles by trigonometry. */
            ff =  su*cv + cu*sv;
            cv = cu*cv - su*sv;
            sv = ff;
          }
        }
      }
      /* Accumulate
       */
      switch( typflg ) {
      /* large longitude and radius */
      case 1:
        j = pt[npt++];
        k = pt[npt++];
        ans[0] += (10000.0 * j  + k) * sv;
        j = pt[npt++];
        k = pt[npt++];
        if( k!=0 ) {
          ans[2] += (10000.0 * j  + k) * cv;
        }
        break;
      /* longitude and radius */
      case 2:
        j = pt[npt++];
        k = pt[npt++];
        ans[0] += j * sv;
        ans[2] += k * cv;
        break;
      /* large latitude */
      case 3:
        j = pt[npt++];
        k = pt[npt++];
        ans[1] += ( 10000.0*j + k)*sv;
        break;
      /* latitude */
      case 4:
        j = pt[npt++];
        ans[1] += j * sv;
        break;
      }
    }
  }

  /* Prepare lookup table of sin and cos ( i*Lj )
   * for required multiple angles
   */
  void sscc(int k, double arg, int n ) {
    double cu, su, cv, sv, s;
    int i;
    su = Math.sin(arg);
    cu = Math.cos(arg);
    ss[k][0] = su;                        /* sin(L) */
    cc[k][0] = cu;                        /* cos(L) */
    sv = 2.0*su*cu;
    cv = cu*cu - su*su;
    ss[k][1] = sv;                        /* sin(2L) */
    cc[k][1] = cv;
    for( i=2; i<n; i++ ) {
      s =  su*cv + cu*sv;
      cv = cu*cv - su*sv;
      sv = s;
      ss[k][i] = sv;              /* sin( i+1 L ) */
      cc[k][i] = cv;
    }
  }

  /* converts from polar coordinates of ecliptic of date
   *          to   cartesian coordinates of equator 2000
   * tjd          date
   * x            array of position
   */
  void ecldat_equ2000(double tjd, double[] xpm) {
    /* cartesian */
    sl.swi_polcart(xpm, xpm);
    /* equatorial */
    sl.swi_coortrf2(xpm, xpm, -swed.oec.seps, swed.oec.ceps);
    /* j2000 */
    sl.swi_precess(xpm, tjd, SwephData.J_TO_J2000);/**/
  }

  /* Reduce arc seconds modulo 360 degrees
   * answer in arc seconds
   */
  double mods3600(double x) {
    double lx;
    lx = x;
    lx = lx - 1296000.0 * Math.floor( lx/1296000.0 );
    return( lx );
  }


  void swi_mean_lunar_elements(double tjd,
                               DblObj node, DblObj dnode,
                               DblObj peri, DblObj dperi) {
    T = (tjd - SwephData.J2000) / 36525.0;
    T2 = T*T;
    mean_elements();
    node.val = sl.swe_degnorm((SWELP - NF) * SwephData.STR * SwissData.RADTODEG);
    peri.val = sl.swe_degnorm((SWELP - MP) * SwephData.STR * SwissData.RADTODEG);
    T -= 1.0 / 36525;
    mean_elements();
    dnode.val = sl.swe_degnorm(node.val - (SWELP-NF) * SwephData.STR * SwissData.RADTODEG);
    dnode.val -= 360;
    dperi.val = sl.swe_degnorm(peri.val - (SWELP-MP) * SwephData.STR * SwissData.RADTODEG);
  }

  void mean_elements() {
    double fracT = T%1.;
    /* Mean anomaly of sun = l' (J. Laskar) */
    M =  mods3600(129600000.0 * fracT - 3418.961646 * T +  1287104.76154);
    M += ((((((((
      1.62e-20 * T
    - 1.0390e-17 ) * T
    - 3.83508e-15 ) * T
    + 4.237343e-13 ) * T
    + 8.8555011e-11 ) * T
    - 4.77258489e-8 ) * T
    - 1.1297037031e-5 ) * T
    + 1.4732069041e-4 ) * T
    - 0.552891801772 ) * T2;
    /* Mean distance of moon from its ascending node = F */
    /*NF = mods3600((1739527263.0983 - 2.079419901760e-01) * T +335779.55755);*/
    NF = mods3600(1739232000.0 * fracT + 295263.0983 * T -
                  2.079419901760e-01 * T + 335779.55755);
    /* Mean anomaly of moon = l */
    MP = mods3600(1717200000.0 * fracT + 715923.4728 * T -
                  2.035946368532e-01 * T + 485868.28096);
    /* Mean elongation of moon = D */
    D = mods3600(1601856000.0 * fracT + 1105601.4603 * T +
                 3.962893294503e-01 * T + 1072260.73512);
    /* Mean longitude of moon, referred to the mean ecliptic and equinox of date */
    SWELP = mods3600(1731456000.0 * fracT + 1108372.83264 * T - 6.784914260953e-01 * T +  785939.95571);
    /* Higher degree secular terms found by least squares fit */
    NF += ((z[2]*T + z[1])*T + z[0])*T2;
    MP += ((z[5]*T + z[4])*T + z[3])*T2;
    D  += ((z[8]*T + z[7])*T + z[6])*T2;
    SWELP += ((z[11]*T + z[10])*T + z[9])*T2;
    /* sensitivity of mean elements
     *    delta argument = scale factor times delta amplitude (arcsec)
     * cos l  9.0019 = mean eccentricity
     * cos 2D 43.6
     * cos F  11.2 (latitude term)
     */
  }
  
  void mean_elements_pl() {
    /* Mean longitudes of planets (Laskar, Bretagnon) */
    Ve = mods3600( 210664136.4335482 * T + 655127.283046 );
    Ve += ((((((((
      -9.36e-023 * T
     - 1.95e-20 ) * T
     + 6.097e-18 ) * T
     + 4.43201e-15 ) * T
     + 2.509418e-13 ) * T
     - 3.0622898e-10 ) * T
     - 2.26602516e-9 ) * T
     - 1.4244812531e-5 ) * T
     + 0.005871373088 ) * T2;
    Ea = mods3600( 129597742.26669231  * T +  361679.214649 );
    Ea += (((((((( -1.16e-22 * T
     + 2.976e-19 ) * T
     + 2.8460e-17 ) * T
     - 1.08402e-14 ) * T
     - 1.226182e-12 ) * T
     + 1.7228268e-10 ) * T
     + 1.515912254e-7 ) * T
     + 8.863982531e-6 ) * T
     - 2.0199859001e-2 ) * T2;
    Ma = mods3600(  68905077.59284 * T + 1279559.78866 );
    Ma += (-1.043e-5*T + 9.38012e-3)*T2;
    Ju = mods3600( 10925660.428608 * T +  123665.342120 );
    Ju += (1.543273e-5*T - 3.06037836351e-1)*T2;
    Sa = mods3600( 4399609.65932 * T + 180278.89694 );
    Sa += (( 4.475946e-8*T - 6.874806E-5 ) * T + 7.56161437443E-1)*T2;
  }
  
  /* Calculate geometric coordinates of true interpolated Moon apsides
   */
  int swi_intp_apsides(double J, double[] pol, int ipli) {
    double dd;
    double rsv[] = new double[3];
    double sNF, sD, sLP, sMP, sM, sVe, sEa, sMa, sJu, sSa, fM, fVe, fEa, fMa, fJu, fSa, cMP, zMP, fNF, fD, fLP;
    double dMP, mLP, mNF, mD, mMP;
    int i, ii, iii, niter = 4;    /* niter: silence compiler warning */
    ii=1;
    zMP=27.55454988;
    fNF = 27.212220817/zMP;/**/
    fD  = 29.530588835/zMP;/**/
    fLP = 27.321582/zMP;/**/
    fM  = 365.2596359/zMP;
    fVe = 224.7008001/zMP;
    fEa = 365.2563629/zMP;
    fMa = 686.9798519/zMP;
    fJu = 4332.589348/zMP;
    fSa = 10759.22722/zMP;
    T = (J-SwephData.J2000)/36525.0;
    T2 = T*T;
    T4 = T2*T2;
    mean_elements();
    mean_elements_pl();
    sNF = NF;
    sD  = D;
    sLP = SWELP;
    sMP = MP;
    sM  = M ;
    sVe = Ve;
    sEa = Ea;
    sMa = Ma;
    sJu = Ju;
    sSa = Sa;
    sNF = mods3600(NF);
    sD  = mods3600(D);
    sLP = mods3600(SWELP);
    sMP = mods3600(MP);
    if (ipli == SwephData.SEI_INTP_PERG) {MP = 0.0; niter = 5;}
    if (ipli == SwephData.SEI_INTP_APOG) {MP = 648000.0; niter = 4;}
    cMP = 0;
    dd = 18000.0;
    for (iii= 0; iii<=niter; iii++) {/**/
      dMP = sMP - MP;
      mLP = sLP - dMP;
      mNF = sNF - dMP;
      mD  = sD  - dMP;
      mMP = sMP - dMP;
      for (ii = 0; ii <=2; ii++) {/**/
        MP = mMP + (ii-1)*dd;       /**/
        NF = mNF + (ii-1)*dd/fNF;
        D  = mD  + (ii-1)*dd/fD;
        SWELP = mLP + (ii-1)*dd/fLP;
        M  = sM  + (ii-1)*dd/fM ;
        Ve = sVe + (ii-1)*dd/fVe;
        Ea = sEa + (ii-1)*dd/fEa;
        Ma = sMa + (ii-1)*dd/fMa;
        Ju = sJu + (ii-1)*dd/fJu;
        Sa = sSa + (ii-1)*dd/fSa;
        moon1();
        moon2();
        moon3();
        moon4();
        if (ii==1) {
          for( i=0; i<3; i++ ) pol[i] = moonpol[i];
        }
        rsv[ii] = moonpol[2];
      }
      cMP = (1.5*rsv[0] - 2*rsv[1] + 0.5*rsv[2]) / (rsv[0] + rsv[2] - 2*rsv[1]);/**/
      cMP *= dd;
      cMP = cMP - dd;
      mMP += cMP;
      MP = mMP;
      dd /= 10;
    }
    return(0);
  }

} // End of class Swemmoon
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class SwemptabEar {
  /*
  First date in file = 1228000.50
  Number of records = 264850.0
  Days per record = 6.0
        Julian Years      Lon    Lat    Rad
   -1349.9 to  -1000.0:   0.13   0.06   0.07
   -1000.0 to   -500.0:   0.12   0.06   0.06
    -500.0 to      0.0:   0.12   0.06   0.08
       0.0 to    500.0:   0.12   0.05   0.06
     500.0 to   1000.0:   0.12   0.05   0.07
    1000.0 to   1500.0:   0.11   0.05   0.07
    1500.0 to   2000.0:   0.11   0.05   0.06
    2000.0 to   2500.0:   0.11   0.05   0.06
    2500.0 to   3000.0:   0.14   0.06   0.07
    3000.0 to   3000.8:  0.074  0.048  0.044
  */

  static final double eartabl[] = {
         -65.54655,        -232.74963, 12959774227.57587,      361678.59587,

           2.52679,          -4.93511,           2.46852,          -8.88928,
           6.66257,          -1.94502,

           0.66887,          -0.06141,           0.08893,           0.18971,

           0.00068,          -0.00307,

           0.03092,           0.03214,          -0.14321,           0.22548,

           0.00314,          -0.00221,

           8.98017,           7.25747,          -1.06655,           1.19671,
          -2.42276,           0.29621,           1.55635,           0.99167,

          -0.00026,           0.00187,

           0.00189,           0.02742,

           0.00158,           0.01475,

           0.00353,          -0.02048,

          -0.01775,          -0.01023,           0.01927,          -0.03122,

          -1.55440,          -4.97423,           2.14765,          -2.77045,
           1.02707,           0.55507,          -0.08066,           0.18479,

           0.00750,           0.00583,

          -0.16977,           0.35555,           0.32036,           0.01309,

           0.54625,           0.08167,           0.10681,           0.17231,
          -0.02287,           0.01631,

          -0.00866,          -0.00190,

           0.00016,          -0.01514,

          -0.00073,           0.04205,

          -0.00072,           0.01490,

          -0.38831,           0.41043,          -1.11857,          -0.84329,
           1.15123,          -1.34167,

           0.01026,          -0.00432,

          -0.02833,          -0.00705,          -0.00285,           0.01645,

          -0.01234,           0.05609,          -0.01893,          -0.00171,

          -0.30527,           0.45390,           0.56713,           0.70030,
           1.27125,          -0.76481,           0.34857,          -2.60318,

          -0.00160,           0.00643,

           0.28492,          -0.37998,           0.23347,           0.00540,
           0.00342,           0.04406,

           0.00037,          -0.02449,

           0.01469,           1.59358,           0.24956,           0.71066,
           0.25477,          -0.98371,

          -0.69412,           0.19687,          -0.44423,          -0.83331,
           0.49647,          -0.31021,

           0.05696,          -0.00802,          -0.14423,          -0.04719,

           0.16762,          -0.01234,           0.02481,           0.03465,

           0.01091,           0.02123,

           0.08212,          -0.07375,           0.01524,          -0.07388,

           0.06673,          -0.22486,           0.10026,          -0.00559,

           0.14711,          -0.11680,           0.05460,           0.02749,

          -1.04467,           0.34273,          -0.67582,          -2.15117,
           2.47372,          -0.04332,

           0.05016,          -0.03991,           0.01908,           0.00943,

           0.07321,          -0.23637,           0.10564,          -0.00446,

          -0.09523,          -0.30710,           0.17400,          -0.10681,

           0.05104,          -0.14078,           0.01390,           0.07288,

          -0.26308,          -0.20717,           0.20773,          -0.37096,

          -0.00205,          -0.27274,

          -0.00792,          -0.00183,

           0.02985,           0.04895,           0.03785,          -0.14731,

           0.02976,          -0.02495,          -0.02644,          -0.04085,

          -0.00843,           0.00027,

           0.00090,           0.00611,

           0.00040,           4.83425,

           0.01692,          -0.01335,

           0.04482,          -0.03602,           0.01672,           0.00838,

           0.03682,          -0.11206,           0.05163,          -0.00219,

          -0.08381,          -0.20911,           0.16400,          -0.13325,

          -0.05945,           0.02114,          -0.00710,          -0.04695,

          -0.01657,          -0.00513,

          -0.06999,          -0.23054,           0.13128,          -0.07975,

           0.00054,          -0.00699,

          -0.01253,          -0.04007,           0.00658,          -0.00607,

          -0.48696,           0.31859,          -0.84292,          -0.87950,
           1.30507,          -0.94042,

          -0.00234,           0.00339,

          -0.30647,          -0.24605,           0.24948,          -0.43369,

          -0.64033,           0.20754,          -0.43829,          -1.31801,
           1.55412,          -0.02893,

          -0.02323,           0.02181,          -0.00398,          -0.01548,

          -0.08005,          -0.01537,          -0.00362,          -0.02033,

           0.00028,          -0.03732,          -0.14083,          -7.21175,

          -0.07430,           0.01886,          -0.00223,           0.01915,

          -0.02270,          -0.03702,           0.10167,          -0.02917,

           0.00879,          -2.04198,

          -0.00433,          -0.41764,

           0.00671,          -0.00030,

           0.00070,          -0.01066,

           0.01144,          -0.03190,

          -0.29653,           0.38638,          -0.16611,          -0.07661,

           0.22071,           0.14665,           0.02487,           0.13524,

        -275.60942,        -335.52251,        -413.89009,         359.65390,
        1396.49813,        1118.56095,        2559.41622,       -3393.39088,
       -6717.66079,       -1543.17403,

          -1.90405,          -0.22958,          -0.57989,          -0.36584,
          -0.04547,          -0.14164,

           0.00749,          -0.03973,

           0.00033,           0.01842,

          -0.08301,          -0.03523,          -0.00408,          -0.02008,

           0.00008,           0.00778,

          -0.00046,           0.02760,

          -0.03135,           0.07710,           0.06130,           0.04003,

          -0.04703,           0.00671,          -0.00754,          -0.01000,

          -0.01902,          -0.00125,

          -0.00264,          -0.00903,

          -0.02672,           0.12765,

          -0.03872,           0.03532,          -0.01534,          -0.00710,

          -0.01087,           0.01124,

          -0.01664,           0.06304,          -0.02779,           0.00214,

          -0.01279,          -5.51814,

           0.05847,          -0.02093,           0.03950,           0.06696,
          -0.04064,           0.02687,

           0.01478,          -0.02169,           0.05821,           0.03301,
          -0.03861,           0.07535,

           0.00290,          -0.00644,

           0.00631,           0.12905,

           0.02400,           0.13194,          -0.14339,           0.00529,

           0.00343,           0.00819,

           0.02692,          -0.03332,          -0.07284,          -0.02064,

           0.07038,           0.03999,           0.02759,           0.07599,

           0.00033,           0.00641,

           0.00128,           0.02032,          -0.00852,           0.00680,

           0.23019,           0.17100,           0.09861,           0.55013,

          -0.00192,           0.00953,

          -0.00943,           0.01783,

           0.05975,           0.01486,           0.00160,           0.01558,

          -0.01629,          -0.02035,           0.01533,           2.73176,

           0.05858,          -0.01327,           0.00209,          -0.01506,

           0.00755,           0.03300,

          -0.00796,          -0.65270,

           0.02305,           0.00165,

          -0.02512,           0.06560,           0.16108,          -0.02087,

           0.00016,           0.10729,

           0.04175,           0.00559,

           0.01176,           0.00110,

          15.15730,          -0.52460,         -37.16535,         -25.85564,
         -60.94577,           4.29961,          57.11617,          67.96463,
          31.41414,         -64.75731,

           0.00848,           0.02971,          -0.03690,          -0.00010,

          -0.03568,           0.06325,           0.11311,           0.02431,

          -0.00383,           0.00421,

          -0.00140,           0.00680,

           0.00069,          -0.21036,

           0.00386,           0.04210,

          -0.01324,           0.16454,

          -0.01398,          -0.00109,

           0.02548,          -0.03842,          -0.06504,          -0.02204,

           0.01359,           0.00232,

           0.07634,          -1.64648,          -1.73103,           0.89176,
           0.81398,           0.65209,

           0.00021,          -0.08441,

          -0.00012,           0.01262,

          -0.00666,          -0.00050,

          -0.00130,           0.01596,

          -0.00485,          -0.00213,

           0.00009,          -0.03941,

          -0.02266,          -0.04421,          -0.01341,           0.01083,

          -0.00011,           0.00004,           0.00003,          -0.02017,

           0.00003,          -0.01096,

           0.00002,          -0.00623,

  };
  static final double eartabb[] = {
         -41.97860,         -48.43539,          74.72897,           0.00075,

          -0.12774,          -0.10188,          -0.00943,          -0.04574,
           0.00265,          -0.00217,

           0.00254,           0.00168,           0.00008,           0.00026,

          -0.00000,          -0.00000,

           0.00004,          -0.00003,           0.00001,          -0.00003,

          -0.00002,          -0.00006,

           0.03351,          -0.02699,           0.00896,          -0.01315,
          -0.00019,          -0.00054,          -0.00020,          -0.00003,

           0.00002,           0.00001,

          -0.00000,           0.00000,

          -0.00002,          -0.00001,

          -0.00001,           0.00003,

           0.00017,          -0.00008,           0.00000,          -0.00003,

           0.00501,          -0.00083,           0.00414,           0.00202,
           0.00051,           0.00060,           0.00002,           0.00000,

          -0.00002,           0.00002,

          -0.00016,          -0.00443,          -0.00083,          -0.00031,

          -0.00394,           0.00148,          -0.00035,           0.00099,
           0.00005,           0.00009,

           0.00004,          -0.00002,

          -0.00001,          -0.00002,

           0.00012,          -0.00005,

           0.00001,           0.00001,

          -0.00577,          -0.00631,          -0.00017,           0.01993,
          -0.00234,          -0.00218,

          -0.00001,           0.00002,

          -0.00101,          -0.00044,          -0.00036,           0.00041,

           0.00294,          -0.00109,           0.00043,          -0.00006,

           0.09650,           0.15003,           0.01087,           0.04905,
           0.00093,          -0.06986,          -0.01471,          -0.00221,

          -0.00002,          -0.00003,

           0.00440,          -0.00083,           0.00102,          -0.00024,
           0.00005,          -0.00002,

          -0.00004,           0.00001,

           0.00505,           0.00930,          -0.01609,          -0.00183,
          -0.00113,           0.00214,

           0.00439,          -0.00295,          -0.00280,           0.00402,
          -0.00047,          -0.00145,

          -0.00114,          -0.00178,           0.00097,           0.00022,

           0.00019,           0.00002,           0.00009,          -0.00005,

          -0.00002,           0.00006,

          -0.01618,          -0.01033,          -0.00372,           0.00301,

          -0.00199,           0.00003,           0.00012,          -0.00068,

          -0.00027,          -0.00011,           0.00009,          -0.00020,

          -0.00618,           0.00129,           0.00452,           0.00620,
          -0.06411,          -0.01524,

          -0.00207,          -0.00140,           0.00005,          -0.00036,

          -0.00009,           0.00005,           0.00012,          -0.00053,

           0.00050,          -0.00068,          -0.00059,          -0.00132,

           0.00719,          -0.13368,          -0.08789,          -0.02072,

           0.00031,          -0.00360,          -0.00241,          -0.00182,

           0.00284,           0.00196,

           0.00083,           0.00008,

           0.00203,          -0.00097,          -0.00120,           0.00748,

           0.00326,          -0.00145,          -0.00276,           0.00236,

          -0.00048,          -0.00258,

           0.00011,           0.00001,

          -0.00284,           0.00795,

          -0.00156,           0.00106,

          -0.00040,          -0.00069,           0.00026,          -0.00039,

          -0.00102,          -0.00098,           0.00017,          -0.00125,

          -0.00180,          -0.01103,          -0.01854,           0.00742,

          -0.02751,          -0.00773,          -0.00263,           0.01059,

           0.00152,           0.00047,

          -0.00106,          -0.00034,          -0.00126,          -0.00291,

          -0.00014,           0.00006,

           0.00069,           0.00316,          -0.00087,           0.00022,

           0.05381,           0.03791,           0.05011,          -0.15168,
          -0.16315,           0.03037,

           0.00068,          -0.00067,

          -0.00457,          -0.00146,          -0.00643,          -0.00451,

           0.07806,           0.00729,           0.03356,          -0.16465,
          -0.20388,          -0.04854,

          -0.00163,          -0.00178,           0.00185,           0.00405,

          -0.00009,           0.00068,          -0.00003,           0.00005,

          -0.01186,           0.00347,          -0.01776,           0.00258,

           0.00081,          -0.00014,           0.00003,          -0.00021,

          -0.01218,          -0.03048,          -0.03109,           0.01387,

          -0.00740,          -0.00113,

          -0.00155,           0.00679,

          -0.00053,          -0.00007,

          -0.00004,          -0.00002,

           0.00248,           0.00127,

          -0.00386,           0.00394,           0.01213,           0.00748,

          -0.04669,          -0.00319,           0.00315,           0.00010,

          85.02966,         -55.85765,         215.62111,         519.00334,
       -1941.10461,         508.68393,        -419.80123,       -4679.60117,
          -0.00916,           0.00204,

          -0.13900,          -0.08473,          -0.07614,          -0.03445,
           0.00359,          -0.00136,

          -0.00111,           0.01028,

           0.00021,          -0.00002,

           0.00039,           0.00246,          -0.00084,          -0.00007,

          -0.00191,           0.00491,

           0.00474,          -0.00676,

          -0.00549,           0.02234,           0.02087,           0.00575,

          -0.00011,           0.00079,          -0.00060,           0.00029,

          -0.00239,          -0.00257,

           0.00020,           0.00163,

           0.00301,          -0.01723,

           0.00049,           0.00086,          -0.00046,           0.00057,

          -0.00049,           0.00024,

           0.00103,          -0.00072,          -0.00005,           0.00095,

           0.00598,          -0.01127,

          -0.00538,           0.00317,          -0.00178,          -0.00010,
           0.00061,           0.00132,

          -0.00001,           0.00318,          -0.00206,           0.00113,
           0.00153,           0.00097,

           0.00161,          -0.00363,

           0.00142,          -0.00047,

          -0.00281,           0.03085,           0.02895,           0.00688,

           0.00025,          -0.00016,

          -0.00197,          -0.08112,           0.02859,          -0.00683,

           0.00004,           0.00016,           0.00158,          -0.00065,

           0.00004,          -0.00001,

           0.00002,          -0.00008,           0.00019,           0.00039,

          -0.00344,           0.00364,           0.00579,          -0.00144,

           0.00031,          -0.00190,

           0.00066,           0.00025,

           0.00011,          -0.00069,           0.00001,          -0.00011,

          -0.01202,           0.00842,           0.00067,          -0.00297,

          -0.00000,           0.00008,           0.00005,           0.00000,

           0.00086,          -0.00057,

           0.00354,          -0.00548,

           0.00009,          -0.00003,

           0.00179,           0.07922,           0.00490,           0.00065,

          -0.00005,          -0.00059,

           0.00061,          -0.00319,

           0.00007,          -0.00048,

           3.49661,          -1.52414,          -6.26431,          -1.76193,
         -26.45666,           7.62583,          77.77395,          10.67040,
           0.00032,           0.00090,

          -0.00026,           0.00680,           0.00827,           0.00199,

          -0.00271,           0.04278,           0.02257,          -0.00532,

           0.00006,           0.00011,

           0.00006,           0.00010,

          -0.00017,          -0.00081,

           0.00050,           0.00001,

           0.00012,           0.00082,

           0.00326,           0.00040,

          -0.00003,          -0.03209,           0.00042,           0.00008,

           0.01059,          -0.00218,

          -0.87557,          -1.06369,          -0.52928,           1.38498,
           0.00082,          -0.00040,

           0.00009,          -0.00047,

           0.00007,           0.00007,

           0.00155,           0.00019,

           0.00002,           0.00008,

           0.00001,           0.00023,

           0.00010,          -0.00029,

          -0.03336,          -0.00987,           0.00012,          -0.00006,

          -0.00198,           0.00333,          -0.00004,           0.00026,

           0.00042,           0.00006,

           0.00025,           0.00021,

  };
  static final double eartabr[] = {
           0.64577,          -2.90183,         -14.50280,          28.85196,

           0.08672,          -0.05643,           0.02353,          -0.00404,
           0.00019,          -0.00137,

           0.00128,          -0.00310,           0.00143,           0.00050,

           0.00000,           0.00000,

          -0.00023,          -0.00003,          -0.00057,          -0.00032,

          -0.00002,           0.00009,

          -0.09716,           0.04111,          -0.03108,           0.00633,
          -0.00220,          -0.00595,          -0.00279,           0.00491,

          -0.00004,          -0.00003,

          -0.00010,          -0.00004,

          -0.00013,          -0.00010,

           0.00017,          -0.00010,

          -0.00075,           0.00002,          -0.00054,          -0.00025,

           0.12572,           0.00948,           0.05937,           0.04900,
          -0.00785,           0.01815,          -0.00303,          -0.00120,

          -0.00010,           0.00010,

          -0.00317,          -0.00143,           0.00068,           0.00213,

          -0.00043,          -0.00420,           0.00406,          -0.00041,
           0.00048,           0.00062,

          -0.00005,           0.00029,

           0.00043,          -0.00002,

          -0.00126,          -0.00009,

          -0.00040,           0.00000,

           0.03557,           0.02143,          -0.02196,           0.04671,
          -0.05571,          -0.03425,

           0.00016,           0.00031,

           0.00020,          -0.00153,          -0.00142,          -0.00051,

          -0.00214,           0.00001,           0.00002,          -0.00061,

          -0.06824,           0.00030,          -0.05717,           0.04196,
           0.05887,           0.07531,           0.12313,          -0.04113,

           0.00025,           0.00021,

           0.02218,           0.01747,           0.00011,           0.01367,
          -0.00247,           0.00029,

           0.00120,          -0.00003,

           0.13373,          -0.02072,           0.06706,          -0.01009,
          -0.09515,          -0.01901,

           0.01767,           0.06939,          -0.06702,           0.04159,
          -0.02809,          -0.03968,

           0.00257,           0.00553,           0.00411,          -0.01309,

           0.00139,           0.01591,          -0.00322,           0.00245,

          -0.00202,           0.00093,

           0.01845,          -0.00018,          -0.00247,          -0.00771,

          -0.02834,          -0.00691,          -0.00154,          -0.01244,

           0.01512,           0.01884,          -0.00359,           0.00731,

          -0.05395,          -0.18108,           0.36303,          -0.12751,
           0.01877,           0.43653,

          -0.00725,          -0.00692,           0.00115,          -0.00327,

           0.04030,           0.01171,           0.00107,           0.01793,

           0.06335,          -0.02171,           0.02229,           0.03533,

          -0.06038,          -0.00356,           0.01325,          -0.03798,

           0.04963,          -0.06258,           0.08931,           0.04904,

           0.07115,          -0.00073,

          -0.00104,           0.00354,

          -0.01549,           0.00647,           0.04418,           0.01061,

           0.00568,           0.00957,           0.01102,          -0.00819,

          -0.00089,           0.00368,

          -0.00214,           0.00031,

          -1.11935,          -0.00029,

           0.00457,           0.00550,

           0.01409,           0.01664,          -0.00306,           0.00629,

           0.04531,           0.01460,           0.00092,           0.02074,

           0.07900,          -0.03241,           0.05122,           0.06151,

           0.01319,           0.03075,          -0.02814,           0.00329,

           0.00208,          -0.00681,

           0.09887,          -0.02956,           0.03410,           0.05617,

           0.00295,           0.00022,

           0.01727,          -0.00666,           0.00255,           0.00256,

          -0.14161,          -0.20656,           0.36936,          -0.35793,
           0.40122,           0.54675,

          -0.00109,          -0.00135,

           0.11179,          -0.13803,           0.19591,           0.11327,

          -0.08785,          -0.29929,           0.60319,          -0.20484,
           0.01418,           0.71392,

          -0.01039,          -0.01041,           0.00694,          -0.00183,

           0.00707,          -0.03745,           0.00943,          -0.00174,

           0.01781,           0.00069,           3.35806,          -0.06731,

          -0.01015,          -0.03402,          -0.00913,          -0.00094,

           0.01682,          -0.01066,           0.01361,           0.04752,

           0.97349,           0.00504,

           0.20303,          -0.00206,

           0.00012,           0.00327,

           0.00504,           0.00040,

          -0.01599,          -0.00570,

          -0.19375,          -0.14714,           0.03820,          -0.08283,

          -0.07716,           0.10543,          -0.06772,           0.01131,

         163.23023,        -126.90743,        -183.43441,        -201.49515,
        -559.82622,         698.28238,        1696.58461,        1279.45831,
         771.51923,       -3358.57619,

          -0.05911,           0.89279,          -0.15861,           0.28577,
          -0.06958,           0.02406,

           0.01999,           0.00382,

          -0.00934,           0.00014,

           0.01792,          -0.04249,           0.01019,          -0.00210,

          -0.00386,           0.00009,

          -0.01353,           0.00101,

          -0.03828,          -0.01677,          -0.02026,           0.03079,

          -0.00285,          -0.02484,           0.00537,          -0.00397,

          -0.00064,           0.00906,

          -0.00411,           0.00100,

          -0.06940,          -0.01482,

          -0.01966,          -0.02171,           0.00388,          -0.00840,

          -0.00621,          -0.00597,

          -0.03690,          -0.00959,          -0.00115,          -0.01557,

           3.24906,          -0.00580,

           0.00745,           0.03347,          -0.04023,           0.02174,
          -0.01544,          -0.02389,

           0.00935,          -0.00141,          -0.02018,           0.03258,
          -0.04479,          -0.02360,

          -0.00542,          -0.00194,

          -0.07906,           0.00273,

          -0.08439,           0.01534,          -0.00264,          -0.09205,

          -0.00539,           0.00220,

           0.01263,           0.01593,           0.01103,          -0.03324,

          -0.02720,           0.04749,          -0.05099,           0.01807,

          -0.00443,           0.00024,

          -0.01386,           0.00029,          -0.00443,          -0.00591,

          -0.11899,           0.15817,          -0.37728,           0.06552,

          -0.00669,          -0.00140,

          -0.01168,          -0.00690,

          -0.01032,           0.04315,          -0.01082,           0.00123,

           0.01192,          -0.01071,          -1.90746,           0.00700,

           0.00779,           0.04261,           0.01052,           0.00173,

          -0.02138,           0.00307,

           0.50118,          -0.00330,

          -0.00111,           0.01624,

          -0.02601,           0.00305,           0.02348,           0.07058,

          -0.07622,           0.00006,

          -0.00183,           0.01636,

          -0.00037,           0.00564,

           4.72127,           3.53639,          13.37363,          -6.68745,
         -12.29946,         -22.51893,         -27.18616,          22.85033,
          25.89912,          12.56594,

          -0.02566,           0.00307,          -0.00064,          -0.02727,

          -0.02634,          -0.01101,          -0.01029,           0.04755,

          -0.00372,          -0.00292,

          -0.00582,          -0.00053,

           0.17840,           0.00027,

          -0.03400,           0.00357,

          -0.13428,          -0.00611,

           0.00099,          -0.01169,

           0.01909,           0.01338,           0.01302,          -0.03071,

          -0.00051,           0.00577,

           0.61945,          -0.32627,          -0.30811,          -0.60197,
          -0.22597,           0.28183,

           0.07739,           0.00011,

           0.01336,          -0.00010,

           0.00049,          -0.00592,

          -0.01407,          -0.00081,

           0.00146,          -0.00280,

           0.03795,           0.00003,

           0.01173,          -0.00655,          -0.00344,          -0.00403,

           0.00036,          -0.00047,           0.02000,           0.00001,

           0.01105,           0.00002,

           0.00620,          -0.00052,

  };

  static final byte earargs[] = {
  (byte)0,  (byte)3,
  (byte)3,  (byte)4,  (byte)3, (byte)-8,  (byte)4,  (byte)3,  (byte)5,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)3,  (byte)2,  (byte)2,  (byte)1,  (byte)3, (byte)-8,  (byte)4,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-7,  (byte)3,  (byte)4,  (byte)4,  (byte)1,
  (byte)3,  (byte)7,  (byte)3,(byte)-13,  (byte)4, (byte)-1,  (byte)5,  (byte)0,
  (byte)2,  (byte)8,  (byte)2,(byte)-13,  (byte)3,  (byte)3,
  (byte)3,  (byte)1,  (byte)2, (byte)-8,  (byte)3, (byte)12,  (byte)4,  (byte)0,
  (byte)1,  (byte)1,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)3,  (byte)3,  (byte)3, (byte)-6,  (byte)4,  (byte)2,  (byte)5,  (byte)1,
  (byte)2,  (byte)8,  (byte)3,(byte)-15,  (byte)4,  (byte)3,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)0,
  (byte)1,  (byte)1,  (byte)6,  (byte)1,
  (byte)2,  (byte)9,  (byte)3,(byte)-17,  (byte)4,  (byte)2,
  (byte)3,  (byte)3,  (byte)2, (byte)-5,  (byte)3,  (byte)1,  (byte)5,  (byte)0,
  (byte)3,  (byte)2,  (byte)3, (byte)-4,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-5,  (byte)3,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-2,  (byte)4,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)1,  (byte)1,  (byte)5,  (byte)3,
  (byte)2,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)3,(byte)-13,  (byte)4,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-5,  (byte)3,  (byte)2,
  (byte)2,  (byte)2,  (byte)3, (byte)-4,  (byte)4,  (byte)2,
  (byte)2,  (byte)5,  (byte)2, (byte)-8,  (byte)3,  (byte)1,
  (byte)2,  (byte)6,  (byte)3,(byte)-11,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)1, (byte)-4,  (byte)3,  (byte)0,
  (byte)1,  (byte)2,  (byte)5,  (byte)1,
  (byte)2,  (byte)3,  (byte)3, (byte)-6,  (byte)4,  (byte)1,
  (byte)2,  (byte)5,  (byte)3, (byte)-9,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)2, (byte)-3,  (byte)3,  (byte)2,
  (byte)2,  (byte)4,  (byte)3, (byte)-8,  (byte)4,  (byte)1,
  (byte)2,  (byte)4,  (byte)3, (byte)-7,  (byte)4,  (byte)1,
  (byte)2,  (byte)3,  (byte)3, (byte)-5,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)2, (byte)-2,  (byte)3,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-3,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-6,  (byte)3,  (byte)1,
  (byte)1,  (byte)1,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-3,  (byte)4,  (byte)0,
  (byte)2,  (byte)7,  (byte)3,(byte)-12,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-1,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)6,  (byte)3,(byte)-10,  (byte)4,  (byte)1,
  (byte)2,  (byte)5,  (byte)3, (byte)-8,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-3,  (byte)5,  (byte)1,
  (byte)2,  (byte)2,  (byte)2, (byte)-4,  (byte)3,  (byte)1,
  (byte)2,  (byte)6,  (byte)2, (byte)-9,  (byte)3,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-6,  (byte)4,  (byte)1,
  (byte)3,  (byte)1,  (byte)3, (byte)-3,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-5,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-2,  (byte)5,  (byte)2,
  (byte)3,  (byte)1,  (byte)3, (byte)-4,  (byte)5,  (byte)5,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-4,  (byte)4,  (byte)1,
  (byte)2,  (byte)3,  (byte)2, (byte)-4,  (byte)3,  (byte)2,
  (byte)2,  (byte)1,  (byte)3, (byte)-3,  (byte)6,  (byte)1,
  (byte)3,  (byte)1,  (byte)3,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)5,  (byte)1,
  (byte)3,  (byte)1,  (byte)3, (byte)-3,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-2,  (byte)6,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)7,  (byte)0,
  (byte)2,  (byte)8,  (byte)2,(byte)-14,  (byte)3,  (byte)0,
  (byte)3,  (byte)1,  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)3,  (byte)5,  (byte)3, (byte)-8,  (byte)4,  (byte)3,  (byte)5,  (byte)1,
  (byte)1,  (byte)1,  (byte)3,  (byte)4,
  (byte)3,  (byte)3,  (byte)3, (byte)-8,  (byte)4,  (byte)3,  (byte)5,  (byte)2,
  (byte)2,  (byte)8,  (byte)2,(byte)-12,  (byte)3,  (byte)0,
  (byte)3,  (byte)1,  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)9,  (byte)3,(byte)-15,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)3,  (byte)1,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)3,  (byte)1,  (byte)5,  (byte)1,
  (byte)2,  (byte)8,  (byte)3,(byte)-13,  (byte)4,  (byte)1,
  (byte)2,  (byte)3,  (byte)2, (byte)-6,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)5,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)7,  (byte)3,(byte)-11,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)1, (byte)-3,  (byte)3,  (byte)0,
  (byte)2,  (byte)6,  (byte)3, (byte)-9,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)2, (byte)-2,  (byte)3,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-7,  (byte)4,  (byte)2,
  (byte)2,  (byte)4,  (byte)3, (byte)-5,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)2, (byte)-3,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-3,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-5,  (byte)3,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-5,  (byte)5,  (byte)0,
  (byte)1,  (byte)1,  (byte)2,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-4,  (byte)5,  (byte)1,
  (byte)3,  (byte)2,  (byte)3, (byte)-4,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)3, (byte)-8,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-3,  (byte)5,  (byte)1,
  (byte)2,  (byte)6,  (byte)2, (byte)-8,  (byte)3,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-6,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-5,  (byte)6,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-2,  (byte)5,  (byte)1,
  (byte)3,  (byte)2,  (byte)3, (byte)-4,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)2,  (byte)4,  (byte)3, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-3,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-1,  (byte)5,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-1,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)3,  (byte)4,
  (byte)2,  (byte)5,  (byte)2, (byte)-6,  (byte)3,  (byte)1,
  (byte)2,  (byte)2,  (byte)2, (byte)-1,  (byte)3,  (byte)1,
  (byte)2,  (byte)6,  (byte)3, (byte)-7,  (byte)4,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-5,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-4,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-3,  (byte)5,  (byte)0,
  (byte)2,  (byte)6,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-2,  (byte)5,  (byte)1,
  (byte)2,  (byte)3,  (byte)2, (byte)-2,  (byte)3,  (byte)0,
  (byte)1,  (byte)3,  (byte)3,  (byte)2,
  (byte)2,  (byte)5,  (byte)2, (byte)-5,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)1, (byte)-1,  (byte)3,  (byte)0,
  (byte)2,  (byte)7,  (byte)2, (byte)-8,  (byte)3,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-3,  (byte)5,  (byte)0,
  (byte)2,  (byte)6,  (byte)2, (byte)-6,  (byte)3,  (byte)0,
  (byte)1,  (byte)4,  (byte)3,  (byte)1,
  (byte)2,  (byte)7,  (byte)2, (byte)-7,  (byte)3,  (byte)1,
  (byte)2,  (byte)8,  (byte)2, (byte)-8,  (byte)3,  (byte)0,
  (byte)2,  (byte)9,  (byte)2, (byte)-9,  (byte)3,  (byte)0,
 (byte)-1
  };
  /* Total terms = 135, small = 134 */
  static Plantbl ear404 = new Plantbl(
                               new short[]{1,  9, 14, 17,  5,  5,  2,  1,  0},
                               (short)4,
                               earargs,
                               eartabl,
                               eartabb,
                               eartabr,
                               1.0
                              );

  /*
  First date in file = 1228000.50
  Number of records = 397276.0
  Days per record = 4.0
        Julian Years      Lon    Lat    Rad
   -1349.9 to  -1000.0:   0.42   0.18   0.25
   -1000.0 to   -500.0:   0.45   0.14   0.21
    -500.0 to      0.0:   0.37   0.10   0.20
       0.0 to    500.0:   0.33   0.09   0.22
     500.0 to   1000.0:   0.48   0.07   0.22
    1000.0 to   1500.0:   0.40   0.07   0.19
    1500.0 to   2000.0:   0.36   0.11   0.19
    2000.0 to   2500.0:   0.38   0.14   0.20
    2500.0 to   3000.0:   0.45   0.15   0.24
    3000.0 to   3000.8:  0.182  0.125  0.087
  */
}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class SwemptabJup {
  /*
  First date in file = 625296.50
  Number of records = 16731.0
  Days per record = 131.0
        Julian Years      Lon    Lat    Rad
   -3000.0 to  -2499.7:   0.64   0.09   0.40
   -2499.7 to  -1999.7:   0.70   0.09   0.45
   -1999.7 to  -1499.7:   0.44   0.08   0.32
   -1499.7 to   -999.8:   0.42   0.07   0.32
    -999.8 to   -499.8:   0.55   0.06   0.34
    -499.8 to      0.2:   0.43   0.06   0.31
       0.2 to    500.2:   0.56   0.07   0.32
     500.2 to   1000.1:   0.49   0.06   0.41
    1000.1 to   1500.1:   0.48   0.06   0.38
    1500.1 to   2000.1:   0.56   0.06   0.38
    2000.1 to   2500.0:   0.63   0.08   0.33
    2500.0 to   3000.0:   0.70   0.09   0.36
    3000.0 to   3000.4:  0.526  0.023  0.190
  */
  static final double juptabl[] = {
      153429.13855,      130818.16897,       18120.42948,       -8463.12663,
       -5058.91447,  1092566021.02148,      123671.25097,

          -5.43364,          12.06012,

       30428.31077,      -74667.61443,       46848.16236,      -66373.44474,
       24312.54264,      -26045.64766,       18353.92564,       -4022.13679,
        4037.97936,       10059.82468,       -4622.55896,        1383.21617,
        -187.25468,       -1171.66028,

          -0.00062,          -0.21713,

       -1198.83945,        1178.62445,       -1492.07393,         153.07155,
        -245.57966,        -391.94010,          82.26400,         -40.92104,
           3.72520,          10.57242,

          -0.04720,          -0.04448,          -0.04329,          -0.06043,

          -0.03905,           0.15712,

          -0.05644,          -0.00129,

          -0.00342,           0.02473,

           0.00434,          -0.01862,

           0.00431,          -0.03993,

          -0.03159,          -0.15982,

          -0.09928,           0.04430,          -0.00357,           0.31312,

          -0.01346,          -0.00180,

          -0.09107,           0.01215,

           0.02485,           0.01024,

          27.29869,           2.70896,          12.91956,          19.21726,
          -6.91384,           5.12954,          -1.07533,          -1.71691,

          -0.01423,           0.03121,

         -32.48652,         -26.13483,          46.78162,         -62.02701,
          94.96809,          81.73791,         -20.13673,         131.05065,

          -0.00798,           0.01786,

          13.99591,          16.87756,          -8.51726,          21.59490,
         -14.28833,          -9.45530,           7.73954,          -6.53078,

           0.03175,          -0.04295,

           3.06742,          -0.11838,           1.03630,           0.94004,
          -0.14085,           0.14434,

          -0.03363,           0.00993,

          -0.00007,          -0.02748,

          26.01507,          -7.37178,          16.96955,           6.24203,
          -0.40481,           3.72456,          -0.53597,          -0.14938,

          37.82081,          26.15887,          -2.82115,          78.26478,
         -63.39155,          -5.52419,          13.11482,         -43.54977,
          15.64940,           6.67505,

         -10.25616,          -7.39672,         -12.37441,          12.24417,
           8.54922,           9.68451,

          -0.03658,          -0.00963,

           1.65523,           0.43093,           0.32023,           0.71365,
          -0.12226,           0.03759,

           0.10388,           0.47212,          -0.02791,           0.09929,

          -0.04116,          -0.03125,

          -0.10240,          -0.23199,          -0.03524,          -0.13625,

           7.52726,           6.86314,           0.01239,          13.46530,
          -5.22256,           1.56116,          -0.15925,          -1.19571,

           3.26302,           0.06097,          -0.14444,          -0.20301,
           1.93822,         -80.12566,

           0.98665,          -7.52986,           3.86703,          -2.43028,
           0.64180,           0.78351,

           0.00190,          -0.00633,

          -0.00321,          -0.04403,

           0.19018,           0.14335,           0.10315,           0.53154,

          -0.00062,          -0.00464,

          -0.00109,           0.02150,

           1.19993,          47.21638,         -24.56067,          25.06332,
          -7.50751,          -6.36250,           1.39443,          -1.23806,

           0.04951,           0.02176,

           0.02802,          -0.01665,

          -0.10698,          -0.13635,

          73.54797,         -52.34968,          74.98754,          86.56283,
         -69.01463,          44.56866,

           0.04387,          -0.05925,

          -0.03732,          -0.03264,

           0.00967,           0.02143,

          10.59429,          26.48226,          34.03470,           3.96160,
           4.15919,         -20.22616,          -5.25903,          -3.40177,

           0.05111,          -0.06788,

           0.06497,           1.21024,          -0.29607,           0.49991,
          -0.06055,          -0.03464,

           0.02950,           0.16429,

           0.00722,          -0.90806,

          -0.02161,           0.00902,

          -0.00261,           0.00077,

           0.00434,          -0.29231,

           0.00456,           0.04781,

           1.33214,          -2.62015,           0.79761,          -0.81850,
           0.06371,           0.00119,

           0.03049,          -0.03553,           0.02373,          -0.01411,

        -189.06132,        -169.17940,           5.27464,        -227.72664,
          83.72511,         -12.04794,           0.23965,          23.75496,
          -3.43532,          -0.34276,

          -1.35880,           0.45053,          -0.34298,          -0.11441,

          -0.16328,           0.07423,

         481.48150,          79.82461,         453.82764,         941.94205,
        -635.83924,         397.29087,         -81.54066,        -417.22420,
         149.91822,          10.53490,

          -0.13210,           0.36740,

           0.33777,           0.15893,

       -2562.04968,        2442.77844,       -2602.66709,        2838.87348,
         723.50715,       -1284.58208,       -4557.23362,       -4514.61100,
       -8960.81693,        4663.55087,       -4947.61530,       19377.42027,

          -0.16786,          -0.19514,

           0.32100,           0.91502,

           4.96600,          -1.11836,

         307.38057,         175.14618,          16.02093,         444.42376,
        -219.80047,          62.39286,         -18.14266,         -52.23698,

           0.02111,           0.00469,

         -20.97409,         -34.48296,          -2.03906,         -27.07560,
           3.73818,          -3.00599,           0.24112,           0.41430,

          -0.03552,           0.00394,

          -0.00217,           0.02307,

           0.03686,           0.00510,

          34.46537,          10.23293,           9.99520,          28.88781,
         -11.31210,           3.52646,          -0.48062,          -2.93641,

          -0.00987,          -0.05310,

         -38.39539,           0.04568,         -31.73684,          -1.83151,
         -24.97332,          -1.71244,           0.33498,           7.03899,
          -4.15247,         200.43434,

          -0.00800,           0.04462,

          37.83113,         -13.40661,           9.49434,         -35.41588,
         -14.72767,          -3.84674,          -0.31412,           3.97734,

           0.02908,          -0.00353,

           1.89935,         -14.31774,           7.77051,          -7.08945,
           1.90915,           1.78908,          -0.41445,           0.30506,

         -14.43121,           7.30707,         -11.97842,         -17.64121,
          13.38962,          -7.20982,

          -5.23362,           2.11364,          -0.45605,           4.08835,
           1.42683,           0.24838,

          -0.00605,           0.03199,

          -0.17609,          -1.43091,           0.32444,          -0.51371,
           0.06182,           0.03733,

           0.00696,          -0.13438,

           4.67581,           4.42379,          -1.52602,           4.20659,
          -1.31757,          -0.72910,

           1.29012,           0.97780,           2.25895,          -0.85306,
           1.74120,          -5.09507,

           0.28107,          -0.05040,           0.05508,          -0.06349,

          -0.00061,           0.48249,

          -2.37749,           1.78180,          -1.67423,          -0.35618,
           0.05789,          -0.35287,

           0.56252,          -0.66584,           0.61979,           4.84016,
          -4.64462,          17.48002,

           0.40982,          -4.19214,          -1.55252,          -1.87505,
          -0.31070,           0.15554,

          -0.00034,           0.11102,

           0.01116,          -0.04166,

           9.27689,          -4.32090,           6.84888,           1.78741,
          -0.09306,           1.68391,          -0.27482,          -0.04197,

          -7.83068,          37.71086,         -37.53346,           7.18559,
           0.74427,         -24.29751,          10.87837,           1.35503,

           0.00998,          -0.03395,

        -133.52206,        -150.11329,           4.27494,        -173.79469,
         150.87961,        -356.29181,        -330.17873,        -426.29809,
        -607.98186,         126.35464,        -299.69623,         556.41055,

          -0.00342,           0.04411,

          44.65946,          42.07312,          85.71397,           5.95130,
          24.98064,         -41.20026,         -14.05970,         -10.46101,
          -2.24038,           2.89211,

           0.06175,           0.08128,           0.00705,           0.01939,

          -1.08361,          -0.08213,          -0.20868,          -0.36268,

          -4.96489,          -2.05966,          -6.16586,           3.65514,
          -3.12555,          12.20821,

          -1.11236,          -1.73772,          -1.34045,          -0.22774,
          -0.08639,           0.27355,

          -0.07700,           1.06260,          -0.46013,           0.31916,
          -0.04969,          -0.09488,

          -1.54000,           0.04949,          -0.07616,          -0.95933,
           0.93303,           3.43183,

          -0.82917,          -0.82042,          -0.68158,           0.17083,
           0.06942,           0.17491,

          -0.02699,          -0.01051,

           0.00657,           0.03063,

          -0.52595,           0.84035,          -0.88323,          -0.70188,
           0.60928,          -0.48179,

           0.38290,           0.04482,           0.26456,          -0.32369,

          -0.00615,           0.03218,

          -0.32943,           0.14675,          -0.10782,          -0.09036,

          -0.58003,           0.72888,          -0.46654,           1.17977,

           0.00222,           0.01541,

          -0.19226,          -0.07770,          -0.01829,          -0.05070,

          -1.75385,          -1.32969,           0.52361,          -1.36036,
           0.67222,           1.34612,

           6.96841,         -29.24025,         -23.76900,         -39.91647,
         -41.01215,          -2.23638,         -18.81024,          20.77095,

          -0.68592,          -2.26212,          -1.14065,          -0.76493,
          -0.18044,           0.15193,

          -0.20669,          -0.44387,           0.25697,          -0.17880,

          -0.53097,           0.43181,          -0.35187,           0.71934,

          -0.14962,           0.09220,          -0.05031,          -0.03924,

           0.06571,           0.29487,

           0.05170,           0.36847,

           0.02754,          -0.00411,

          -0.08313,          -0.16907,           0.10273,          -0.07315,

          -0.02312,           0.04912,

          -0.01062,          -0.02713,

           0.03806,           0.13401,

          -1.79865,          -2.04540,          -2.69965,          -0.65706,
          -1.17916,           0.79292,

           0.02415,           0.14001,

          -0.01767,           0.04209,

           0.05212,          -0.01795,

           0.01285,           0.04028,

           0.01075,           0.05533,

           0.02323,          -0.00864,

          -0.04691,           0.03128,

           0.00548,           0.02254,

           0.00011,           0.12033,

  };
  static final double juptabb[] = {
         548.59659,         594.29629,         219.97664,          59.71822,
          23.62157,          40.77732,         227.07380,

           0.00293,          -0.00745,

        -307.33226,        -347.92807,        -309.49383,        -428.18929,
         -96.59506,        -191.36254,           2.11014,         -34.44145,
           2.23085,           6.77110,          -5.43468,          -0.28391,
           0.28355,          -1.81690,

           0.00036,           0.00078,

          -1.83259,           1.17464,          -2.66976,          -0.92339,
          -0.23645,          -1.20623,           0.25248,          -0.04958,
           0.00064,           0.03599,

          -0.00079,           0.00004,          -0.00005,          -0.00010,

          -0.00024,           0.00051,

           0.00001,           0.00005,

           0.00015,           0.00010,

           0.00017,          -0.00004,

           0.00113,          -0.00011,

           0.00021,           0.00087,

           0.00120,          -0.00114,          -0.00881,          -0.00020,

          -0.00005,           0.00009,

           0.00005,           0.00007,

           0.00002,          -0.00033,

          -0.00554,          -0.32274,           0.23695,          -0.11184,
           0.04050,           0.09929,          -0.02189,           0.00305,

          -0.00142,          -0.00055,

           0.66623,           0.34590,           0.74913,          -0.23202,
          -1.08316,          -1.40407,           1.72287,          -0.07604,

           0.00024,           0.00004,

           0.03592,           0.91143,          -1.11848,          -0.17473,
           0.91500,          -1.34912,           0.85229,           0.69029,

          -0.00019,           0.00075,

           0.03615,           0.30768,          -0.08733,           0.12016,
          -0.01716,          -0.01138,

           0.00021,           0.00004,

           0.00531,           0.00098,

          -0.14354,          -0.02364,          -0.05559,          -0.07561,
           0.01419,          -0.01141,           0.00014,           0.00218,

          -0.36564,           0.13498,          -0.13283,          -0.11462,
           0.23741,           0.14960,          -0.23173,           0.25148,
           0.00763,          -0.05987,

          -0.00857,           0.20312,          -0.29399,           0.34831,
          -1.33166,          -0.46808,

          -0.00027,           0.00046,

           0.15729,           0.01367,           0.04093,           0.07447,
          -0.01598,           0.00785,

           0.00583,           0.00324,           0.00053,           0.00160,

          -0.00030,           0.00043,

          -0.00208,           0.00334,          -0.00316,           0.00136,

           0.23086,           0.05711,           0.19558,           0.05897,
           0.01070,           0.05021,          -0.00818,          -0.02242,

           0.06301,          -0.26483,           0.66177,           0.02125,
           0.13477,           0.19376,

          -0.36520,           0.83588,          -0.69848,          -0.00877,
           0.01626,          -0.23878,

          -0.00373,           0.00044,

           0.00008,          -0.00004,

          -0.00374,          -0.00283,           0.01104,          -0.00619,

           0.00004,           0.00015,

           0.00026,           0.00013,

           0.04630,          -0.11815,           0.00773,           0.03796,
          -0.05172,           0.00149,           0.00444,          -0.01493,

          -0.00064,          -0.00044,

          -0.00033,           0.00002,

          -0.00012,           0.00284,

          -0.15622,          -0.92158,          -0.82690,          -1.52101,
          -0.55934,           0.69375,

          -0.00171,           0.00031,

           0.00129,          -0.00013,

          -0.00024,          -0.00083,

           0.66101,          -0.21764,          -0.43967,           0.30157,
           0.53389,           1.59141,           1.94286,           0.14146,

          -0.00064,          -0.00006,

           0.21850,          -0.02912,           0.08594,           0.08734,
          -0.01678,           0.01629,

           0.00133,           0.00562,

           0.00128,          -0.00025,

          -0.00005,           0.00027,

           0.00032,           0.00001,

           0.00037,           0.00042,

           0.00070,           0.00003,

           0.00275,          -0.13096,           0.02329,          -0.05582,
           0.00405,          -0.00251,

           0.01316,          -0.01165,           0.00279,          -0.00374,

         -39.62783,          20.91467,         -28.97236,           3.77560,
          -3.30029,           0.11472,          -0.48216,           1.05814,
          -0.21607,          -0.03055,

          -0.64162,          -0.57355,          -0.05861,          -0.18592,

          -0.12207,          -0.06279,

         -38.55325,        -125.74207,         -47.22357,          41.75842,
        -119.38841,          18.88515,         -11.04830,         -50.98851,
          16.64895,           1.76553,

           0.09474,           0.03714,

           0.02593,           0.07967,

       -1187.61854,       -1094.91786,       -1011.21939,       -1102.25998,
        -575.88672,        -107.84860,        -890.58889,        -807.06589,
         971.78461,       -1287.24560,       -4601.44669,        -849.54329,

          -0.00904,           0.06233,

          -0.19456,          -0.05521,

          -0.36915,           1.15363,

          32.64763,         -85.19705,         114.34437,         -13.37747,
          15.92865,          55.84857,         -13.10538,           3.07629,

          -0.00327,           0.00104,

          -7.81035,           6.19960,          -6.36096,           1.00493,
          -0.66971,          -0.84572,           0.09943,          -0.04583,

           0.00200,          -0.00032,

          -0.00265,           0.00047,

          -0.00053,           0.00046,

          -0.24396,           0.20664,          -0.30820,          -0.04917,
           0.06184,          -0.12642,           0.03053,           0.05054,

           0.00035,           0.00012,

           0.42063,          -0.58254,           0.90517,          -0.66276,
           0.64765,           0.39338,          -1.40645,           0.33017,
          -1.43377,          -0.67089,

          -0.00045,          -0.00036,

           0.23690,           0.07185,           0.28386,          -0.04397,
           0.02836,          -0.13082,          -0.00978,           0.00108,

           0.00046,           0.00083,

          -0.01665,           0.32499,          -0.09980,           0.18611,
          -0.02561,           0.00239,          -0.00084,          -0.00110,

           0.46854,          -0.35113,           0.69908,           0.53244,
           0.12875,           0.01115,

           0.13930,           0.02747,          -0.10587,          -0.17759,
          -0.26850,           0.04400,

           0.00010,          -0.00015,

           0.00164,          -0.01308,           0.00488,          -0.01046,
           0.00170,           0.00024,

           0.00084,           0.00014,

          -0.08481,          -0.02547,          -0.02290,          -0.02281,
          -0.03946,          -0.02810,

           0.01298,           0.08658,           0.05575,          -0.01081,
           1.09695,           0.35441,

          -0.03127,           0.07946,           0.01245,           0.02578,

          -0.00524,          -0.00027,

           0.08217,          -0.31742,           0.15273,          -0.07804,
           0.01197,           0.03053,

           0.81596,           0.38640,          -0.89777,           0.59499,
          -0.39581,          -0.87375,

           0.02096,           0.49772,           0.29986,           0.24210,
           0.14038,          -0.03016,

          -0.00208,           0.00045,

           0.01024,           0.00114,

           1.23010,           1.75663,          -0.12741,           1.44996,
          -0.31607,           0.03151,           0.00259,          -0.04741,

         -11.57091,           8.00331,          -9.24028,          -6.36906,
           4.71248,          -2.43695,           0.38630,           1.90625,

           0.01401,           0.00114,

          33.56690,         -55.17784,          33.21425,         -52.57002,
          27.04138,          13.78610,          69.60307,         -81.16312,
          27.53960,        -158.28336,        -205.94418,         -95.08051,

          -0.01407,          -0.00364,

         -18.56128,           6.02270,         -10.11059,          24.69471,
          12.31878,           9.94393,           3.81994,          -4.84109,
          -1.08440,          -0.72136,

           0.03731,          -0.02094,           0.00789,          -0.00176,

           0.09673,          -0.11181,           0.03112,          -0.00065,

          -0.29167,          -0.82083,           0.40866,          -0.77487,
          -2.23349,          -0.46973,

           0.41024,          -0.14274,           0.07755,          -0.24895,
          -0.04965,          -0.01197,

          -0.02264,           0.05917,          -0.02817,           0.01242,
          -0.00250,          -0.00247,

          -0.14414,          -0.03739,           0.14708,          -0.07908,
           0.05843,           0.15173,

          -0.01601,          -0.07844,          -0.05957,          -0.03143,
          -0.01830,           0.01257,

          -0.00109,          -0.00000,

           0.00174,           0.00050,

          -0.02119,           0.06918,          -0.02470,           0.00185,
           0.02372,          -0.02417,

           0.01081,           0.05222,           0.09820,           0.05931,

          -0.00588,          -0.00086,

           0.01688,          -0.00133,          -0.00073,           0.00041,

          -0.02280,          -0.05706,          -0.17694,          -0.12027,

           0.00196,          -0.00060,

           0.00051,          -0.02426,           0.00314,          -0.00302,

           0.17923,          -0.78343,           0.52073,          -0.02398,
          -0.03978,           0.20841,

           6.51325,           3.37139,          12.88844,          -6.72098,
           3.40949,         -14.34313,          -9.68278,          -7.85143,

           1.06886,          -0.21727,           0.36675,          -0.49815,
          -0.07289,          -0.07537,

           0.01107,          -0.00644,           0.01013,          -0.00306,

          -0.00708,          -0.13488,          -0.23041,          -0.10698,

          -0.00049,          -0.00692,          -0.00142,          -0.00211,

          -0.04021,           0.01805,

           0.00479,           0.00620,

           0.00739,           0.00566,

          -0.00101,          -0.00022,           0.00261,          -0.00188,

          -0.01812,          -0.01205,

          -0.00061,          -0.00061,

          -0.02479,           0.01157,

           0.91642,          -0.65781,           0.39969,          -1.13699,
          -0.43337,          -0.57828,

           0.00145,           0.00281,

          -0.01675,          -0.00975,

           0.00119,          -0.00074,

          -0.00343,           0.00139,

           0.00061,           0.00086,

           0.00054,          -0.00046,

          -0.01996,          -0.02689,

           0.00034,           0.00037,

          -0.00006,           0.00001,

  };
  static final double juptabr[] = {
        -734.58857,       -1081.04460,        -551.65750,        -148.79782,
         -25.23171,         164.64781,         248.64813,

          -0.05163,          -0.02413,

       -1306.61004,         560.02437,       -1622.58047,         589.92513,
        -812.39674,         166.85340,        -157.92826,        -107.14755,
          68.98900,         -18.95875,          -0.16183,          36.24345,
          -9.19972,          -2.29315,

          -0.00316,           0.00222,

          10.95234,          21.37177,          -6.29550,          21.83656,
          -7.70755,           1.38228,          -0.21770,          -1.49525,
           0.17951,           0.01043,

           0.00062,           0.00208,          -0.00066,           0.00050,

           0.00313,           0.00187,

           0.00010,           0.00131,

           0.00102,           0.00047,

           0.00102,           0.00012,

           0.00012,          -0.00037,

           0.00808,           0.00027,

          -0.01219,          -0.00961,          -0.04166,          -0.00327,

          -0.00001,          -0.00146,

          -0.00092,          -0.00989,

          -0.00135,           0.00196,

           0.19216,           2.48442,          -1.43599,           1.39651,
          -0.48549,          -0.53272,           0.14066,          -0.10352,

           0.00141,           0.00066,

           2.96838,          -3.09575,           6.27741,           5.24306,
          -8.77080,           9.03247,         -10.98350,          -3.58579,

          -0.00168,          -0.00100,

           0.20234,          -0.75737,           0.36838,          -0.58241,
           0.41430,          -0.35784,           0.47038,          -0.10586,

           0.00539,           0.00490,

          -0.01375,          -0.01950,           0.00145,           0.00723,
          -0.00391,           0.00391,

          -0.00131,          -0.00568,

           0.01317,           0.00319,

           1.31006,           5.89394,          -1.61753,           3.68814,
          -0.80644,          -0.14747,           0.04481,          -0.11361,

          -4.36130,           7.92488,         -16.29047,          -1.52163,
           2.14492,         -14.38028,           9.65573,           3.56881,
          -1.87208,           3.36213,

           1.84499,          -2.41575,          -2.77076,          -3.23915,
          -3.34573,           1.40979,

           0.00217,          -0.00841,

           0.29313,          -0.36246,           0.22043,           0.02328,
          -0.01182,           0.04074,

          -0.15728,           0.02468,          -0.03185,          -0.01099,

           0.01059,          -0.01274,

           0.07362,          -0.02642,           0.04035,          -0.00968,

          -2.14457,           2.53297,          -4.34196,          -0.11421,
          -0.38757,          -1.73872,           0.39784,          -0.01397,

          -0.03311,           0.97723,           0.16060,          -0.07486,
          25.96413,           0.75088,

          -3.04736,           0.30340,          -1.43451,          -1.35136,
           0.26526,          -0.40247,

          -0.00460,          -0.00056,

           0.01633,          -0.00128,

          -0.05197,           0.07002,          -0.19450,           0.03737,

           0.00188,          -0.00037,

          -0.00903,          -0.00059,

         -19.73809,           0.58424,         -10.42034,         -10.14579,
           2.65990,          -3.07889,           0.50884,           0.58508,

          -0.00970,           0.02099,

           0.00716,           0.01161,

           0.05751,          -0.04515,

          22.08042,          30.82415,         -36.27430,          31.40265,
         -18.30150,         -29.16403,

           0.02454,           0.01834,

          -0.01312,           0.01576,

          -0.00928,           0.00330,

         -11.78094,           4.06738,          -2.51590,          15.05277,
           9.12747,           2.88088,           2.32916,          -2.08271,

           0.02872,           0.02194,

           0.60494,          -0.04597,           0.24749,           0.15971,
          -0.02185,           0.03384,

          -0.07075,           0.01287,

           0.40201,           0.00347,

          -0.00410,          -0.00998,

          -0.00005,          -0.00121,

           0.13770,           0.00186,

          -0.02268,           0.00210,

           1.26291,           0.65546,           0.38885,           0.38880,
          -0.00184,           0.03067,

           0.01273,           0.01136,           0.00557,           0.01117,

          94.13171,         -88.37882,         120.53292,           8.32903,
           7.77313,          43.46523,         -11.66698,           0.44639,
           0.15092,          -1.68367,

          -0.30833,          -0.49030,           0.01971,          -0.14144,

          -0.04019,          -0.05110,

         -39.70024,         272.91667,        -468.46263,         256.77696,
        -200.63130,        -307.98554,         206.56301,         -41.76039,
          -4.74242,          74.19909,

           0.18474,           0.05547,

          -0.06732,           0.16515,

       -1156.31285,       -1102.97666,       -1346.99288,       -1121.01090,
         666.84550,         421.92305,        2259.49740,       -2268.69758,
       -2325.87639,       -4476.46256,       -9683.77583,       -2472.92565,

          -0.10400,           0.08075,

          -0.45225,           0.16621,

           0.57789,           2.43804,

          85.21675,        -154.17208,         219.91042,          -9.71116,
          31.13240,         108.60117,         -25.85622,           8.98402,

          -0.00233,           0.01030,

         -17.01324,          10.41588,         -13.34449,           1.08782,
          -1.48199,          -1.81734,           0.20334,          -0.11734,

          -0.00230,          -0.01869,

          -0.01182,          -0.00129,

          -0.00281,           0.02021,

          -5.75973,          19.13309,         -16.13690,           5.53382,
          -1.96585,          -6.29211,           1.63105,          -0.26089,

           0.02935,          -0.00555,

           0.30700,         -19.96182,           0.99825,         -16.32664,
           0.83052,         -13.76201,          -3.15609,           0.17360,
        -111.81423,          -2.05419,

          -0.02455,          -0.00478,

           7.45114,          21.53296,          19.90263,           5.69420,
           2.31253,          -8.15116,          -2.17440,          -0.23014,

           0.00168,           0.01590,

           8.78005,           0.71418,           4.48561,           4.50680,
          -1.05713,           1.17880,          -0.19327,          -0.24877,

          -5.00870,          -8.66354,          10.51902,          -7.71011,
           4.65486,           8.05673,

          -1.39635,          -3.07669,          -2.40347,          -0.11167,
          -0.04064,           0.83512,

          -0.02041,          -0.00351,

           0.97375,          -0.15795,           0.36361,           0.19913,
          -0.02142,           0.04193,

           0.08801,           0.00475,

          -2.81010,           3.11341,          -2.79191,          -0.93313,
           0.44570,          -0.88287,

          -0.51815,           0.54776,           0.29736,           0.99779,
           2.28957,           0.82183,

           0.03386,           0.12855,           0.03124,           0.02454,

          -0.31958,           0.00070,

          -1.48184,          -1.28195,           0.03965,          -1.12026,
           0.23910,           0.01293,

           0.36146,          -0.64483,          -1.88470,           0.21469,
         -11.79819,          -1.87287,

           2.65699,          -0.36287,           0.88148,          -1.26883,
          -0.19657,          -0.14279,

          -0.07536,          -0.00004,

           0.01496,           0.00537,

           2.48352,           3.75581,          -0.34909,           3.26696,
          -0.82105,           0.11287,          -0.00755,          -0.13764,

         -15.34429,          -2.79957,          -3.22976,         -15.46084,
          10.66793,          -0.26054,          -0.12188,           5.06211,

           0.01313,           0.00424,

          84.34332,         -57.05646,          92.68150,          -0.02024,
         149.62698,          59.14407,         174.04569,        -129.26785,
         -55.99789,        -238.01484,        -212.51618,        -115.94914,

          -0.01720,          -0.00158,

         -13.65602,          17.47396,           0.16714,          32.66367,
          16.30095,           9.18345,           3.98555,          -5.39985,
          -1.09958,          -0.86072,

           0.02752,          -0.02474,           0.00671,          -0.00278,

          -0.21030,          -0.73658,           0.20708,          -0.21378,

           0.78462,          -2.14051,          -1.60070,          -2.60915,
          -5.02441,          -1.19246,

           0.67622,          -0.41889,           0.07430,          -0.53204,
          -0.11214,          -0.03417,

          -0.72636,          -0.15535,          -0.16815,          -0.35603,
           0.07530,          -0.02521,

          -0.01261,          -0.94883,           0.39930,          -0.05370,
          -2.77309,           0.38431,

           0.72127,          -0.52030,          -0.01804,          -0.51188,
          -0.11993,           0.02189,

           0.00928,          -0.02129,

          -0.02760,           0.00441,

          -0.56832,          -0.48114,           0.64192,          -0.65656,
           0.37483,           0.51883,

          -0.08474,           0.20324,           0.12783,           0.13041,

          -0.01545,          -0.00282,

          -0.16196,          -0.26980,           0.06584,          -0.09987,

          -0.36305,          -0.27610,          -0.57074,          -0.13607,

          -0.00824,           0.00369,

           0.06094,          -0.12214,           0.03581,          -0.00876,

           0.49346,          -0.74596,           0.47814,           0.18201,
          -1.00640,           0.24465,

          10.09808,           2.30496,          13.63359,          -7.94007,
           0.29792,         -13.55724,          -6.48556,          -5.99581,

           0.69686,          -0.22434,           0.23198,          -0.35579,
          -0.04736,          -0.05683,

           0.36710,          -0.16571,           0.14876,           0.21824,

          -0.18940,          -0.15063,          -0.23692,          -0.09990,

          -0.08923,          -0.12222,           0.02998,          -0.04560,

          -0.16229,           0.04552,

          -0.33051,           0.02585,

          -0.00622,           0.01583,

           0.15436,          -0.07109,           0.06429,           0.09218,

          -0.01277,          -0.00019,

           0.02345,          -0.01057,

          -0.07294,           0.02506,

           0.62063,          -0.52533,           0.16814,          -0.77168,
          -0.20614,          -0.31828,

          -0.12856,           0.01316,

          -0.01522,          -0.00126,

           0.01558,           0.04765,

          -0.02776,           0.01166,

          -0.05185,           0.00674,

           0.00754,           0.02183,

          -0.00645,          -0.01050,

          -0.02155,           0.00375,

           0.12040,          -0.00004,

  };

  static byte jupargs[] = {
  (byte)0,  (byte)6,
  (byte)3,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)6,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)5,(byte)-10,  (byte)6,  (byte)4,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)3,  (byte)3,  (byte)5,(byte)-10,  (byte)6,  (byte)7,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)5,(byte)-15,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)4,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)1,  (byte)1,  (byte)7,  (byte)1,
  (byte)2,  (byte)5,  (byte)5,(byte)-12,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)7,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-7,  (byte)6,  (byte)3,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)3,
  (byte)3,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)3,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)2,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)1,  (byte)2,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-9,  (byte)6,  (byte)3,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)4,
  (byte)1,  (byte)1,  (byte)6,  (byte)2,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)2,
  (byte)2,  (byte)5,  (byte)5,(byte)-11,  (byte)6,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-3,  (byte)7,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-6,  (byte)6,  (byte)3,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)2,
  (byte)2,  (byte)3,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)7,  (byte)1,
  (byte)2,  (byte)6,  (byte)5,(byte)-13,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-2,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-8,  (byte)6,  (byte)3,
  (byte)2,  (byte)3,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)6,  (byte)5,(byte)-14,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)2,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)7,  (byte)5,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)4,  (byte)5, (byte)-9,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-6,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)3,  (byte)4,  (byte)5, (byte)-8,  (byte)6,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)7,  (byte)5,(byte)-15,  (byte)6,  (byte)2,
  (byte)3,  (byte)3,  (byte)5, (byte)-4,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)2,  (byte)5,  (byte)5,(byte)-10,  (byte)6,  (byte)4,
  (byte)3,  (byte)1,  (byte)5,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)3,  (byte)7,  (byte)5,(byte)-16,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-5,  (byte)6,  (byte)4,
  (byte)3,  (byte)1,  (byte)5, (byte)-6,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)5,  (byte)5,(byte)-11,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)1,  (byte)1,  (byte)5,  (byte)5,
  (byte)3,  (byte)3,  (byte)5,(byte)-11,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-6,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-7,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)3,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5,(byte)-10,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5,  (byte)1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-7,  (byte)6,  (byte)3,
  (byte)2,  (byte)4,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)6,  (byte)4,
  (byte)3,  (byte)4,  (byte)5, (byte)-8,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)1,  (byte)3,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-9,  (byte)6,  (byte)3,
  (byte)2,  (byte)3,  (byte)5, (byte)-4,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)5,  (byte)1,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)5,(byte)-11,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-6,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-1,  (byte)6,  (byte)2,
  (byte)1,  (byte)4,  (byte)6,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-8,  (byte)6,  (byte)2,
  (byte)2,  (byte)3,  (byte)5, (byte)-3,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)5,  (byte)2,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-1,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)5,(byte)-10,  (byte)6,  (byte)3,
  (byte)2,  (byte)4,  (byte)5, (byte)-5,  (byte)6,  (byte)3,
  (byte)2,  (byte)6,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)1,  (byte)2,  (byte)5,  (byte)5,
  (byte)3,  (byte)4,  (byte)5, (byte)-6,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)1,  (byte)5,  (byte)6,  (byte)4,
  (byte)2,  (byte)2,  (byte)5,(byte)-10,  (byte)6,  (byte)1,
  (byte)2,  (byte)5,  (byte)5, (byte)-7,  (byte)6,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-2,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)5,  (byte)3,  (byte)6,  (byte)2,
  (byte)2,  (byte)6,  (byte)5, (byte)-9,  (byte)6,  (byte)2,
  (byte)2,  (byte)4,  (byte)5, (byte)-4,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5,  (byte)1,  (byte)6,  (byte)2,
  (byte)2,  (byte)7,  (byte)5,(byte)-11,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-6,  (byte)6,  (byte)2,
  (byte)2,  (byte)3,  (byte)5, (byte)-1,  (byte)6,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-8,  (byte)6,  (byte)1,
  (byte)2,  (byte)4,  (byte)5, (byte)-3,  (byte)6,  (byte)1,
  (byte)2,  (byte)2,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)5,(byte)-10,  (byte)6,  (byte)1,
  (byte)2,  (byte)5,  (byte)5, (byte)-5,  (byte)6,  (byte)2,
  (byte)1,  (byte)3,  (byte)5,  (byte)3,
  (byte)2,  (byte)1,  (byte)5,  (byte)5,  (byte)6,  (byte)2,
  (byte)2,  (byte)6,  (byte)5, (byte)-7,  (byte)6,  (byte)1,
  (byte)2,  (byte)4,  (byte)5, (byte)-2,  (byte)6,  (byte)1,
  (byte)2,  (byte)7,  (byte)5, (byte)-9,  (byte)6,  (byte)1,
  (byte)2,  (byte)5,  (byte)5, (byte)-4,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-6,  (byte)6,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-1,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)5, (byte)-8,  (byte)6,  (byte)1,
  (byte)2,  (byte)5,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)8,  (byte)5,(byte)-10,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)1,  (byte)4,  (byte)5,  (byte)2,
  (byte)2,  (byte)7,  (byte)5, (byte)-7,  (byte)6,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)8,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)5, (byte)-6,  (byte)6,  (byte)0,
  (byte)2,  (byte)8,  (byte)5, (byte)-8,  (byte)6,  (byte)0,
  (byte)2,  (byte)9,  (byte)5,(byte)-10,  (byte)6,  (byte)0,
  (byte)1,  (byte)5,  (byte)5,  (byte)0,
  (byte)2,  (byte)9,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)5,  (byte)0,
 (byte)-1
  };
  /* Total terms = 142, small = 140 */
  static Plantbl jup404 = new Plantbl(
                               new short[]{0,  0,  1,  0,  9, 16,  7,  5,  0},
                               (short)6,
                               jupargs,
                               juptabl,
                               juptabb,
                               juptabr,
                               5.2026032092000003e+00
  );
}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class SwemptabMar {
  /*
  First date in file = 1228000.50
  Number of records = 397276.0
  Days per record = 4.0
        Julian Years      Lon    Lat    Rad
   -1349.9 to  -1000.0:   0.42   0.18   0.25
   -1000.0 to   -500.0:   0.45   0.14   0.21
    -500.0 to      0.0:   0.37   0.10   0.20
       0.0 to    500.0:   0.33   0.09   0.22
     500.0 to   1000.0:   0.48   0.07   0.22
    1000.0 to   1500.0:   0.40   0.07   0.19
    1500.0 to   2000.0:   0.36   0.11   0.19
    2000.0 to   2500.0:   0.38   0.14   0.20
    2500.0 to   3000.0:   0.45   0.15   0.24
    3000.0 to   3000.8:  0.182  0.125  0.087
  */

  static final double martabl[] = {
       43471.66140,       21291.11063,        2033.37848,  6890507597.78366,
     1279543.73631,

         317.74183,         730.69258,         -15.26502,         277.56960,
         -62.96711,          20.96285,

           1.01857,          -2.19395,

           3.75708,           3.65854,           0.01049,           1.09183,

          -0.00605,          -0.04769,

           0.41839,           0.10091,           0.03887,           0.11666,

          -0.03301,           0.02664,

           0.38777,          -0.56974,

           0.02974,          -0.15041,           0.02179,          -0.00808,

           0.08594,           0.09773,

          -0.00902,          -0.04597,           0.00762,          -0.03858,

          -0.00139,           0.01562,

           0.02019,           0.01878,

          -0.01244,           0.00795,

           0.00815,           0.03501,

          -0.00335,          -0.02970,

          -0.00518,          -0.01763,

           0.17257,           0.14698,          -0.14417,           0.26028,

           0.00062,          -0.00180,

          13.35262,          39.38771,         -15.49558,          22.00150,
          -7.71321,          -4.20035,           0.62074,          -1.42376,

           0.07043,          -0.06670,           0.16960,          -0.06859,
           0.07787,           0.01845,

          -0.01608,          -0.00914,

           5.60438,          -3.44436,           5.88876,           6.77238,
          -5.29704,           3.48944,

           0.01291,           0.01280,

          -0.53532,           0.86584,           0.79604,           0.31635,

          -3.92977,          -0.94829,          -0.74254,          -1.37947,
           0.17871,          -0.12477,

           0.00171,           0.11537,

           0.02281,          -0.03922,

          -0.00165,           0.02965,

           1.59773,           1.24565,          -0.35802,           1.37272,
          -0.44811,          -0.08611,

           3.04184,          -3.39729,           8.86270,           6.65967,
          -9.10580,          10.66103,

           0.02015,          -0.00902,

          -0.01166,          -0.23957,          -0.12128,          -0.04640,

          -0.07114,           0.14053,          -0.04966,          -0.01665,

           0.28411,          -0.37754,          -1.26265,           1.01377,
           3.70433,          -0.21025,

          -0.00972,           0.00350,

           0.00997,           0.00450,

          -2.15305,           3.18147,          -1.81957,          -0.02321,
          -0.02560,          -0.35188,

           0.00003,          -0.01110,

           0.00244,          -0.05083,

          -0.00216,          -0.02026,

           0.05179,           0.04188,

           5.92031,          -1.61316,           3.72001,           6.98783,
          -4.17690,           2.61250,

           0.04157,           2.76453,          -1.34043,           0.74586,
          -0.20258,          -0.30467,

           0.00733,           0.00376,

           1.72800,           0.76593,           1.26577,          -2.02682,
          -1.14637,          -0.91894,

          -0.00002,           0.00036,

           2.54213,           0.89533,          -0.04166,           2.36838,
          -0.97069,           0.05486,

           0.46927,           0.04500,           0.23388,           0.35005,

           1.61402,           2.30209,          -0.99859,           1.63349,
          -0.51490,          -0.26112,

           0.27848,          -0.26100,          -0.07645,          -0.22001,

           0.92901,           1.12627,          -0.39829,           0.77120,
          -0.23716,          -0.11245,

          -0.02387,           0.03960,

          -0.00802,           0.02179,

           2.86448,           1.00246,          -0.14647,           2.80278,
          -1.14143,           0.05177,

           1.68671,          -1.23451,           3.16285,           0.70070,
           0.25817,           3.17416,

           0.07447,          -0.08116,          -0.03029,          -0.02795,

           0.00816,           0.01023,

           0.00685,          -0.01075,

          -0.34268,           0.03680,          -0.05488,          -0.07430,

          -0.00041,          -0.02968,

           3.13228,          -0.83209,           1.95765,           3.78394,
          -2.26196,           1.38520,

          -0.00401,          -0.01397,

           1.01604,          -0.99485,           0.62465,           0.22431,
          -0.05076,           0.12025,

           4.35229,          -5.04483,          14.87533,           9.00826,
         -10.37595,          19.26596,

           0.40352,           0.19895,           0.09463,          -0.10774,

          -0.17809,          -0.08979,          -0.00796,          -0.04313,

           0.01520,          -0.03538,

           1.53301,          -1.75553,           4.87236,           3.23662,
          -3.62305,           6.42351,

          -0.00439,          -0.01305,

           0.17194,          -0.64003,           0.26609,           0.06600,

           0.01767,          -0.00251,

          -0.08871,          -0.15523,           0.01201,          -0.03408,

          -0.29126,          -0.07093,          -0.00998,          -0.07876,

           1.05932,         -25.38650,

          -0.29354,           0.04179,          -0.01726,           0.07473,

          -0.07607,          -0.08859,           0.00842,          -0.02359,

           0.47858,          -0.39809,           1.25061,           0.87017,
          -0.82453,           1.56864,

          -0.00463,           0.02385,

          -0.29070,           8.56535,

          -0.12495,           0.06580,          -0.03395,          -0.02465,

          -1.06759,           0.47004,          -0.40281,          -0.23957,
           0.03572,          -0.07012,

           0.00571,          -0.00731,

           0.18601,          -1.34068,

           0.03798,          -0.00532,           0.00448,          -0.01147,

           1.41208,          -0.00668,           0.25883,           1.23788,
          -0.57774,           0.09166,

          -2.49664,          -0.25235,          -0.53582,          -0.80126,
           0.10827,          -0.08861,

          -0.03577,           0.06825,

          -0.00143,           0.04633,

           0.01586,          -0.01056,

          -0.02106,           0.03804,

          -0.00088,          -0.03458,

          -0.00033,          -0.01079,

           0.05821,          -0.02445,

           0.00602,           0.00721,

          -0.00315,          -0.01021,

          -0.65454,           1.08478,          -0.44593,          -0.21492,

          -1.35004,           4.47299,          -4.19170,           3.51236,

        1946.04629,       13960.88247,         576.24572,        8023.81797,
        2402.48512,        -753.87007,       -6376.99217,      -10278.88014,
      -25743.89874,       15506.87748,       15609.59853,       35173.63133,

          -3.70370,           6.29538,          -4.84183,          -0.76942,

          -0.02465,          -0.03840,

           0.00565,          -0.06071,

           0.01174,           0.00253,

          -0.00230,           0.05252,

          -0.02813,           0.01359,

           0.23208,           0.03393,           0.01734,           0.04838,

          -0.46340,          -0.18941,           0.25428,          -0.56925,

           0.05213,           0.24704,           0.12922,          -0.01531,

           0.06885,          -0.08510,           0.01853,          -0.00390,

           0.01196,          -0.30530,           0.13117,          -0.03533,

           1.79597,          -0.42743,           0.98545,           2.13503,
          -1.32942,           0.68005,

          -0.01226,           0.00571,

           0.31081,           0.34932,           0.34531,          -0.32947,

          -0.00548,           0.00186,          -0.00157,          -0.00065,

           0.30877,          -0.03864,           0.04921,           0.06693,

           0.01761,          -0.04119,

           1.28318,           0.38546,           0.06462,           1.18337,
          -0.48698,           0.07086,

           0.26031,          -0.22813,           0.10272,           0.04737,

          -0.04506,          -0.38581,          -0.16624,          -0.04588,

           0.00992,           0.00722,

          -0.21041,           0.20560,          -0.09267,          -0.03438,

           0.32264,          -0.07383,

           0.09553,          -0.38730,           0.17109,          -0.01342,

          -0.02336,          -0.01286,

           0.00230,           0.04626,

           0.01176,           0.01868,

          -0.15411,          -0.32799,           0.22083,          -0.14077,

           1.98392,           1.68058,

          -0.02526,          -0.13164,          -0.04447,          -0.00153,

           0.01277,           0.00553,

          -0.26035,          -0.11362,           0.14672,          -0.32242,

           0.16686,          -0.69957,           0.40091,          -0.06721,
           0.00837,           0.09635,

          -0.08545,           0.25178,          -0.22486,          16.03256,

           0.34130,          -0.06313,           0.01469,          -0.09012,

          -0.00744,          -0.02510,

          -0.08492,          -0.13733,

          -0.07620,          -0.15329,           0.13716,          -0.03769,

           2.01176,          -1.35991,          -1.04319,          -2.97226,

          -0.01433,           0.61219,

          -0.55522,           0.38579,           0.31831,           0.81843,

          -0.04583,          -0.14585,

          -0.10218,           0.16039,          -0.06552,          -0.01802,

           0.06480,          -0.06641,           0.01672,          -0.00287,

           0.00308,           0.09982,          -0.05679,          -0.00249,

          -0.36034,           0.52385,          -0.29759,           0.59539,

          -3.59641,          -1.02499,

        -547.53774,         734.11470,         441.86760,        -626.68255,
       -2255.81376,       -1309.01028,       -2025.69590,        2774.69901,
        1711.21478,        1509.99797,

          -0.99274,           0.61858,          -0.47634,          -0.33034,

           0.00261,           0.01183,

          -0.00038,           0.11687,

           0.00994,          -0.01122,

           0.03482,          -0.01942,

          -0.11557,           0.38237,          -0.17826,           0.00830,

           0.01193,          -0.05469,

           0.01557,           0.01747,

           0.02730,          -0.01182,

          -0.11284,           0.12939,          -0.05621,          -0.01615,

           0.04258,           0.01058,

          -0.01723,           0.00963,

           0.20666,           0.11742,

           0.07830,          -0.02922,

          -0.10659,          -0.05407,           0.07254,          -0.13005,

          -0.02365,           0.24583,           0.31915,           1.27060,

           0.00009,          -0.21541,

          -0.55324,          -0.45999,          -1.45885,           0.86530,
           0.85932,           1.92999,

          -0.00755,          -0.00715,

          -0.02004,          -0.00788,

           0.01539,           0.00837,

           0.27652,          -0.50297,          -0.26703,          -0.28159,

           0.03950,           0.07182,

          -0.07177,           0.14140,           0.07693,           0.07564,

          -0.01316,          -0.01259,

           0.01529,           0.07773,

         -90.74225,        -378.15784,        -510.30190,         -52.35396,
         -89.15267,         415.56828,         181.52119,          54.01570,

          -0.01093,          -0.05931,

          -0.01344,          -0.02390,

           0.01432,          -0.02470,

          -0.01509,          -0.01346,

           0.03352,           0.02248,

           0.02588,          -0.00948,

           0.03610,           0.17238,

           0.02909,          -0.04065,

           0.00155,          -0.07025,

          -0.09508,           0.14487,           0.12441,           0.16451,

           0.00001,          -0.00005,

          -0.00982,          -0.01895,

          -0.16968,           0.36565,           0.20234,           0.17789,

          -0.04519,          -0.00588,

           0.01268,           0.00107,

         -56.32137,         -58.22145,         -80.55270,          28.14532,
          11.43301,          52.05752,          17.79480,          -2.61997,

          -0.00005,          -0.02629,

           0.01080,          -0.00390,

           0.00744,           0.03132,

           0.01156,          -0.01621,

           0.02162,           0.02552,

           0.00075,          -0.02497,

           0.02495,           0.00830,

           0.03230,           0.00103,

         -14.84965,          -4.50200,          -9.73043,           9.40426,
           4.08054,           5.38571,           1.53731,          -1.01288,

           0.21076,           1.74227,           0.79760,           0.39583,
           0.09879,          -0.16736,

          -0.00723,          -0.01536,

  };
  static final double martabb[] = {
        -364.49380,         -47.17612,        -554.97858,        -430.63121,
         596.44312,

          -3.94434,          -7.43169,          -0.06665,          -2.23987,
           0.10366,          -0.05567,

          -0.01463,           0.01908,

          -0.02611,          -0.00350,          -0.01057,          -0.00610,

          -0.00015,           0.00002,

           0.00010,           0.00033,           0.00007,          -0.00000,

          -0.00010,          -0.00004,

           0.00012,           0.00002,

          -0.00014,          -0.00048,          -0.00003,          -0.00007,

           0.00008,          -0.00005,

          -0.00043,          -0.00003,          -0.00010,          -0.00004,

           0.00001,           0.00001,

          -0.00003,          -0.00003,

           0.00004,           0.00007,

          -0.00041,           0.00031,

           0.00076,           0.00062,

           0.00001,          -0.00002,

           0.00035,           0.00053,           0.00026,           0.00019,

           0.00020,           0.00010,

           0.02936,           0.09624,          -0.01153,           0.01386,
           0.00551,          -0.00690,           0.00196,           0.00148,

          -0.00408,          -0.00673,          -0.00067,          -0.00152,
          -0.00014,          -0.00005,

           0.00000,           0.00005,

          -0.00116,           0.00276,          -0.00391,           0.00983,
          -0.01327,          -0.01986,

          -0.00003,           0.00001,

           0.01104,           0.00631,          -0.01364,           0.01152,

          -0.00439,           0.01103,          -0.00546,           0.00181,
          -0.00039,          -0.00083,

           0.00007,           0.00002,

          -0.00010,          -0.00008,

           0.00005,           0.00002,

          -0.00584,           0.00512,          -0.00722,          -0.00174,
           0.00101,          -0.00316,

          -0.02229,          -0.02797,          -0.10718,           0.05741,
           0.11403,           0.10033,

           0.00036,          -0.00022,

           0.00787,           0.01191,           0.01756,          -0.02121,

          -0.00169,          -0.00364,           0.00070,          -0.00051,

           0.01850,          -0.06836,           0.21471,           0.00162,
          -0.29165,           0.16799,

          -0.00002,           0.00011,

          -0.00075,          -0.00077,

          -0.00675,          -0.00814,           0.00029,          -0.00599,
           0.00107,           0.00013,

           0.00010,          -0.00002,

           0.00005,           0.00020,

           0.00355,           0.00306,

          -0.00013,          -0.00061,

          -0.02950,          -0.00847,           0.01037,          -0.04783,
           0.04237,           0.11662,

          -0.00331,           0.00207,          -0.00107,          -0.00264,
           0.00072,          -0.00023,

          -0.00151,           0.00146,

          -0.12847,           0.02294,           0.03611,           0.19705,
           0.16855,          -0.28279,

          -0.00000,          -0.00002,

          -0.00525,          -0.03619,           0.05048,          -0.00481,
          -0.00745,           0.04618,

           0.00286,           0.00443,           0.00521,          -0.00351,

           0.00200,           0.00474,          -0.00149,           0.00031,
          -0.00003,           0.00029,

           0.00686,           0.02467,           0.04275,          -0.02223,

           0.02282,          -0.04228,           0.03312,           0.01847,
          -0.01253,           0.01601,

           0.00076,           0.00091,

           0.00045,           0.00035,

           0.00658,           0.01586,          -0.00310,           0.00628,
          -0.00045,           0.00316,

          -0.01602,          -0.00340,          -0.01744,           0.04907,
           0.06426,           0.02275,

          -0.00217,          -0.00377,          -0.00091,           0.00037,

           0.00040,          -0.00003,

          -0.00017,          -0.00027,

           0.00366,           0.02693,          -0.00934,           0.00386,

           0.00616,          -0.00037,

           0.02028,           0.02120,          -0.01768,           0.02421,
           0.00102,           0.00877,

           0.00012,           0.00030,

          -0.00019,          -0.02165,           0.01245,          -0.00742,
           0.00172,           0.00320,

          -0.17117,          -0.12908,          -0.43134,           0.15617,
           0.21216,           0.56432,

           0.01139,          -0.00937,          -0.00058,          -0.00337,

          -0.00999,           0.01862,          -0.00621,          -0.00080,

          -0.00025,          -0.00140,

           0.09250,           0.01173,          -0.03549,           0.14651,
          -0.01784,           0.00945,

           0.00000,          -0.00006,

          -0.00500,           0.00086,           0.01079,          -0.00002,

          -0.00012,          -0.00029,

          -0.02661,           0.00140,          -0.00524,          -0.00460,

          -0.00352,          -0.00563,          -0.00277,          -0.00052,

          -0.10171,          -0.02001,

           0.00045,           0.00265,          -0.00082,           0.00160,

          -0.00302,          -0.00434,          -0.00022,          -0.00134,

           0.03285,           0.02964,          -0.05612,          -0.00668,
          -0.01821,           0.06590,

           0.00039,           0.00061,

          -0.13531,          -0.03831,

           0.02553,           0.02130,          -0.00336,           0.00468,

          -0.04522,          -0.05540,           0.00129,          -0.01767,
           0.00181,           0.00031,

          -0.00011,          -0.00034,

          -0.00146,           0.01101,

          -0.00030,           0.00240,          -0.00039,           0.00072,

          -0.01954,          -0.03822,           0.09682,          -0.04541,
          -0.01567,           0.09617,

          -0.03371,           0.33028,          -0.12102,           0.05874,
          -0.00990,          -0.02236,

           0.00109,           0.00158,

          -0.00482,           0.00019,

          -0.00036,           0.00004,

           0.00024,           0.00201,

           0.00017,           0.00011,

          -0.00012,           0.00002,

          -0.00323,          -0.01062,

          -0.00130,           0.00091,

           0.00056,          -0.00017,

           0.00774,           0.00601,           0.02550,           0.01700,

          -0.84327,           0.77533,          -0.71414,          -0.50643,

        -473.30877,       -1504.79179,        -458.52274,        -865.82237,
        -417.34994,        -681.03976,         765.50697,       -1653.67165,
        4427.33176,         710.53895,       -5016.39367,        4280.60361,

           0.33957,           0.38390,          -0.38631,           0.81193,

           0.00154,          -0.00043,

           0.01103,          -0.00017,

          -0.00046,           0.00221,

           0.00059,           0.00014,

           0.00160,           0.00475,

           0.06191,          -0.13289,           0.02884,          -0.00566,

          -0.01572,           0.23780,          -0.05140,          -0.03228,

          -0.00716,          -0.00978,          -0.01048,           0.01317,

          -0.01267,          -0.01198,           0.00037,          -0.00330,

          -0.02305,           0.00355,          -0.00121,          -0.00496,

          -0.04369,          -0.01343,           0.05347,          -0.12433,
           0.02090,           0.17683,

           0.00028,          -0.00490,

          -0.02778,          -0.05587,          -0.01658,           0.05655,

           0.00204,          -0.00092,           0.00020,           0.00014,

          -0.00603,          -0.03829,           0.00778,          -0.00588,

          -0.00266,           0.00097,

          -0.02158,          -0.07742,           0.09306,          -0.01827,
          -0.01048,           0.07885,

          -0.02485,          -0.02505,           0.00471,          -0.01026,

           0.06663,           0.01110,           0.00469,          -0.05347,

          -0.00016,          -0.00013,

           0.02622,           0.02273,          -0.01009,           0.01391,

          -0.01042,          -0.00444,

          -0.04293,          -0.00767,          -0.00154,          -0.01739,

           0.00353,          -0.00763,

          -0.00060,           0.00010,

          -0.00053,          -0.00146,

          -0.05317,           0.05760,          -0.01801,          -0.02099,

          -0.02611,          -0.01836,

          -0.00256,           0.00812,          -0.00145,           0.00054,

          -0.00008,           0.00015,

          -0.04087,           0.08860,          -0.05385,          -0.02134,

           0.02771,           0.02441,          -0.00234,           0.01571,
          -0.00260,           0.00097,

           0.10151,           0.49378,          -0.28555,           0.11428,

          -0.00286,           0.01224,           0.00160,           0.00069,

           0.00000,          -0.00040,

          -0.13286,           0.00448,

           0.01225,          -0.00568,           0.00341,           0.00224,

          -0.23483,          -0.07859,           0.30733,          -0.21548,

          -0.02608,           0.00756,

           0.09789,           0.02878,          -0.11968,           0.08981,

           0.02046,          -0.00888,

           0.02955,           0.01486,          -0.00981,           0.01542,

          -0.01674,          -0.01540,           0.00019,          -0.00449,

          -0.02140,           0.00638,           0.00112,          -0.00730,

          -0.08571,           0.13811,          -0.16951,          -0.02917,

          -0.03931,          -0.32643,

         -68.64541,         -81.00521,         -47.97737,          15.75290,
         181.76392,         -36.00647,         -48.32098,        -259.02226,
        -265.57466,         554.05904,

           0.09017,           0.18803,          -0.12459,           0.10852,

           0.00211,           0.00002,

           0.00304,          -0.00370,

           0.00174,           0.00279,

           0.00139,           0.00095,

           0.04881,           0.00262,          -0.01020,           0.03762,

           0.00987,           0.00612,

           0.00054,          -0.00036,

           0.00009,          -0.00094,

           0.02279,           0.01785,          -0.00778,           0.01263,

           0.00040,          -0.00112,

          -0.00452,          -0.00662,

           0.00483,          -0.00030,

          -0.00054,          -0.00205,

          -0.00052,          -0.00362,          -0.00215,          -0.00247,

           0.02893,          -0.01965,          -0.00004,           0.04114,

          -0.00284,          -0.00103,

           0.01827,          -0.07822,           0.18010,           0.04805,
          -0.21702,           0.18808,

           0.00095,          -0.00132,

          -0.01488,           0.00746,

           0.00198,           0.00190,

           0.01032,           0.03392,           0.04318,          -0.07332,

          -0.01004,           0.00787,

          -0.00308,          -0.01177,          -0.01431,           0.02659,

           0.00273,          -0.00374,

          -0.02545,           0.00644,

          28.68376,          13.74978,          29.60401,         -47.98255,
         -65.91944,         -18.48404,          -1.73580,          64.67487,

          -0.02492,           0.00104,

          -0.00829,          -0.00134,

           0.00077,           0.00005,

          -0.00513,           0.00403,

           0.00071,          -0.00047,

          -0.00023,          -0.00063,

           0.00120,           0.00370,

          -0.00038,          -0.00037,

           0.00080,          -0.00018,

           0.00866,           0.00156,          -0.01064,           0.02131,

           0.00000,          -0.00001,

           0.00038,          -0.00068,

          -0.00909,          -0.02187,          -0.02599,           0.05507,

          -0.00022,          -0.01468,

           0.00032,           0.00500,

           9.86233,          -2.85314,          -2.25791,         -13.83444,
         -12.38794,           3.79861,           2.76343,           6.63505,

           0.00066,           0.00007,

          -0.00016,          -0.00039,

           0.00014,           0.00059,

          -0.00031,          -0.00024,

          -0.00168,           0.00259,

           0.00007,          -0.00005,

          -0.00052,           0.00558,

           0.00110,           0.01037,

           1.59224,          -2.37284,          -2.00023,          -2.28280,
          -1.49571,           1.48293,           0.60041,           0.56376,

          -0.54386,           0.03568,          -0.10392,           0.31005,
           0.09104,           0.03015,

           0.00826,          -0.00524,

  };
  static final double martabr[] = {
        -816.07287,        -381.41365,         -33.69436,         177.22955,
           0.18630,

          -8.29605,         -11.15519,          -0.57407,          -3.53642,
           0.16663,          -0.06334,

          -0.03056,           0.02767,

          -0.04161,           0.03917,          -0.02425,           0.00204,

          -0.00034,           0.00023,

           0.00058,          -0.00111,           0.00039,          -0.00015,

           0.00006,          -0.00023,

           0.00237,           0.00191,

           0.00154,          -0.00029,           0.00009,           0.00011,

          -0.00041,           0.00037,

          -0.00010,          -0.00064,           0.00015,          -0.00005,

           0.00012,          -0.00003,

          -0.00034,           0.00026,

           0.00011,          -0.00007,

          -0.00158,           0.00087,

           0.00278,           0.00137,

           0.00024,          -0.00020,

           0.00530,          -0.00448,           0.00780,           0.00408,

           0.00062,           0.00035,

          -1.35261,           0.79891,          -0.81597,          -0.43774,
           0.14713,          -0.27415,           0.05298,           0.02230,

          -0.02089,          -0.01070,          -0.00374,           0.00342,
          -0.00142,           0.00270,

          -0.00039,           0.00063,

           0.16024,           0.27088,          -0.32127,           0.27467,
          -0.16615,          -0.24460,

          -0.00073,           0.00032,

          -0.05710,          -0.05265,          -0.06025,           0.05120,

          -0.05295,           0.23477,          -0.08211,           0.04575,
          -0.00769,          -0.01067,

          -0.00570,           0.00015,

          -0.00251,          -0.00140,

          -0.00131,          -0.00018,

          -0.12246,           0.15836,          -0.13065,          -0.03222,
           0.00795,          -0.04232,

          -0.36585,          -0.31154,           0.68504,          -0.96006,
           1.19304,           0.88631,

           0.00132,           0.00046,

           0.13105,           0.04252,           0.05164,          -0.06837,

          -0.01351,          -0.01458,           0.00376,          -0.00557,

           0.28532,          -0.17290,          -0.53946,          -0.79365,
          -0.95246,           0.74984,

           0.00019,           0.00132,

          -0.00163,          -0.00295,

          -0.40106,          -0.26573,          -0.00155,          -0.22655,
           0.04349,          -0.00376,

           0.00149,          -0.00001,

           0.00523,           0.00078,

           0.01203,           0.00558,

          -0.00708,           0.00520,

          -0.36428,          -1.28827,           1.50845,          -0.83063,
           0.58802,           0.89998,

          -0.55256,           0.01255,          -0.15169,          -0.26715,
           0.06061,          -0.04122,

          -0.00397,           0.00534,

          -0.52576,           1.22031,           1.44098,           0.92406,
           0.67214,          -0.85486,

          -0.00010,           0.00001,

           0.28820,          -0.84198,           0.78291,           0.00251,
           0.02398,           0.32093,

          -0.02331,           0.10109,          -0.07555,           0.03557,

          -0.61580,           0.43399,          -0.43779,          -0.26390,
           0.06885,          -0.13803,

           0.17694,           0.19245,           0.15119,          -0.05100,

           0.49469,          -0.45028,           0.33590,           0.15677,
          -0.04702,           0.10265,

          -0.00942,          -0.00580,

          -0.00555,          -0.00252,

          -0.32933,           0.92539,          -0.91004,          -0.04490,
          -0.01812,          -0.37121,

           0.34695,           0.50855,          -0.24721,           0.86063,
          -0.84747,           0.01983,

           0.01948,           0.02039,           0.00748,          -0.00727,

          -0.00271,           0.00220,

           0.00309,           0.00196,

           0.02030,           0.17201,          -0.03716,           0.02801,

           0.01871,           0.00002,

           0.31736,           1.17319,          -1.42245,           0.73416,
          -0.52302,          -0.85056,

           0.00522,          -0.00126,

           0.33571,           0.34594,          -0.07709,           0.21114,
          -0.04066,          -0.01742,

           1.72228,           1.46934,          -3.06437,           5.06723,
          -6.53800,          -3.55839,

          -0.06933,           0.13815,           0.03684,           0.03284,

          -0.04841,           0.09571,          -0.02350,           0.00418,

           0.01302,           0.00579,

           0.73408,           0.64718,          -1.37437,           2.04816,
          -2.70756,          -1.52808,

           0.00523,          -0.00166,

           0.25915,           0.06900,          -0.02758,           0.10707,

           0.00062,           0.00744,

          -0.08117,           0.04840,          -0.01806,          -0.00637,

           0.03034,          -0.12414,           0.03419,          -0.00388,

          10.92603,           0.48169,

          -0.01753,          -0.12853,          -0.03207,          -0.00801,

           0.03904,          -0.03326,           0.01033,           0.00366,

           0.17249,           0.20846,          -0.38157,           0.54639,
          -0.68518,          -0.36121,

          -0.01043,          -0.00186,

          -3.33843,          -0.16353,

           0.03462,           0.06669,          -0.01305,           0.01803,

          -0.22703,          -0.52219,           0.11709,          -0.19628,
           0.03410,           0.01741,

           0.00338,           0.00265,

           0.63213,           0.08944,

           0.00236,           0.01829,           0.00546,           0.00218,

           0.00073,          -0.72570,           0.63698,          -0.13340,
           0.04698,           0.29716,

          -0.13126,           1.27705,          -0.40980,           0.27400,
          -0.04525,          -0.05529,

          -0.03249,          -0.01696,

          -0.02314,          -0.00076,

           0.00510,           0.00764,

          -0.01847,          -0.01021,

           0.01688,          -0.00044,

           0.00531,          -0.00016,

          -0.01219,          -0.02903,

          -0.00361,           0.00299,

           0.00504,          -0.00153,

          -0.53625,          -0.32460,           0.10642,          -0.22070,

          -2.21651,          -0.66036,          -1.74652,          -2.08198,

       -6810.78679,         967.02869,       -3915.97140,         291.65905,
         372.99563,        1196.01966,        5108.01033,       -3172.64698,
       -7685.78246,      -12789.43898,      -17474.50562,        7757.84703,

           3.13224,           1.84743,          -0.38257,           2.40590,

           0.01860,          -0.01217,

           0.03004,           0.00278,

          -0.00125,           0.00579,

          -0.02673,          -0.00112,

           0.00662,           0.01374,

          -0.02729,           0.13109,          -0.02836,           0.00877,

           0.12171,          -0.27475,           0.34765,           0.15882,

          -0.12548,           0.02603,           0.00710,           0.06538,

          -0.04039,          -0.03257,          -0.00186,          -0.00880,

           0.16643,           0.00707,           0.01918,           0.07156,

          -0.20459,          -0.85107,           1.01832,          -0.47158,
           0.32582,           0.63002,

          -0.00282,          -0.00711,

          -0.19695,           0.15053,           0.15676,           0.17847,

           0.00071,           0.00286,          -0.00039,           0.00083,

           0.02009,           0.17859,          -0.03894,           0.02805,

           0.02379,           0.00752,

           0.17529,          -0.57783,           0.53257,          -0.02829,
           0.03211,           0.21777,

           0.13813,           0.16305,          -0.02996,           0.06303,

           0.21058,          -0.02659,           0.02596,          -0.08808,

          -0.00389,           0.00586,

           0.08986,           0.09204,          -0.01480,           0.04031,

           0.06115,           0.18366,

           0.25636,           0.06905,           0.00719,           0.11391,

           0.00636,          -0.01113,

          -0.02808,           0.00150,

          -0.01219,           0.00832,

           0.28626,          -0.09573,           0.10481,           0.16559,

          -0.94578,           1.26394,

           0.08846,          -0.01623,           0.00082,          -0.02640,

          -0.00347,           0.00798,

           0.12873,          -0.21248,           0.27999,           0.14348,

           0.44082,           0.10453,           0.04362,           0.25332,
          -0.06077,           0.00555,

          -0.06947,          -0.05511,         -10.08703,          -0.10614,

           0.04059,           0.21355,           0.05632,           0.00871,

           0.01599,          -0.00531,

           0.36835,          -0.03530,

           0.09519,          -0.04961,           0.02568,           0.08613,

           0.57033,           0.84599,           1.27123,          -0.41266,

          -0.36937,          -0.00655,

          -0.16547,          -0.24000,          -0.35213,           0.13345,

           0.05870,          -0.01524,

           0.06419,           0.04136,          -0.00681,           0.02606,

          -0.02519,          -0.02732,          -0.00105,          -0.00677,

          -0.03891,           0.00106,           0.00087,          -0.02256,

          -0.20834,          -0.14624,          -0.23178,          -0.11786,

           0.32479,          -1.41222,

        -303.74549,        -202.79324,         260.20290,         184.84320,
         536.68016,        -881.56427,       -1125.64824,        -791.09928,
        -596.61162,         659.35664,

           0.24561,           0.39519,          -0.12601,           0.18709,

          -0.00700,           0.00136,

           0.30750,           0.00009,

           0.00443,           0.00384,

           0.01170,           0.02078,

           0.15043,           0.04802,           0.00386,           0.06942,

           0.02107,           0.00495,

          -0.01067,           0.00951,

           0.00937,           0.01996,

           0.04922,           0.04337,          -0.00583,           0.02110,

          -0.00691,           0.02793,

          -0.00364,          -0.00682,

          -0.09143,           0.15369,

           0.02043,           0.05451,

           0.04053,          -0.08179,           0.09645,           0.05330,

          -0.10149,          -0.01594,          -0.96773,           0.13660,

           0.17326,           0.00013,

           0.20990,          -0.23184,          -0.38407,          -0.64733,
          -0.84754,           0.38889,

           0.00310,          -0.00340,

           0.00970,          -0.00788,

          -0.01111,           0.00677,

           0.18147,           0.09968,           0.10170,          -0.09233,

          -0.03165,           0.01790,

          -0.04727,          -0.02364,          -0.02546,           0.02451,

           0.00442,          -0.00426,

          -0.02540,           0.00471,

         130.42585,         -31.30051,          17.99957,        -174.75585,
        -142.96798,         -27.89752,         -19.42122,          59.14872,

          -0.01899,           0.00388,

          -0.01265,           0.00694,

           0.01966,           0.01140,

          -0.00439,           0.00503,

          -0.01867,           0.02826,

           0.00752,           0.02012,

          -0.14734,           0.01909,

           0.03312,           0.02327,

           0.05843,           0.00061,

          -0.06958,          -0.05798,          -0.09174,           0.06242,

           0.00003,           0.00001,

           0.00670,          -0.00305,

          -0.13637,          -0.06058,          -0.06372,           0.07257,

           0.00209,          -0.01369,

          -0.00044,           0.00355,

          17.90079,         -17.48270,          -8.77915,         -24.54483,
         -15.67123,           3.62668,           0.52038,           5.13220,

           0.02574,           0.00003,

           0.00339,           0.00919,

          -0.02778,           0.00464,

           0.01429,           0.01003,

          -0.01661,           0.01327,

           0.02216,           0.00034,

          -0.00389,           0.01076,

          -0.00035,           0.00983,

           1.23731,          -4.18017,          -2.61932,          -2.66346,
          -1.45540,           1.10310,           0.23322,           0.40775,

          -0.43623,           0.06212,          -0.09900,           0.19456,
           0.03639,           0.02566,

           0.00309,          -0.00116,

  };

  static final byte marargs[] = {
  (byte)0,  (byte)4,
  (byte)3,  (byte)4,  (byte)3, (byte)-8,  (byte)4,  (byte)3,  (byte)5,  (byte)2,
  (byte)3,  (byte)5,  (byte)2, (byte)-6,  (byte)3, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)3, (byte)12,  (byte)3,(byte)-24,  (byte)4,  (byte)9,  (byte)5,  (byte)0,
  (byte)3,  (byte)2,  (byte)2,  (byte)1,  (byte)3, (byte)-8,  (byte)4,  (byte)1,
  (byte)3, (byte)11,  (byte)3,(byte)-21,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-7,  (byte)3,  (byte)4,  (byte)4,  (byte)0,
  (byte)3,  (byte)7,  (byte)3,(byte)-13,  (byte)4, (byte)-1,  (byte)5,  (byte)1,
  (byte)3,  (byte)1,  (byte)3, (byte)-2,  (byte)4,  (byte)2,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)2, (byte)-8,  (byte)3, (byte)12,  (byte)4,  (byte)1,
  (byte)3,  (byte)1,  (byte)4, (byte)-8,  (byte)5,  (byte)4,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)4, (byte)-7,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)4, (byte)-9,  (byte)5,  (byte)7,  (byte)6,  (byte)0,
  (byte)1,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)3, (byte)-2,  (byte)4,  (byte)1,  (byte)5,  (byte)0,
  (byte)3,  (byte)3,  (byte)3, (byte)-6,  (byte)4,  (byte)2,  (byte)5,  (byte)1,
  (byte)3, (byte)12,  (byte)3,(byte)-23,  (byte)4,  (byte)3,  (byte)5,  (byte)0,
  (byte)2,  (byte)8,  (byte)3,(byte)-15,  (byte)4,  (byte)3,
  (byte)2,  (byte)1,  (byte)4, (byte)-6,  (byte)5,  (byte)2,
  (byte)3,  (byte)2,  (byte)2, (byte)-7,  (byte)3,  (byte)7,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-3,  (byte)4,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)0,
  (byte)1,  (byte)1,  (byte)6,  (byte)1,
  (byte)2,  (byte)9,  (byte)3,(byte)-17,  (byte)4,  (byte)2,
  (byte)3,  (byte)2,  (byte)3, (byte)-4,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)3,  (byte)2,  (byte)3, (byte)-4,  (byte)4,  (byte)1,  (byte)5,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-6,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)3, (byte)-2,  (byte)4,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)1,  (byte)1,  (byte)5,  (byte)2,
  (byte)3,  (byte)4,  (byte)3, (byte)-8,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)3,(byte)-13,  (byte)4,  (byte)2,
  (byte)2,  (byte)3,  (byte)2, (byte)-9,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)1,  (byte)3,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-5,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-4,  (byte)4,  (byte)2,
  (byte)2,  (byte)6,  (byte)3,(byte)-11,  (byte)4,  (byte)2,
  (byte)2,  (byte)4,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)5,  (byte)2,
  (byte)3,  (byte)1,  (byte)4, (byte)-3,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-6,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)4, (byte)-4,  (byte)5,  (byte)1,
  (byte)2,  (byte)5,  (byte)3, (byte)-9,  (byte)4,  (byte)2,
  (byte)1,  (byte)3,  (byte)5,  (byte)1,
  (byte)2,  (byte)4,  (byte)3, (byte)-8,  (byte)4,  (byte)2,
  (byte)3,  (byte)1,  (byte)4, (byte)-4,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)4, (byte)-1,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-7,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)4, (byte)-3,  (byte)5,  (byte)2,
  (byte)3,  (byte)1,  (byte)4, (byte)-5,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)3,  (byte)1,  (byte)4, (byte)-4,  (byte)5,  (byte)3,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)4, (byte)-3,  (byte)5,  (byte)1,  (byte)6,  (byte)0,
  (byte)2,  (byte)5,  (byte)3,(byte)-10,  (byte)4,  (byte)1,
  (byte)1,  (byte)4,  (byte)5,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-5,  (byte)4,  (byte)2,
  (byte)3,  (byte)1,  (byte)4, (byte)-3,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-5,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)4, (byte)-2,  (byte)5,  (byte)2,
  (byte)3,  (byte)1,  (byte)4, (byte)-4,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)2,  (byte)6,  (byte)3,(byte)-12,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)4, (byte)-4,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-3,  (byte)4,  (byte)2,
  (byte)2, (byte)10,  (byte)3,(byte)-18,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-3,  (byte)6,  (byte)1,
  (byte)3,  (byte)1,  (byte)4, (byte)-2,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)3,(byte)-14,  (byte)4,  (byte)1,
  (byte)3,  (byte)1,  (byte)4,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)4, (byte)-1,  (byte)5,  (byte)0,
  (byte)3,  (byte)1,  (byte)4, (byte)-3,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)3,  (byte)1,  (byte)4,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)4, (byte)-2,  (byte)6,  (byte)2,
  (byte)3,  (byte)1,  (byte)4, (byte)-2,  (byte)5,  (byte)3,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-7,  (byte)4,  (byte)1,
  (byte)2,  (byte)9,  (byte)3,(byte)-16,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)4, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-1,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)4, (byte)-2,  (byte)5,  (byte)4,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)2, (byte)-4,  (byte)4,  (byte)2,
  (byte)2,  (byte)8,  (byte)3,(byte)-16,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)4, (byte)-2,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)3, (byte)-5,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)3,  (byte)1,  (byte)4,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-1,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-1,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-7,  (byte)3,  (byte)3,  (byte)4,  (byte)0,
  (byte)3,  (byte)2,  (byte)2,  (byte)1,  (byte)3, (byte)-7,  (byte)4,  (byte)0,
  (byte)3,  (byte)1,  (byte)4,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)4,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)3,  (byte)4,  (byte)3, (byte)-7,  (byte)4,  (byte)3,  (byte)5,  (byte)1,
  (byte)1,  (byte)1,  (byte)4,  (byte)5,
  (byte)3,  (byte)4,  (byte)3, (byte)-9,  (byte)4,  (byte)3,  (byte)5,  (byte)1,
  (byte)3,  (byte)1,  (byte)4, (byte)-2,  (byte)5,  (byte)5,  (byte)6,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-7,  (byte)3,  (byte)5,  (byte)4,  (byte)0,
  (byte)3,  (byte)1,  (byte)3, (byte)-1,  (byte)4,  (byte)2,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)4,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)3,  (byte)3,  (byte)3, (byte)-7,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)8,  (byte)3,(byte)-14,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)2, (byte)-2,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)4,  (byte)1,  (byte)6,  (byte)1,
  (byte)2,  (byte)9,  (byte)3,(byte)-18,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)2, (byte)-5,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-3,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)4,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)4,  (byte)1,  (byte)5,  (byte)1,
  (byte)3,  (byte)4,  (byte)3, (byte)-9,  (byte)4,  (byte)2,  (byte)5,  (byte)1,
  (byte)2,  (byte)7,  (byte)3,(byte)-12,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-5,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-5,  (byte)4,  (byte)2,
  (byte)2,  (byte)6,  (byte)3,(byte)-10,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)4,  (byte)2,  (byte)5,  (byte)1,
  (byte)3,  (byte)2,  (byte)4, (byte)-5,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-7,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-8,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)4,  (byte)3,  (byte)5,  (byte)0,
  (byte)3,  (byte)2,  (byte)4, (byte)-4,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)4, (byte)-1,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-6,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-3,  (byte)5,  (byte)0,
  (byte)3,  (byte)2,  (byte)4, (byte)-5,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)3,  (byte)2,  (byte)4, (byte)-4,  (byte)5,  (byte)3,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-4,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-5,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)4, (byte)-2,  (byte)5,  (byte)1,
  (byte)3,  (byte)2,  (byte)4, (byte)-4,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-4,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)4, (byte)-3,  (byte)6,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-1,  (byte)5,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-2,  (byte)6,  (byte)0,
  (byte)1,  (byte)1,  (byte)3,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-1,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-5,  (byte)4,  (byte)1,
  (byte)2,  (byte)8,  (byte)3,(byte)-17,  (byte)4,  (byte)1,
  (byte)3,  (byte)2,  (byte)4,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)3,  (byte)4,  (byte)3, (byte)-6,  (byte)4,  (byte)3,  (byte)5,  (byte)1,
  (byte)3, (byte)10,  (byte)3,(byte)-17,  (byte)4,  (byte)3,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)4,  (byte)4,
  (byte)3,  (byte)4,  (byte)3,(byte)-10,  (byte)4,  (byte)3,  (byte)5,  (byte)1,
  (byte)2,  (byte)8,  (byte)3,(byte)-13,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-1,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)4,  (byte)1,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-4,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)4,  (byte)1,  (byte)5,  (byte)0,
  (byte)2,  (byte)7,  (byte)3,(byte)-11,  (byte)4,  (byte)0,
  (byte)2,  (byte)3,  (byte)4, (byte)-5,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-6,  (byte)4,  (byte)1,
  (byte)2,  (byte)6,  (byte)3, (byte)-9,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)3,  (byte)4, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-7,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-5,  (byte)4,  (byte)1,
  (byte)2,  (byte)3,  (byte)4, (byte)-3,  (byte)5,  (byte)1,
  (byte)2,  (byte)3,  (byte)3, (byte)-3,  (byte)4,  (byte)0,
  (byte)2,  (byte)3,  (byte)4, (byte)-2,  (byte)5,  (byte)2,
  (byte)3,  (byte)3,  (byte)4, (byte)-4,  (byte)5,  (byte)5,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-1,  (byte)4,  (byte)0,
  (byte)2,  (byte)3,  (byte)4, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)4, (byte)-1,  (byte)5,  (byte)1,
  (byte)2,  (byte)3,  (byte)4, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3,  (byte)1,  (byte)4,  (byte)1,
  (byte)2,  (byte)3,  (byte)4, (byte)-1,  (byte)6,  (byte)0,
  (byte)3,  (byte)4,  (byte)3, (byte)-5,  (byte)4,  (byte)3,  (byte)5,  (byte)0,
  (byte)1,  (byte)3,  (byte)4,  (byte)3,
  (byte)3,  (byte)4,  (byte)3,(byte)-11,  (byte)4,  (byte)3,  (byte)5,  (byte)0,
  (byte)1,  (byte)1,  (byte)2,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-3,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-5,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)4, (byte)-5,  (byte)5,  (byte)0,
  (byte)2,  (byte)6,  (byte)3, (byte)-8,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)4, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-6,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)4, (byte)-3,  (byte)5,  (byte)1,
  (byte)3,  (byte)6,  (byte)3, (byte)-8,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)4, (byte)-2,  (byte)5,  (byte)1,
  (byte)2,  (byte)4,  (byte)4, (byte)-1,  (byte)5,  (byte)0,
  (byte)2,  (byte)1,  (byte)3,  (byte)2,  (byte)4,  (byte)0,
  (byte)1,  (byte)4,  (byte)4,  (byte)3,
  (byte)2,  (byte)2,  (byte)2, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)7,  (byte)3, (byte)-9,  (byte)4,  (byte)0,
  (byte)2,  (byte)5,  (byte)4, (byte)-5,  (byte)5,  (byte)0,
  (byte)2,  (byte)6,  (byte)3, (byte)-7,  (byte)4,  (byte)0,
  (byte)2,  (byte)5,  (byte)4, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-5,  (byte)4,  (byte)0,
  (byte)2,  (byte)5,  (byte)4, (byte)-3,  (byte)5,  (byte)0,
  (byte)2,  (byte)5,  (byte)4, (byte)-2,  (byte)5,  (byte)0,
  (byte)1,  (byte)5,  (byte)4,  (byte)3,
  (byte)1,  (byte)6,  (byte)4,  (byte)2,
  (byte)1,  (byte)7,  (byte)4,  (byte)0,
 (byte)-1
  };
  /* Total terms = 201, small = 199 */
  static Plantbl mar404 = new Plantbl(
                               new short[]{0,  5, 12, 24,  9,  7,  3,  2,  0},
                               (short)5,
                               marargs,
                               martabl,
                               martabb,
                               martabr,
                               1.5303348827100001e+00
                              );
}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class SwemptabMer {
  /*
  First date in file = 1228000.50
  Number of records = 397276.0
  Days per record = 4.0
        Julian Years      Lon    Lat    Rad
   -1349.9 to  -1000.0:   0.42   0.18   0.16
   -1000.0 to   -500.0:   0.37   0.19   0.13
    -500.0 to      0.0:   0.35   0.17   0.12
       0.0 to    500.0:   0.34   0.15   0.10
     500.0 to   1000.0:   0.28   0.14   0.09
    1000.0 to   1500.0:   0.34   0.14   0.09
    1500.0 to   2000.0:   0.35   0.13   0.09
    2000.0 to   2500.0:   0.38   0.12   0.12
    2500.0 to   3000.0:   0.42   0.13   0.16
    3000.0 to   3000.8:  0.252  0.087  0.115
  */
  static final double mertabl[] = {
          35.85255,        -163.26379, 53810162857.56026,      908082.18475,

           0.05214,          -0.07712,

           1.07258,           0.04008,           0.49259,           0.00230,
           0.02324,           0.05869,

           0.24516,           0.22898,          -0.06037,           0.13023,

           0.00331,          -0.03576,

           0.06464,           0.00089,

           0.03103,           0.05078,

          -0.01133,           0.01520,

           0.14654,           0.07538,           0.25112,          -0.24473,
          -0.17928,          -0.53366,

          -0.06367,           0.20458,          -0.42985,           0.14848,
          -0.35317,          -0.61364,

           0.00325,          -0.08617,          -0.23180,           0.08576,
           0.22995,           0.43569,

           1.92114,           2.89319,          -5.55637,           4.70329,
          -4.91411,          -5.45521,

           0.02607,           0.04468,

          -0.05439,           0.13476,          -0.07329,          -0.00985,

          -0.00278,           0.05377,

           0.07474,          -0.09658,           0.29818,           0.20422,
          -0.29074,           0.44962,

          -0.15411,          -0.04287,           0.29907,          -1.02948,
           3.62183,           0.84869,

          -0.08157,           0.02754,

          -0.03610,          -0.12909,           0.09195,          -0.04424,

          -0.08845,           0.09347,

          -0.27140,           0.08185,

           0.24783,           0.19543,          -0.25154,           0.41371,

          -0.00046,           0.01524,

           0.04127,           0.06663,

           0.43023,           0.11790,

           0.04427,           0.05329,

           0.00411,          -0.71074,

          -0.07111,          -0.09824,

           0.01264,          -0.02075,

          -0.00068,          -0.01678,

           0.01186,           0.00181,

           0.00302,          -0.21963,

          -0.06412,          -0.10155,          -0.36856,           0.20240,
           0.32282,           0.65133,

          -0.07178,          -0.01876,           0.13399,          -0.39522,
           1.28413,           0.33790,

           0.05040,          -0.01679,

          -0.00794,           0.01117,

           0.02630,           0.00575,

          -0.07113,          -0.11414,           0.16422,          -0.23060,
           0.35198,           0.05409,

           1.11486,          -0.35833,           0.87313,           1.66304,
          -1.28434,           0.72067,

           0.01400,           0.00971,

           0.21044,          -0.87385,           3.20820,           0.67957,

          -0.01716,           0.00111,

          -0.13776,          -0.02650,

          -0.06778,           0.00908,           0.00616,          -0.04520,

          -0.31625,          -0.61913,

           0.36184,           0.09373,

           0.00984,          -0.03292,

           0.01944,           0.00530,

           0.00243,          -0.00123,

           0.01589,           0.02223,

          -0.02992,          -0.01086,

        4356.04809,       -5859.86328,        2918.27323,       -4796.67315,
         510.24783,       -1220.02233,         127.48927,         250.10654,
        3250.43013,        -904.27614,       -5667.40042,      -22634.00922,
      -82471.79425,       18615.92342,

           0.01941,           0.00372,

           0.01830,          -0.00652,

          -0.02548,          -0.01157,

           0.00635,           0.02343,

          -0.00980,           0.00961,

           0.12137,           0.10068,           0.16676,          -0.07257,

          -0.07267,          -0.13761,           0.25305,          -0.28112,

          -0.07974,           0.07866,

          -0.41726,           0.49991,          -1.55187,          -1.14150,
           1.54754,          -2.35141,

          -0.00862,           0.00808,

           0.00218,          -0.03726,

           0.06914,          -0.08986,

          -0.00501,           2.09577,

          -0.01409,          -0.01842,

           0.04138,           0.05961,

          -0.12276,          -0.04929,

          -0.03963,          -0.06080,

          -0.27697,          -0.09329,

          -0.01011,           0.00295,

          -0.01374,           0.01328,

          -0.00171,           0.25815,

           0.01446,           0.00782,

           0.17909,          -0.04683,

           0.03765,          -0.04990,

           0.00036,           0.00528,

           0.05508,          -0.01369,

          -0.11751,          -0.10624,          -0.14448,           0.10522,

          -0.00884,           0.43006,

           0.01162,           0.01659,

          -0.00076,           0.10143,

           0.55779,           0.05510,           0.12350,          -0.34025,

           0.01320,           0.92985,
          -0.00026,          -0.03426,

           0.01305,           0.00041,

           0.13187,          -0.11903,

           0.00058,           0.09877,

         -33.10230,         -41.96782,        -268.28908,         174.29259,
         731.20089,        1508.07639,        5223.99114,       -3008.08849,
       -3909.34957,       -9646.69156,

           0.02988,           0.03182,

           0.07149,           0.04513,

          -0.02356,          -0.01641,

          -0.03188,          -0.03711,           0.15084,          -0.22436,
           0.61987,           0.25706,

           0.02425,           0.01200,

          -0.05543,          -0.14435,          -0.53398,           0.10997,

           0.00465,          -0.01893,

           0.01260,          -0.01314,

           0.00650,          -0.05499,

          -0.06804,           0.01608,

           0.02134,           0.04160,

           0.00636,           0.01293,

          -0.03470,          -0.02697,

          -0.11323,           0.02409,

          -0.02618,           0.00827,

           0.01879,           0.16838,           0.08978,           0.01934,

          -0.23564,           0.05565,

           0.03686,           0.02644,

          -0.02471,           0.00558,

        -140.22669,        -120.40692,        -501.88143,         434.05868,
        1044.54998,        1162.72084,        1527.78437,        -882.37371,

          -0.00768,           0.02213,

          -0.04090,           0.16718,

          -0.05923,          -0.12595,

           0.01154,          -0.00025,

          -0.00776,          -0.01653,

          -0.01213,          -0.02773,

           0.00344,           0.02180,

          -0.02558,          -0.05682,

          -0.00490,           0.01050,

          38.75496,         -78.17502,        -189.90700,        -136.33371,
        -249.94062,         319.76423,         205.73478,         272.64549,

          -0.01132,          -0.01071,          -0.04607,          -0.00390,

           0.02903,          -0.02070,

           0.01326,          -0.00901,

          35.38435,           7.45358,          31.08987,         -70.52685,
         -92.13879,         -51.58876,         -51.80016,          48.98102,

          -0.00124,          -0.01159,

           0.47335,          13.71886,          23.71637,           5.55804,
          10.06850,         -25.65292,         -11.85300,         -10.20802,

          -4.72861,           1.27151,          -0.47322,           7.46754,
           6.99528,           1.79089,           2.05336,          -2.90866,

          -1.97528,           0.72236,          -0.25084,           1.90269,
           0.72127,           0.41354,

          -0.30286,          -0.53125,          -0.50883,          -0.01200,
          -0.08301,           0.18083,

          -0.04286,          -0.10963,          -0.04544,          -0.01645,

          -0.00013,          -0.00986,

  };
  static final double mertabb[] = {
          68.33369,         422.77623,       -2057.26405,       -2522.29068,

          -0.00030,          -0.00009,

           0.02400,          -0.06471,           0.02074,          -0.00904,
           0.00044,           0.00261,

          -0.00174,          -0.00088,          -0.00027,           0.00003,

           0.00005,          -0.00004,

          -0.00036,           0.00200,

           0.01432,           0.01199,

           0.00006,          -0.00004,

           0.00236,           0.00803,           0.01235,           0.00406,
          -0.03253,           0.00179,

          -0.00243,           0.00132,          -0.00352,           0.00011,
          -0.00146,          -0.01154,

           0.00824,          -0.01195,          -0.01829,          -0.00465,
           0.12540,           0.09997,

           0.00400,           0.00288,          -0.02848,           0.01094,
          -0.02273,          -0.07051,

           0.01305,           0.01078,

          -0.00119,           0.00136,          -0.00107,          -0.00066,

           0.00097,          -0.00315,

           0.00120,           0.00430,          -0.00710,          -0.00157,
           0.06052,          -0.04777,

           0.00192,          -0.00229,          -0.02077,           0.00647,
           0.06907,           0.07644,

          -0.00717,           0.00451,

           0.00052,          -0.00262,           0.00345,           0.00039,

          -0.00674,           0.00346,

          -0.02880,           0.00807,

           0.00054,           0.00206,          -0.01745,           0.00517,

          -0.00044,           0.00049,

           0.01749,           0.01230,

           0.01703,           0.01563,

           0.00934,           0.02372,

           0.01610,          -0.01136,

           0.00186,          -0.00503,

           0.00082,          -0.00673,

           0.00170,          -0.00539,

           0.00042,           0.00037,

           0.00415,          -0.00430,

           0.00258,          -0.00914,          -0.01761,          -0.00251,
           0.15909,           0.13276,

           0.02436,          -0.00791,           0.00491,           0.03890,
          -0.02982,           0.05645,

          -0.00003,           0.00427,

          -0.00363,           0.00221,

           0.00077,           0.00130,

           0.00131,          -0.00071,           0.00796,           0.00453,
           0.01186,           0.01631,

           0.12949,          -0.02546,           0.03613,           0.32854,
          -0.43001,           0.01417,

           0.00034,           0.00095,

          -0.03268,           0.04034,           0.11407,           0.15049,

          -0.00079,          -0.00052,

          -0.04009,           0.00988,

          -0.00259,          -0.00085,           0.00221,          -0.00133,

           0.00003,          -0.01733,

           0.01055,           0.01976,

           0.00222,           0.00085,

           0.00089,           0.00087,

           0.00014,           0.00001,

           0.00145,           0.00802,

           0.00122,           0.00068,

         947.79367,       -1654.39690,         542.00864,       -1281.09901,
          90.02068,        -318.36115,         -87.67090,          92.91960,
         376.98232,        -419.10705,        5094.60412,        2476.97098,
      -18160.57888,       16010.48165,

           0.00621,          -0.00128,

           0.00186,          -0.00153,

          -0.00790,           0.00011,

          -0.00032,           0.00165,

          -0.00277,           0.00539,

           0.00552,           0.00682,           0.01086,          -0.00978,

          -0.02292,          -0.01300,           0.02940,          -0.04427,

          -0.02051,           0.04860,

          -0.05020,           0.29089,          -0.50763,          -0.04900,
           0.11177,          -0.41357,

          -0.00222,           0.00504,

          -0.00006,          -0.00459,

          -0.00175,          -0.02691,

           0.05921,           0.18938,

          -0.00181,          -0.00154,

           0.00322,           0.00586,

          -0.01098,          -0.00520,

          -0.00861,          -0.01342,

          -0.02694,          -0.00706,

          -0.00103,           0.00012,

          -0.00284,           0.00797,

           0.00743,           0.02523,

           0.00872,           0.00096,

           0.03155,          -0.01644,

           0.00414,          -0.00583,

           0.00029,           0.00066,

           0.00935,          -0.00619,

          -0.02498,          -0.01600,          -0.03545,           0.07623,

           0.01649,           0.06498,

           0.00148,           0.00209,

           0.00621,           0.02014,

           0.17407,          -0.05022,          -0.03485,          -0.17012,

           0.06164,           0.20059,

          -0.00804,          -0.01475,

           0.00296,          -0.00068,

           0.01880,          -0.03797,

           0.00608,           0.02270,

           5.89651,          -6.62562,         -37.41057,         -10.51542,
         -47.22373,          95.76862,         494.45951,          -5.37252,
       -3991.04809,       -2886.97750,

           0.01232,           0.00487,

           0.03163,           0.00561,

          -0.01847,          -0.00207,

          -0.10138,           0.01430,          -0.04269,          -0.22338,
           0.24955,          -0.02066,

           0.01119,          -0.00186,

           0.03416,           0.01805,          -0.12498,           0.10385,

          -0.00210,          -0.01011,

           0.00346,          -0.00682,

          -0.00683,          -0.02227,

          -0.01649,           0.01259,

           0.01392,           0.01174,

           0.00440,           0.00351,

          -0.02871,          -0.00375,

          -0.03170,           0.02246,

          -0.00833,           0.00596,
           0.04081,           0.06666,           0.05400,          -0.02387,

          -0.07852,           0.05781,

           0.01881,           0.00324,

          -0.00868,           0.00606,

          -6.52157,         -19.74446,         -72.46009,          43.12366,
         321.78233,         215.45201,         452.61804,       -1025.05619,

           0.00119,           0.01169,

           0.02239,           0.09003,

          -0.05329,          -0.03974,

           0.00688,          -0.00421,

          -0.00676,          -0.00515,

          -0.01171,          -0.00952,

           0.01337,           0.01270,

          -0.02791,          -0.02184,

           0.00058,           0.00679,

           8.42102,         -11.87757,         -49.07247,         -25.34584,
         -43.54829,         161.26509,         261.70993,          56.25777,

           0.00568,           0.00871,          -0.02656,           0.01582,

           0.00875,          -0.02114,

           0.00464,          -0.01075,

           9.08966,           1.37810,           3.44548,         -27.44651,
         -59.62749,          -0.73611,          -0.77613,          65.72607,

          -0.00664,          -0.00723,

           1.04214,           4.78920,          11.67397,          -1.84524,
          -4.16685,         -19.14211,         -16.14483,           3.02496,

          -1.98140,           1.16261,           1.81526,           4.21224,
           5.59020,          -2.55741,          -1.54151,          -3.85817,

          -1.08723,           1.23372,           1.12378,           1.51554,
           0.88937,          -0.57631,

          -0.50549,          -0.25617,          -0.37618,           0.42163,
           0.18902,           0.19575,

          -0.15402,          -0.04062,          -0.04017,           0.05717,

          -0.01665,          -0.00199,

  };
  static final double mertabr[] = {
          -8.30490,         -11.68232,          86.54880,        4361.05018,

           0.00002,          -0.00001,

          -0.01102,           0.00410,           0.00007,          -0.00276,
           0.00117,           0.00082,

           0.00049,           0.00007,           0.00003,          -0.00001,

           0.00012,           0.00005,

          -0.00186,          -0.00534,

          -0.03301,           0.01808,

           0.00008,           0.00005,

          -0.00394,           0.00202,           0.02362,          -0.00359,
           0.00638,          -0.06767,

           0.00422,          -0.00493,           0.00660,           0.00513,
          -0.00417,           0.00708,

           0.05849,          -0.00213,          -0.07647,          -0.16162,
          -0.30551,           0.13856,

          -0.02789,           0.01811,          -0.04155,          -0.06229,
           0.05729,          -0.03694,

          -0.03087,           0.01610,

          -0.00297,          -0.00167,           0.00041,          -0.00157,

          -0.00115,           0.00058,

           0.00796,           0.00436,          -0.01393,           0.02921,
          -0.05902,          -0.02363,

           0.00459,          -0.01512,           0.10038,           0.02964,
          -0.08369,           0.34570,

          -0.00749,          -0.02653,

           0.01361,          -0.00326,           0.00406,           0.00952,

          -0.00594,          -0.00829,

          -0.02763,          -0.09933,

          -0.04143,           0.05152,          -0.08436,          -0.05294,

          -0.00329,          -0.00016,

          -0.04340,           0.02566,

          -0.03027,           0.10904,

           0.03665,          -0.03070,

           0.23525,           0.00182,

           0.03092,          -0.02212,

           0.01255,           0.00777,

          -0.01025,           0.00042,

          -0.00065,           0.00440,

           0.08688,           0.00136,

           0.05700,          -0.03616,          -0.11272,          -0.20838,
          -0.37048,           0.18314,

           0.00717,          -0.02911,           0.15848,           0.05266,
          -0.13451,           0.51639,

           0.00688,           0.02029,

           0.00596,           0.00423,

          -0.00253,           0.01196,

           0.05264,          -0.03301,           0.10669,           0.07558,
          -0.02461,           0.16282,

          -0.18481,          -0.57118,           0.85303,          -0.44876,
           0.37090,           0.65915,

          -0.00458,           0.00660,

           0.41186,           0.09829,          -0.31999,           1.51149,

          -0.00052,          -0.00809,

           0.01384,          -0.07114,

          -0.00435,          -0.03237,           0.02162,           0.00294,

           0.29742,          -0.15430,

          -0.04508,           0.17436,

           0.01577,           0.00485,

          -0.00258,           0.00946,

           0.00061,           0.00119,

           0.01095,          -0.00788,

           0.00530,          -0.01478,

        2885.06380,        2152.76256,        2361.91098,        1442.28586,
         602.45147,         251.18991,        -121.68155,          71.20167,
         404.94753,        1607.37580,       11211.04090,       -2905.37340,
       -9066.27933,      -40747.62807,

          -0.00189,           0.00957,

           0.00332,           0.00907,

           0.00574,          -0.01255,

          -0.01134,           0.00291,

          -0.00666,          -0.00615,

          -0.04947,           0.06182,           0.03965,           0.08091,

           0.06846,          -0.03612,           0.13966,           0.12543,

          -0.05494,          -0.05043,

          -0.24454,          -0.20507,           0.56201,          -0.75997,
           1.15728,           0.76203,
          -0.00559,          -0.00536,

           0.01872,           0.00104,

           0.03044,           0.02504,

          -1.07241,          -0.00288,

           0.00950,          -0.00760,

          -0.03211,           0.02261,

           0.02678,          -0.06868,

           0.03008,          -0.02062,

           0.04997,          -0.15164,

          -0.00176,          -0.00580,

          -0.00730,          -0.00676,

          -0.13906,          -0.00089,

          -0.00362,           0.00817,

           0.02021,           0.07719,

           0.02788,           0.02061,

          -0.00274,           0.00016,

           0.00566,           0.02293,

           0.04691,          -0.05005,          -0.05095,          -0.06225,

          -0.19770,          -0.00456,

          -0.00848,           0.00595,

          -0.04506,          -0.00172,

          -0.01960,           0.22971,           0.14459,           0.04362,

          -0.40199,           0.00386,

           0.01442,          -0.00088,

          -0.00020,           0.00544,

           0.04768,           0.05222,

          -0.04069,          -0.00003,

          15.71084,         -12.28846,         -66.23443,        -109.83758,
        -586.31996,         311.09606,        1070.75040,        2094.34080,
        3839.04103,       -1797.34193,

          -0.01216,           0.01244,

          -0.01666,           0.02627,

           0.00687,          -0.01291,

           0.00939,          -0.01905,           0.09401,           0.05027,
          -0.09398,           0.23942,

          -0.00379,           0.00834,

           0.05632,          -0.01907,          -0.04654,          -0.21243,

           0.00255,           0.00179,

           0.00540,           0.00497,

           0.01427,           0.00243,

          -0.00697,          -0.02792,

          -0.01524,           0.00810,

          -0.00461,           0.00238,

           0.00899,          -0.01515,

          -0.01011,          -0.04390,

          -0.00447,          -0.00992,

          -0.06110,           0.00975,          -0.00261,           0.03415,

          -0.02336,          -0.08776,

          -0.00883,           0.01346,

          -0.00229,          -0.00895,

          42.18049,         -48.21316,        -148.61588,        -171.57236,
        -414.27195,         343.09118,         394.59044,         511.79914,

          -0.00911,          -0.00220,

          -0.06315,          -0.00988,

           0.04357,          -0.02389,

           0.00004,           0.00232,

           0.00581,          -0.00317,

           0.00948,          -0.00497,

          -0.00734,           0.00300,

           0.01883,          -0.01055,

          -0.00365,          -0.00126,

          24.18074,          12.28004,          43.18187,         -58.69806,
        -102.40566,         -79.48349,         -74.81060,          89.71332,

           0.00241,          -0.00135,          -0.00136,          -0.01617,

           0.00818,           0.00873,

           0.00368,           0.00383,

          -2.25893,          10.18542,          20.73104,           9.07389,
          13.73458,         -29.10491,         -20.62071,         -10.63404,

           0.00382,          -0.00143,

          -3.77385,           0.12725,          -1.30842,           6.75795,
           7.94463,           1.79092,           1.24458,          -4.73211,

          -0.36978,          -1.25710,          -2.06373,           0.06194,
          -0.00509,           2.08851,           1.07491,           0.04112,

          -0.28582,          -0.51413,          -0.53312,           0.11936,
           0.04447,           0.23945,

           0.12450,          -0.11821,          -0.06100,          -0.12924,
          -0.05193,           0.02219,

           0.01977,          -0.02933,          -0.00771,          -0.01077,

           0.00109,          -0.00273,

  };

  static final byte[] merargs={
    (byte)0,  (byte)3,
    (byte)3,  (byte)1,  (byte)1,(byte)-10,  (byte)3, (byte)11,  (byte)4,(byte)0,
    (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)2,
    (byte)3,  (byte)5,  (byte)1,(byte)-14,  (byte)2,  (byte)2,  (byte)3,(byte)1,
    (byte)3,  (byte)1,  (byte)1, (byte)-5,  (byte)2,  (byte)4,  (byte)3,(byte)0,
    (byte)1,  (byte)1,  (byte)6,  (byte)0,
    (byte)1,  (byte)2,  (byte)6,  (byte)0,
    (byte)3,  (byte)2,  (byte)1, (byte)-7,  (byte)2,  (byte)3,  (byte)3,(byte)0,
    (byte)1,  (byte)1,  (byte)5,  (byte)2,
    (byte)2,  (byte)1,  (byte)1, (byte)-4,  (byte)3,  (byte)2,
    (byte)1,  (byte)2,  (byte)5,  (byte)2,
    (byte)2,  (byte)2,  (byte)1, (byte)-5,  (byte)2,  (byte)2,
    (byte)1,  (byte)3,  (byte)5,  (byte)0,
    (byte)2,  (byte)4,  (byte)1,(byte)-10,  (byte)2,  (byte)1,
    (byte)2,  (byte)3,  (byte)1, (byte)-8,  (byte)2,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-3,  (byte)2,  (byte)2,
    (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)2,  (byte)2,
    (byte)1,  (byte)1,  (byte)3,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-7,  (byte)2,  (byte)1,
    (byte)2,  (byte)1,  (byte)1, (byte)-3,  (byte)3,  (byte)0,
    (byte)1,  (byte)1,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-4,  (byte)2,  (byte)1,
    (byte)2,  (byte)4,  (byte)1, (byte)-9,  (byte)2,  (byte)0,
    (byte)1,  (byte)2,  (byte)3,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)3,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-4,  (byte)2,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-1,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-6,  (byte)2,  (byte)0,
    (byte)1,  (byte)3,  (byte)3,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-7,  (byte)2,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)4,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-1,  (byte)3,  (byte)0,
    (byte)1,  (byte)2,  (byte)2,  (byte)2,
    (byte)2,  (byte)2,  (byte)1, (byte)-3,  (byte)2,  (byte)2,
    (byte)2,  (byte)4,  (byte)1, (byte)-8,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1,(byte)-10,  (byte)2,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-4,  (byte)5,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-3,  (byte)5,  (byte)2,
    (byte)2,  (byte)1,  (byte)1, (byte)-5,  (byte)2,  (byte)2,
    (byte)2,  (byte)1,  (byte)1, (byte)-5,  (byte)6,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)5,  (byte)1,
    (byte)3,  (byte)1,  (byte)1, (byte)-4,  (byte)5,  (byte)5,  (byte)6,(byte)0,
    (byte)1,  (byte)4,  (byte)3,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-3,  (byte)6,  (byte)1,
    (byte)2,  (byte)1,  (byte)1, (byte)-1,  (byte)5,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)6,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-1,  (byte)6,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)7,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-1,  (byte)7,  (byte)0,
    (byte)3,  (byte)4,  (byte)1,(byte)-14,  (byte)2,  (byte)2,  (byte)3,(byte)0,
    (byte)3,  (byte)1,  (byte)1,  (byte)2,  (byte)5, (byte)-5,  (byte)6,(byte)0,
    (byte)1,  (byte)1,  (byte)1,  (byte)6,
    (byte)3,  (byte)2,  (byte)1,(byte)-10,  (byte)3, (byte)11,  (byte)4,(byte)0,
    (byte)3,  (byte)1,  (byte)1, (byte)-2,  (byte)5,  (byte)5,  (byte)6,(byte)0,
    (byte)3,  (byte)6,  (byte)1,(byte)-14,  (byte)2,  (byte)2,  (byte)3,(byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)1,  (byte)6,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)2,  (byte)6,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)1,  (byte)5,  (byte)1,
    (byte)2,  (byte)2,  (byte)1, (byte)-4,  (byte)3,  (byte)1,
    (byte)2,  (byte)1,  (byte)1,  (byte)2,  (byte)5,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-5,  (byte)2,  (byte)2,
    (byte)2,  (byte)1,  (byte)1,  (byte)3,  (byte)5,  (byte)0,
    (byte)2,  (byte)5,  (byte)1,(byte)-10,  (byte)2,  (byte)0,
    (byte)1,  (byte)3,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-2,  (byte)2,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)1,  (byte)3,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-7,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-3,  (byte)3,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)1,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-4,  (byte)2,  (byte)0,
    (byte)2,  (byte)5,  (byte)1, (byte)-9,  (byte)2,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)2,  (byte)3,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-2,  (byte)3,  (byte)0,
    (byte)1,  (byte)4,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-1,  (byte)2,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-6,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-2,  (byte)4,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-1,  (byte)3,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)2,  (byte)2,  (byte)1,
    (byte)2,  (byte)3,  (byte)1, (byte)-3,  (byte)2,  (byte)0,
    (byte)2,  (byte)5,  (byte)1, (byte)-8,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-3,  (byte)5,  (byte)0,
    (byte)1,  (byte)5,  (byte)2,  (byte)1,
    (byte)2,  (byte)2,  (byte)1, (byte)-2,  (byte)5,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)4,  (byte)3,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-3,  (byte)6,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-1,  (byte)5,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-2,  (byte)6,  (byte)0,
    (byte)1,  (byte)2,  (byte)1,  (byte)4,
    (byte)2,  (byte)2,  (byte)1,  (byte)1,  (byte)5,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-4,  (byte)3,  (byte)0,
    (byte)2,  (byte)2,  (byte)1,  (byte)2,  (byte)5,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-5,  (byte)2,  (byte)2,
    (byte)2,  (byte)1,  (byte)1,  (byte)3,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-2,  (byte)2,  (byte)1,
    (byte)2,  (byte)3,  (byte)1, (byte)-3,  (byte)3,  (byte)0,
    (byte)2,  (byte)2,  (byte)1,  (byte)1,  (byte)2,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-4,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-2,  (byte)3,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-1,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-1,  (byte)3,  (byte)0,
    (byte)2,  (byte)2,  (byte)1,  (byte)2,  (byte)2,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-3,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-3,  (byte)5,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)5,  (byte)2,  (byte)1,
    (byte)2,  (byte)3,  (byte)1, (byte)-2,  (byte)5,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-1,  (byte)5,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-2,  (byte)6,  (byte)0,
    (byte)1,  (byte)3,  (byte)1,  (byte)3,
    (byte)2,  (byte)4,  (byte)1, (byte)-4,  (byte)3,  (byte)0,
    (byte)2,  (byte)5,  (byte)1, (byte)-5,  (byte)2,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-2,  (byte)2,  (byte)0,
    (byte)2,  (byte)5,  (byte)1, (byte)-4,  (byte)2,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-2,  (byte)3,  (byte)0,
    (byte)2,  (byte)5,  (byte)1, (byte)-3,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1,  (byte)5,  (byte)2,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-2,  (byte)5,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-1,  (byte)5,  (byte)0,
    (byte)1,  (byte)4,  (byte)1,  (byte)3,
    (byte)2,  (byte)6,  (byte)1, (byte)-5,  (byte)2,  (byte)1,
    (byte)2,  (byte)5,  (byte)1, (byte)-2,  (byte)2,  (byte)0,
    (byte)2,  (byte)5,  (byte)1, (byte)-2,  (byte)5,  (byte)0,
    (byte)1,  (byte)5,  (byte)1,  (byte)3,
    (byte)2,  (byte)7,  (byte)1, (byte)-5,  (byte)2,  (byte)0,
    (byte)1,  (byte)6,  (byte)1,  (byte)3,
    (byte)1,  (byte)7,  (byte)1,  (byte)3,
    (byte)1,  (byte)8,  (byte)1,  (byte)2,
    (byte)1,  (byte)9,  (byte)1,  (byte)2,
    (byte)1, (byte)10,  (byte)1,  (byte)1,
    (byte)1, (byte)11,  (byte)1,  (byte)0,
   (byte)-1
  };
  /* Total terms = 130, small = 128 */
  static Plantbl mer404=new Plantbl(
                            new short[]{11, 14, 10, 11,  4,  5,  2,  0,  0},
                            (short)6,merargs,mertabl,mertabb,mertabr,
                            3.8709830979999998e-01);
}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class SwemptabNep {
  /*
  First date in file = 625296.50
  Number of records = 16731.0
  Days per record = 131.0
        Julian Years      Lon    Lat    Rad
   -3000.0 to  -2499.7:   0.44   0.30   0.50
   -2499.7 to  -1999.7:   0.39   0.20   0.39
   -1999.7 to  -1499.7:   0.31   0.15   0.31
   -1499.7 to   -999.8:   0.32   0.19   0.36
    -999.8 to   -499.8:   0.29   0.15   0.29
    -499.8 to      0.2:   0.31   0.14   0.27
       0.2 to    500.2:   0.28   0.14   0.27
     500.2 to   1000.1:   0.34   0.15   0.39
    1000.1 to   1500.1:   0.31   0.16   0.31
    1500.1 to   2000.1:   0.33   0.16   0.29
    2000.1 to   2500.0:   0.38   0.21   0.36
    2500.0 to   3000.0:   0.43   0.25   0.46
    3000.0 to   3000.4:  0.122  0.071  0.260
  */
  static final double neptabl[] = {
       -1376.86480,         730.38970,    78655362.50948,     1095691.38676,

        -196.19023,        2086.77782,

        -122.04650,        -276.81592,

         184.56164,        -148.08924,

           3.39142,         -14.75027,

          -9.22741,           0.87688,

          -0.13903,          -0.44707,

          -0.17668,          -0.36299,

          -0.12682,          -0.26636,

          -0.51426,          -0.24667,

          -0.04965,          -0.03177,

           0.05050,          -0.00249,

          -0.80362,          -0.07363,          -0.15436,          -0.07180,

           2.45034,          -3.50145,           0.86698,           0.09777,

           7.72386,           7.16565,           2.10273,           8.86682,

           2.44705,          77.90155,

           0.28323,         -11.87157,         -13.64083,         252.70556,

          -4.94214,          -6.17988,        -305.60504,          51.23962,
       -2759.81719,        2476.20912,

          12.65762,          13.31543,

           0.36996,          -0.19077,           0.67363,           0.36737,

           0.02312,           0.02216,

           0.09953,           0.04777,

          -0.00572,          -0.02772,

          -0.02478,          -0.21920,

          -0.15289,          -1.50784,

          -0.17822,           0.34638,          -0.70473,          -8.61559,

          -2.65756,           1.25632,

          -0.31453,          -1.40348,          -4.02571,          -1.50467,
         -69.62308,           3.21315,

           0.69973,           0.08832,

          -0.00551,          -0.04964,

          -0.02264,          -0.34881,

           0.00762,          -1.85072,

           0.01407,          -0.30457,

          -0.09851,          -0.02372,

          -0.07729,          -0.11602,          -0.75995,          -0.71884,

          -0.08585,          -0.30406,           0.45818,           0.14921,

          -0.01033,          -0.11776,

           0.00640,          -0.57717,

          -0.01014,          -0.01357,          -0.00544,          -0.02168,

           0.40468,           0.28195,           0.00668,           0.14448,

           0.01245,          -0.08956,

          -0.26283,           0.01864,          -0.00641,          18.55347,

           0.01460,           0.08284,

          -0.04785,           0.11360,

          -0.33861,           0.01327,          -0.06392,          -0.18758,

           0.05449,          -0.05583,

          -0.00435,          -0.09869,

          -0.00286,          -0.04613,

          -0.00395,          -0.14564,

          -0.01385,          -0.01762,

           0.21160,          -0.61631,          -0.52100,          -0.04583,

           0.32812,           0.32138,

           0.04749,          -0.05724,

           0.11239,           0.13216,

          -0.01203,           0.40084,          -0.05207,          34.07903,

          -0.21457,          -0.34938,          -0.04594,           0.11198,

          -0.30662,          -0.20776,          -0.01076,          -0.10959,

           0.10891,          -0.10304,

          -0.28141,           0.25061,          -0.20293,           0.79930,

  };
  static final double neptabb[] = {
        -391.05987,        -243.95958,         -23.83558,          58.13857,

           5.04859,          -3.93183,

         -14.21914,           7.14247,

         -12.09415,          -9.70132,

           1.04307,           0.47323,

          -0.07504,           0.70575,

          -0.05239,           0.00482,

          -0.02916,           0.00877,

          -0.00528,          -0.00286,

           0.00028,          -0.00228,

          -0.00056,          -0.00149,

           0.00049,           0.00047,

          -0.18765,          -0.59571,           0.03742,          -0.14653,

           2.30535,           0.65092,           0.42216,           0.24521,

          -2.86932,           2.37808,          -0.58456,           0.27446,

          -1.12264,          -2.04413,

         -11.71318,          -1.41554,         -23.30671,         -24.70499,

           8.82738,          85.64657,         -90.02223,          22.42604,
       -4749.41359,       -4244.46820,

          25.20811,         -18.51469,

          -1.19892,          -0.61067,           0.67734,          -1.08912,

          -0.01607,           0.00626,

          -0.00008,           0.00126,

          -0.00330,          -0.00078,

          -0.01503,           0.00758,

          -0.13208,          -0.00218,

          -0.04522,           0.20297,          -0.94708,          -0.77897,

          -2.74075,          -3.01122,

          -1.03394,           0.00886,           1.55485,          -4.68416,
          -0.13244,         -57.26983,

           0.05589,          -0.55396,

          -0.00130,           0.00526,

          -0.01028,           0.02086,

           0.01334,           0.00699,

           0.08565,           0.02020,

           0.01001,          -0.08402,

           0.08558,          -0.04488,           0.57268,          -0.59574,

           0.00807,           0.00492,           0.21993,          -0.18949,

          -0.00396,           0.00735,

           0.00487,           0.00230,

           0.00699,          -0.00473,           0.01406,          -0.00139,

           0.00738,           0.00099,           0.00161,           0.00019,

          -0.00067,          -0.00047,

           0.00572,          -0.00486,          -0.00842,           0.00322,

           0.00018,          -0.00109,

          -0.00272,           0.00112,

          -0.00041,           0.00763,           0.00211,           0.00118,

          -0.46842,          -0.17877,

           0.00209,          -0.00179,

           0.00090,          -0.00075,

           0.00618,           0.00610,

           0.00015,           0.00032,

          -0.00123,           0.00026,           0.00332,           0.00135,

           0.39130,          -0.34727,

           0.00015,          -0.00027,

          -0.00026,          -0.00052,

           0.00162,           0.00913,          -0.00697,           0.00308,

          -0.00333,          -0.00258,          -0.00117,           0.00035,

           0.00766,           0.00194,           0.00135,           0.00067,

          -0.41171,           0.24241,

           0.00106,           0.00025,           0.00013,          -0.00019,

  };
  static final double neptabr[] = {
        -767.68936,        -460.59576,         -52.41861,        -273.85897,

          59.52489,           1.85006,

         -39.64750,          23.63348,

         -34.60399,         -23.41681,

           2.74937,           1.55389,

           0.20343,           2.15502,

          -0.12846,           0.07199,

          -0.07555,           0.05582,

          -0.04354,           0.01546,

          -0.03931,           0.07623,

          -0.00491,           0.00661,

           0.00322,           0.01540,

          -0.06741,          -0.35343,           0.00469,          -0.08073,

           1.94975,           0.66376,           0.06137,           0.31426,

          -2.93841,           4.27732,          -4.00342,           1.11157,

         -36.87785,           1.24960,

           4.69573,           2.15164,        -114.24899,          -6.69320,

          12.99919,          -9.47795,         -21.82350,        -156.88624,
       -1237.19769,       -1379.88864,

           6.54369,          -6.20873,

          -0.14163,          -0.32700,           0.17937,          -0.34864,

           0.01393,          -0.01286,

           0.02876,          -0.05767,

           0.02210,          -0.00128,

           0.16495,          -0.01242,

           1.15915,          -0.10365,

          -0.33224,          -0.10045,           6.83719,          -0.27499,

          -0.31284,          -0.94332,

           1.63704,          -0.33318,           1.48134,          -1.32257,
           0.96498,          -8.31047,

          -0.00402,          -0.09441,

           0.04292,          -0.00444,

           0.30325,          -0.02012,

           1.67999,           0.00353,

           0.00467,           0.03556,

           0.01393,          -0.01229,

           0.01188,          -0.01390,           0.04615,          -0.03509,

           0.32423,          -0.12491,           0.13682,           0.15131,

           0.11221,          -0.01201,

           0.57239,           0.00093,

           0.02068,          -0.01162,           0.00647,          -0.00325,

           0.27010,          -0.42993,           0.14314,          -0.01353,

          -0.08757,          -0.00699,

           0.00199,           0.31873,          18.80329,           0.01681,

           0.08009,          -0.00998,

          -0.14421,          -0.15912,

           0.37208,           0.49744,           0.35144,           0.06582,

          -0.11501,          -0.14037,

           0.10352,          -0.00768,

           0.04826,          -0.00423,

           0.19850,           0.00310,

          -0.01780,           0.01350,

          -0.61106,          -0.20525,          -0.04388,           0.52143,

           0.19300,          -0.21446,

          -0.05749,          -0.04776,

           0.12877,          -0.10908,

           0.39821,           0.00627,          34.03956,           0.04392,

          -0.34455,           0.22015,           0.11743,           0.04638,

           0.20723,          -0.30447,           0.10976,          -0.01008,

          -0.20778,          -0.21822,

           0.24939,           0.27976,           0.79790,           0.20200,

  };

  static byte nepargs[] = {
  (byte)0,  (byte)3,
  (byte)2,  (byte)1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)3,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)3,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-8,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-6,  (byte)7,  (byte)6,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-5,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-4,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-2,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-9,  (byte)8,  (byte)1,
  (byte)2,  (byte)4,  (byte)7, (byte)-7,  (byte)8,  (byte)1,
  (byte)2,  (byte)3,  (byte)7, (byte)-5,  (byte)8,  (byte)1,
  (byte)2,  (byte)2,  (byte)7, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)7, (byte)-1,  (byte)8,  (byte)1,
  (byte)1,  (byte)1,  (byte)8,  (byte)2,
  (byte)2,  (byte)1,  (byte)7, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-5,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)6, (byte)-6,  (byte)7,  (byte)5,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-5,  (byte)7,  (byte)3,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-8,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-2,  (byte)8,  (byte)1,
  (byte)1,  (byte)1,  (byte)7,  (byte)0,
  (byte)1,  (byte)2,  (byte)8,  (byte)2,
  (byte)2,  (byte)1,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)1,  (byte)3,  (byte)8,  (byte)1,
  (byte)2,  (byte)1,  (byte)6, (byte)-2,  (byte)8,  (byte)1,
  (byte)2,  (byte)5,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)1,  (byte)4,  (byte)8,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-1,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)6,  (byte)1,  (byte)7, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-1,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)6, (byte)-1,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)1,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-5,  (byte)8,  (byte)1,
  (byte)1,  (byte)1,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-1,  (byte)8,  (byte)1,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-5,  (byte)6, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7,  (byte)5,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)7,  (byte)1,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)1,  (byte)8,  (byte)1,
  (byte)1,  (byte)1,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-1,  (byte)8,  (byte)1,
 (byte)-1
  };
  /* Total terms = 59, small = 58 */
  static Plantbl nep404 = new Plantbl(
                               new short[]{0,  0,  0,  0,  3,  8,  7,  9,  0},
                               (short)3,
                               nepargs,
                               neptabl,
                               neptabb,
                               neptabr,
                               3.0110386869399999e+01
  );
}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class SwemptabPlu {
  /*
  First date in file = 625296.50
  Number of records = 16731.0
  Days per record = 131.0
        Julian Years      Lon    Lat    Rad
   -3000.0 to  -2499.7:   1.17   0.90   0.83
   -2499.7 to  -1999.7:   0.57   0.51   0.58
   -1999.7 to  -1499.7:   0.63   0.39   0.40
   -1499.7 to   -999.8:   0.40   0.45   0.41
    -999.8 to   -499.8:   0.42   0.22   0.30
    -499.8 to      0.2:   0.41   0.24   0.35
       0.2 to    500.2:   0.58   0.24   0.26
     500.2 to   1000.1:   0.47   0.35   0.33
    1000.1 to   1500.1:   0.43   0.31   0.28
    1500.1 to   2000.1:   0.37   0.40   0.35
    2000.1 to   2500.0:   0.46   0.35   0.39
    2500.0 to   3000.0:   1.09   0.70   0.46
    3000.0 to   3000.4:  0.871  0.395  0.051
  */
  static final double plutabl[] = {
    74986469.33577,   100898343.73690,    48199471.54076,     9520076.03177,
      690431.67340,     -427355.12716,    52266623.77862,      860190.70714,

         -21.08511,        -143.39295,

        -126.71124,          48.18528,

         -88.74508,          40.50942,

          51.29367,         -10.24075,

           0.63094,          32.03258,

        -410.00781,         399.90234,        -116.54319,          51.50329,

         116.84565,         687.76781,         -13.38605,         182.70107,

       -1668.12226,       -5162.22648,        -585.68297,       -2247.56041,
         -20.95875,        -193.13703,

         -57.12097,         -10.35058,

       -1778.01442,       -6463.73779,        -657.86093,       -2713.44436,
         -41.32560,        -211.82042,

        -107.16513,         -36.58628,

    97929588.08231,   -33582903.63417,   143382679.31770,   -47411568.92345,
    79428827.73581,   -24658834.87499,    19861233.17488,    -5755585.62084,
     1995060.95931,     -693507.08147,      135176.31467,      109360.38672,
       -8188.00598,       -1680.95072,       71020.19608,      -70785.39049,

         -24.56034,         -20.34919,

        1618.45976,       -2079.48538,         635.62954,        -850.87068,
          44.95257,         -64.04459,

         -18.61475,          -1.77734,

           9.38079,           5.19958,

       17422.08783,       -4872.53852,       10985.76629,       -1137.68569,
        1771.28893,         288.93745,          40.22664,          37.90027,

           6.81361,         -32.65868,

          16.97268,          11.76152,

          29.33024,         -12.92289,

         -55.13187,         -14.73791,

           7.52474,        -102.05060,

         182.53144,         -20.18960,

  -490237997.49400,   486646248.63360,  -781277018.26430,   602300460.57290,
  -463787999.46420,   249529525.96100,  -123964746.86420,    31353019.97807,
   -13353800.92159,    -3463382.63269,      -35469.17654,    -1035343.45385,
       65076.64025,      -38181.61312,      -16473.33813,        3928.44674,

         188.60263,        1000.42530,

     -208376.39376,     -700566.62363,      114839.84613,     -342407.71113,
       39467.04812,      -14553.84849,

      581895.26100,     1012499.16715,      406317.22416,      310804.78515,
       43625.07033,       -4157.26545,

       -5930.13795,       -2070.62413,

        3348.17582,      -10871.23729,

      144609.18550,       60383.63650,       27912.02226,       15254.61228,

      -98561.37758,      -67442.28158,      -15573.63338,      -19931.99773,

       24323.06905,      -37473.32558,        2840.64042,       -8911.23694,

      -19636.31898,       71725.21946,      -12280.54554,       12251.00101,

       88626.52260,        5513.68450,       18506.41546,       -6513.87434,

      -83350.14621,       44300.00743,      -22075.37353,        3731.57531,

      -29167.76020,      -21642.67384,

    56602666.72177,   -22225578.01823,    50576897.80669,   -50319847.79086,
     5689259.25622,   -29585299.79697,    -4249711.27661,    -4490830.29568,
     -727678.08724,      366050.85631,       19183.62792,       55647.98226,

        1897.78091,       -1091.03988,         432.38158,        -138.62556,

         101.38743,          25.67379,

         320.20735,         362.16615,          85.06067,          54.02616,

           2.39460,          18.70004,

          -8.43353,           2.72100,

          -3.11205,          -3.06201,

         136.31503,         -28.33620,          48.68781,         -18.45285,
           1.15302,          -1.52360,

          -0.13706,          -0.37489,

           0.08750,          -0.14579,

          -0.07051,          -0.06518,

           0.30237,          -0.00448,

           4.83172,           6.83684,

     1752447.78043,     -945086.75857,     2340978.12819,    -1963675.42559,
     1254147.25257,    -1274861.91191,      279459.60237,     -263954.01378,
       11835.62290,      -16344.44434,        9119.98960,       -2390.44218,
         -23.67909,          86.73916,        -642.78635,       -1290.12208,

          -0.43345,          -1.85348,

           0.03094,          -0.01655,

           0.12380,           0.31834,

           5.54756,          -1.63109,           1.10598,          -0.17578,

           2.66994,          -2.17573,           0.97360,          -0.92226,

          -0.18533,          -0.39747,

           0.45809,          -0.65286,

           0.26129,           0.91922,

           0.81068,           0.11183,

           6.32182,          14.16786,           0.20872,           3.28489,

          -1.47458,          -2.11724,

           1.70020,          -1.99889,

           3.13003,           1.90638,

    -4483669.52795,     -446454.90158,    -6586256.67478,     -671890.16779,
    -3620444.55554,     -499672.41074,     -855998.32655,     -191073.94266,
      -73186.69110,      -22649.38582,       -2414.81729,       -1294.40542,
         436.80907,         125.48109,         -81.16877,         458.86508,

         -11.57414,         -26.39114,          -4.00801,          -5.01054,

         -18.17569,          20.86879,          -4.80965,           3.10535,

          -4.71122,           1.18169,

          74.75544,         649.21464,         -26.55060,         272.35592,
          -8.06982,          16.86110,

         -26.54868,          26.75711,

         -35.82910,          38.51063,

          22.22814,          19.38336,

          -6.30462,           0.90602,

           0.62856,          -0.34981,

          -0.10232,          -0.00939,

           0.04439,          -0.18875,

           0.16025,           0.11306,

          -0.06803,           0.06004,

      -91305.66728,      262370.61704,     -194633.44577,      304838.17733,
     -124505.90904,       94111.75602,      -22317.18255,        1575.23438,
         748.66316,        -349.78711,         166.64450,         -89.05045,
         120.76207,        -100.26715,

           3.13806,           3.71747,

          -1.44731,          -0.35235,

          -0.51660,          -1.50621,

           2.81310,          -3.93573,           1.20292,          -0.36412,

          -0.03340,          -0.00561,

          -5.29764,          26.02941,           1.91382,           3.30686,
          -3.35265,          -3.20868,

           0.05807,          -0.11885,

          -0.78588,           0.34807,          -0.19038,           0.11295,

          -0.03642,          -0.03794,

           0.00251,           0.03449,

          -0.08426,          -0.00310,

           0.05297,          -0.09278,

           0.10941,           0.00099,

     -228688.56632,      312567.73069,     -331458.31119,      328200.19460,
     -143760.57524,      104182.01134,      -17313.30132,       12591.15513,
        -440.32735,        -105.67674,         104.35854,        -852.84590,
           0.95527,           0.30212,         -54.63983,           4.06948,

           0.07545,          -0.13429,

          16.21005,          29.24658,           9.23410,          50.48867,
          30.55641,          12.76809,           0.11781,           0.70929,
          -0.04100,          13.60859,

           0.04976,          -0.02083,

           0.36279,           0.30130,          -0.02129,           0.09363,

          -0.07812,           0.01570,

          -0.06217,          -0.37181,

      -29348.55031,       43889.87672,      -35765.41577,       33855.90070,
      -10128.69894,        4535.32148,         281.75353,        -218.49194,
          -7.55224,         134.28640,           2.11319,          -2.13109,
          15.71244,          11.07183,

          -0.05406,          -0.23337,

          -1.28949,           1.34281,

           0.04212,          -0.02080,

           0.08109,           0.14820,

       -6010.46564,        3639.41780,       -5973.16000,        1381.66999,
       -1177.36865,        -501.06937,         166.14792,        -103.36431,
          14.92766,           4.12877,          -2.20893,          -6.32033,

          -0.29038,          -0.43172,

          -0.59341,           0.20477,          -0.13143,          -0.03150,

           0.10992,           0.01976,

          -0.00254,           0.02028,

          -0.30044,          -0.44658,          -0.03409,          -0.10758,

           0.08349,           0.06153,

          -0.06055,           0.18249,

          -1.15341,          -8.68699,          -0.11348,          -3.30688,

           1.08604,           1.04018,

          -0.46892,          -0.69765,           0.21504,           0.01968,

          -0.00455,          -0.01678,

           3.95643,          -3.17191,           3.95220,          -2.12670,
           0.99305,          -0.16651,

           0.34839,          -0.49162,

           0.85744,           0.20173,          -0.00975,           0.20225,

          -0.02627,          -0.02281,

          -0.18002,          -0.01803,

          -0.06144,          -0.21510,

           0.15935,          -0.01251,

          -0.21378,           0.44806,          -0.01174,           0.05779,

           0.07646,          -0.19656,          -0.04044,          -0.02521,

           0.02996,           0.06169,

           0.16698,          -0.04710,          -0.06506,          -0.02114,

           0.05500,           0.00276,

           0.08433,           0.03160,

           0.08193,           0.35773,           0.05454,           0.10718,

          -0.02823,          -0.00839,

           0.54078,           0.49347,           0.09609,           0.11825,

          -0.16092,          -0.11897,

           0.09059,           0.08254,

           0.16712,           0.05860,

          -0.09547,          -0.03206,

           0.03876,           0.04719,

          -0.02345,           0.02240,

          -0.00609,          -0.00649,

           0.03859,           0.00077,

           0.47819,           0.26196,           0.09780,           0.08104,

          -0.16919,           0.05042,

          -0.42652,           0.30810,

          -0.03409,          -0.51452,

          -0.23120,          -0.01380,

          -0.01157,          -0.00143,

          -0.00512,          -0.01628,

          -0.00189,           0.00183,

          -0.01427,          -0.02861,

           0.00618,          -0.00015,

           0.13087,           0.13870,

           0.15158,          -0.21056,

          -3.94829,          -1.06028,          -1.36602,           0.77954,

           0.08709,          -0.03118,

         -44.74949,          91.17393,           8.78173,          45.84010,
           1.97560,         -15.02849,          -0.10755,          -0.02884,
           3.38670,           0.30615,

         130.92778,         -24.33209,          43.01636,         -40.81327,
         -19.43900,          22.18162,          -0.12691,           0.33795,
          -6.44790,          -6.23145,

           0.00319,           0.01141,

          -0.03252,           0.03872,

           0.04467,           0.01614,

          -0.00382,          -0.00019,

           0.05955,           0.01533,

          16.11371,          41.37565,          61.44963,           6.90615,
           1.41326,          -0.73920,          -0.03871,          24.81978,

          -0.10229,          -0.32775,          -0.05188,          -0.05628,

          -2.33618,           2.39053,

          -0.00584,           0.00436,

           0.20903,           0.02220,

          -0.01738,          -0.02765,

          -0.00217,           0.00613,

          -0.01772,           0.01903,

           0.07075,          -0.00530,

           0.15234,          -0.37760,          -0.11641,          -0.20102,

          -0.63675,           0.20525,          -0.15783,           0.58945,

          -0.06243,           0.04306,

  };
  static final double plutabb[] = {
   -35042727.30412,   -49049197.81293,   -25374963.60995,    -5761406.03035,
     -467370.57540,       14040.11453,        2329.15763,      -13978.69390,

          45.43441,          29.70305,

          32.33772,         -38.34012,

          26.43575,         -28.76136,

         -18.59040,          12.64837,

           5.56569,         -12.51581,

         248.37350,         -64.44466,          54.02618,           4.39466,

        -269.35114,        -290.63134,         -48.03841,         -52.83576,

        1508.94995,        1682.78967,         554.02336,         715.65819,
          34.37602,          58.44397,

          16.63685,          16.10176,

       -1069.51609,        2300.89166,        -437.16796,         927.89245,
         -33.17679,          68.74495,

          18.72022,          32.97640,

   -34004958.12619,   -17758805.77098,   -48416073.75788,   -24973405.03542,
   -25374996.23732,   -13351084.97340,    -5738294.54942,    -3082092.63350,
     -519989.39256,     -206440.89101,       44186.23548,      -87639.22630,
        2506.47602,        2327.01164,      -53878.47903,      -19670.13471,

           2.66934,          -3.86086,

         106.32427,         576.47944,          46.56388,         218.28339,
           4.35402,          15.04642,

           2.68717,          -2.86835,

           0.81728,          -2.34417,

       -1604.85823,       -1999.24986,        -631.47343,       -1382.19156,
         -15.74075,        -256.97077,           6.99648,          -4.54257,

           2.63478,           1.88838,

           0.17628,          -2.11518,

          -2.46735,          -1.48743,

           1.83456,           4.68487,

          -7.10919,           3.57046,

          -5.36342,          -7.70367,

    28395956.20816,   -37176795.74372,    48969952.83034,   -48145798.96248,
    31155823.23557,   -21163596.14822,     9057634.38260,    -3167688.51696,
     1167488.70078,      219103.97591,      -19017.97335,      107849.61195,
       -3814.43474,        4405.92120,        5800.13959,       12619.88708,

          22.18168,         -89.47801,

       52202.81929,       55119.44083,        5082.58907,       37955.06062,
       -3165.24355,        3316.67588,

     -113906.43970,      -69279.41495,      -57358.07767,      -10176.17329,
       -4179.79867,        2495.99374,

         787.87180,        -154.35591,

       -1148.62509,        1034.58199,

      -22194.95235,        3341.97949,       -4578.53994,         108.30832,

        7444.39789,       16646.40725,         509.75430,        3808.92686,

        -179.85869,        7408.76716,         340.65366,        1504.64227,

       -3783.09873,      -13505.60867,         875.74489,       -3181.27898,

      -16220.93983,        8041.37347,       -2631.07448,        2899.50781,

       18894.92095,      -20072.81471,        5925.05701,       -1947.91902,

       -6731.56601,        8014.52403,

     -987793.49463,     6491762.34471,     -279205.73643,     6117135.96868,
     -140925.91402,     2259422.06929,      114028.61646,      605600.90358,
       91858.00186,       56506.65187,        8949.15777,       -9782.67413,

        -394.66541,        -105.19208,         -76.54752,         -32.59411,

         -19.28741,          10.40013,

        -107.64003,          -7.36229,         -22.25126,           4.05952,

          -3.74402,          -2.79308,

           1.03337,          -2.13968,

           1.53794,          -0.02617,

          35.70756,          12.97733,          14.46213,           6.20518,
           1.79381,           1.65422,

          -0.31216,           0.29053,

          -0.03538,          -0.01584,

          -0.08934,           0.00079,

           0.05539,          -0.21591,

           2.86929,          -2.24724,

      320797.07455,       93342.16556,      -20903.39115,       79523.22083,
     -226588.37473,     -121017.23944,      -48472.25935,      -74195.36778,
       -7962.48081,       -4607.76339,       -4597.33274,       -7983.12541,
         -20.34500,          56.82999,       -1038.19507,         619.69624,

           1.08907,          -0.91278,

          -0.13391,           0.34956,

          -0.19982,          -0.18296,

          -0.97688,           2.36806,          -0.30127,           0.50980,

           0.96103,           1.96432,           0.43338,           0.87317,

           0.36997,          -0.01583,

          -0.44692,          -0.25159,

          -0.53525,           0.01154,

          -0.13231,           0.35562,

           3.88928,          -4.02882,           1.06967,          -0.56305,

          -0.45204,           0.77213,

          -0.82873,          -0.25854,

           0.21136,          -1.06696,

      458529.05491,      616790.47568,      698431.01349,     1124501.41713,
      300226.10339,      766533.33698,       26896.22954,      207880.75720,
        1116.29607,       21793.26153,        -850.64044,        3528.95568,
          29.61278,        -120.13367,         376.95131,          66.45758,

          -3.64868,           2.76062,          -0.85352,           0.95115,

           5.35056,           2.52803,           0.90026,           0.76403,

           0.43191,           0.83605,

         125.81792,         -39.65364,          50.14425,          -5.75891,
           2.78555,           2.05055,

          -4.27266,          -4.92428,

           6.78868,           5.73537,

           3.35229,          -3.70143,

           0.08488,           1.07465,

           0.10227,           0.06074,

           0.00291,           0.01522,

          -0.02274,           0.00297,

           0.01095,          -0.01856,

          -0.02862,           0.00178,

      143640.07486,         707.21331,      177163.08586,       53386.52697,
       56856.89297,       48268.74645,        1764.52814,        7711.76224,
         352.34159,        -968.03169,         -45.16568,         -81.60481,
         -76.35993,         -98.06932,

          -1.42185,           1.81425,

          -0.23427,           0.59023,

           0.57127,          -0.36335,

           1.89975,           0.66890,           0.28797,           0.43592,

          -0.03769,           0.03273,

          -6.06571,          -2.68515,          -0.55315,           0.86977,
           1.53840,          -0.59422,

          -0.05453,           0.02447,

          -0.12658,           0.22814,          -0.01715,           0.08497,

          -0.01288,          -0.00606,

           0.01547,          -0.00692,

           0.01157,           0.02407,

          -0.03883,           0.00835,

          -0.01542,          -0.04761,

      174386.39024,      158048.26273,      159192.81681,      220154.55148,
       33716.11953,       87537.86597,        -116.90381,        7535.83928,
        -962.06994,        -132.28837,        -644.90482,        -110.52332,
           3.42499,           3.74660,          -0.94008,          41.55548,

          -0.03824,          -0.05607,

          28.74787,         -37.31399,          30.87853,         -26.11940,
          10.79742,          -5.97905,           1.01237,          -0.04429,
           0.54402,           0.41905,

          -0.02440,          -0.03991,

          -0.00347,          -0.04362,          -0.00347,          -0.00469,

          -0.02707,           0.02761,

          -0.17773,          -0.11789,

       26475.02580,       35363.04345,       19877.11475,       41430.35940,
        2948.09998,       12983.41406,         281.93744,         570.70054,
         147.83157,          16.00090,          -1.62814,          -8.30846,
           9.29131,         -10.16496,

          -0.15799,           0.03843,

           1.44716,           0.46953,

          -0.02150,          -0.02502,

           0.08861,          -0.06690,

        2237.41551,        3739.08722,         753.74867,        3460.41553,
        -298.69226,         520.47031,         -33.62615,        -138.12767,
           3.61843,          -8.29860,          -4.56656,           0.79553,

           0.20041,          -0.25771,

          -0.35233,          -0.27913,          -0.02799,          -0.08328,

          -0.06889,          -0.16853,

           0.01701,          -0.00964,

          -0.37737,           0.18030,          -0.08525,           0.01906,

           0.05236,          -0.05155,

           0.11320,           0.05991,

          -5.66926,          -0.54402,          -2.08508,          -0.39407,

           0.82155,          -0.55975,

           0.39168,          -0.25551,           0.00623,           0.16162,

          -0.02519,           0.02420,

          -1.23293,          -3.19649,          -0.60519,          -2.79729,
           0.05362,          -0.61569,

          -0.25638,          -0.27033,

          -0.03987,           0.46623,          -0.12070,           0.00643,

           0.00849,          -0.00768,

          -0.03687,           0.10445,

          -0.13544,          -0.00592,

           0.02078,           0.09172,

           0.15824,           0.15815,           0.02020,           0.00747,

           0.10919,           0.09553,           0.01953,          -0.00135,

           0.04266,          -0.00218,

           0.02182,          -0.13742,          -0.01249,           0.01724,

          -0.02200,           0.02975,

          -0.01401,           0.03416,

          -0.28873,           0.04235,          -0.08137,           0.04223,

          -0.00326,           0.02144,

          -0.40423,           0.14281,          -0.08256,           0.02142,

           0.08116,          -0.03680,

          -0.02324,           0.07260,

          -0.06746,           0.11645,

           0.03233,          -0.05997,

          -0.03101,           0.02197,

          -0.00896,          -0.00491,

           0.00574,           0.00855,

           0.00052,           0.01209,

          -0.31828,           0.29955,          -0.08133,           0.04318,

           0.06787,          -0.08865,

          -0.13228,          -0.06507,

           0.34008,           0.06417,

          -0.00177,          -0.15116,

          -0.00553,          -0.01950,

           0.01144,          -0.00309,

          -0.00115,          -0.00153,

           0.02063,          -0.00791,

          -0.00314,           0.00493,

          -0.10614,           0.08338,

           0.08845,           0.20168,

           1.38955,          -2.52285,          -0.30475,          -1.05787,

           0.00580,           0.06623,

         -44.33263,         -47.70073,         -29.80583,          -8.77838,
           7.02948,           2.77221,           0.05248,          -0.13702,
          -0.78176,           1.77489,

         -16.32831,          46.68457,           2.54516,          21.78145,
          -5.09080,          -8.42611,          -0.24419,          -0.03315,
           2.80629,          -1.12755,

          -0.00402,           0.00053,

           0.00024,          -0.00043,

           0.00403,          -0.00210,

           0.00603,           0.00411,

          -0.00260,           0.00416,

           2.29235,           3.05992,           2.36465,          -0.58750,
           0.14030,           0.13523,           0.89998,           0.70156,

          -0.02188,           0.02003,          -0.00533,           0.00447,

           2.96411,           1.30183,

           0.01422,           0.00624,

          -0.10737,          -0.38316,

          -0.05968,           0.04379,

           0.01171,           0.01180,

          -0.00989,          -0.01375,

          -0.00845,           0.03782,

           0.09484,           0.09909,           0.07640,          -0.00898,

          -0.01076,           0.02760,           0.01630,           0.02198,

           0.05985,           0.04130,

  };
  static final double plutabr[] = {
    17990649.12487,    24806479.30874,    12690953.00645,     2892671.69562,
      249947.71316,       -5138.71425,        1142.68629,        6075.25751,

         -34.76785,         -19.72399,

         -15.81516,          30.47718,

         -11.73638,          21.87955,

           9.42107,         -10.40957,

          -5.59670,           6.85778,

        -167.06735,          -2.31999,         -32.42575,         -13.72714,

         130.16635,         117.97555,          31.33915,          39.64331,

       -1378.54934,        -395.83244,        -562.79856,        -167.74359,
         -45.12476,         -17.08986,

          -4.20576,         -16.56724,

        1762.12089,       -1148.86987,         736.55320,        -423.09108,
          56.13621,         -26.26674,

           9.77810,         -38.05151,

     4702224.98754,    27254904.94363,     5306232.25993,    39518429.29982,
     1725110.05669,    21833263.27069,       46010.62605,     5425411.66252,
       17238.09865,      536771.62156,      -61263.36051,       66270.70142,
        2084.66296,       -1936.71208,       35898.49503,       34885.28549,

           1.93276,          10.66292,

        -665.11445,           3.70467,        -265.68478,          16.16272,
         -19.45954,           2.32738,

           3.04237,           3.97339,

          -2.64312,           0.66308,

       -3207.68754,        3418.03720,       -2342.62310,        1729.15030,
        -450.84643,         179.00943,         -13.20367,          -1.86087,

          -4.95659,           7.22347,

          -5.08890,          -1.28891,

          -6.21713,           5.10551,

          13.97276,           0.44529,

           3.25177,          25.02775,

         -45.56672,          11.58470,

   124443355.55450,  -100018293.41775,   190506421.77863,  -118262753.40162,
   108199328.45091,   -45247957.63323,    27272084.41143,    -4125106.01144,
     2583469.66051,     1024678.12935,      -22702.55109,      199269.51481,
      -15783.14789,        5564.52481,        -427.22231,       -6330.86079,

         -97.50757,        -204.32241,

       -9060.54822,      156661.77631,      -47791.83678,       59725.58975,
       -8807.74881,         -92.38886,

      -28886.11572,     -244419.59744,      -53336.36915,      -92232.16479,
       -8724.89354,       -2446.76739,

         889.71335,         936.51108,

         494.80305,        2252.83602,

      -18326.60823,      -25443.13554,       -3130.86382,       -5426.29135,

       23494.08846,          91.28882,        4664.14726,        1552.06143,

       -8090.43357,        2843.48366,       -1445.73506,        1023.11482,

       11664.20863,       -7020.08612,        3100.21504,         -64.16577,

       -9724.97938,      -12261.47155,       -3008.08276,       -1523.06301,

        6788.74046,       10708.27853,         343.09434,        1701.52760,

       14743.99857,       -4781.96586,

   -15922236.41469,     1825172.51825,   -14006084.36972,    10363332.64447,
     -979550.91360,     6542446.18797,     1160614.26915,      570804.88172,
       89912.68112,     -171247.08757,      -13899.52899,       -6182.25841,

        -240.64725,         412.42581,         -66.24510,          71.30726,

         -15.81125,         -15.76899,

         -21.85515,        -102.12717,         -10.18287,         -19.38527,

           1.43749,          -3.87533,

           1.97109,           0.20138,

           0.32012,           1.02928,

         -40.22077,          20.80684,         -15.69766,           9.63663,
          -1.26010,           0.56197,

           0.08592,           0.18540,

          -0.07303,           0.03897,

           0.01438,          -0.08809,

           0.15479,           0.10354,

           0.19052,           2.08790,

      405480.24475,     -607986.83623,      582811.58843,     -915111.10396,
      258696.21023,     -493391.09443,       23403.62628,     -119503.67282,
       -4036.86957,       -9766.17805,        -663.93268,        2544.07799,
          40.36638,          76.26390,         246.67716,         -13.93440,

           0.12403,           0.25378,

           0.14004,          -0.08501,

           0.07904,           0.12731,

           1.02117,          -1.34663,           0.25142,          -0.26903,

           0.18135,          -0.57683,          -0.30092,          -0.36121,

          -0.09623,           0.05873,

          -0.05803,           0.02869,

          -0.01194,           0.04983,

           0.04250,           0.04894,

           1.34245,           0.70137,           0.24217,           0.25912,

          -0.32759,          -0.03575,

           0.06780,          -0.41277,

           0.43865,           0.17857,

     -763933.02226,      465658.17048,    -1082753.91241,      593319.68634,
     -553911.89340,      274748.95145,     -122250.71547,       56608.95768,
       -9914.17300,        2988.43709,         707.94605,        -765.01470,
          52.73260,         -34.22263,         -43.58300,         -38.43647,

          -4.95939,          -1.97173,          -1.04406,          -0.13072,

          -0.34281,           4.75202,          -0.35513,           0.93597,

          -0.54380,           0.70536,

          84.83116,         102.93003,          26.34884,          48.57746,
           0.02853,           2.91676,

          -8.07116,           1.66613,

          -2.07908,          11.62592,

           6.64704,           0.98291,

          -1.19192,           0.93791,

           0.18822,           0.00900,

          -0.03181,          -0.02000,

           0.02755,          -0.01398,

          -0.03971,          -0.03756,

           0.13454,          -0.04193,

      -18672.98484,       28230.75834,      -28371.58823,       26448.45214,
      -13352.09393,        7461.71279,       -2609.33578,         726.50321,
        -309.72942,         -86.71982,          12.48589,          -9.69726,
           1.82185,          14.92220,

          -0.04748,           0.42510,

          -0.20047,           0.00154,

           0.00176,          -0.26262,

           0.78218,          -0.73243,           0.23694,          -0.03132,

          -0.00290,          -0.03678,

          14.03094,           4.25948,           0.79368,          -0.78489,
          -2.30962,           2.31946,

           0.00158,          -0.04125,

          -0.01387,           0.28503,           0.00892,           0.05154,

           0.00184,          -0.01727,

          -0.00889,           0.03526,

          -0.00521,          -0.02093,

           0.00200,           0.04872,

          -0.02163,           0.00578,

       20699.27413,       -2175.57827,       31177.33085,        4572.02063,
       15486.28190,        8747.74091,        2455.51737,        3839.83609,
          51.31433,         507.91086,          15.90082,          44.75942,
          -0.98374,          -2.64477,           2.52336,          -3.09203,

          -0.08897,          -0.00083,

         -15.91892,           0.72597,          14.04523,          -3.16525,
           4.33379,         -30.82980,           0.40462,          -0.75845,
          13.14831,          -0.02721,

          -0.01779,           0.00481,

           0.42365,          -0.09048,           0.08653,           0.04391,

           0.00846,           0.01082,

          -0.04736,           0.02308,

        6282.21778,       -4952.70286,        7886.57505,       -5328.36122,
        3113.76826,       -1696.84590,         330.70011,        -155.51989,
         -18.31559,          -3.90798,          -3.11242,           1.87818,
          -1.05578,           0.11198,

           0.05077,          -0.01571,

           2.41291,           2.40568,

          -0.01136,          -0.00076,

          -0.00392,          -0.02774,

         634.85065,        -352.21937,         674.31665,        -260.73473,
         199.16422,         -28.44198,           6.54187,           6.44960,
          -1.55155,           0.29755,           0.16977,           0.17540,

          -0.02652,           0.03726,

          -0.00623,           0.11777,          -0.00933,           0.02602,

          -0.13943,          -0.24818,

           0.02876,          -0.01463,

          -0.07166,           0.06747,          -0.01578,           0.01628,

           0.00233,          -0.00686,

           0.00431,          -0.00276,

           0.21774,           0.09735,           0.07894,           0.07279,

          -0.01300,          -0.00268,

           0.10824,           0.09435,           0.00720,           0.02111,

          -0.01960,           0.06154,

           0.56867,          -0.07544,           0.18210,           0.06343,
          -0.00906,           0.01942,

          -0.00850,          -0.00351,

          -0.06988,           0.01713,          -0.01110,          -0.00663,

           0.00196,          -0.02064,

          -0.00008,           0.00043,

           0.00375,           0.00084,

          -0.00279,           0.00100,

           0.00271,          -0.02017,          -0.00074,          -0.00357,

           0.03793,          -0.10108,          -0.01083,          -0.03952,

           0.00030,           0.00012,

           0.01576,           0.01142,           0.00351,           0.00277,

           0.01409,          -0.00774,

          -0.00065,           0.01895,

           0.07350,          -0.02519,           0.01528,          -0.01057,

          -0.00099,          -0.00295,

           0.21347,          -0.17458,           0.04940,          -0.02757,

          -0.06243,           0.05203,

           0.01055,          -0.00109,

           0.00003,          -0.04201,

          -0.00263,           0.02387,

           0.00886,          -0.01168,

           0.00479,           0.00204,

          -0.00239,           0.00022,

          -0.00223,          -0.02029,

          -0.14130,          -0.15237,          -0.01827,          -0.04877,

           0.12104,           0.06796,

           0.16379,           0.31892,

          -0.15605,           0.07048,

          -0.00700,           0.07481,

          -0.00370,          -0.00142,

          -0.00446,           0.00329,

          -0.00018,           0.00117,

          -0.00910,           0.00510,

          -0.00055,          -0.00114,

           0.04131,          -0.04013,

          -0.13238,           0.02680,

          -0.10369,           1.38709,           0.35515,           0.41437,

          -0.01327,          -0.02692,

          38.02603,          13.38166,          15.33389,          -7.40145,
          -8.55293,          -0.13185,          -0.03316,           0.13016,
           0.04428,          -1.60953,

         -12.87829,         -76.97922,         -23.96039,         -22.45636,
          14.83309,          14.09854,           0.24252,           0.13850,
          -4.16582,           4.08846,

           0.00751,          -0.00051,

           0.03456,           0.02900,

           0.01625,          -0.04660,

           0.01390,          -0.00530,

           0.01665,          -0.04571,

          40.90768,         -14.11641,           7.46071,         -58.07356,
          -0.27859,          -1.33816,          23.76074,          -0.03124,

          -0.27860,           0.13654,          -0.04800,           0.05375,

           4.38091,           4.39337,

           0.02233,           0.00514,

          -0.25616,          -0.54439,

          -0.05155,           0.11553,

           0.02944,          -0.00818,

           0.00570,           0.00119,

          -0.00733,          -0.02700,

          -0.23759,          -0.08712,          -0.12433,           0.07397,

           0.20629,           0.60251,           0.56512,           0.14790,

           0.07778,           0.11614,

  };

  static byte pluargs[] = {
  (byte)0,  (byte)7,
  (byte)2,  (byte)3,  (byte)7, (byte)-9,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7,(byte)-12,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-8,  (byte)8,  (byte)0,
  (byte)3, (byte)-4,  (byte)7,  (byte)5,  (byte)8,  (byte)4,  (byte)9,  (byte)0,
  (byte)3,  (byte)3,  (byte)7, (byte)-5,  (byte)8, (byte)-1,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-8,  (byte)9,  (byte)1,
  (byte)2,  (byte)3,  (byte)8, (byte)-5,  (byte)9,  (byte)1,
  (byte)2,  (byte)1,  (byte)6, (byte)-9,  (byte)9,  (byte)2,
  (byte)3,  (byte)6,  (byte)7, (byte)-6,  (byte)8, (byte)-8,  (byte)9,  (byte)0,
  (byte)3,  (byte)4,  (byte)7,(byte)-10,  (byte)8,  (byte)4,  (byte)9,  (byte)2,
  (byte)2,  (byte)3,  (byte)7, (byte)-8,  (byte)9,  (byte)0,
  (byte)1,  (byte)1,  (byte)9,  (byte)7,
  (byte)2,  (byte)3,  (byte)7,(byte)-10,  (byte)9,  (byte)0,
  (byte)3,  (byte)4,  (byte)7,(byte)-10,  (byte)8,  (byte)2,  (byte)9,  (byte)2,
  (byte)3,  (byte)5,  (byte)7,(byte)-12,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-7,  (byte)9,  (byte)0,
  (byte)1,  (byte)1,  (byte)8,  (byte)3,
  (byte)2,  (byte)1,  (byte)6,(byte)-10,  (byte)9,  (byte)0,
  (byte)3,  (byte)6,  (byte)7,(byte)-12,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)3,  (byte)5,  (byte)7,(byte)-10,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)7,(byte)-13,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7,(byte)-10,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-7,  (byte)9,  (byte)0,
  (byte)1,  (byte)2,  (byte)9,  (byte)7,
  (byte)2,  (byte)3,  (byte)7,(byte)-11,  (byte)9,  (byte)0,
  (byte)3,  (byte)4,  (byte)7, (byte)-9,  (byte)8,  (byte)4,  (byte)9,  (byte)2,
  (byte)3,  (byte)3,  (byte)7, (byte)-5,  (byte)8,  (byte)1,  (byte)9,  (byte)2,
  (byte)2,  (byte)1,  (byte)6, (byte)-6,  (byte)9,  (byte)0,
  (byte)2,  (byte)7,  (byte)8,(byte)-13,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)8, (byte)-2,  (byte)9,  (byte)1,
  (byte)3,  (byte)1,  (byte)7, (byte)-5,  (byte)8,  (byte)2,  (byte)9,  (byte)1,
  (byte)3,  (byte)6,  (byte)7,(byte)-12,  (byte)8,  (byte)3,  (byte)9,  (byte)1,
  (byte)2,  (byte)5,  (byte)7,(byte)-12,  (byte)9,  (byte)1,
  (byte)2,  (byte)4,  (byte)7, (byte)-9,  (byte)9,  (byte)1,
  (byte)2,  (byte)2,  (byte)7, (byte)-3,  (byte)9,  (byte)1,
  (byte)1,  (byte)1,  (byte)7,  (byte)0,
  (byte)1,  (byte)3,  (byte)9,  (byte)5,
  (byte)2,  (byte)3,  (byte)7,(byte)-12,  (byte)9,  (byte)1,
  (byte)3,  (byte)5,  (byte)7, (byte)-9,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)3,  (byte)4,  (byte)7, (byte)-7,  (byte)8,  (byte)2,  (byte)9,  (byte)1,
  (byte)3,  (byte)3,  (byte)7, (byte)-5,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)3,  (byte)2,  (byte)7, (byte)-5,  (byte)8,  (byte)5,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-5,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)8, (byte)-1,  (byte)9,  (byte)2,
  (byte)2,  (byte)1,  (byte)6,(byte)-12,  (byte)9,  (byte)0,
  (byte)3,  (byte)2,  (byte)7, (byte)-7,  (byte)8,  (byte)1,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)7,(byte)-11,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-8,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-2,  (byte)9,  (byte)0,
  (byte)1,  (byte)4,  (byte)9,  (byte)7,
  (byte)3,  (byte)2,  (byte)7, (byte)-8,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)3,  (byte)5,  (byte)7, (byte)-9,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)3,  (byte)4,  (byte)7, (byte)-9,  (byte)8,  (byte)6,  (byte)9,  (byte)0,
  (byte)3,  (byte)3,  (byte)7, (byte)-5,  (byte)8,  (byte)3,  (byte)9,  (byte)1,
  (byte)2,  (byte)2,  (byte)7, (byte)-1,  (byte)8,  (byte)1,
  (byte)2,  (byte)3,  (byte)8, (byte)-9,  (byte)9,  (byte)0,
  (byte)2,  (byte)9,  (byte)8, (byte)-9,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6,(byte)-13,  (byte)9,  (byte)0,
  (byte)3,  (byte)2,  (byte)7, (byte)-5,  (byte)8, (byte)-3,  (byte)9,  (byte)0,
  (byte)2,  (byte)6,  (byte)7,(byte)-13,  (byte)9,  (byte)1,
  (byte)2,  (byte)5,  (byte)7,(byte)-10,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-7,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-4,  (byte)9,  (byte)0,
  (byte)1,  (byte)5,  (byte)9,  (byte)7,
  (byte)3,  (byte)6,  (byte)7, (byte)-9,  (byte)8,  (byte)1,  (byte)9,  (byte)1,
  (byte)3,  (byte)4,  (byte)7, (byte)-5,  (byte)8,  (byte)1,  (byte)9,  (byte)1,
  (byte)3,  (byte)3,  (byte)7, (byte)-3,  (byte)8,  (byte)1,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-3,  (byte)9,  (byte)2,
  (byte)2,  (byte)3,  (byte)8,(byte)-10,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)8,  (byte)4,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)8, (byte)-2,  (byte)9,  (byte)0,
  (byte)2, (byte)11,  (byte)8,(byte)-11,  (byte)9,  (byte)0,
  (byte)3,  (byte)1,  (byte)7, (byte)-9,  (byte)8,  (byte)5,  (byte)9,  (byte)0,
  (byte)2,  (byte)6,  (byte)7,(byte)-12,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-9,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-6,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-3,  (byte)9,  (byte)0,
  (byte)1,  (byte)6,  (byte)9,  (byte)6,
  (byte)2,  (byte)2,  (byte)7,(byte)-12,  (byte)9,  (byte)0,
  (byte)3,  (byte)6,  (byte)7, (byte)-9,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)3,  (byte)3,  (byte)7,(byte)-12,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)3,  (byte)4,  (byte)7,(byte)-10,  (byte)8, (byte)-3,  (byte)9,  (byte)1,
  (byte)3,  (byte)3,  (byte)7, (byte)-3,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-2,  (byte)9,  (byte)2,
  (byte)2,  (byte)1,  (byte)8,  (byte)5,  (byte)9,  (byte)0,
  (byte)2, (byte)13,  (byte)8,(byte)-13,  (byte)9,  (byte)1,
  (byte)3,  (byte)2,  (byte)7, (byte)-9,  (byte)8,  (byte)1,  (byte)9,  (byte)0,
  (byte)2,  (byte)6,  (byte)7,(byte)-11,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-8,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-5,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-2,  (byte)9,  (byte)0,
  (byte)1,  (byte)7,  (byte)9,  (byte)7,
  (byte)3,  (byte)6,  (byte)7, (byte)-9,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-1,  (byte)9,  (byte)4,
  (byte)2,  (byte)3,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)7,  (byte)7,(byte)-13,  (byte)9,  (byte)1,
  (byte)2,  (byte)3,  (byte)7, (byte)-1,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)7,  (byte)2,  (byte)9,  (byte)0,
  (byte)1,  (byte)8,  (byte)9,  (byte)6,
  (byte)3,  (byte)7,  (byte)7, (byte)-9,  (byte)8,  (byte)1,  (byte)9,  (byte)0,
  (byte)1,  (byte)1,  (byte)6,  (byte)0,
  (byte)1,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)7,  (byte)3,  (byte)9,  (byte)0,
  (byte)1,  (byte)9,  (byte)9,  (byte)5,
  (byte)3,  (byte)1,  (byte)7,(byte)-10,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)3,  (byte)2,  (byte)7,(byte)-12,  (byte)8,  (byte)3,  (byte)9,  (byte)1,
  (byte)2,  (byte)1,  (byte)6,  (byte)1,  (byte)9,  (byte)0,
  (byte)3,  (byte)1,  (byte)7, (byte)-1,  (byte)8,  (byte)8,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)7,  (byte)1,  (byte)9,  (byte)1,
  (byte)2,  (byte)2,  (byte)7,  (byte)4,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)7,  (byte)7,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)8,  (byte)4,  (byte)9,  (byte)1,
  (byte)2, (byte)12,  (byte)8, (byte)-8,  (byte)9,  (byte)0,
  (byte)3,  (byte)1,  (byte)7,(byte)-10,  (byte)8,  (byte)2,  (byte)9,  (byte)1,
  (byte)2,  (byte)1,  (byte)6,  (byte)2,  (byte)9,  (byte)0,
  (byte)1, (byte)11,  (byte)9,  (byte)2,
  (byte)2, (byte)12,  (byte)8, (byte)-7,  (byte)9,  (byte)0,
  (byte)3,  (byte)1,  (byte)7,(byte)-10,  (byte)8,  (byte)1,  (byte)9,  (byte)1,
  (byte)1,  (byte)4,  (byte)7,  (byte)0,
  (byte)1, (byte)12,  (byte)9,  (byte)0,
  (byte)2,  (byte)6,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)3,  (byte)1,  (byte)7, (byte)-2,  (byte)8,(byte)-12,  (byte)9,  (byte)0,
  (byte)3,  (byte)7,  (byte)7, (byte)-7,  (byte)8,  (byte)2,  (byte)9,  (byte)1,
  (byte)2,  (byte)2,  (byte)6, (byte)-4,  (byte)9,  (byte)1,
  (byte)1, (byte)13,  (byte)9,  (byte)0,
  (byte)2, (byte)10,  (byte)8, (byte)-2,  (byte)9,  (byte)1,
  (byte)2,  (byte)4,  (byte)7,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-3,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)7,  (byte)8,  (byte)9,  (byte)1,
  (byte)2,  (byte)8,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)1,  (byte)5,  (byte)7,  (byte)1,
  (byte)2,  (byte)4,  (byte)7,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)7,  (byte)6,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-6,  (byte)9,  (byte)0,
  (byte)3,  (byte)2,  (byte)7,  (byte)8,  (byte)8, (byte)-3,  (byte)9,  (byte)0,
  (byte)3,  (byte)1,  (byte)7,  (byte)6,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)6,  (byte)8,  (byte)6,  (byte)9,  (byte)0,
  (byte)3,  (byte)8,  (byte)7, (byte)-7,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)9,  (byte)7,(byte)-11,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)7,  (byte)1,  (byte)9,  (byte)1,
  (byte)2,  (byte)4,  (byte)7,  (byte)4,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-1,  (byte)9,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-1,  (byte)7,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)10,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)7, (byte)13,  (byte)9,  (byte)0,
  (byte)2,  (byte)8,  (byte)7, (byte)-7,  (byte)9,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-4,  (byte)9,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-1,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)7,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7,  (byte)5,  (byte)9,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-4,  (byte)9,  (byte)1,
  (byte)3,  (byte)1,  (byte)6,  (byte)9,  (byte)8, (byte)-5,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-3,  (byte)9,  (byte)4,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)9,  (byte)4,
  (byte)3,  (byte)9,  (byte)7, (byte)-9,  (byte)8,  (byte)6,  (byte)9,  (byte)0,
  (byte)2,  (byte)8,  (byte)7, (byte)-4,  (byte)9,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-1,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)6,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)9,  (byte)3,
  (byte)3,  (byte)6,  (byte)7, (byte)-3,  (byte)8,  (byte)7,  (byte)9,  (byte)1,
  (byte)1,  (byte)1,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)6,  (byte)5,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)5,  (byte)1,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)5,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)5,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)9,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-1,  (byte)9,  (byte)1,
  (byte)1,  (byte)2,  (byte)5,  (byte)0,
 (byte)-1
  };
  /* Total terms = 173, small = 156 */
  static Plantbl plu404 = new Plantbl(
                               new short[]{0,  0,  0,  0,  2,  2,  9, 13, 13},
                               (short)7,
                               pluargs,
                               plutabl,
                               plutabb,
                               plutabr,
                               3.9539999999999999e+01
  );
}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class SwemptabSat {
  /*
  First date in file = 625296.50
  Number of records = 16731.0
  Days per record = 131.0
        Julian Years      Lon    Lat    Rad
   -3000.0 to  -2499.7:   0.78   0.26   0.55
   -2499.7 to  -1999.7:   0.66   0.19   0.57
   -1999.7 to  -1499.7:   0.62   0.19   0.53
   -1499.7 to   -999.8:   0.79   0.17   0.61
    -999.8 to   -499.8:   0.78   0.15   0.42
    -499.8 to      0.2:   0.75   0.19   0.52
       0.2 to    500.2:   0.62   0.18   0.41
     500.2 to   1000.1:   0.56   0.13   0.54
    1000.1 to   1500.1:   0.53   0.15   0.41
    1500.1 to   2000.1:   0.51   0.15   0.49
    2000.1 to   2500.0:   0.52   0.13   0.41
    2500.0 to   3000.0:   0.63   0.22   0.53
    3000.0 to   3000.4:  0.047  0.073  0.086
  */
  static final double sattabl[] = {
     1788381.26240,     2460423.68044,     1370113.15868,      415406.99187,
       72040.39885,       12669.58806,   439960754.85333,      180256.80433,

          18.71177,         -40.37092,

       66531.01889,     -195702.70142,       57188.02694,     -179110.60982,
      -19803.06520,      -58084.15705,       -9055.13344,      -31146.10779,
       11245.43286,       -3247.59575,         459.48670,        2912.82402,

          -4.06749,         -13.53763,

         -30.55598,          -4.51172,

           1.48832,           0.37139,

         597.35433,        1193.44545,        -297.50957,         976.38608,
        -263.26842,          34.84354,          -6.77785,         -29.92106,

          -0.16325,          -0.18346,

          -0.15364,          -0.08227,

           0.20180,           0.02244,

           0.04672,          -0.29867,

          -0.04143,          -0.00760,

          -0.17046,          -0.00778,

           0.04200,           0.23937,          -0.00098,          -0.05236,

          -0.02749,          -0.01813,

           0.00637,           0.01256,

          -0.04506,           0.04448,

          -0.00105,           0.06224,

           0.01157,           0.17057,          -0.03214,           0.18178,

          -0.22059,          -0.01472,

          -0.24213,           0.04309,           0.03436,           0.44873,

           0.01350,          -0.01931,

          -0.80618,          -0.56864,           0.29223,          -0.03101,

           0.04171,           0.02264,

          -0.01264,          -0.01645,

           0.01774,           0.06374,

          -0.01925,          -0.03552,

           0.10473,          -0.04119,

           0.08045,           0.04635,

          -3.01112,          -9.26158,           8.13745,           1.88838,

          -0.15184,           0.16898,

          -0.22091,           0.29070,          -0.03259,           0.06938,

          -0.08499,          -0.21688,           0.01848,          -0.05594,

           0.50100,          -0.00027,           0.13300,           0.12055,

           0.03039,           0.03854,

          -1.55287,           2.55618,          -0.45497,          -0.29895,
          -0.93268,           0.83518,

          -0.32785,           7.03878,          -1.66649,           2.75564,
          -0.29459,           0.01050,

           0.08293,          -0.03161,

          -0.12750,          -0.04359,

           0.04217,           0.07480,

        -114.43467,          49.47867,         -66.52340,         -26.27841,
          15.48190,         -13.06589,           3.28365,           5.02286,

          -0.17155,          -0.07404,

           0.00924,          -0.07407,

          -0.02922,           0.06184,

         108.04882,          86.09791,        -155.12793,         208.10044,
        -311.72810,        -268.92703,          74.57561,        -420.03057,

          -0.07893,           0.09246,

          -0.66033,          -0.39026,          -0.13816,          -0.08490,

         -36.79241,         -78.88254,          71.88167,         -68.05297,
          51.71616,          65.77970,         -43.59328,          23.51076,

          -0.02029,          -0.32943,

          -8.82754,           1.48646,          -3.12794,           2.12866,
          -0.06926,           0.44979,

           0.00621,          -0.51720,

          -3.82964,          -1.48596,          -0.11277,          -3.21677,
           0.81705,          -0.19487,

          -0.06195,           0.10005,          -0.02208,           0.00108,

           0.00455,          -0.03825,

           0.01217,          -0.00599,

          -0.17479,          -0.47290,           0.85469,           1.12548,
          -0.80648,          -0.44134,

          -0.01559,          -0.07061,

           0.01268,          -0.01773,

           0.01308,          -0.03461,

          -0.71114,           1.97680,          -0.78306,          -0.23052,
           0.94475,          -0.10743,

           0.18252,          -8.03174,

           0.00734,           0.04779,

           0.12334,          -0.03513,

           0.01341,           0.02461,

           0.02047,          -0.03454,

           0.02169,          -0.01921,

          -1.12789,           0.09304,           0.14585,           0.36365,

           0.03702,           0.10661,          -0.00464,          -1.72706,

          -0.00769,          -0.04635,

          -0.01157,           0.00099,

          10.92646,           1.96174,           2.91142,           4.74585,
          -0.29832,           0.75543,

           0.05411,           1.05850,

           0.38846,          -0.16265,

           1.52209,           0.12185,           0.18650,           0.35535,

        -278.33587,         -82.58648,        -160.00093,        -225.55776,
          35.17458,         -77.56672,          10.61975,           3.33907,

           0.06090,           2.17429,

          -4.32981,          -5.84246,          11.43116,          20.61395,

          -0.65772,           1.28796,

        1224.46687,       -3113.15508,        3798.33409,        -137.28735,
        -256.89302,        2227.35649,        -779.78215,        -260.37372,

          11.73617,         -13.25050,          -0.75248,          -2.87527,

          -8.38102,          17.21321,

      -61784.69616,       39475.02257,      -54086.68308,       54550.85490,
      -16403.69351,       29602.70098,       14672.06363,       16234.17489,
       15702.37109,      -22086.30300,      -22889.89844,       -1245.88352,

           1.48864,          19.75000,           0.78646,           3.29343,

       -1058.13125,        4095.02368,       -2793.78506,        1381.93282,
        -409.19381,        -772.54270,         161.67509,         -34.15910,

        -514.27437,          27.34222,        -311.04046,          48.01030,
         -43.36486,          16.19535,          -0.73816,          -0.81422,

         287.32231,        -110.44135,         200.43610,          37.98170,
          17.73719,          34.40023,          -2.46337,           1.48125,

           0.09042,          -0.11788,

           0.37284,           0.51725,           0.00597,           0.14590,

          -0.01536,           0.00980,

           0.00721,           0.02023,

           0.00027,           0.02451,

          -0.72448,          -0.71371,           0.29322,           0.18359,

           0.72719,          -0.37154,           0.14854,          -0.02530,

           0.23052,           0.04258,

           4.82082,           0.01885,           3.11279,          -0.63338,
           0.10559,          -0.02146,

          -0.01672,           0.03412,

           0.00605,           0.06415,

          -0.89085,           1.51929,          -0.36571,           0.39317,

          12.05250,          -3.79392,           3.96557,          -3.51272,
          -0.17953,          12.30669,

          -0.05083,          -0.11442,

           0.02013,          -0.02837,

          -0.02087,          -0.01599,

           0.49190,           0.30360,           0.01316,           0.17649,

           0.21193,          -0.09149,          -0.07173,          -0.05707,

           4.24196,          -1.25155,           1.81336,           0.68887,
          -0.01675,           0.20772,

          -0.04117,          -0.03531,

          -0.02690,          -0.02766,

          37.54264,          10.95327,           8.05610,          30.58210,
         -12.68257,           1.72831,           0.13466,          -3.27007,

           0.01864,          -0.00595,

           0.03676,           0.14857,          -0.07223,           0.06179,

           0.44878,          -1.64901,         -20.06001,           0.63384,
          -4.97849,           4.78627,          29.87370,           7.29899,

           0.00047,          -0.00155,

           0.00314,           0.01425,

          -0.17842,          -0.08461,

          -1.61020,          -8.47710,           6.85048,          -4.38196,
           1.05809,           2.68088,

          -0.01027,          -0.00833,

           0.06834,          -0.04205,

           0.03330,          -0.01271,

           0.01301,          -0.01358,

           0.03537,           0.03612,           0.02962,           0.62471,
          -0.30400,          -0.64857,

           0.01773,           0.01890,

           0.01426,          -0.00226,

          -0.50957,          -0.01955,          -0.09702,           1.09983,

           0.64387,          -0.02755,

           0.26604,           0.30684,           0.06354,           0.05114,

          -0.00058,          -0.04672,

          -0.00828,           0.00712,

          -0.00440,           0.00029,

          -0.01601,           0.03566,

           0.13398,          -0.02666,

          -0.06752,          -0.43044,           0.07172,          -0.01999,

          -0.01761,          -0.05357,

           0.06104,           0.29742,          -0.08785,           0.05241,

          -6.57162,          -4.20103,           0.03199,          -6.46187,
           1.32846,          -0.51137,

           0.06358,           0.37309,

          -1.46946,           2.34981,

          -0.18712,           0.11618,

         240.62965,        -107.21962,         219.81977,          84.04246,
         -62.22931,          68.35902,          -9.48460,         -32.62906,

           5.57483,          -1.82396,           1.00095,          -0.39774,

           7.87054,          11.45449,

        -432.67155,       55064.72398,       12444.62359,       54215.28871,
        8486.03749,       12297.48243,        -333.27968,        1147.93192,
        1403.73797,         990.40885,          -3.84938,        -722.43963,

          16.83276,          96.48787,           7.04834,          38.22208,
           0.63843,           2.61007,

         230.73221,         171.64166,           1.96751,         287.80846,
         -85.21762,          31.33649,          -2.25739,         -11.28441,

           0.04699,           0.06555,

          -0.08887,           1.70919,           0.09477,           0.26291,

          -0.15490,           0.16009,

           1.93274,           1.01953,           0.36380,           1.29582,
          -0.13911,           0.14169,

          -0.00491,          -0.00030,

          -0.08908,          -0.10216,

          -0.03265,          -0.03889,

           0.40413,          -1.12715,          -0.94687,          -0.04514,

           0.02487,          -0.01048,

           0.39729,           2.82305,          -0.61100,           1.11728,
          -0.13083,          -0.04965,

          -0.00602,          -0.02952,

          -6.13507,          13.73998,         -15.70559,          -1.28059,
           2.64422,          -9.33798,           3.26470,           1.56984,

          -0.00572,           0.09992,

          -8.80458,          -8.23890,         -11.51628,           9.47904,
          11.31646,           4.29587,

          -2.41367,          -0.05883,          -0.80022,          -1.02706,
           0.21461,          -0.06864,

           0.01882,           0.01798,

           0.27614,          -0.01007,           0.04362,           0.07560,
           0.05519,           0.23435,

          -0.09389,           0.01613,

           0.01298,           0.04691,

          -0.02665,          -0.03582,

           0.60080,          -4.28673,           1.87316,          -1.05840,
           0.13248,           0.40887,

          -0.67657,           0.67732,           0.05522,           0.07812,
          -0.17707,          -0.07510,

           0.24885,          10.63974,          -7.40226,          -2.33827,
           2.75463,         -32.51518,

           0.05140,           0.01555,

         180.43808,         263.28252,         384.50646,         -76.53434,
         -93.50706,        -220.50123,         -81.91610,         103.92061,
          30.90305,          -2.89292,

          -0.06634,          -0.37717,          -0.01945,          -0.05936,

          29.27877,         -59.73705,          35.86569,         -18.36556,
           3.88812,           4.82090,          -0.70903,           0.06615,

           0.01558,          -0.01854,

           0.16209,           0.12682,           0.02508,           0.02406,

          -0.03078,          -0.01737,          -0.00033,          -0.00020,

           0.01023,           0.05972,

          -0.03373,          -0.07289,

          -2.08162,          -0.14717,          -0.64233,          -0.75397,
           0.11752,          -0.09202,

           4.42981,          -4.19241,           5.02542,           5.03467,
          -4.22983,           2.80794,

           3.03016,          -2.74373,          -1.11490,          -2.72378,
          -0.63131,           0.74864,

          -0.00759,          -0.00675,

           0.03615,          -0.01806,

          -2.71920,          -1.50954,           0.54479,          -1.92088,
           0.66427,           0.32228,

          -2.55188,          -0.65332,          -2.73798,           2.10182,
           1.54407,           3.01357,

          38.76777,          23.54578,          27.29884,         -14.93005,
          -7.50931,          -5.66773,           0.30142,           1.52416,

           0.00634,           0.09697,          -0.00748,           0.01433,

           0.02936,           0.53228,          -0.03603,           0.06345,

           0.30816,          -1.07925,           0.46709,          -0.21568,
           0.01663,           0.10810,

          -0.42511,           0.35872,          -0.19662,          -6.74031,

           1.05776,           1.86205,           1.08919,           0.10483,
          -0.03368,          -0.21535,

           0.07556,          -0.27104,           0.05142,          -0.03812,

           1.20189,          -1.36782,           1.35764,           1.39387,
          -1.19124,           0.77347,

          -0.54760,          -0.26295,          -0.07473,           0.23043,

           2.82621,          -0.23524,           0.47352,          -0.81672,
          -0.08515,           0.04700,

           0.55355,          -0.40138,           0.22255,           0.12236,

          -0.09110,           0.31982,           0.39404,          -0.17898,

          -0.00056,           0.00014,

          -0.02012,           0.03102,

           0.43236,          -0.10037,          -0.00961,           0.07440,
          -0.07076,          -1.97272,

           0.25555,          -0.21832,          -0.00837,          -0.08393,

           0.01531,           0.00627,

           0.33193,           0.70765,          -0.43556,           0.28542,

          -0.23190,          -0.04293,          -0.08062,           0.13427,

           0.23763,          -0.17092,           0.09259,           0.05155,

           0.08065,          -0.11943,

          -0.02174,          -0.68899,

          -0.01875,          -0.01746,

           0.13604,           0.29280,          -0.17871,           0.11799,

           0.02003,           0.04065,

           0.01343,          -0.06060,

          -0.01290,          -0.26068,

          -0.09033,           0.02649,

          -0.00092,          -0.03094,

          -0.00770,          -0.10447,

          -0.04113,           0.01259,

          -0.00469,          -0.04346,

          -0.00010,           0.06547,

  };
  static final double sattabb[] = {
     -567865.62548,     -796277.29029,     -410804.00791,      -91793.12562,
       -6268.13975,         398.64391,        -710.67442,         175.29456,

          -0.87260,           0.18444,

       -1314.88121,       20709.97394,       -1850.41481,       20670.34255,
        -896.96283,        6597.16433,        -179.80702,         613.45468,
          17.37823,         -13.62177,          -0.36348,          12.34740,

           0.47532,           0.48189,

           0.27162,          -0.20655,

          -0.23268,           0.05992,

          46.94511,          15.78836,          21.57439,          23.11342,
          -0.25862,           5.21410,          -0.22612,          -0.05822,

          -0.00439,          -0.01641,

          -0.01108,          -0.00608,

           0.00957,           0.00272,

          -0.00217,           0.00001,

          -0.00534,          -0.00545,

           0.00277,          -0.00843,

           0.00167,          -0.00794,           0.00032,          -0.00242,

          -0.00002,          -0.00041,

          -0.00025,           0.00031,

           0.00062,          -0.00060,

           0.00083,           0.00032,

           0.00527,          -0.00211,           0.00054,           0.00004,

          -0.02769,          -0.01777,

           0.00247,           0.00097,           0.00020,          -0.00232,

           0.00044,          -0.00035,

          -0.00072,           0.01341,           0.00325,          -0.01159,

           0.00079,          -0.00078,

          -0.00009,           0.00066,

           0.00222,           0.00002,

           0.00013,          -0.00161,

           0.01374,          -0.05305,

           0.00478,          -0.00283,

           0.16033,           0.13859,           0.33288,          -0.16932,

          -0.00316,           0.00625,

          -0.00309,           0.01687,           0.00001,           0.00486,

           0.00401,          -0.01805,          -0.00048,          -0.00407,

          -0.01329,           0.01311,          -0.00591,           0.00166,

           0.00830,           0.00665,

          -0.80207,           0.22994,          -0.34687,           0.08460,
          -0.11499,          -0.01449,

          -0.01574,           0.78813,          -0.03063,           0.28872,
          -0.00337,           0.01801,

          -0.01703,          -0.00929,

          -0.00738,           0.03938,

           0.05616,          -0.00516,

          -3.09497,          30.13091,          -3.14968,          17.62201,
          -0.73728,           2.46962,          -0.11233,           0.03450,

          -0.07837,          -0.01573,

          -0.01595,           0.00394,

           0.00174,           0.01470,

           6.83560,          -2.37594,           4.95125,           3.24711,
           2.44781,           5.17159,           1.99820,          -2.38419,

           0.00840,           0.03614,

          -0.00209,          -0.30407,          -0.02681,          -0.06128,

           1.50134,          11.82856,           4.39644,           6.98850,
          -4.17679,           5.73436,          -9.66087,           1.98221,

          -0.29755,           0.08019,

          -0.24766,          -8.54956,          -1.74494,          -3.36794,
          -0.32661,          -0.00722,

           0.14141,           0.01023,

          -1.21541,          -2.58470,           0.38983,          -1.70307,
           0.31209,          -0.10345,

           0.02593,           0.02178,           0.00289,           0.00393,

          -0.00236,          -0.00373,

          -0.00270,          -0.00049,

          -0.06282,          -0.00443,          -0.02439,          -0.02254,
          -0.02220,           0.03532,

          -0.00072,           0.00010,

          -0.00049,          -0.00112,

           0.00086,           0.00112,

           0.10135,          -0.10972,           0.08357,           0.00155,
           0.04363,          -0.00201,

          -0.01996,          -0.01341,

          -0.00039,          -0.00042,

          -0.00294,           0.00070,

           0.00005,          -0.00027,

           0.00070,          -0.00076,

           0.00234,          -0.00239,

          -0.08365,          -0.08531,          -0.03531,           0.15012,

          -0.01995,          -0.01731,          -0.00370,          -0.00745,

          -0.00315,          -0.00079,

          -0.00120,          -0.00145,

          -0.99404,          -1.31859,           0.03584,          -0.83421,
           0.10720,          -0.05768,

           0.06664,          -0.09338,

          -0.01814,          -0.00003,

          -0.05371,          -0.06458,          -0.00100,          -0.01298,

          -7.08710,         -23.13374,           4.18669,         -19.94756,
           4.85584,          -3.37187,           0.58851,           0.31363,

           0.01994,           0.27494,

          -1.37112,           2.61742,           0.52477,          -0.46520,

          -0.13183,           0.26777,

         836.90400,        -484.65861,         815.99098,         236.54649,
         -32.38814,         288.95705,         -68.17178,         -18.87875,

          -1.79782,          -3.68662,          -1.27310,          -0.65697,

          -3.67530,           2.10471,

      -13758.97795,        4807.62301,      -14582.14552,        9019.73021,
       -3202.60105,        4570.16895,        2078.68911,        2892.62326,
       -2399.35382,        3253.16198,       -8182.38152,       -3588.77680,

          -0.16505,           1.08603,           0.53388,           0.87152,

          61.53677,         538.43813,        -407.32927,         322.27446,
        -148.71585,        -179.37765,          54.07268,         -34.12281,

         -14.76569,         -17.95681,         -10.82061,          -6.39954,
          -2.10954,           0.67063,           0.22607,          -0.43648,

          20.90476,         -45.48667,          30.39436,         -14.20077,
           5.17385,           5.12726,          -0.66319,           0.55668,

           0.02269,          -0.00016,

           0.07811,           0.00111,           0.01603,           0.01020,

          -0.00107,           0.00494,

          -0.00077,          -0.00084,

          -0.00196,           0.00081,

          -0.03776,           0.01286,          -0.00652,          -0.01450,

           0.05942,          -0.08612,           0.01093,          -0.01644,

           0.02147,          -0.00592,

           0.36350,          -0.00201,           0.14419,          -0.10070,
          -0.00491,          -0.01771,

          -0.00053,          -0.00033,

           0.00146,           0.00048,

           0.00582,           0.04423,          -0.00549,           0.00983,

           0.27355,          -0.38057,           0.24001,          -0.05441,
          -0.07706,           0.14269,

          -0.00059,          -0.00154,

          -0.00013,          -0.00088,

          -0.00046,           0.00029,

          -0.00276,          -0.00507,           0.00075,          -0.00076,

           0.01806,           0.00862,          -0.00510,          -0.01364,

          -0.00029,          -0.12664,           0.03899,          -0.03562,
           0.00318,           0.00514,

           0.00057,           0.00201,

           0.00028,           0.00014,

          -0.47022,          -0.74561,           0.40155,          -0.16471,
          -0.18445,           0.34425,          -0.07464,          -0.13709,

          -0.01018,          -0.00748,

          -0.01210,          -0.04274,          -0.00579,          -0.00692,

         -11.09188,          -1.67755,          -6.62063,         -13.84023,
          12.75563,          -6.73501,           8.31662,           5.40196,

           0.00052,           0.00034,

           0.00128,           0.00085,

          -0.02202,          -0.00599,

          -0.33458,          -1.65852,           1.47003,          -1.02434,
           0.87885,           1.15334,

          -0.00241,          -0.00721,

           0.03154,           0.00612,

           0.00318,          -0.02521,

           0.00042,           0.00213,

          -0.01094,           0.05417,          -0.03989,          -0.00567,
           0.00123,          -0.00244,

           0.00108,           0.00242,

          -0.00138,          -0.00099,

           0.04967,           0.01643,          -0.00133,           0.02296,

           0.12207,           0.05584,

           0.00437,          -0.04432,          -0.00176,          -0.00922,

          -0.00252,           0.00326,

          -0.00020,          -0.00050,

          -0.00263,          -0.00084,

          -0.01971,           0.00297,

           0.03076,           0.01736,

          -0.01331,           0.01121,          -0.00675,           0.00340,

          -0.00256,           0.00327,

          -0.00946,           0.03377,          -0.00770,           0.00337,

           0.61383,           0.71128,          -0.02018,           0.62097,
          -0.07247,           0.04418,

          -0.02886,          -0.03848,

          -0.44062,           0.03973,

          -0.00999,          -0.04382,

          57.94459,         117.45112,         -71.22893,         126.39415,
         -62.33152,         -31.90754,          12.17738,         -16.46809,

          -1.13298,           0.08962,          -0.20532,           0.16320,

          -1.55110,          -1.44757,

       -3102.08749,       -7452.61957,       -5009.53858,       -7216.29165,
       -2476.87148,       -1880.58197,        -574.49433,         227.45615,
         144.50228,         379.15791,         225.36130,        -443.47371,

          -8.51989,          -3.75208,          -4.25415,          -1.59741,
          -0.43946,          -0.06595,

         150.42986,           6.54937,          87.67736,          92.32332,
         -21.97187,          29.87097,          -4.21636,          -5.72955,

          -0.03879,          -0.01071,

          -0.45985,           0.02679,          -0.02448,           0.02397,

          -0.06551,          -0.01154,

           1.97905,          -0.82292,           1.10140,           0.30924,
           0.03389,           0.14230,

           0.00003,           0.00119,

          -0.01117,           0.00665,

          -0.00132,          -0.00576,

          -0.08356,           0.08556,          -0.26362,          -0.12450,

           0.00509,           0.00165,

           0.02591,           0.16200,          -0.03318,           0.06463,
          -0.00899,          -0.00462,

           0.00102,           0.00004,

          -0.73102,           0.08299,          -0.52957,          -0.35744,
           0.14119,          -0.24903,           0.20843,           0.14143,

           0.00031,          -0.00234,

          -0.42643,          -2.02084,           1.58848,          -1.57963,
           0.68418,           2.07749,

          -0.45888,           0.19859,          -0.30277,          -0.22591,
           0.11607,          -0.09705,

           0.00040,           0.00431,

          -0.02683,           0.03158,          -0.01302,          -0.00541,
           0.01742,          -0.00006,

          -0.02231,          -0.01128,

          -0.00800,           0.02055,

          -0.00346,           0.00151,

           0.56732,          -0.68995,           0.27701,          -0.16748,
           0.01002,           0.00043,

           0.26916,          -0.57751,           0.15547,          -0.15825,
          -0.02074,          -0.07722,

          -8.23483,          -4.02022,           0.69327,          -5.91543,
           1.72440,           1.02090,

           0.00024,          -0.00053,

          20.03959,          14.79136,          76.43531,         -14.42019,
          -7.82608,         -69.96121,         -54.94229,          23.55140,
          26.60767,          14.68275,

           0.05118,          -0.10401,          -0.00075,          -0.01942,

          -3.84266,         -26.23442,          10.20395,         -14.77139,
           3.40853,           2.07297,          -0.53348,           0.40635,

           0.00716,          -0.00189,

           0.12472,          -0.02903,           0.02254,          -0.00183,

          -0.00175,          -0.01522,           0.00003,          -0.00339,

           0.00383,          -0.00168,

           0.01327,          -0.03657,

          -0.08458,          -0.00115,          -0.03991,          -0.02629,
           0.00243,          -0.00505,

           0.33875,          -0.16744,           0.05183,           0.01744,
          -0.24427,           0.15271,

           0.37550,          -0.17378,           0.09198,          -0.27966,
          -0.22160,           0.16426,

           0.00032,          -0.00310,

          -0.00022,          -0.00144,

          -0.06170,          -0.01195,          -0.00918,           0.02538,
           0.03602,           0.03414,

          -0.14998,          -0.44351,           0.45512,          -0.11766,
           0.35638,           0.27539,

           5.93405,          10.55777,          12.42596,          -1.82530,
          -2.36124,          -6.04176,          -0.98609,           1.67652,

          -0.09271,           0.03448,          -0.01951,           0.00108,

           0.33862,           0.21461,           0.02564,           0.06924,

           0.01126,          -0.01168,          -0.00829,          -0.00740,
           0.00106,          -0.00854,

          -0.08404,           0.02508,          -0.02722,          -0.06537,

           0.01662,           0.11454,           0.06747,           0.00742,
          -0.01975,          -0.02597,

          -0.00097,          -0.01154,           0.00164,          -0.00274,

           0.02954,          -0.05161,          -0.02162,          -0.02069,
          -0.06369,           0.03846,

           0.00219,          -0.01634,          -0.04518,           0.06696,

           1.21537,           0.99500,           0.68376,          -0.28709,
          -0.11397,          -0.06468,

           0.00607,          -0.00744,           0.01531,           0.00975,

          -0.03983,           0.02405,           0.07563,           0.00356,

          -0.00018,          -0.00009,

           0.00172,          -0.00331,

           0.01565,          -0.03466,          -0.00230,           0.00142,
          -0.00788,          -0.01019,

           0.01411,          -0.01456,          -0.00672,          -0.00543,

           0.00059,          -0.00011,

          -0.00661,          -0.00496,          -0.01986,           0.01271,

          -0.01323,          -0.00764,           0.00041,           0.01145,

           0.00378,          -0.00137,           0.00652,           0.00412,

           0.01946,          -0.00573,

          -0.00326,          -0.00257,

          -0.00225,           0.00090,

          -0.00292,          -0.00317,          -0.00719,           0.00468,

           0.00245,           0.00189,

           0.00565,          -0.00330,

          -0.00168,          -0.00047,

          -0.00256,           0.00220,

           0.00180,          -0.00162,

          -0.00085,          -0.00003,

          -0.00100,           0.00098,

          -0.00043,           0.00007,

          -0.00003,          -0.00013,

  };
  static final double sattabr[] = {
      -38127.94034,      -48221.08524,      -20986.93487,       -3422.75861,
          -8.97362,          53.34259,        -404.15708,          -0.05434,

           0.46327,           0.16968,

        -387.16771,        -146.07622,         103.77956,          19.11054,
         -40.21762,         996.16803,        -702.22737,         246.36496,
         -63.89626,        -304.82756,          78.23653,          -2.58314,

          -0.11368,          -0.06541,

          -0.34321,           0.33039,

           0.05652,          -0.16493,

          67.44536,         -29.43578,          50.85074,          18.68861,
           0.39742,          13.64587,          -1.61284,           0.11482,

           0.01668,          -0.01182,

          -0.00386,           0.01025,

           0.00234,          -0.01530,

          -0.02569,          -0.00799,

          -0.00429,          -0.00217,

          -0.00672,           0.00650,

           0.01154,           0.00120,          -0.00515,           0.00125,

           0.00236,          -0.00216,

          -0.00098,           0.00009,

          -0.00460,          -0.00518,

           0.00600,           0.00003,

           0.00834,           0.00095,           0.01967,           0.00637,

          -0.00558,          -0.06911,

          -0.01344,          -0.06589,          -0.05425,          -0.00607,

          -0.00247,          -0.00266,

           0.08790,          -0.08537,          -0.00647,           0.04028,

          -0.00325,           0.00488,

           0.00111,          -0.00044,

          -0.00731,           0.00127,

          -0.00417,           0.00303,

           0.05261,           0.01858,

          -0.00807,           0.01195,

           1.26352,          -0.38591,          -0.34825,           1.10733,

          -0.02815,          -0.02148,

          -0.05083,          -0.04377,          -0.01206,          -0.00586,

           0.03158,          -0.01117,           0.00643,           0.00306,

          -0.01186,          -0.05161,           0.01136,          -0.00976,

          -0.00536,           0.01949,

          -1.41680,          -0.81290,          -0.09254,          -0.24347,
          -0.14831,          -0.34381,

          -2.44464,           0.41202,          -0.99240,          -0.33707,
          -0.01930,          -0.08473,

           0.00830,           0.01165,

          -0.01604,          -0.02439,

           0.00227,           0.04493,

         -42.75310,         -22.65155,          -9.93679,         -18.36179,
           2.73773,           3.24126,          -1.20698,           1.07731,

           0.00434,          -0.10360,

          -0.02359,           0.00054,

          -0.02664,          -0.00122,

         -19.79520,          33.11770,         -53.56452,         -35.41902,
          67.95039,         -82.46551,         117.31843,          14.08609,

           0.06447,           0.03289,

           0.40365,          -0.33397,           0.07079,          -0.09504,

         -30.36873,           6.23538,         -14.25988,         -44.91408,
          38.53146,         -16.31919,           6.99584,          22.47169,

          -0.13313,           0.28016,

           6.83715,          -6.01384,           1.68531,          -3.62443,
          -0.22469,          -0.29718,

           0.25169,           0.13780,

          -3.64824,           1.22420,          -2.48963,          -1.12515,
          -0.01510,          -0.56180,

          -0.03306,           0.01848,          -0.00103,          -0.00077,

          -0.01681,          -0.00227,

          -0.00402,          -0.00287,

           0.04965,          -0.16190,          -0.40025,           0.20734,
           0.15819,          -0.25451,

           0.02467,          -0.00495,

           0.00597,           0.00490,

          -0.01085,          -0.00460,

          -0.71564,          -0.26624,           0.03797,          -0.28263,
           0.03510,           0.30014,

           2.79810,           0.07258,

          -0.01618,           0.00337,

           0.00876,           0.04438,

           0.00742,          -0.00455,

          -0.01163,          -0.00683,

           0.00950,           0.01275,

          -0.02124,          -0.67527,          -0.23635,           0.06298,

          -0.03844,           0.01010,           0.73588,          -0.00271,

           0.01742,          -0.00467,

           0.00017,          -0.00505,

          -0.27482,           5.00521,          -1.92099,           1.55295,
          -0.35919,          -0.09314,

          -0.47002,           0.06826,

           0.07924,           0.16838,

          -0.04221,           0.71510,          -0.16482,           0.08809,

          41.76829,        -125.79427,         106.65271,         -71.30642,
          36.18112,          17.36143,          -1.63846,           5.02215,

          -1.08404,           0.00061,

           2.45567,          -2.42818,          -9.88756,           5.36587,

          -0.61253,          -0.35003,

        1523.54790,         602.82184,          68.66902,        1878.26100,
       -1098.78095,        -120.72600,         127.30918,        -383.96064,

          -7.00838,          -6.09942,          -1.54187,           0.34883,

          -9.47561,          -4.35408,

      -21541.63676,      -32542.09807,      -29720.82604,      -28072.21231,
      -15755.56255,       -8084.58657,       -8148.87315,        7434.89857,
       11033.30133,        7827.94658,         610.18256,      -11411.93624,

          -9.87426,           0.94865,          -1.63656,           0.41275,

        1996.57150,         511.48468,         669.78228,        1363.67610,
        -379.72037,         198.84438,         -16.63126,         -79.37624,

          -2.30776,        -246.07820,         -16.85846,        -148.18168,
          -6.89632,         -20.49587,           0.39892,          -0.34627,

         -57.81309,        -136.96971,          15.25671,         -96.61153,
          16.09785,          -8.79091,           0.70515,           1.16197,

           0.05647,           0.04684,

           0.25032,          -0.19951,           0.07282,          -0.00696,

           0.00493,           0.00733,

          -0.01085,           0.00422,

          -0.01309,           0.00262,

           0.37616,          -0.36203,          -0.11154,           0.18213,

           0.15691,           0.29343,           0.00485,           0.06106,

          -0.01492,           0.09954,

           0.28486,           2.27190,           0.33102,           1.50696,
          -0.01926,           0.04901,

           0.01827,           0.00863,

          -0.03315,           0.00178,

          -0.77600,          -0.48576,          -0.21111,          -0.19485,

           1.90295,           6.44856,           1.71638,           2.12980,
          -7.19585,          -0.08043,

           0.07004,          -0.02764,

           0.01604,           0.01158,

           0.00936,          -0.01199,

           0.18396,          -0.29234,           0.10422,          -0.00720,

           0.05196,           0.10753,           0.02859,          -0.03602,

           0.63828,           1.96280,          -0.31919,           0.85859,
          -0.10218,          -0.00673,

           0.01748,          -0.02190,

           0.01266,          -0.02729,

          -4.80220,           8.90557,          -5.94059,           2.28577,
          -0.19687,          -1.28666,           0.32398,           0.14879,

          -0.02619,          -0.02056,

          -0.04872,          -0.07011,          -0.04082,          -0.04740,

           0.60167,          -2.20365,          -0.27919,          -0.45957,
          -1.31664,          -2.22682,         176.89871,          13.03918,

           0.00568,           0.00560,

           0.01093,           0.00486,

          -0.00948,          -0.31272,

         -11.87638,          -3.68471,          -1.74977,          -9.60468,
           2.94988,          -0.57118,

           0.00307,          -0.01636,

           0.02624,           0.03032,

          -0.00464,          -0.01338,

           0.00935,           0.00530,

          -0.11822,           0.03328,          -0.41854,           0.04331,
           0.41340,          -0.21657,

          -0.00865,           0.00849,

          -0.00374,          -0.00899,

           0.01227,          -0.23462,          -0.71894,          -0.04515,

           0.00047,           0.28112,

          -0.12788,           0.11698,          -0.02030,           0.02759,

           0.02967,          -0.00092,

           0.00454,           0.00565,

          -0.00026,           0.00164,

          -0.01405,          -0.00862,

           0.01088,           0.05589,

           0.18248,          -0.06931,          -0.00011,           0.03713,

           0.01932,          -0.00982,

          -0.13861,           0.09853,          -0.03441,          -0.02492,

           2.26163,          -5.94453,           4.14361,          -0.94105,
           0.39561,           0.75414,

          -0.17642,           0.03724,

          -1.32978,          -0.56610,

          -0.03259,          -0.06752,

          39.07495,          80.25429,         -28.15558,          82.69851,
         -37.53894,         -17.88963,           6.98299,         -13.04691,

          -0.48675,          -1.84530,          -0.07985,          -0.33004,

          -3.39292,           2.73153,

      -17268.46134,        1144.22336,      -16658.48585,        5252.94094,
       -3461.47865,        2910.56452,        -433.49442,        -305.74268,
        -383.45023,         545.16136,         313.83376,          27.00533,

         -31.41075,           7.90570,         -12.40592,           3.01833,
          -0.83334,           0.23404,

          59.26487,        -112.74279,         113.29402,         -15.37579,
          14.03282,          32.74482,          -4.73299,           1.30224,

          -0.00866,           0.01232,

          -0.53797,           0.00238,          -0.07979,           0.04443,

          -0.05617,          -0.05396,

           0.10185,          -1.05476,           0.43791,          -0.32302,
           0.06465,           0.03815,

           0.00028,          -0.00446,

           0.09289,          -0.06389,

           0.01701,          -0.01409,

           0.47101,           0.16158,           0.01036,          -0.39836,

           0.00477,           0.01101,

          -2.06535,           0.33197,          -0.82468,          -0.41414,
           0.03209,          -0.09348,

           0.00843,          -0.00030,

          -9.49517,          -3.82206,           0.66899,         -10.28786,
           6.33435,           1.73684,          -0.98164,           2.25164,

          -0.07577,          -0.00277,

           1.02122,           0.75747,           1.79155,          -0.77789,
          -2.56780,          -2.07807,

           0.19528,           0.77118,          -0.28083,           0.32130,
          -0.04350,          -0.07428,

          -0.01161,           0.01387,

           0.02074,           0.19802,          -0.03600,           0.04922,
          -0.19837,           0.02572,

          -0.00682,          -0.04277,

          -0.01805,           0.00299,

           0.03283,          -0.02099,

           3.57307,           1.17468,           0.65769,           1.88181,
          -0.39215,           0.08415,

          -0.53635,          -0.19087,          -0.12456,           0.02176,
           0.01182,          -0.07941,

          -2.43731,           2.44464,           1.03961,          -1.81936,
          30.33140,           0.92645,

           0.00508,          -0.01771,

         -81.06338,          66.43957,          33.16729,         131.44697,
          76.63344,         -34.34324,         -35.33012,         -28.04413,
          -1.47440,          13.09015,

           0.13253,          -0.01629,           0.02187,          -0.00963,

         -21.47470,          -9.44332,          -7.21711,         -12.59472,
           1.76195,          -1.63911,           0.09060,           0.28656,

           0.00635,           0.00536,

           0.03470,          -0.06493,           0.00666,          -0.01084,

           0.01116,          -0.01612,          -0.00102,           0.00208,

          -0.05568,           0.00628,

           0.02665,          -0.01032,

           0.21261,          -1.90651,           0.72728,          -0.57788,
           0.08662,           0.10918,

           3.39133,           3.97302,          -4.63381,           4.26670,
          -2.50873,          -3.76064,

           1.28114,           1.81919,           1.48064,          -0.37578,
          -0.26209,          -0.47187,

           0.00282,          -0.00499,

           0.01749,           0.03222,

           1.60521,          -1.79705,           1.61453,           0.68886,
          -0.29909,           0.55025,

          -0.07894,           0.19880,          -0.15635,           0.46159,
           2.09769,           1.52742,

          -7.60312,          11.34886,           4.35640,           8.61048,
           2.15001,          -2.15303,          -0.61587,          -0.11950,

          -0.03289,          -0.00520,          -0.00501,          -0.00445,

           0.15294,          -0.05277,           0.02455,           0.00408,

           1.19601,           0.43479,           0.20422,           0.57125,
          -0.12790,           0.01318,

          -0.15275,          -0.43856,           6.99144,          -0.08794,

          -1.69865,           0.82589,          -0.20235,           0.97040,
           0.20903,           0.00675,

           0.26943,           0.08281,           0.03686,           0.05311,

           1.28468,           1.21735,          -1.38174,           1.29570,
          -0.75899,          -1.17168,

           0.44696,          -0.32341,          -0.06378,          -0.27573,

          -0.06406,           0.87186,           0.21069,           0.19724,
           0.00119,          -0.04147,

           0.39279,           0.51437,          -0.11035,           0.21450,

          -0.04309,           0.02359,           0.20490,           0.14210,

           0.00007,          -0.00017,

          -0.03529,          -0.02644,

           0.10710,           0.44476,          -0.02632,          -0.01817,
           2.11335,          -0.04432,

           0.18206,           0.27335,           0.08867,           0.00313,

          -0.00692,           0.01595,

          -0.72957,           0.32080,          -0.29291,          -0.44764,

           0.12767,          -0.05778,           0.04797,          -0.00223,

           0.17661,           0.22427,          -0.04914,           0.09114,

           0.12236,           0.00708,

           0.74315,          -0.01346,

           0.02245,          -0.02555,

          -0.30446,           0.13947,          -0.12340,          -0.18498,

          -0.04099,           0.02103,

           0.06337,          -0.01224,

           0.28181,          -0.01019,

          -0.02794,          -0.09412,

           0.03272,          -0.01095,

           0.11247,          -0.00650,

          -0.01319,          -0.04296,

           0.04653,          -0.00423,

           0.06535,           0.00014,

  };

  static final byte satargs[] = {
  (byte)0,  (byte)7,
  (byte)3,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)5,
  (byte)3,  (byte)1,  (byte)6, (byte)-4,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)5,(byte)-10,  (byte)6,  (byte)3,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6, (byte)-4,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-8,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)5,(byte)-10,  (byte)6,  (byte)7,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)5,(byte)-15,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-6,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)4,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)1,  (byte)7,  (byte)1,
  (byte)1,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)2,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-5,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-6,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-7,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6, (byte)-5,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-7,  (byte)7,  (byte)5,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-2,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-4,  (byte)7,  (byte)4,  (byte)8,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)2,  (byte)8,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)2,  (byte)7,  (byte)1,
  (byte)2,  (byte)2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)7,  (byte)2,
  (byte)2,  (byte)5,  (byte)5,(byte)-12,  (byte)6,  (byte)2,
  (byte)3,  (byte)2,  (byte)6, (byte)-5,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)7,  (byte)5,(byte)-18,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-7,  (byte)6,  (byte)3,
  (byte)3,  (byte)1,  (byte)6,  (byte)1,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)5,  (byte)5,(byte)-13,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)3,
  (byte)3,  (byte)3,  (byte)5, (byte)-9,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)2,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)3,
  (byte)3,  (byte)5,  (byte)5,(byte)-14,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)3,  (byte)7,  (byte)2,
  (byte)2,  (byte)3,  (byte)6, (byte)-7,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)2,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-4,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)7,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)5,(byte)-13,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-4,  (byte)7,  (byte)2,
  (byte)3,  (byte)2,  (byte)6, (byte)-5,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)4,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-2,  (byte)8,  (byte)2,
  (byte)2,  (byte)1,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-2,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)2,  (byte)7,  (byte)1,
  (byte)2,  (byte)1,  (byte)6, (byte)-1,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-6,  (byte)7,  (byte)2,
  (byte)2,  (byte)6,  (byte)5,(byte)-14,  (byte)6,  (byte)0,
  (byte)3,  (byte)3,  (byte)6, (byte)-7,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)2,  (byte)4,  (byte)5, (byte)-9,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)6, (byte)-2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-4,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)6,  (byte)1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)6,  (byte)5,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)3,
  (byte)1,  (byte)3,  (byte)7,  (byte)3,
  (byte)2,  (byte)4,  (byte)5,(byte)-11,  (byte)6,  (byte)3,
  (byte)2,  (byte)1,  (byte)5, (byte)-4,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)2,  (byte)6,  (byte)5,(byte)-16,  (byte)6,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-7,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)6, (byte)-4,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-5,  (byte)7,  (byte)1,
  (byte)3,  (byte)3,  (byte)6, (byte)-6,  (byte)7,  (byte)2,  (byte)8,  (byte)1,
  (byte)3,  (byte)3,  (byte)6, (byte)-7,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-2,  (byte)7,  (byte)2,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)5,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-4,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-1,  (byte)7, (byte)-2,  (byte)8,  (byte)1,
  (byte)2,  (byte)2,  (byte)6, (byte)-2,  (byte)7,  (byte)2,
  (byte)3,  (byte)2,  (byte)6, (byte)-3,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)2,  (byte)7,  (byte)1,
  (byte)2,  (byte)1,  (byte)6,  (byte)1,  (byte)7,  (byte)1,
  (byte)2,  (byte)5,  (byte)5,(byte)-11,  (byte)6,  (byte)2,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-6,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)6,  (byte)1,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-3,  (byte)8,  (byte)1,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)3,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-7,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-1,  (byte)6, (byte)-7,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)2,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-7,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-2,  (byte)6, (byte)-4,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-4,  (byte)7,  (byte)2,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)4,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-2,  (byte)8,  (byte)1,
  (byte)2,  (byte)2,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-2,  (byte)7,  (byte)2,  (byte)8,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-6,  (byte)7,  (byte)1,
  (byte)2,  (byte)6,  (byte)5,(byte)-13,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-2,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)2,  (byte)4,  (byte)5, (byte)-8,  (byte)6,  (byte)2,
  (byte)3,  (byte)3,  (byte)6, (byte)-2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)6, (byte)-4,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6,  (byte)1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)5,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)3,  (byte)7,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)3,
  (byte)3,  (byte)1,  (byte)6,  (byte)4,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)6,  (byte)2,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)5,(byte)-12,  (byte)6,  (byte)2,
  (byte)2,  (byte)5,  (byte)6, (byte)-8,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-5,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-2,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-2,  (byte)7,  (byte)1,
  (byte)3,  (byte)3,  (byte)6, (byte)-3,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)5,(byte)-10,  (byte)6,  (byte)2,
  (byte)3,  (byte)1,  (byte)5,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-5,  (byte)6,  (byte)3,
  (byte)2,  (byte)3,  (byte)6, (byte)-3,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)5,  (byte)2,
  (byte)2,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)2,
  (byte)2,  (byte)5,  (byte)6, (byte)-7,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-4,  (byte)7,  (byte)2,
  (byte)2,  (byte)3,  (byte)6, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)6, (byte)-6,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-7,  (byte)6,  (byte)2,
  (byte)2,  (byte)4,  (byte)6, (byte)-3,  (byte)7,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)6,  (byte)2,
  (byte)3,  (byte)2,  (byte)6, (byte)-9,  (byte)7,  (byte)3,  (byte)8,  (byte)0,
  (byte)1,  (byte)3,  (byte)6,  (byte)4,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)6,  (byte)4,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)5,(byte)-13,  (byte)6,  (byte)1,
  (byte)2,  (byte)6,  (byte)6, (byte)-8,  (byte)7,  (byte)1,
  (byte)2,  (byte)5,  (byte)6, (byte)-5,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-9,  (byte)6,  (byte)2,
  (byte)2,  (byte)3,  (byte)5, (byte)-4,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)5,  (byte)1,  (byte)6,  (byte)2,
  (byte)2,  (byte)6,  (byte)5,(byte)-11,  (byte)6,  (byte)0,
  (byte)3,  (byte)6,  (byte)6, (byte)-7,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-6,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-1,  (byte)6,  (byte)2,
  (byte)1,  (byte)4,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-2,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-9,  (byte)6,  (byte)1,
  (byte)2,  (byte)5,  (byte)5, (byte)-8,  (byte)6,  (byte)2,
  (byte)2,  (byte)3,  (byte)5, (byte)-3,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)5,  (byte)2,  (byte)6,  (byte)2,
  (byte)2,  (byte)6,  (byte)5,(byte)-10,  (byte)6,  (byte)1,
  (byte)2,  (byte)4,  (byte)5, (byte)-5,  (byte)6,  (byte)2,
  (byte)1,  (byte)2,  (byte)5,  (byte)1,
  (byte)1,  (byte)5,  (byte)6,  (byte)2,
  (byte)2,  (byte)5,  (byte)5, (byte)-7,  (byte)6,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-2,  (byte)6,  (byte)1,
  (byte)3,  (byte)1,  (byte)5,  (byte)2,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-4,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5,  (byte)1,  (byte)6,  (byte)1,
  (byte)2,  (byte)7,  (byte)5,(byte)-11,  (byte)6,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-6,  (byte)6,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-1,  (byte)6,  (byte)1,
  (byte)2,  (byte)6,  (byte)5, (byte)-8,  (byte)6,  (byte)1,
  (byte)2,  (byte)4,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)1,  (byte)3,  (byte)5,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-7,  (byte)6,  (byte)1,
  (byte)2,  (byte)7,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-4,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-6,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)5, (byte)-8,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)5, (byte)-7,  (byte)6,  (byte)0,
  (byte)2,  (byte)8,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)2,  (byte)8,  (byte)5, (byte)-8,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)6,  (byte)0,
 (byte)-1
  };
  /* Total terms = 215, small = 211 */
  static Plantbl sat404 = new Plantbl(
                               new short[]{0,  0,  1,  0,  8, 18,  9,  5,  0},
                               (short)7,
                               satargs,
                               sattabl,
                               sattabb,
                               sattabr,
                               9.5575813548599999e+00
  );
}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class SwemptabUra {
  /*
  First date in file = 625296.50
  Number of records = 16731.0
  Days per record = 131.0
        Julian Years      Lon    Lat    Rad
   -3000.0 to  -2499.7:   0.35   0.06   0.42
   -2499.7 to  -1999.7:   0.50   0.06   0.38
   -1999.7 to  -1499.7:   0.39   0.07   0.34
   -1499.7 to   -999.8:   0.34   0.06   0.30
    -999.8 to   -499.8:   0.35   0.05   0.32
    -499.8 to      0.2:   0.32   0.05   0.27
       0.2 to    500.2:   0.26   0.04   0.25
     500.2 to   1000.1:   0.28   0.04   0.25
    1000.1 to   1500.1:   0.26   0.06   0.31
    1500.1 to   2000.1:   0.33   0.05   0.24
    2000.1 to   2500.0:   0.32   0.06   0.26
    2500.0 to   3000.0:   0.34   0.06   0.32
    3000.0 to   3000.4:  0.406  0.035  0.172
  */
  static final double uratabl[] = {
          21.56000,       -4652.06828,   154246324.90417,     1130486.05080,

         330.11531,       -3020.20235,

          -8.03769,        -122.02019,

         212.45130,         254.23866,          25.39758,          60.08296,

        6949.85053,       51951.42606,       -1834.66531,       44481.91144,
       -3267.45825,       10776.65972,        -628.05388,         532.83011,
         -16.80583,         -30.05544,

        1420.33767,        2007.21040,         592.32842,        1541.61732,
        -163.55984,         121.14134,         114.74969,         -16.04944,

           0.06069,           0.00725,

          -0.16861,           0.28785,

           0.07399,          -0.09680,

           0.19936,          -0.41620,

           0.02922,           0.07398,

           0.17272,           0.05602,

           1.65461,          -0.68278,          -2.18745,          -0.85327,
           0.52467,          -0.30863,

           0.01598,           0.30017,

          -0.04190,          -0.03288,

          -0.02013,           0.02257,

          -0.54883,          -0.22701,          -0.09257,          -0.03921,

           0.02644,           0.04667,

           0.24773,          -0.16562,

       44242.85814,     -223163.54065,      123776.84417,     -206375.74884,
       70472.73820,      -27456.55173,        4065.74401,       13202.39154,
       -3260.72648,         802.50579,        -153.13236,        -503.81026,
          30.17812,         -31.91893,

         -65.14719,          77.78417,         -37.38185,          19.13337,
          -3.14043,          -0.21147,

           0.27143,           0.17424,

           0.04458,           0.10976,

          -0.41841,          -0.21887,          -0.09194,          -0.02303,

           0.02896,           0.10044,

           0.01385,           0.01723,

          -0.01126,          -0.09318,

         -57.95890,          29.69059,         -46.41390,           3.07177,
           0.42494,           2.33678,          -3.09621,           0.05256,

          -0.02134,          -0.35202,

          -0.44475,          -0.83135,

        1318.18265,       25605.86848,       -9168.38371,       18917.31507,
       -5145.74480,        2130.77612,        -485.25920,        -438.44867,
          19.97802,         -33.14800,

      -23383.91826,      -45133.19122,      -18520.80729,      -26549.95198,
       -2276.70124,       -2974.01604,         603.23665,         306.87616,
         -87.73070,         -32.49134,

      549975.14525,      261920.31896,      526261.09735,      362619.26839,
      150616.68873,      164643.90808,        9550.02662,       27381.83042,
       -1065.89047,        1024.20231,         -66.63822,         -44.75169,

         -92.10532,         -20.26930,

     -313205.95341,     1462242.64616,      112982.53079,     1865690.41965,
      308844.30901,      639864.93227,       89716.32843,       10378.80773,
        4395.08428,      -14565.35913,       -3016.07754,      -19348.64612,

        3838.36899,       -9813.42713,        6883.58821,       -6064.92588,
        2740.47455,        -176.29547,         241.91895,         268.44181,
          -6.13397,          17.92503,

          -0.01377,          -0.08742,

         387.51915,         257.03872,         152.81792,         221.56197,
         -22.94836,          29.56640,          -2.27801,           4.72805,
          -6.03420,          -0.36763,

           0.00667,           0.00443,

          -0.01405,           0.04658,

          -0.06533,          -0.01966,

           0.10738,           0.00443,

           0.02889,           0.01056,

           0.00900,          -0.02206,

           0.00013,           0.05281,

           0.03035,           0.34793,

           0.19460,           2.47360,

           0.18189,          -0.83895,           0.24983,          15.32050,

           0.46010,           2.79643,

          -0.45793,           0.96707,          -0.31226,           0.51911,
           0.04071,           0.39399,

           0.00038,           0.03854,

           0.22446,           0.13630,          -0.04357,           0.03635,

           0.00202,          -0.04502,

          -0.00458,          -0.03884,

           1.32597,           3.40849,          -1.67839,          -0.95411,

          -1.00116,          -0.72744,          -0.22484,          -0.27682,

          -0.18069,           0.00405,

          -0.01000,           0.27523,

          -0.07038,          -0.01051,

          -0.09064,           0.08518,

           0.02083,          -0.25406,

           0.17745,          -0.00944,

           0.21326,           0.20454,

          18.84894,          -7.64400,           0.62670,         -11.02728,
           8.91329,          20.67190,

           0.17757,          -0.15471,

          -0.11385,          -0.46057,

           6.23014,         -14.46025,           2.30012,          -2.22677,

           5.16823,          -1.64235,

        -274.58413,         833.33247,        -191.26241,         269.90157,
         -17.25965,           9.11368,

        -261.65136,      -18274.45858,       -2553.83872,      -10039.10490,
        -508.52567,         336.18172,          14.88587,         421.35954,
         162.43462,         544.92580,

          -0.44246,           0.23216,

          -0.29024,          -0.13057,

          -1.58438,           0.34032,          -0.31604,          -0.01166,

          -0.07112,           0.05721,

          -0.10813,           0.01064,

          -0.05413,           0.06705,

          -0.41582,          -0.47725,           0.31031,           0.08605,

           0.00409,           0.02373,

           0.08092,           0.06247,          -0.01026,           0.05863,

          -0.00238,           0.02948,

           0.00117,           0.02714,

           0.01720,           0.18261,

          -0.04067,           0.88639,

          -0.15502,          -0.96383,

          -0.05307,          -0.17319,

          -0.00486,          -0.02373,

          -0.14748,          -0.11884,           0.07798,          -0.00358,

           0.01104,           0.00805,

           0.15099,          -0.03453,           0.01846,           0.03459,

           0.02197,           0.07012,

          -0.43677,          -1.87445,           1.35202,           2.28294,

          -0.03592,           0.07679,

           0.16427,           0.03014,           0.02472,           0.05549,

          -0.04985,           0.05874,

           0.35361,           0.01144,          -0.57400,           1.34898,

           0.00265,           0.01540,

           0.00951,           0.08159,

          -0.00435,           0.34759,

          -0.12413,          -0.49848,

          -0.77075,          -2.73810,

         -31.77702,          12.16042,         -14.87605,          11.98287,
          12.69358,           1.31307,          -8.22911,         -21.47437,

          -0.24051,          -0.38332,

          -0.01162,          -0.03175,

           0.00556,           0.02454,

          -0.02297,          -0.01654,

           0.00707,           0.04828,

          -0.00309,           0.17381,

          -0.00500,          -0.07579,

           0.02008,           0.05356,

           0.00702,           0.01133,

          -0.00237,          -0.00612,

           0.18551,           0.22799,          -0.14194,          -0.08593,

           0.00002,          -0.01049,

          -0.17363,          -0.13986,           0.00078,          -0.06993,

          -0.00430,          -0.07795,

          -0.03232,          -4.13170,

           0.00311,           0.05356,

          -0.17324,          -0.15505,          -0.00590,          -0.06608,

           0.04257,          -0.04571,

           0.00501,           0.02141,

          -0.00037,           0.07845,

          -0.00381,          -0.03417,

           0.01834,           0.03349,

           0.07994,           0.15297,

          -0.82299,           0.24672,           0.51764,           0.96379,

           0.01729,           0.02489,

          -0.08581,           0.13252,

           0.00538,           0.01995,

          -0.00148,          -0.02261,

           0.00534,           0.01565,

          -0.07518,          -0.28114,           0.22386,           0.39023,

          -0.00864,           0.00964,

          -0.01923,          -0.02426,

          -0.00112,           0.00923,

          -0.00685,           0.02450,

           0.26733,          -0.99972,          -0.82005,           0.13725,

           0.01520,          -0.00790,

           0.00358,           0.00751,

          -0.00648,          -0.00605,

          -0.04966,          -0.04633,

           0.06394,          -0.01965,

           0.50185,           0.40553,          -0.25809,           0.28853,
           0.52545,          -3.41675,

          -0.00347,          -0.11848,

           0.02945,          -0.01061,

          -0.04160,          -0.03519,

          -0.03234,          -0.81852,

          -0.02156,          -0.00841,

           0.00029,           0.00020,

          -0.02281,          -0.00364,

           0.04738,          -0.04504,

          -0.19161,           0.37225,           0.05765,           0.11987,

           0.00050,           0.02012,

          -0.03806,           0.39498,

           0.29982,           0.00886,           0.01671,          53.04042,

          -0.04160,          -0.38856,

          -0.00174,          -0.01773,

          -0.47661,          -0.32010,          -0.01088,          -0.16231,

          -0.01584,          -0.00144,

           0.06659,           0.12734,

           0.04884,           0.02236,

           0.00146,           0.06030,

          -0.20660,          -0.03982,           0.15091,           1.24562,

          -0.01303,          -0.22426,

          -0.01518,          -0.03922,

          -0.00043,          -0.00047,

           0.02451,           0.04437,

           0.02380,          -0.00189,

          -0.00640,          -0.07114,

          -0.00320,          -0.02491,

          -0.00829,           0.07284,

           0.02846,          -0.28034,

          -0.00268,           0.00256,

          -0.43420,           0.39645,          -0.31053,           1.25916,

          -0.00371,          -0.00651,

          -0.00096,           0.02762,

          -0.00067,          -0.02503,

          -0.01517,           0.03748,

  };
  static final double uratabb[] = {
           0.00000,         107.91527,          83.39404,        -124.29804,

          -7.73277,          -3.99442,

          -0.08328,          -1.74251,

          -9.05659,         -22.88559,          -2.30655,          -4.40259,

        -470.94604,       -3648.43408,         326.28960,       -2972.91303,
         337.37285,        -650.33570,          57.18479,         -18.29130,
           1.13897,           2.70158,

         -13.64388,         -71.88619,           7.36408,         -43.79994,
           6.57463,          -5.81111,          -0.06451,           0.73379,

           0.00574,          -0.01635,

           0.00074,          -0.01496,

          -0.00418,           0.00647,

          -0.00407,           0.00548,

           0.00002,           0.00187,

          -0.00591,           0.00557,

           0.32568,          -0.01574,           0.19347,          -0.01705,
           0.00173,           0.02384,

          -0.00248,          -0.00103,

           0.00227,           0.00146,

           0.00307,          -0.00040,

           0.03886,           0.01987,           0.00546,           0.00345,

           0.00134,          -0.00609,

          -0.01502,          -0.01569,

      -10080.59325,       10806.67752,      -14013.76861,        9928.38683,
       -6540.83480,        2084.91597,       -1093.05006,        -305.34266,
          -9.04558,        -110.32310,           9.26094,          -3.93195,
           0.25552,           0.50327,

         -13.12170,          -4.19317,          -4.50857,          -3.37626,
          -0.26850,          -0.36028,

          -0.00357,           0.05862,

          -0.00828,           0.00926,

          -0.01515,          -0.03687,          -0.00224,          -0.00802,

          -0.00225,          -0.00158,

          -0.00022,          -0.00044,

          -0.00281,           0.00371,

           2.28259,          -4.29888,           1.74622,          -2.13604,
           0.37023,          -0.37022,           0.00886,           0.07081,

           0.01669,           0.00056,

          -0.02020,           0.01586,

       -4255.31929,        5978.03267,       -7264.48027,        1884.12585,
       -2353.93882,       -1593.23001,          17.57205,        -498.54139,
          33.28704,         -13.79498,

      -38416.64883,      -13774.09664,      -32822.03952,       -3983.42726,
       -7538.09822,        1906.66915,        -221.24439,         512.77046,
          32.26101,          12.46483,

      142710.47871,      -96584.83892,      145395.05981,      -86630.96423,
       48202.96749,      -23596.77676,        5286.16967,       -1626.44031,
         -16.53568,          95.15428,         -15.19472,           5.69207,

          -6.72181,           7.28683,

        9515.16142,     -166495.49381,        5588.84271,     -146260.29445,
        2023.55881,      -30687.22422,         243.64741,         971.58076,
         390.73247,        -236.13754,       -2684.56349,         739.81087,

        -597.39429,         474.89313,        -631.69166,         213.04947,
        -204.89515,         -33.09139,         -17.78004,         -22.21866,
           0.61083,          -1.41177,

          -0.00070,          -0.00501,

         -58.24552,          25.27978,         -36.39386,           0.36376,
          -2.21030,          -6.46685,          -0.58473,          -0.09357,
           0.12829,          -0.94855,

           0.00042,           0.00048,

           0.00411,           0.00101,

           0.00249,          -0.00865,

           0.00223,           0.00293,

           0.00041,          -0.00042,

           0.00104,          -0.00086,

           0.00126,          -0.00380,

           0.00906,          -0.02253,

           0.05998,          -0.10318,

           0.00004,          -0.03225,           0.14303,          -0.05273,

           0.32683,           0.09386,

          -0.17053,           0.60847,          -0.06190,           0.28166,
           0.06411,           0.05289,

           0.01138,           0.00128,

          -0.00930,           0.00272,           0.00037,           0.00215,

           0.00004,           0.00050,

           0.00114,          -0.00217,

           0.05358,          -0.06413,          -0.00124,           0.03842,

           0.01006,           0.22479,           0.00412,           0.04040,

           0.01708,           0.02164,

           0.02484,          -0.02463,

          -0.00103,           0.02633,

          -0.01303,          -0.03214,

           0.03613,           0.02205,

          -0.02677,          -0.02522,

          -0.00293,           0.03130,

          -1.87255,          -2.50308,          -1.53715,           0.36859,
          -0.17829,          -1.12095,

          -0.05652,          -0.00786,

          -0.06992,           0.07279,

          -2.95896,           0.55138,          -0.61498,          -0.11008,

          -0.87790,          -0.50965,

         119.73553,         -35.18217,          44.78683,          -4.22438,
           1.95723,           0.58033,

       -4077.02379,        -353.39110,       -2781.63273,         -75.23318,
        -312.50478,         -23.86495,          24.59887,          32.56837,
         120.09593,         -51.00495,

           0.09737,           0.09111,

           0.04799,          -0.05029,

           0.08351,          -0.33726,           0.03158,          -0.06435,

          -0.00523,          -0.01736,

           0.00751,          -0.01757,

          -0.00406,          -0.01198,

           0.16402,          -0.10986,          -0.02024,           0.07205,

          -0.00440,          -0.00072,

          -0.00465,           0.00310,          -0.00121,          -0.00121,

           0.00083,           0.00020,

           0.00140,          -0.00176,

           0.00381,          -0.00731,

          -0.01618,           0.01570,

          -0.10201,           0.05809,

          -0.03359,           0.01024,

          -0.00535,           0.00018,

           0.00024,           0.00509,          -0.00158,          -0.00466,

           0.00009,          -0.00083,

          -0.00700,          -0.00090,          -0.00011,          -0.00079,

           0.00133,          -0.00126,

           0.01416,           0.05553,           0.04283,          -0.06719,

           0.00119,           0.00291,

          -0.00263,           0.01282,          -0.00040,           0.00188,

          -0.00237,           0.00973,

          -0.39533,           0.18773,          -0.79821,          -0.40168,

           0.00151,          -0.00161,

           0.00123,          -0.00516,

          -0.01432,          -0.00293,

          -0.05477,           0.04130,

          -0.48837,           0.18944,

          -0.12552,           9.37098,           1.02045,           5.11382,
           0.72098,          -3.70049,          -5.80982,           3.30105,

          -0.09682,           0.09696,

          -0.00876,           0.00504,

           0.00318,           0.00245,

           0.00563,          -0.00665,

           0.00108,          -0.00233,

          -0.00117,           0.00177,

          -0.00343,           0.00503,

           0.01044,          -0.00651,

           0.00296,          -0.00162,

           0.00037,           0.00028,

          -0.00020,          -0.00786,           0.00029,           0.00836,

           0.00004,           0.00033,

          -0.00309,          -0.00086,          -0.00157,          -0.00086,

          -0.00058,           0.00105,

          -0.04557,           0.01794,

          -0.00122,          -0.00086,

           0.00420,          -0.00285,           0.00118,          -0.00020,

           0.00743,          -0.01217,

           0.00053,          -0.00084,

          -0.00075,           0.00097,

          -0.00107,           0.00314,

           0.00576,          -0.00505,

           0.03624,          -0.02546,

           0.05379,           0.30081,           0.29870,          -0.22106,

           0.00696,          -0.00801,

          -0.03995,          -0.01808,

          -0.00139,           0.00102,

          -0.00059,           0.00138,

           0.00019,          -0.00037,

           0.00274,           0.00658,           0.00672,          -0.01132,

           0.00023,           0.00051,

           0.00031,           0.00090,

          -0.00017,          -0.00001,

           0.00085,           0.00004,

           0.02221,          -0.01977,           0.07498,           0.03025,

          -0.00082,          -0.00022,

          -0.00073,          -0.00028,

          -0.00253,           0.00259,

          -0.01329,           0.01805,

           0.00096,           0.00833,

          -0.11836,           0.04277,          -0.10820,          -0.03018,
           0.34504,           0.09834,

          -0.00538,          -0.00231,

           0.00036,           0.00042,

          -0.00023,           0.00260,

          -0.01137,           0.00036,

           0.01081,          -0.03271,

          -0.00029,          -0.00028,

           0.00018,          -0.00003,

           0.00009,           0.00012,

           0.00127,           0.00343,           0.00100,          -0.00064,

           0.00014,           0.00004,

           0.00150,           0.00069,

          -0.01484,           0.00135,           0.03930,           0.01405,

           0.00064,           0.00029,

           0.00009,           0.00009,

           0.00054,          -0.00048,           0.00019,           0.00005,

          -0.00009,           0.00018,

           0.00192,          -0.00333,

           0.01824,           0.01071,

           0.00107,          -0.00341,

           0.25530,          -0.18414,          -0.84151,          -0.31475,

          -0.00400,          -0.00010,

          -0.00174,           0.00019,

           0.00006,          -0.00079,

           0.00066,          -0.00070,

           0.00599,           0.00330,

          -0.00160,          -0.00013,

          -0.00067,          -0.00006,

          -0.00176,          -0.00111,

           0.00652,           0.00368,

           0.00004,           0.00001,

          -0.00081,           0.00089,           0.00366,           0.00139,

           0.00002,           0.00001,

          -0.01870,          -0.00998,

          -0.00020,          -0.00007,

           0.00005,           0.00003,

  };
  static final double uratabr[] = {
           0.00000,         -53.23277,         -44.70609,         -62.54432,

         -19.15218,           0.10867,

          -1.91911,           1.47517,

          16.51994,           5.00458,           3.88980,           1.55740,

        3598.17109,        1831.07574,        2633.34851,        1775.69482,
         497.10486,         488.77343,           6.03892,          31.08365,
          -2.06585,          -1.12599,

         230.37762,        -113.95449,         162.40244,         -46.57185,
           6.70207,          17.27241,          -0.66092,         -14.42065,

          -0.01044,          -0.00287,

          -0.03894,          -0.01663,

           0.01629,           0.00496,

           0.08411,           0.02855,

           0.01795,          -0.00695,

           0.02426,          -0.03921,

          -0.24495,          -0.77369,          -0.31404,           0.38668,
          -0.05682,          -0.17197,

           0.06145,          -0.00510,

           0.00606,          -0.00886,

          -0.00370,          -0.00588,

           0.02173,          -0.11909,           0.00302,          -0.01796,

          -0.01067,           0.00990,

           0.05283,           0.06517,

       59710.89716,        -491.12783,       58672.38609,       19564.41947,
       10597.99050,       14313.02561,       -2585.52040,         766.78396,
        -138.39893,        -802.43403,         131.35006,         -31.97561,
           7.95978,           8.16075,

          28.72669,          31.72473,           6.45792,          16.50701,
           0.01066,           1.29718,

           0.11565,          -0.13240,

           0.05110,          -0.01543,

          -0.09994,           0.18864,          -0.01330,           0.04148,

           0.03510,          -0.00366,

           0.00604,          -0.00604,

           0.03752,          -0.00256,

          -7.00488,         -21.63748,           1.43064,         -17.10914,
          -0.62987,           0.48719,           0.00697,          -1.22665,

          -0.14435,          -0.00550,

           0.32008,          -0.19855,

      -13976.73731,       -3559.49432,       -7709.90803,       -9310.80334,
         749.31835,       -3491.50696,         540.94979,         -84.57550,
          16.96663,          35.53930,

       37214.64771,      -36361.15845,       21093.74492,      -31855.33076,
        1500.84653,       -7031.97901,        -453.40865,         -18.36692,
          -2.07726,         -17.92336,

      -56348.30507,      378512.71483,     -111444.43340,      370543.95160,
      -61893.70301,      112131.05507,      -11977.44617,        9156.15245,
        -567.61838,        -495.25760,          16.96202,         -44.06279,

           4.24760,         -48.83674,

     -643705.49516,     -131013.09649,     -838580.02217,       67627.11556,
     -288441.70339,      150227.25291,       -2500.57537,       42676.19888,
        7084.60505,        2043.65642,        9639.56835,       -1502.03390,

       -4126.00409,        -828.73564,       -2801.35204,       -2293.77751,
        -209.23365,       -1045.31476,          95.57334,        -102.74623,
           7.19216,           1.89593,

          -0.05661,           0.02166,

         120.38332,        -141.16507,          98.31386,         -40.23448,
          10.84269,          17.57713,           1.69239,           1.45065,
          -0.19626,           2.76108,

          -0.00270,           0.00360,

          -0.02333,          -0.00710,

          -0.01035,           0.02950,

           0.00737,          -0.06311,

          -0.00613,           0.01407,

           0.01377,           0.00879,

          -0.03287,           0.00012,

          -0.21667,           0.01793,

          -1.54865,           0.10953,

           0.54543,           0.12102,          -9.48047,           0.11477,

          -1.34966,           0.23199,

          -1.50834,           0.26567,          -0.64503,           0.10742,
          -0.21452,           0.04428,

          -0.01920,          -0.00906,

          -0.09378,           0.12773,          -0.02787,          -0.03090,

           0.03111,           0.00140,

           0.03771,          -0.01269,

          -1.94794,           1.22823,           0.64183,          -1.11467,

          -0.19301,          -0.27357,           0.05710,          -0.08115,

          -0.07318,           0.00806,

           0.14286,           0.20297,

           0.14920,          -0.07897,

           0.09682,           0.02379,

          -0.13928,           0.01679,

          -0.00774,           0.10060,

           0.24433,           0.16760,

          -2.88905,          -1.61439,           2.83052,          -3.41031,
          36.37048,           3.37867,

           0.29321,           0.09687,

           0.29324,          -0.14651,

           8.11116,           1.79211,           1.36421,           0.88111,

           1.21683,           2.37950,

        -357.76211,         -87.84636,        -117.55745,         -67.18338,
          -5.26029,          -6.27559,

        7509.94562,           3.68942,        4223.62097,       -1041.13557,
         -74.64464,        -251.41613,        -166.22180,          -1.68190,
        -214.55340,          62.79593,

          -0.08250,          -0.15936,

          -0.03830,           0.10857,

           0.21368,           0.50812,           0.00869,           0.09832,

           0.02158,           0.02045,

           0.01407,           0.03591,

           0.03460,           0.01171,

          -0.16400,           0.09751,           0.03521,          -0.12858,

           0.00700,          -0.00524,

           0.01698,          -0.04796,           0.04006,           0.00565,

          -0.02783,          -0.00205,

          -0.02296,           0.00153,

          -0.16139,           0.01514,

          -0.78136,          -0.01546,

           0.40374,          -0.06014,

           0.06212,          -0.01828,

           0.00831,          -0.00173,

           0.06857,          -0.11677,           0.00028,           0.05765,

          -0.00796,           0.00691,

           0.03764,           0.14902,          -0.02653,           0.02122,

          -0.05503,           0.01549,

           1.56630,          -0.35551,          -1.87960,           1.14303,

          -0.06063,          -0.03425,

           0.03367,          -0.11969,           0.04485,          -0.01651,

           0.04647,          -0.02097,

           0.22841,           0.47362,           0.99226,          -0.60660,

          -0.01249,           0.00134,

          -0.07435,           0.00722,

          -0.31796,          -0.00015,

           0.20533,          -0.04398,

           0.93944,          -0.26710,

          -5.60051,          -9.32918,          -5.13538,          -4.05130,
          -0.56529,           4.34112,           7.18308,          -2.66103,

           0.13241,          -0.07999,

           0.01046,          -0.00535,

          -0.04037,          -0.00455,

          -0.00510,           0.00731,

          -0.04576,           0.00513,

          -0.15846,          -0.00236,

           0.04628,          -0.00463,

          -0.01585,           0.00585,

          -0.00213,           0.00283,

           0.00778,          -0.00198,

          -0.17803,           0.18321,           0.07702,          -0.12325,

           0.01091,           0.00349,

           0.14211,          -0.21830,           0.07289,          -0.00994,

           0.07090,          -0.00079,

           4.18441,          -0.07413,

          -0.06247,          -0.00011,

          -0.15453,           0.14499,          -0.06557,          -0.00098,

           0.00290,           0.02921,

          -0.01923,           0.00457,

          -0.07538,          -0.00120,

           0.02263,          -0.00037,

          -0.01061,           0.00591,

          -0.04725,           0.02364,

          -0.07460,          -0.24108,          -0.28310,           0.14643,

          -0.00700,           0.00427,

           0.22963,           0.03713,

          -0.02062,           0.00478,

           0.01434,           0.00095,

          -0.01425,           0.00376,

           0.29611,          -0.08038,          -0.37811,           0.21703,

          -0.00723,          -0.00924,

          -0.02736,           0.01814,

           0.00934,           0.00731,

           0.00613,           0.00686,

          -0.91503,          -0.32009,          -0.15505,           0.79589,

          -0.00555,          -0.01536,

          -0.00698,           0.00480,

           0.00373,          -0.00046,

           0.00715,          -0.00470,

          -0.01970,          -0.05238,

           0.60649,          -0.32669,           0.17790,           0.33383,
          -2.74922,          -0.25827,

          -0.07862,           0.00406,

          -0.00948,          -0.02117,

           0.03127,          -0.04199,

           0.89670,          -0.02413,

           0.01954,           0.03990,

           0.00063,          -0.00071,

          -0.00226,           0.02009,

          -0.04407,          -0.05069,

           0.38230,           0.16101,           0.11893,          -0.06125,

           0.02051,          -0.00046,

           0.39211,           0.03679,

           0.01666,          -0.31336,          53.28735,          -0.01791,

          -0.39414,           0.04181,

          -0.01885,           0.00165,

           0.31349,          -0.47359,           0.16133,          -0.01023,

           0.00007,           0.01758,

          -0.13351,           0.07249,

           0.00977,           0.05445,

           0.11650,          -0.00191,

          -0.09824,           0.40106,           2.41155,          -0.30655,

           0.24975,          -0.01248,

          -0.03688,           0.01097,

           0.00038,          -0.00051,

          -0.04736,           0.02610,

           0.00968,           0.02634,

           0.07918,          -0.00606,

           0.02735,          -0.00320,

          -0.07544,          -0.00468,

           0.19996,          -0.01964,

           0.00201,           0.00267,

           0.39562,           0.43289,           1.24743,           0.31084,

          -0.00666,           0.00377,

           0.05668,           0.00148,

           0.03220,          -0.00026,

           0.03717,           0.01509,

  };

  static byte uraargs[] = {
  (byte)0,  (byte)3,
  (byte)2,  (byte)1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-6,  (byte)8,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)4,
  (byte)2,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)3,
  (byte)3,  (byte)1,  (byte)6, (byte)-1,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)6,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-6,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-7,  (byte)7,  (byte)3,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-8,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-7,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-6,  (byte)7,  (byte)2,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)4,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-2,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-4,  (byte)7,  (byte)3,  (byte)8,  (byte)1,
  (byte)2,  (byte)5,  (byte)7, (byte)-9,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-3,  (byte)8,  (byte)6,
  (byte)2,  (byte)1,  (byte)7, (byte)-3,  (byte)8,  (byte)2,
  (byte)2,  (byte)2,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-6,  (byte)7,  (byte)5,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)6, (byte)-5,  (byte)7,  (byte)3,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)8,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)5,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-5,  (byte)7,  (byte)3,
  (byte)3,  (byte)1,  (byte)6,  (byte)1,  (byte)7, (byte)-9,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-4,  (byte)8,  (byte)4,
  (byte)2,  (byte)1,  (byte)6, (byte)-2,  (byte)7,  (byte)4,
  (byte)2,  (byte)5,  (byte)7, (byte)-8,  (byte)8,  (byte)5,
  (byte)2,  (byte)3,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)7,  (byte)5,
  (byte)2,  (byte)2,  (byte)7, (byte)-6,  (byte)8,  (byte)4,
  (byte)3,  (byte)1,  (byte)6, (byte)-6,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-4,  (byte)7,  (byte)4,
  (byte)3,  (byte)2,  (byte)6, (byte)-5,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-6,  (byte)7,  (byte)3,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-7,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-1,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-9,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-3,  (byte)8,  (byte)1,
  (byte)2,  (byte)2,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)7,  (byte)1,  (byte)8,  (byte)2,
  (byte)1,  (byte)3,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-7,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-4,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-3,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-4,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-5,  (byte)7,  (byte)2,  (byte)8,  (byte)1,
  (byte)3,  (byte)5,  (byte)5, (byte)-9,  (byte)6, (byte)-8,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)6,  (byte)3,  (byte)7, (byte)-8,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-8,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)4,  (byte)7,  (byte)0,
  (byte)3,  (byte)4,  (byte)5,(byte)-10,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-1,  (byte)7,  (byte)2,
  (byte)2,  (byte)8,  (byte)7,(byte)-12,  (byte)8,  (byte)0,
  (byte)2,  (byte)7,  (byte)7,(byte)-10,  (byte)8,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-8,  (byte)8,  (byte)1,
  (byte)2,  (byte)5,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-4,  (byte)8,  (byte)2,
  (byte)1,  (byte)2,  (byte)7,  (byte)4,
  (byte)1,  (byte)4,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-8,  (byte)8,  (byte)1,
  (byte)2,  (byte)3,  (byte)7,(byte)-10,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7,(byte)-12,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-6,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-5,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)6, (byte)-4,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)2,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-9,  (byte)8,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-6,  (byte)7,  (byte)1,
  (byte)3,  (byte)3,  (byte)6, (byte)-7,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-4,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)6,  (byte)1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)6,  (byte)1,
  (byte)2,  (byte)8,  (byte)7,(byte)-10,  (byte)8,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-8,  (byte)8,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)3,  (byte)7,  (byte)3,
  (byte)2,  (byte)2,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-4,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-6,  (byte)7,  (byte)0,
  (byte)2,  (byte)8,  (byte)7, (byte)-9,  (byte)8,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)6, (byte)-4,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-5,  (byte)7,  (byte)1,
  (byte)3,  (byte)3,  (byte)6, (byte)-6,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-2,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-3,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)2,  (byte)7,  (byte)1,
  (byte)2,  (byte)1,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)9,  (byte)7,(byte)-10,  (byte)8,  (byte)0,
  (byte)2,  (byte)8,  (byte)7, (byte)-8,  (byte)8,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)4,  (byte)7,  (byte)1,
  (byte)2,  (byte)3,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)9,  (byte)7, (byte)-9,  (byte)8,  (byte)0,
  (byte)2,  (byte)8,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)6, (byte)-3,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-4,  (byte)7,  (byte)1,
  (byte)3,  (byte)3,  (byte)6, (byte)-5,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)4,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-1,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-2,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)5,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)6, (byte)-4,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)7,  (byte)2,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-6,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5,  (byte)1,  (byte)6, (byte)-4,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-5,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)1,  (byte)6,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)5,  (byte)1,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)1,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-5,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5,  (byte)1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)5,  (byte)1,
  (byte)2,  (byte)4,  (byte)6, (byte)-4,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-5,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)6, (byte)-6,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)6, (byte)-5,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)6, (byte)-6,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-1,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-2,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)1,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-1,  (byte)7,  (byte)0,
 (byte)-1
  };
  /* Total terms = 177, small = 171 */
  static Plantbl ura404 = new Plantbl(
                               new short[]{0,  0,  0,  0,  5, 10,  9, 12,  0},
                               (short)6,
                               uraargs,
                               uratabl,
                               uratabb,
                               uratabr,
                               1.9218446061800002e+01
  );
}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class SwemptabVen {
  /*
  First date in file = 1228000.50
  Number of records = 397276.0
  Days per record = 4.0
        Julian Years      Lon    Lat    Rad
   -1349.9 to  -1000.0:   0.23   0.15   0.10
   -1000.0 to   -500.0:   0.25   0.15   0.10
    -500.0 to      0.0:   0.20   0.13   0.09
       0.0 to    500.0:   0.16   0.11   0.08
     500.0 to   1000.0:   0.19   0.09   0.08
    1000.0 to   1500.0:   0.16   0.09   0.08
    1500.0 to   2000.0:   0.21   0.12   0.08
    2000.0 to   2500.0:   0.28   0.14   0.09
    2500.0 to   3000.0:   0.30   0.15   0.10
    3000.0 to   3000.8:  0.116  0.062  0.058
  */
  static final double ventabl[] = {
           9.08078,          55.42416, 21066413644.98911,      655127.20186,

           0.00329,           0.10408,

           0.00268,          -0.01908,

           0.00653,           0.00183,

           0.15083,          -0.21997,

           6.08596,           2.34841,           3.70668,          -0.22740,
          -2.29376,          -1.46741,

          -0.03840,           0.01242,

           0.00176,           0.00913,

           0.00121,          -0.01222,

          -1.22624,           0.65264,          -1.15974,          -1.28172,
           1.00656,          -0.66266,

           0.01560,          -0.00654,           0.00896,           0.00069,

           0.21649,          -0.01786,

           0.01239,           0.00255,

           0.00084,          -0.06086,

          -0.00041,           0.00887,

           0.13453,          -0.20013,           0.08234,           0.01575,

           0.00658,          -0.00214,

           0.00254,           0.00857,

          -0.01047,          -0.00519,

           0.63215,          -0.40914,           0.34271,          -1.53258,

           0.00038,          -0.01437,

          -0.02599,          -2.27805,          -0.36873,          -1.01799,
          -0.36798,           1.41356,

          -0.08167,           0.01368,           0.20676,           0.06807,

           0.02282,          -0.04691,

           0.30308,          -0.20218,           0.24785,           0.27522,

           0.00197,          -0.00499,

           1.43909,          -0.46154,           0.93459,           2.99583,
          -3.43274,           0.05672,

          -0.06586,           0.12467,           0.02505,          -0.08433,

           0.00743,           0.00174,

          -0.04013,           0.17715,

          -0.00603,          -0.01024,

           0.01542,          -0.02378,

           0.00676,           0.00002,

          -0.00168,          -4.89487,

           0.02393,          -0.03064,

           0.00090,           0.00977,

           0.01223,           0.00381,

           0.28135,          -0.09158,           0.18550,           0.58372,
          -0.67437,           0.01409,

          -0.25404,          -0.06863,

           0.06763,          -0.02939,

          -0.00009,          -0.04888,

           0.01718,          -0.00978,

          -0.01945,           0.08847,

          -0.00135,         -11.29920,

           0.01689,          -0.04756,

           0.02075,          -0.01667,

           0.01397,           0.00443,

          -0.28437,           0.07600,           0.17996,          -0.44326,

           0.29356,           1.41869,          -1.58617,           0.03206,

           0.00229,          -0.00753,

          -0.03076,          -2.96766,

           0.00245,           0.00697,

           0.01063,          -0.02468,

          -0.00351,          -0.18179,

          -0.01088,           0.00380,

           0.00496,           0.02072,

          -0.12890,           0.16719,          -0.06820,          -0.03234,

         -60.36135,         -11.74485,         -11.03752,          -3.80145,
         -21.33955,        -284.54495,        -763.43839,         248.50823,
        1493.02775,        1288.79621,       -2091.10921,       -1851.15420,

          -0.00922,           0.06233,

           0.00004,           0.00785,

           0.10363,          -0.16770,           0.45497,           0.24051,
          -0.28057,           0.61126,

          -0.02057,           0.00010,

           0.00561,           0.01994,

           0.01416,          -0.00442,

           0.03073,          -0.14961,

          -0.06272,           0.08301,

           0.02040,           7.12824,

          -0.00453,          -0.01815,

           0.00004,          -0.00013,

          -0.03593,          -0.18147,           0.20353,          -0.00683,

           0.00003,           0.06226,

          -0.00443,           0.00257,

           0.03194,           0.03254,

           0.00282,          -0.01401,

           0.00422,           1.03169,

          -0.00169,          -0.00591,

          -0.00307,           0.00540,

           0.05511,           0.00347,

           0.07896,           0.06583,

           0.00783,           0.01926,

           0.03109,           0.15967,

           0.00343,           0.88734,

           0.01047,           0.32054,

           0.00814,           0.00051,

           0.02474,           0.00047,

           0.00052,           0.03763,

         -57.06618,          20.34614,         -45.06541,        -115.20465,
         136.46887,         -84.67046,          92.93308,         160.44644,

          -0.00020,          -0.00082,

           0.02496,           0.00279,

           0.00849,           0.00195,

          -0.05013,          -0.04331,

          -0.00136,           0.14491,

          -0.00183,          -0.00406,

           0.01163,           0.00093,

          -0.00604,          -0.00680,

          -0.00036,           0.06861,

          -0.00450,          -0.00969,

           0.00171,           0.00979,

          -0.00152,           0.03929,

           0.00631,           0.00048,

          -0.00709,          -0.00864,

           1.51002,          -0.24657,           1.27338,           2.64699,
          -2.40990,          -0.57413,

          -0.00023,           0.03528,

           0.00268,           0.00522,

          -0.00010,           0.01933,

          -0.00006,           0.01100,

           0.06313,          -0.09939,           0.08571,           0.03206,

          -0.00004,           0.00645,

  };
  static final double ventabb[] = {
         -23.91858,          31.44154,          25.93273,         -67.68643,

          -0.00171,           0.00123,

           0.00001,          -0.00018,

          -0.00005,           0.00018,

          -0.00001,           0.00019,

           0.00733,           0.00030,          -0.00038,           0.00011,
           0.00181,           0.00120,

           0.00010,           0.00002,

          -0.00012,           0.00002,

           0.00021,           0.00004,

          -0.00403,           0.00101,           0.00342,          -0.00328,
           0.01564,           0.01212,

           0.00011,           0.00010,          -0.00002,          -0.00004,

          -0.00524,           0.00079,

           0.00011,           0.00002,

          -0.00001,           0.00003,

           0.00001,           0.00000,

           0.00108,           0.00035,           0.00003,           0.00064,

          -0.00000,          -0.00002,

          -0.00069,           0.00031,

           0.00020,           0.00003,

           0.00768,           0.03697,          -0.07906,           0.01673,

          -0.00003,          -0.00001,

          -0.00198,          -0.01045,           0.01761,          -0.00803,
          -0.00751,           0.04199,

           0.00280,          -0.00213,          -0.00482,          -0.00209,

          -0.01077,           0.00715,

           0.00048,          -0.00004,           0.00199,           0.00237,

           0.00017,          -0.00032,

          -0.07513,          -0.00658,          -0.04213,           0.16065,
           0.27661,           0.06515,

           0.02156,          -0.08144,          -0.23994,          -0.05674,

           0.00167,           0.00069,

           0.00244,          -0.01247,

          -0.00100,           0.00036,

           0.00240,           0.00012,

           0.00010,           0.00018,

           0.00208,          -0.00098,

          -0.00217,           0.00707,

          -0.00338,           0.01260,

          -0.00127,          -0.00039,

          -0.03516,          -0.00544,          -0.01746,           0.08258,
           0.10633,           0.02523,

           0.00077,          -0.00214,

          -0.02335,           0.00976,

          -0.00019,           0.00003,

           0.00041,           0.00039,

           0.00199,          -0.01098,

           0.00813,          -0.00853,

           0.02230,           0.00349,

          -0.02250,           0.08119,

          -0.00214,          -0.00052,

          -0.00220,           0.15216,           0.17152,           0.08051,

          -0.01561,           0.27727,           0.25837,           0.07021,

          -0.00005,          -0.00000,

          -0.02692,          -0.00047,

          -0.00007,          -0.00016,

           0.01072,           0.01418,

          -0.00076,           0.00379,

          -0.00807,           0.03463,

          -0.05199,           0.06680,

          -0.00622,           0.00787,           0.00672,           0.00453,

         -10.69951,         -67.43445,        -183.55956,         -37.87932,
        -102.30497,        -780.40465,        2572.21990,        -446.97798,
        1665.42632,        5698.61327,      -11889.66501,        2814.93799,

           0.03204,          -0.09479,

           0.00014,          -0.00001,

          -0.04118,          -0.04562,           0.03435,          -0.05878,
           0.01700,           0.02566,

          -0.00121,           0.00170,

           0.02390,           0.00403,

           0.04629,           0.01896,

          -0.00521,           0.03215,

          -0.01051,           0.00696,

          -0.01332,          -0.08937,

          -0.00469,          -0.00751,

           0.00016,          -0.00035,

           0.00492,          -0.03930,          -0.04742,          -0.01013,

           0.00065,           0.00021,

          -0.00006,           0.00017,

           0.06768,          -0.01558,

          -0.00055,           0.00322,

          -0.00287,          -0.01656,

           0.00061,          -0.00041,

           0.00030,           0.00047,

          -0.01436,          -0.00148,

           0.30302,          -0.05511,

          -0.00020,          -0.00005,

           0.00042,          -0.00025,

           0.01270,           0.00458,

          -0.00593,          -0.04480,

           0.00005,          -0.00008,

           0.08457,          -0.01569,

           0.00062,           0.00018,

           9.79942,          -2.48836,           4.17423,           6.72044,
         -63.33456,          34.63597,          39.11878,         -72.89581,

          -0.00066,           0.00036,

          -0.00045,          -0.00062,

          -0.00287,          -0.00118,

          -0.21879,           0.03947,

           0.00086,           0.00671,

          -0.00113,           0.00122,

          -0.00193,          -0.00029,

          -0.03612,           0.00635,

           0.00024,           0.00207,

          -0.00273,           0.00443,

          -0.00055,           0.00030,

          -0.00451,           0.00175,

          -0.00110,          -0.00015,

          -0.02608,           0.00480,

           2.16555,          -0.70419,           1.74648,           0.97514,
          -1.15360,           1.73688,

           0.00004,           0.00105,

           0.00187,          -0.00311,

           0.00005,           0.00055,

           0.00004,           0.00032,

          -0.04629,           0.02292,          -0.00363,          -0.03807,

           0.00002,           0.00020,

  };
  static final double ventabr[] = {
          -0.24459,           3.72698,          -6.67281,           5.24378,

           0.00030,           0.00003,

          -0.00002,          -0.00000,

          -0.00000,           0.00001,

           0.00032,           0.00021,

          -0.00326,           0.01002,           0.00067,           0.00653,
           0.00243,          -0.00417,

          -0.00004,          -0.00010,

          -0.00002,          -0.00001,

           0.00004,          -0.00002,

          -0.00638,          -0.01453,           0.01458,          -0.01235,
           0.00755,           0.01030,

           0.00006,           0.00014,           0.00000,           0.00009,

           0.00063,           0.00176,

           0.00003,          -0.00022,

           0.00112,           0.00001,

          -0.00014,          -0.00001,

           0.00485,           0.00322,          -0.00035,           0.00198,

           0.00004,           0.00013,

          -0.00015,          -0.00003,

           0.00011,          -0.00025,

           0.00634,           0.02207,           0.04620,           0.00160,

           0.00045,           0.00001,

          -0.11563,           0.00643,          -0.05947,           0.02018,
           0.07704,           0.01574,

          -0.00090,          -0.00471,          -0.00322,           0.01104,

           0.00265,          -0.00038,

           0.01395,           0.02165,          -0.01948,           0.01713,

          -0.00057,          -0.00019,

           0.04889,           0.13403,          -0.28327,           0.10597,
          -0.02325,          -0.35829,

           0.01171,          -0.00904,           0.00747,           0.02546,

           0.00029,          -0.00190,

          -0.03408,          -0.00703,

           0.00176,          -0.00109,

           0.00463,           0.00293,

           0.00000,           0.00148,

           1.06691,          -0.00054,

          -0.00935,          -0.00790,

           0.00552,          -0.00084,

          -0.00100,           0.00336,

           0.02874,           0.08604,          -0.17876,           0.05973,
          -0.00720,          -0.21195,

           0.02134,          -0.07980,

           0.01500,           0.01398,

           0.01758,          -0.00004,

           0.00371,           0.00650,

          -0.03375,          -0.00723,

           4.65465,          -0.00040,

           0.02040,           0.00707,

          -0.00727,          -0.01144,

          -0.00196,           0.00620,

          -0.03396,          -0.12904,           0.20160,           0.08092,

          -0.67045,           0.14014,          -0.01571,          -0.75141,

           0.00361,           0.00110,

           1.42165,          -0.01499,

          -0.00334,           0.00117,

           0.01187,           0.00507,

           0.08935,          -0.00174,

          -0.00211,          -0.00525,

           0.01035,          -0.00252,

          -0.08355,          -0.06442,           0.01616,          -0.03409,

           5.55241,         -30.62428,           2.03824,          -6.26978,
         143.07279,         -10.24734,        -125.25411,        -380.85360,
        -644.78411,         745.02852,         926.70000,       -1045.09820,

          -0.03124,          -0.00465,

          -0.00396,           0.00002,

           0.08518,           0.05248,          -0.12178,           0.23023,
          -0.30943,          -0.14208,

          -0.00005,          -0.01054,

          -0.00894,           0.00233,

          -0.00173,          -0.00768,

           0.07881,           0.01633,

          -0.04463,          -0.03347,

          -3.92991,           0.00945,

           0.01524,          -0.00422,

          -0.00011,          -0.00005,

           0.10842,          -0.02126,           0.00349,           0.12097,

          -0.03752,           0.00001,

          -0.00156,          -0.00270,

          -0.01520,           0.01349,

           0.00895,           0.00186,

          -0.67751,           0.00180,

           0.00516,          -0.00151,

          -0.00365,          -0.00210,

          -0.00276,           0.03793,

          -0.02637,           0.03235,

          -0.01343,           0.00541,

          -0.11270,           0.02169,

          -0.63365,           0.00122,

          -0.24329,           0.00428,

          -0.00040,           0.00586,

           0.00581,           0.01112,

          -0.02731,           0.00008,

          -2.69091,           0.42729,           2.78805,           3.43849,
          -0.87998,          -6.62373,           0.56882,           4.69370,

           0.00005,          -0.00008,

          -0.00181,           0.01767,

          -0.00168,           0.00660,

           0.01802,          -0.01836,

          -0.11245,          -0.00061,

           0.00199,          -0.00070,

          -0.00076,           0.00919,

           0.00311,          -0.00165,

          -0.05650,          -0.00018,

           0.00121,          -0.00069,

          -0.00803,           0.00146,

          -0.03260,          -0.00072,

          -0.00042,           0.00524,

           0.00464,          -0.00339,

          -0.06203,          -0.00278,           0.04145,           0.02871,
          -0.01962,          -0.01362,

          -0.03040,          -0.00010,

           0.00085,          -0.00001,

          -0.01712,          -0.00006,

          -0.00996,          -0.00003,

          -0.00029,           0.00026,           0.00016,          -0.00005,

          -0.00594,          -0.00003,

  };

  static byte venargs[] = {
  (byte)0,  (byte)3,
  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)2,  (byte)1,  (byte)3, (byte)-8,  (byte)4,  (byte)0,
  (byte)3,  (byte)5,  (byte)1,(byte)-14,  (byte)2,  (byte)2,  (byte)3,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-7,  (byte)3,  (byte)4,  (byte)4,  (byte)0,
  (byte)2,  (byte)8,  (byte)2,(byte)-13,  (byte)3,  (byte)2,
  (byte)3,  (byte)6,  (byte)2,(byte)-10,  (byte)3,  (byte)3,  (byte)5,  (byte)0,
  (byte)1,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-3,  (byte)4,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)1,
  (byte)1,  (byte)1,  (byte)6,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-5,  (byte)3,  (byte)1,  (byte)5,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-5,  (byte)3,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-6,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)1,  (byte)1,  (byte)5,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-5,  (byte)3,  (byte)2,
  (byte)2,  (byte)5,  (byte)2, (byte)-8,  (byte)3,  (byte)1,
  (byte)1,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)1, (byte)-5,  (byte)2,  (byte)1,
  (byte)2,  (byte)6,  (byte)2,(byte)-10,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-3,  (byte)3,  (byte)2,
  (byte)2,  (byte)1,  (byte)2, (byte)-2,  (byte)3,  (byte)1,
  (byte)2,  (byte)4,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-6,  (byte)3,  (byte)0,
  (byte)1,  (byte)1,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-5,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-1,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)1, (byte)-3,  (byte)2,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-4,  (byte)3,  (byte)0,
  (byte)2,  (byte)6,  (byte)2, (byte)-9,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-4,  (byte)3,  (byte)2,
  (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)2,  (byte)0,
  (byte)1,  (byte)1,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-1,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)5,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-2,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-3,  (byte)5,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-3,  (byte)3,  (byte)0,
  (byte)2,  (byte)7,  (byte)2,(byte)-10,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-2,  (byte)5,  (byte)1,
  (byte)2,  (byte)4,  (byte)2, (byte)-5,  (byte)3,  (byte)1,
  (byte)3,  (byte)1,  (byte)2,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-1,  (byte)5,  (byte)0,
  (byte)3,  (byte)1,  (byte)2, (byte)-3,  (byte)5,  (byte)5,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-1,  (byte)6,  (byte)0,
  (byte)1,  (byte)3,  (byte)4,  (byte)0,
  (byte)2,  (byte)7,  (byte)2,(byte)-13,  (byte)3,  (byte)0,
  (byte)3,  (byte)1,  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)1,  (byte)1,  (byte)2,  (byte)5,
  (byte)2,  (byte)9,  (byte)2,(byte)-13,  (byte)3,  (byte)0,
  (byte)3,  (byte)1,  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-3,  (byte)4,  (byte)2,
  (byte)2,  (byte)3,  (byte)2, (byte)-6,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)2,  (byte)1,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-5,  (byte)3,  (byte)0,
  (byte)2,  (byte)6,  (byte)2, (byte)-8,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)1, (byte)-4,  (byte)2,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-3,  (byte)3,  (byte)0,
  (byte)1,  (byte)2,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)5,  (byte)2, (byte)-6,  (byte)3,  (byte)1,
  (byte)2,  (byte)2,  (byte)2, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-5,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-1,  (byte)3,  (byte)0,
  (byte)2,  (byte)7,  (byte)2, (byte)-9,  (byte)3,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-4,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)2,  (byte)1,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)6,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-2,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-3,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-2,  (byte)5,  (byte)0,
  (byte)2,  (byte)5,  (byte)2, (byte)-5,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-1,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-2,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)2,  (byte)3,
  (byte)2,  (byte)2,  (byte)2,  (byte)1,  (byte)5,  (byte)0,
  (byte)2,  (byte)7,  (byte)2, (byte)-8,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)1, (byte)-3,  (byte)2,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-3,  (byte)3,  (byte)0,
  (byte)2,  (byte)6,  (byte)2, (byte)-6,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-1,  (byte)3,  (byte)0,
  (byte)2,  (byte)8,  (byte)2, (byte)-9,  (byte)3,  (byte)0,
  (byte)2,  (byte)5,  (byte)2, (byte)-4,  (byte)3,  (byte)0,
  (byte)2,  (byte)7,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-2,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-3,  (byte)5,  (byte)0,
  (byte)2,  (byte)9,  (byte)2,(byte)-10,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-2,  (byte)5,  (byte)0,
  (byte)1,  (byte)3,  (byte)2,  (byte)2,
  (byte)2,  (byte)8,  (byte)2, (byte)-8,  (byte)3,  (byte)0,
  (byte)2,  (byte)5,  (byte)2, (byte)-3,  (byte)3,  (byte)0,
  (byte)2,  (byte)9,  (byte)2, (byte)-9,  (byte)3,  (byte)0,
  (byte)2, (byte)10,  (byte)2,(byte)-10,  (byte)3,  (byte)0,
  (byte)1,  (byte)4,  (byte)2,  (byte)1,
  (byte)2, (byte)11,  (byte)2,(byte)-11,  (byte)3,  (byte)0,
 (byte)-1
  };
  /* Total terms = 108, small = 107 */
  static Plantbl ven404 = new Plantbl(
                               new short[]{5, 14, 13,  8,  4,  5,  1,  0,  0},
                               (short)5,
                               venargs,
                               ventabl,
                               ventabb,
                               ventabr,
                               7.2332982000000001e-01
                              );
}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following.

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 28rd of April 2006

*/
/* Copyright (C) 1997, 1998 Astrodienst AG, Switzerland.  All rights reserved.
  
  This file is part of Swiss Ephemeris Free Edition.
  
  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.
  
  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class Swenut2000a {
  /* 0.1 microarcsecond to degrees */
  static final double O1MAS2DEG = 1 / 3600.0 / 10000000.0;
  /* Number of terms in the luni-solar nutation model */
  static final int NLS = 678;
  static final int NLS_2000B = 77;
  /* Number of terms in the planetary nutation model */
  static final int NPL = 687;
  /* Luni-Solar argument multipliers
  L L' F D Om */
  static final int nls[] = {
  0, 0, 0, 0, 1,
  0, 0, 2, -2, 2,
  0, 0, 2, 0, 2,
  0, 0, 0, 0, 2,
  0, 1, 0, 0, 0,
  0, 1, 2, -2, 2,
  1, 0, 0, 0, 0,
  0, 0, 2, 0, 1,
  1, 0, 2, 0, 2,
  0, -1, 2, -2, 2,
  0, 0, 2, -2, 1,
  -1, 0, 2, 0, 2,
  -1, 0, 0, 2, 0,
  1, 0, 0, 0, 1,
  -1, 0, 0, 0, 1,
  -1, 0, 2, 2, 2,
  1, 0, 2, 0, 1,
  -2, 0, 2, 0, 1,
  0, 0, 0, 2, 0,
  0, 0, 2, 2, 2,
  0, -2, 2, -2, 2,
  -2, 0, 0, 2, 0,
  2, 0, 2, 0, 2,
  1, 0, 2, -2, 2,
  -1, 0, 2, 0, 1,
  2, 0, 0, 0, 0,
  0, 0, 2, 0, 0,
  0, 1, 0, 0, 1,
  -1, 0, 0, 2, 1,
  0, 2, 2, -2, 2,
  0, 0, -2, 2, 0,
  1, 0, 0, -2, 1,
  0, -1, 0, 0, 1,
  -1, 0, 2, 2, 1,
  0, 2, 0, 0, 0,
  1, 0, 2, 2, 2,
  -2, 0, 2, 0, 0,
  0, 1, 2, 0, 2,
  0, 0, 2, 2, 1,
  0, -1, 2, 0, 2,
  0, 0, 0, 2, 1,
  1, 0, 2, -2, 1,
  2, 0, 2, -2, 2,
  -2, 0, 0, 2, 1,
  2, 0, 2, 0, 1,
  0, -1, 2, -2, 1,
  0, 0, 0, -2, 1,
  -1, -1, 0, 2, 0,
  2, 0, 0, -2, 1,
  1, 0, 0, 2, 0,
  0, 1, 2, -2, 1,
  1, -1, 0, 0, 0,
  -2, 0, 2, 0, 2,
  3, 0, 2, 0, 2,
  0, -1, 0, 2, 0,
  1, -1, 2, 0, 2,
  0, 0, 0, 1, 0,
  -1, -1, 2, 2, 2,
  -1, 0, 2, 0, 0,
  0, -1, 2, 2, 2,
  -2, 0, 0, 0, 1,
  1, 1, 2, 0, 2,
  2, 0, 0, 0, 1,
  -1, 1, 0, 1, 0,
  1, 1, 0, 0, 0,
  1, 0, 2, 0, 0,
  -1, 0, 2, -2, 1,
  1, 0, 0, 0, 2,
  -1, 0, 0, 1, 0,
  0, 0, 2, 1, 2,
  -1, 0, 2, 4, 2,
  -1, 1, 0, 1, 1,
  0, -2, 2, -2, 1,
  1, 0, 2, 2, 1,
  -2, 0, 2, 2, 2,
  -1, 0, 0, 0, 2,
  1, 1, 2, -2, 2,
  -2, 0, 2, 4, 2,
  -1, 0, 4, 0, 2,
  2, 0, 2, -2, 1,
  2, 0, 2, 2, 2,
  1, 0, 0, 2, 1,
  3, 0, 0, 0, 0,
  3, 0, 2, -2, 2,
  0, 0, 4, -2, 2,
  0, 1, 2, 0, 1,
  0, 0, -2, 2, 1,
  0, 0, 2, -2, 3,
  -1, 0, 0, 4, 0,
  2, 0, -2, 0, 1,
  -2, 0, 0, 4, 0,
  -1, -1, 0, 2, 1,
  -1, 0, 0, 1, 1,
  0, 1, 0, 0, 2,
  0, 0, -2, 0, 1,
  0, -1, 2, 0, 1,
  0, 0, 2, -1, 2,
  0, 0, 2, 4, 2,
  -2, -1, 0, 2, 0,
  1, 1, 0, -2, 1,
  -1, 1, 0, 2, 0,
  -1, 1, 0, 1, 2,
  1, -1, 0, 0, 1,
  1, -1, 2, 2, 2,
  -1, 1, 2, 2, 2,
  3, 0, 2, 0, 1,
  0, 1, -2, 2, 0,
  -1, 0, 0, -2, 1,
  0, 1, 2, 2, 2,
  -1, -1, 2, 2, 1,
  0, -1, 0, 0, 2,
  1, 0, 2, -4, 1,
  -1, 0, -2, 2, 0,
  0, -1, 2, 2, 1,
  2, -1, 2, 0, 2,
  0, 0, 0, 2, 2,
  1, -1, 2, 0, 1,
  -1, 1, 2, 0, 2,
  0, 1, 0, 2, 0,
  0, -1, -2, 2, 0,
  0, 3, 2, -2, 2,
  0, 0, 0, 1, 1,
  -1, 0, 2, 2, 0,
  2, 1, 2, 0, 2,
  1, 1, 0, 0, 1,
  1, 1, 2, 0, 1,
  2, 0, 0, 2, 0,
  1, 0, -2, 2, 0,
  -1, 0, 0, 2, 2,
  0, 1, 0, 1, 0,
  0, 1, 0, -2, 1,
  -1, 0, 2, -2, 2,
  0, 0, 0, -1, 1,
  -1, 1, 0, 0, 1,
  1, 0, 2, -1, 2,
  1, -1, 0, 2, 0,
  0, 0, 0, 4, 0,
  1, 0, 2, 1, 2,
  0, 0, 2, 1, 1,
  1, 0, 0, -2, 2,
  -1, 0, 2, 4, 1,
  1, 0, -2, 0, 1,
  1, 1, 2, -2, 1,
  0, 0, 2, 2, 0,
  -1, 0, 2, -1, 1,
  -2, 0, 2, 2, 1,
  4, 0, 2, 0, 2,
  2, -1, 0, 0, 0,
  2, 1, 2, -2, 2,
  0, 1, 2, 1, 2,
  1, 0, 4, -2, 2,
  -1, -1, 0, 0, 1,
  0, 1, 0, 2, 1,
  -2, 0, 2, 4, 1,
  2, 0, 2, 0, 0,
  1, 0, 0, 1, 0,
  -1, 0, 0, 4, 1,
  -1, 0, 4, 0, 1,
  2, 0, 2, 2, 1,
  0, 0, 2, -3, 2,
  -1, -2, 0, 2, 0,
  2, 1, 0, 0, 0,
  0, 0, 4, 0, 2,
  0, 0, 0, 0, 3,
  0, 3, 0, 0, 0,
  0, 0, 2, -4, 1,
  0, -1, 0, 2, 1,
  0, 0, 0, 4, 1,
  -1, -1, 2, 4, 2,
  1, 0, 2, 4, 2,
  -2, 2, 0, 2, 0,
  -2, -1, 2, 0, 1,
  -2, 0, 0, 2, 2,
  -1, -1, 2, 0, 2,
  0, 0, 4, -2, 1,
  3, 0, 2, -2, 1,
  -2, -1, 0, 2, 1,
  1, 0, 0, -1, 1,
  0, -2, 0, 2, 0,
  -2, 0, 0, 4, 1,
  -3, 0, 0, 0, 1,
  1, 1, 2, 2, 2,
  0, 0, 2, 4, 1,
  3, 0, 2, 2, 2,
  -1, 1, 2, -2, 1,
  2, 0, 0, -4, 1,
  0, 0, 0, -2, 2,
  2, 0, 2, -4, 1,
  -1, 1, 0, 2, 1,
  0, 0, 2, -1, 1,
  0, -2, 2, 2, 2,
  2, 0, 0, 2, 1,
  4, 0, 2, -2, 2,
  2, 0, 0, -2, 2,
  0, 2, 0, 0, 1,
  1, 0, 0, -4, 1,
  0, 2, 2, -2, 1,
  -3, 0, 0, 4, 0,
  -1, 1, 2, 0, 1,
  -1, -1, 0, 4, 0,
  -1, -2, 2, 2, 2,
  -2, -1, 2, 4, 2,
  1, -1, 2, 2, 1,
  -2, 1, 0, 2, 0,
  -2, 1, 2, 0, 1,
  2, 1, 0, -2, 1,
  -3, 0, 2, 0, 1,
  -2, 0, 2, -2, 1,
  -1, 1, 0, 2, 2,
  0, -1, 2, -1, 2,
  -1, 0, 4, -2, 2,
  0, -2, 2, 0, 2,
  -1, 0, 2, 1, 2,
  2, 0, 0, 0, 2,
  0, 0, 2, 0, 3,
  -2, 0, 4, 0, 2,
  -1, 0, -2, 0, 1,
  -1, 1, 2, 2, 1,
  3, 0, 0, 0, 1,
  -1, 0, 2, 3, 2,
  2, -1, 2, 0, 1,
  0, 1, 2, 2, 1,
  0, -1, 2, 4, 2,
  2, -1, 2, 2, 2,
  0, 2, -2, 2, 0,
  -1, -1, 2, -1, 1,
  0, -2, 0, 0, 1,
  1, 0, 2, -4, 2,
  1, -1, 0, -2, 1,
  -1, -1, 2, 0, 1,
  1, -1, 2, -2, 2,
  -2, -1, 0, 4, 0,
  -1, 0, 0, 3, 0,
  -2, -1, 2, 2, 2,
  0, 2, 2, 0, 2,
  1, 1, 0, 2, 0,
  2, 0, 2, -1, 2,
  1, 0, 2, 1, 1,
  4, 0, 0, 0, 0,
  2, 1, 2, 0, 1,
  3, -1, 2, 0, 2,
  -2, 2, 0, 2, 1,
  1, 0, 2, -3, 1,
  1, 1, 2, -4, 1,
  -1, -1, 2, -2, 1,
  0, -1, 0, -1, 1,
  0, -1, 0, -2, 1,
  -2, 0, 0, 0, 2,
  -2, 0, -2, 2, 0,
  -1, 0, -2, 4, 0,
  1, -2, 0, 0, 0,
  0, 1, 0, 1, 1,
  -1, 2, 0, 2, 0,
  1, -1, 2, -2, 1,
  1, 2, 2, -2, 2,
  2, -1, 2, -2, 2,
  1, 0, 2, -1, 1,
  2, 1, 2, -2, 1,
  -2, 0, 0, -2, 1,
  1, -2, 2, 0, 2,
  0, 1, 2, 1, 1,
  1, 0, 4, -2, 1,
  -2, 0, 4, 2, 2,
  1, 1, 2, 1, 2,
  1, 0, 0, 4, 0,
  1, 0, 2, 2, 0,
  2, 0, 2, 1, 2,
  3, 1, 2, 0, 2,
  4, 0, 2, 0, 1,
  -2, -1, 2, 0, 0,
  0, 1, -2, 2, 1,
  1, 0, -2, 1, 0,
  0, -1, -2, 2, 1,
  2, -1, 0, -2, 1,
  -1, 0, 2, -1, 2,
  1, 0, 2, -3, 2,
  0, 1, 2, -2, 3,
  0, 0, 2, -3, 1,
  -1, 0, -2, 2, 1,
  0, 0, 2, -4, 2,
  -2, 1, 0, 0, 1,
  -1, 0, 0, -1, 1,
  2, 0, 2, -4, 2,
  0, 0, 4, -4, 4,
  0, 0, 4, -4, 2,
  -1, -2, 0, 2, 1,
  -2, 0, 0, 3, 0,
  1, 0, -2, 2, 1,
  -3, 0, 2, 2, 2,
  -3, 0, 2, 2, 1,
  -2, 0, 2, 2, 0,
  2, -1, 0, 0, 1,
  -2, 1, 2, 2, 2,
  1, 1, 0, 1, 0,
  0, 1, 4, -2, 2,
  -1, 1, 0, -2, 1,
  0, 0, 0, -4, 1,
  1, -1, 0, 2, 1,
  1, 1, 0, 2, 1,
  -1, 2, 2, 2, 2,
  3, 1, 2, -2, 2,
  0, -1, 0, 4, 0,
  2, -1, 0, 2, 0,
  0, 0, 4, 0, 1,
  2, 0, 4, -2, 2,
  -1, -1, 2, 4, 1,
  1, 0, 0, 4, 1,
  1, -2, 2, 2, 2,
  0, 0, 2, 3, 2,
  -1, 1, 2, 4, 2,
  3, 0, 0, 2, 0,
  -1, 0, 4, 2, 2,
  1, 1, 2, 2, 1,
  -2, 0, 2, 6, 2,
  2, 1, 2, 2, 2,
  -1, 0, 2, 6, 2,
  1, 0, 2, 4, 1,
  2, 0, 2, 4, 2,
  1, 1, -2, 1, 0,
  -3, 1, 2, 1, 2,
  2, 0, -2, 0, 2,
  -1, 0, 0, 1, 2,
  -4, 0, 2, 2, 1,
  -1, -1, 0, 1, 0,
  0, 0, -2, 2, 2,
  1, 0, 0, -1, 2,
  0, -1, 2, -2, 3,
  -2, 1, 2, 0, 0,
  0, 0, 2, -2, 4,
  -2, -2, 0, 2, 0,
  -2, 0, -2, 4, 0,
  0, -2, -2, 2, 0,
  1, 2, 0, -2, 1,
  3, 0, 0, -4, 1,
  -1, 1, 2, -2, 2,
  1, -1, 2, -4, 1,
  1, 1, 0, -2, 2,
  -3, 0, 2, 0, 0,
  -3, 0, 2, 0, 2,
  -2, 0, 0, 1, 0,
  0, 0, -2, 1, 0,
  -3, 0, 0, 2, 1,
  -1, -1, -2, 2, 0,
  0, 1, 2, -4, 1,
  2, 1, 0, -4, 1,
  0, 2, 0, -2, 1,
  1, 0, 0, -3, 1,
  -2, 0, 2, -2, 2,
  -2, -1, 0, 0, 1,
  -4, 0, 0, 2, 0,
  1, 1, 0, -4, 1,
  -1, 0, 2, -4, 1,
  0, 0, 4, -4, 1,
  0, 3, 2, -2, 2,
  -3, -1, 0, 4, 0,
  -3, 0, 0, 4, 1,
  1, -1, -2, 2, 0,
  -1, -1, 0, 2, 2,
  1, -2, 0, 0, 1,
  1, -1, 0, 0, 2,
  0, 0, 0, 1, 2,
  -1, -1, 2, 0, 0,
  1, -2, 2, -2, 2,
  0, -1, 2, -1, 1,
  -1, 0, 2, 0, 3,
  1, 1, 0, 0, 2,
  -1, 1, 2, 0, 0,
  1, 2, 0, 0, 0,
  -1, 2, 2, 0, 2,
  -1, 0, 4, -2, 1,
  3, 0, 2, -4, 2,
  1, 2, 2, -2, 1,
  1, 0, 4, -4, 2,
  -2, -1, 0, 4, 1,
  0, -1, 0, 2, 2,
  -2, 1, 0, 4, 0,
  -2, -1, 2, 2, 1,
  2, 0, -2, 2, 0,
  1, 0, 0, 1, 1,
  0, 1, 0, 2, 2,
  1, -1, 2, -1, 2,
  -2, 0, 4, 0, 1,
  2, 1, 0, 0, 1,
  0, 1, 2, 0, 0,
  0, -1, 4, -2, 2,
  0, 0, 4, -2, 4,
  0, 2, 2, 0, 1,
  -3, 0, 0, 6, 0,
  -1, -1, 0, 4, 1,
  1, -2, 0, 2, 0,
  -1, 0, 0, 4, 2,
  -1, -2, 2, 2, 1,
  -1, 0, 0, -2, 2,
  1, 0, -2, -2, 1,
  0, 0, -2, -2, 1,
  -2, 0, -2, 0, 1,
  0, 0, 0, 3, 1,
  0, 0, 0, 3, 0,
  -1, 1, 0, 4, 0,
  -1, -1, 2, 2, 0,
  -2, 0, 2, 3, 2,
  1, 0, 0, 2, 2,
  0, -1, 2, 1, 2,
  3, -1, 0, 0, 0,
  2, 0, 0, 1, 0,
  1, -1, 2, 0, 0,
  0, 0, 2, 1, 0,
  1, 0, 2, 0, 3,
  3, 1, 0, 0, 0,
  3, -1, 2, -2, 2,
  2, 0, 2, -1, 1,
  1, 1, 2, 0, 0,
  0, 0, 4, -1, 2,
  1, 2, 2, 0, 2,
  -2, 0, 0, 6, 0,
  0, -1, 0, 4, 1,
  -2, -1, 2, 4, 1,
  0, -2, 2, 2, 1,
  0, -1, 2, 2, 0,
  -1, 0, 2, 3, 1,
  -2, 1, 2, 4, 2,
  2, 0, 0, 2, 2,
  2, -2, 2, 0, 2,
  -1, 1, 2, 3, 2,
  3, 0, 2, -1, 2,
  4, 0, 2, -2, 1,
  -1, 0, 0, 6, 0,
  -1, -2, 2, 4, 2,
  -3, 0, 2, 6, 2,
  -1, 0, 2, 4, 0,
  3, 0, 0, 2, 1,
  3, -1, 2, 0, 1,
  3, 0, 2, 0, 0,
  1, 0, 4, 0, 2,
  5, 0, 2, -2, 2,
  0, -1, 2, 4, 1,
  2, -1, 2, 2, 1,
  0, 1, 2, 4, 2,
  1, -1, 2, 4, 2,
  3, -1, 2, 2, 2,
  3, 0, 2, 2, 1,
  5, 0, 2, 0, 2,
  0, 0, 2, 6, 2,
  4, 0, 2, 2, 2,
  0, -1, 1, -1, 1,
  -1, 0, 1, 0, 3,
  0, -2, 2, -2, 3,
  1, 0, -1, 0, 1,
  2, -2, 0, -2, 1,
  -1, 0, 1, 0, 2,
  -1, 0, 1, 0, 1,
  -1, -1, 2, -1, 2,
  -2, 2, 0, 2, 2,
  -1, 0, 1, 0, 0,
  -4, 1, 2, 2, 2,
  -3, 0, 2, 1, 1,
  -2, -1, 2, 0, 2,
  1, 0, -2, 1, 1,
  2, -1, -2, 0, 1,
  -4, 0, 2, 2, 0,
  -3, 1, 0, 3, 0,
  -1, 0, -1, 2, 0,
  0, -2, 0, 0, 2,
  0, -2, 0, 0, 2,
  -3, 0, 0, 3, 0,
  -2, -1, 0, 2, 2,
  -1, 0, -2, 3, 0,
  -4, 0, 0, 4, 0,
  2, 1, -2, 0, 1,
  2, -1, 0, -2, 2,
  0, 0, 1, -1, 0,
  -1, 2, 0, 1, 0,
  -2, 1, 2, 0, 2,
  1, 1, 0, -1, 1,
  1, 0, 1, -2, 1,
  0, 2, 0, 0, 2,
  1, -1, 2, -3, 1,
  -1, 1, 2, -1, 1,
  -2, 0, 4, -2, 2,
  -2, 0, 4, -2, 1,
  -2, -2, 0, 2, 1,
  -2, 0, -2, 4, 0,
  1, 2, 2, -4, 1,
  1, 1, 2, -4, 2,
  -1, 2, 2, -2, 1,
  2, 0, 0, -3, 1,
  -1, 2, 0, 0, 1,
  0, 0, 0, -2, 0,
  -1, -1, 2, -2, 2,
  -1, 1, 0, 0, 2,
  0, 0, 0, -1, 2,
  -2, 1, 0, 1, 0,
  1, -2, 0, -2, 1,
  1, 0, -2, 0, 2,
  -3, 1, 0, 2, 0,
  -1, 1, -2, 2, 0,
  -1, -1, 0, 0, 2,
  -3, 0, 0, 2, 0,
  -3, -1, 0, 2, 0,
  2, 0, 2, -6, 1,
  0, 1, 2, -4, 2,
  2, 0, 0, -4, 2,
  -2, 1, 2, -2, 1,
  0, -1, 2, -4, 1,
  0, 1, 0, -2, 2,
  -1, 0, 0, -2, 0,
  2, 0, -2, -2, 1,
  -4, 0, 2, 0, 1,
  -1, -1, 0, -1, 1,
  0, 0, -2, 0, 2,
  -3, 0, 0, 1, 0,
  -1, 0, -2, 1, 0,
  -2, 0, -2, 2, 1,
  0, 0, -4, 2, 0,
  -2, -1, -2, 2, 0,
  1, 0, 2, -6, 1,
  -1, 0, 2, -4, 2,
  1, 0, 0, -4, 2,
  2, 1, 2, -4, 2,
  2, 1, 2, -4, 1,
  0, 1, 4, -4, 4,
  0, 1, 4, -4, 2,
  -1, -1, -2, 4, 0,
  -1, -3, 0, 2, 0,
  -1, 0, -2, 4, 1,
  -2, -1, 0, 3, 0,
  0, 0, -2, 3, 0,
  -2, 0, 0, 3, 1,
  0, -1, 0, 1, 0,
  -3, 0, 2, 2, 0,
  1, 1, -2, 2, 0,
  -1, 1, 0, 2, 2,
  1, -2, 2, -2, 1,
  0, 0, 1, 0, 2,
  0, 0, 1, 0, 1,
  0, 0, 1, 0, 0,
  -1, 2, 0, 2, 1,
  0, 0, 2, 0, 2,
  -2, 0, 2, 0, 2,
  2, 0, 0, -1, 1,
  3, 0, 0, -2, 1,
  1, 0, 2, -2, 3,
  1, 2, 0, 0, 1,
  2, 0, 2, -3, 2,
  -1, 1, 4, -2, 2,
  -2, -2, 0, 4, 0,
  0, -3, 0, 2, 0,
  0, 0, -2, 4, 0,
  -1, -1, 0, 3, 0,
  -2, 0, 0, 4, 2,
  -1, 0, 0, 3, 1,
  2, -2, 0, 0, 0,
  1, -1, 0, 1, 0,
  -1, 0, 0, 2, 0,
  0, -2, 2, 0, 1,
  -1, 0, 1, 2, 1,
  -1, 1, 0, 3, 0,
  -1, -1, 2, 1, 2,
  0, -1, 2, 0, 0,
  -2, 1, 2, 2, 1,
  2, -2, 2, -2, 2,
  1, 1, 0, 1, 1,
  1, 0, 1, 0, 1,
  1, 0, 1, 0, 0,
  0, 2, 0, 2, 0,
  2, -1, 2, -2, 1,
  0, -1, 4, -2, 1,
  0, 0, 4, -2, 3,
  0, 1, 4, -2, 1,
  4, 0, 2, -4, 2,
  2, 2, 2, -2, 2,
  2, 0, 4, -4, 2,
  -1, -2, 0, 4, 0,
  -1, -3, 2, 2, 2,
  -3, 0, 2, 4, 2,
  -3, 0, 2, -2, 1,
  -1, -1, 0, -2, 1,
  -3, 0, 0, 0, 2,
  -3, 0, -2, 2, 0,
  0, 1, 0, -4, 1,
  -2, 1, 0, -2, 1,
  -4, 0, 0, 0, 1,
  -1, 0, 0, -4, 1,
  -3, 0, 0, -2, 1,
  0, 0, 0, 3, 2,
  -1, 1, 0, 4, 1,
  1, -2, 2, 0, 1,
  0, 1, 0, 3, 0,
  -1, 0, 2, 2, 3,
  0, 0, 2, 2, 2,
  -2, 0, 2, 2, 2,
  -1, 1, 2, 2, 0,
  3, 0, 0, 0, 2,
  2, 1, 0, 1, 0,
  2, -1, 2, -1, 2,
  0, 0, 2, 0, 1,
  0, 0, 3, 0, 3,
  0, 0, 3, 0, 2,
  -1, 2, 2, 2, 1,
  -1, 0, 4, 0, 0,
  1, 2, 2, 0, 1,
  3, 1, 2, -2, 1,
  1, 1, 4, -2, 2,
  -2, -1, 0, 6, 0,
  0, -2, 0, 4, 0,
  -2, 0, 0, 6, 1,
  -2, -2, 2, 4, 2,
  0, -3, 2, 2, 2,
  0, 0, 0, 4, 2,
  -1, -1, 2, 3, 2,
  -2, 0, 2, 4, 0,
  2, -1, 0, 2, 1,
  1, 0, 0, 3, 0,
  0, 1, 0, 4, 1,
  0, 1, 0, 4, 0,
  1, -1, 2, 1, 2,
  0, 0, 2, 2, 3,
  1, 0, 2, 2, 2,
  -1, 0, 2, 2, 2,
  -2, 0, 4, 2, 1,
  2, 1, 0, 2, 1,
  2, 1, 0, 2, 0,
  2, -1, 2, 0, 0,
  1, 0, 2, 1, 0,
  0, 1, 2, 2, 0,
  2, 0, 2, 0, 3,
  3, 0, 2, 0, 2,
  1, 0, 2, 0, 2,
  1, 0, 3, 0, 3,
  1, 1, 2, 1, 1,
  0, 2, 2, 2, 2,
  2, 1, 2, 0, 0,
  2, 0, 4, -2, 1,
  4, 1, 2, -2, 2,
  -1, -1, 0, 6, 0,
  -3, -1, 2, 6, 2,
  -1, 0, 0, 6, 1,
  -3, 0, 2, 6, 1,
  1, -1, 0, 4, 1,
  1, -1, 0, 4, 0,
  -2, 0, 2, 5, 2,
  1, -2, 2, 2, 1,
  3, -1, 0, 2, 0,
  1, -1, 2, 2, 0,
  0, 0, 2, 3, 1,
  -1, 1, 2, 4, 1,
  0, 1, 2, 3, 2,
  -1, 0, 4, 2, 1,
  2, 0, 2, 1, 1,
  5, 0, 0, 0, 0,
  2, 1, 2, 1, 2,
  1, 0, 4, 0, 1,
  3, 1, 2, 0, 1,
  3, 0, 4, -2, 2,
  -2, -1, 2, 6, 2,
  0, 0, 0, 6, 0,
  0, -2, 2, 4, 2,
  -2, 0, 2, 6, 1,
  2, 0, 0, 4, 1,
  2, 0, 0, 4, 0,
  2, -2, 2, 2, 2,
  0, 0, 2, 4, 0,
  1, 0, 2, 3, 2,
  4, 0, 0, 2, 0,
  2, 0, 2, 2, 0,
  0, 0, 4, 2, 2,
  4, -1, 2, 0, 2,
  3, 0, 2, 1, 2,
  2, 1, 2, 2, 1,
  4, 1, 2, 0, 2,
  -1, -1, 2, 6, 2,
  -1, 0, 2, 6, 1,
  1, -1, 2, 4, 1,
  1, 1, 2, 4, 2,
  3, 1, 2, 2, 2,
  5, 0, 2, 0, 1,
  2, -1, 2, 4, 2,
  2, 0, 2, 4, 1,
  };

  /* Luni-Solar nutation coefficients, unit 1e-7 arcsec
   * longitude (sin, t*sin, cos), obliquity (cos, t*cos, sin) */
  static final int cls[] = {
  -172064161, -174666, 33386, 92052331, 9086, 15377,
  -13170906, -1675, -13696, 5730336, -3015, -4587,
  -2276413, -234, 2796, 978459, -485, 1374,
  2074554, 207, -698, -897492, 470, -291,
  1475877, -3633, 11817, 73871, -184, -1924,
  -516821, 1226, -524, 224386, -677, -174,
  711159, 73, -872, -6750, 0, 358,
  -387298, -367, 380, 200728, 18, 318,
  -301461, -36, 816, 129025, -63, 367,
  215829, -494, 111, -95929, 299, 132,
  128227, 137, 181, -68982, -9, 39,
  123457, 11, 19, -53311, 32, -4,
  156994, 10, -168, -1235, 0, 82,
  63110, 63, 27, -33228, 0, -9,
  -57976, -63, -189, 31429, 0, -75,
  -59641, -11, 149, 25543, -11, 66,
  -51613, -42, 129, 26366, 0, 78,
  45893, 50, 31, -24236, -10, 20,
  63384, 11, -150, -1220, 0, 29,
  -38571, -1, 158, 16452, -11, 68,
  32481, 0, 0, -13870, 0, 0,
  -47722, 0, -18, 477, 0, -25,
  -31046, -1, 131, 13238, -11, 59,
  28593, 0, -1, -12338, 10, -3,
  20441, 21, 10, -10758, 0, -3,
  29243, 0, -74, -609, 0, 13,
  25887, 0, -66, -550, 0, 11,
  -14053, -25, 79, 8551, -2, -45,
  15164, 10, 11, -8001, 0, -1,
  -15794, 72, -16, 6850, -42, -5,
  21783, 0, 13, -167, 0, 13,
  -12873, -10, -37, 6953, 0, -14,
  -12654, 11, 63, 6415, 0, 26,
  -10204, 0, 25, 5222, 0, 15,
  16707, -85, -10, 168, -1, 10,
  -7691, 0, 44, 3268, 0, 19,
  -11024, 0, -14, 104, 0, 2,
  7566, -21, -11, -3250, 0, -5,
  -6637, -11, 25, 3353, 0, 14,
  -7141, 21, 8, 3070, 0, 4,
  -6302, -11, 2, 3272, 0, 4,
  5800, 10, 2, -3045, 0, -1,
  6443, 0, -7, -2768, 0, -4,
  -5774, -11, -15, 3041, 0, -5,
  -5350, 0, 21, 2695, 0, 12,
  -4752, -11, -3, 2719, 0, -3,
  -4940, -11, -21, 2720, 0, -9,
  7350, 0, -8, -51, 0, 4,
  4065, 0, 6, -2206, 0, 1,
  6579, 0, -24, -199, 0, 2,
  3579, 0, 5, -1900, 0, 1,
  4725, 0, -6, -41, 0, 3,
  -3075, 0, -2, 1313, 0, -1,
  -2904, 0, 15, 1233, 0, 7,
  4348, 0, -10, -81, 0, 2,
  -2878, 0, 8, 1232, 0, 4,
  -4230, 0, 5, -20, 0, -2,
  -2819, 0, 7, 1207, 0, 3,
  -4056, 0, 5, 40, 0, -2,
  -2647, 0, 11, 1129, 0, 5,
  -2294, 0, -10, 1266, 0, -4,
  2481, 0, -7, -1062, 0, -3,
  2179, 0, -2, -1129, 0, -2,
  3276, 0, 1, -9, 0, 0,
  -3389, 0, 5, 35, 0, -2,
  3339, 0, -13, -107, 0, 1,
  -1987, 0, -6, 1073, 0, -2,
  -1981, 0, 0, 854, 0, 0,
  4026, 0, -353, -553, 0, -139,
  1660, 0, -5, -710, 0, -2,
  -1521, 0, 9, 647, 0, 4,
  1314, 0, 0, -700, 0, 0,
  -1283, 0, 0, 672, 0, 0,
  -1331, 0, 8, 663, 0, 4,
  1383, 0, -2, -594, 0, -2,
  1405, 0, 4, -610, 0, 2,
  1290, 0, 0, -556, 0, 0,
  -1214, 0, 5, 518, 0, 2,
  1146, 0, -3, -490, 0, -1,
  1019, 0, -1, -527, 0, -1,
  -1100, 0, 9, 465, 0, 4,
  -970, 0, 2, 496, 0, 1,
  1575, 0, -6, -50, 0, 0,
  934, 0, -3, -399, 0, -1,
  922, 0, -1, -395, 0, -1,
  815, 0, -1, -422, 0, -1,
  834, 0, 2, -440, 0, 1,
  1248, 0, 0, -170, 0, 1,
  1338, 0, -5, -39, 0, 0,
  716, 0, -2, -389, 0, -1,
  1282, 0, -3, -23, 0, 1,
  742, 0, 1, -391, 0, 0,
  1020, 0, -25, -495, 0, -10,
  715, 0, -4, -326, 0, 2,
  -666, 0, -3, 369, 0, -1,
  -667, 0, 1, 346, 0, 1,
  -704, 0, 0, 304, 0, 0,
  -694, 0, 5, 294, 0, 2,
  -1014, 0, -1, 4, 0, -1,
  -585, 0, -2, 316, 0, -1,
  -949, 0, 1, 8, 0, -1,
  -595, 0, 0, 258, 0, 0,
  528, 0, 0, -279, 0, 0,
  -590, 0, 4, 252, 0, 2,
  570, 0, -2, -244, 0, -1,
  -502, 0, 3, 250, 0, 2,
  -875, 0, 1, 29, 0, 0,
  -492, 0, -3, 275, 0, -1,
  535, 0, -2, -228, 0, -1,
  -467, 0, 1, 240, 0, 1,
  591, 0, 0, -253, 0, 0,
  -453, 0, -1, 244, 0, -1,
  766, 0, 1, 9, 0, 0,
  -446, 0, 2, 225, 0, 1,
  -488, 0, 2, 207, 0, 1,
  -468, 0, 0, 201, 0, 0,
  -421, 0, 1, 216, 0, 1,
  463, 0, 0, -200, 0, 0,
  -673, 0, 2, 14, 0, 0,
  658, 0, 0, -2, 0, 0,
  -438, 0, 0, 188, 0, 0,
  -390, 0, 0, 205, 0, 0,
  639, -11, -2, -19, 0, 0,
  412, 0, -2, -176, 0, -1,
  -361, 0, 0, 189, 0, 0,
  360, 0, -1, -185, 0, -1,
  588, 0, -3, -24, 0, 0,
  -578, 0, 1, 5, 0, 0,
  -396, 0, 0, 171, 0, 0,
  565, 0, -1, -6, 0, 0,
  -335, 0, -1, 184, 0, -1,
  357, 0, 1, -154, 0, 0,
  321, 0, 1, -174, 0, 0,
  -301, 0, -1, 162, 0, 0,
  -334, 0, 0, 144, 0, 0,
  493, 0, -2, -15, 0, 0,
  494, 0, -2, -19, 0, 0,
  337, 0, -1, -143, 0, -1,
  280, 0, -1, -144, 0, 0,
  309, 0, 1, -134, 0, 0,
  -263, 0, 2, 131, 0, 1,
  253, 0, 1, -138, 0, 0,
  245, 0, 0, -128, 0, 0,
  416, 0, -2, -17, 0, 0,
  -229, 0, 0, 128, 0, 0,
  231, 0, 0, -120, 0, 0,
  -259, 0, 2, 109, 0, 1,
  375, 0, -1, -8, 0, 0,
  252, 0, 0, -108, 0, 0,
  -245, 0, 1, 104, 0, 0,
  243, 0, -1, -104, 0, 0,
  208, 0, 1, -112, 0, 0,
  199, 0, 0, -102, 0, 0,
  -208, 0, 1, 105, 0, 0,
  335, 0, -2, -14, 0, 0,
  -325, 0, 1, 7, 0, 0,
  -187, 0, 0, 96, 0, 0,
  197, 0, -1, -100, 0, 0,
  -192, 0, 2, 94, 0, 1,
  -188, 0, 0, 83, 0, 0,
  276, 0, 0, -2, 0, 0,
  -286, 0, 1, 6, 0, 0,
  186, 0, -1, -79, 0, 0,
  -219, 0, 0, 43, 0, 0,
  276, 0, 0, 2, 0, 0,
  -153, 0, -1, 84, 0, 0,
  -156, 0, 0, 81, 0, 0,
  -154, 0, 1, 78, 0, 0,
  -174, 0, 1, 75, 0, 0,
  -163, 0, 2, 69, 0, 1,
  -228, 0, 0, 1, 0, 0,
  91, 0, -4, -54, 0, -2,
  175, 0, 0, -75, 0, 0,
  -159, 0, 0, 69, 0, 0,
  141, 0, 0, -72, 0, 0,
  147, 0, 0, -75, 0, 0,
  -132, 0, 0, 69, 0, 0,
  159, 0, -28, -54, 0, 11,
  213, 0, 0, -4, 0, 0,
  123, 0, 0, -64, 0, 0,
  -118, 0, -1, 66, 0, 0,
  144, 0, -1, -61, 0, 0,
  -121, 0, 1, 60, 0, 0,
  -134, 0, 1, 56, 0, 1,
  -105, 0, 0, 57, 0, 0,
  -102, 0, 0, 56, 0, 0,
  120, 0, 0, -52, 0, 0,
  101, 0, 0, -54, 0, 0,
  -113, 0, 0, 59, 0, 0,
  -106, 0, 0, 61, 0, 0,
  -129, 0, 1, 55, 0, 0,
  -114, 0, 0, 57, 0, 0,
  113, 0, -1, -49, 0, 0,
  -102, 0, 0, 44, 0, 0,
  -94, 0, 0, 51, 0, 0,
  -100, 0, -1, 56, 0, 0,
  87, 0, 0, -47, 0, 0,
  161, 0, 0, -1, 0, 0,
  96, 0, 0, -50, 0, 0,
  151, 0, -1, -5, 0, 0,
  -104, 0, 0, 44, 0, 0,
  -110, 0, 0, 48, 0, 0,
  -100, 0, 1, 50, 0, 0,
  92, 0, -5, 12, 0, -2,
  82, 0, 0, -45, 0, 0,
  82, 0, 0, -45, 0, 0,
  -78, 0, 0, 41, 0, 0,
  -77, 0, 0, 43, 0, 0,
  2, 0, 0, 54, 0, 0,
  94, 0, 0, -40, 0, 0,
  -93, 0, 0, 40, 0, 0,
  -83, 0, 10, 40, 0, -2,
  83, 0, 0, -36, 0, 0,
  -91, 0, 0, 39, 0, 0,
  128, 0, 0, -1, 0, 0,
  -79, 0, 0, 34, 0, 0,
  -83, 0, 0, 47, 0, 0,
  84, 0, 0, -44, 0, 0,
  83, 0, 0, -43, 0, 0,
  91, 0, 0, -39, 0, 0,
  -77, 0, 0, 39, 0, 0,
  84, 0, 0, -43, 0, 0,
  -92, 0, 1, 39, 0, 0,
  -92, 0, 1, 39, 0, 0,
  -94, 0, 0, 0, 0, 0,
  68, 0, 0, -36, 0, 0,
  -61, 0, 0, 32, 0, 0,
  71, 0, 0, -31, 0, 0,
  62, 0, 0, -34, 0, 0,
  -63, 0, 0, 33, 0, 0,
  -73, 0, 0, 32, 0, 0,
  115, 0, 0, -2, 0, 0,
  -103, 0, 0, 2, 0, 0,
  63, 0, 0, -28, 0, 0,
  74, 0, 0, -32, 0, 0,
  -103, 0, -3, 3, 0, -1,
  -69, 0, 0, 30, 0, 0,
  57, 0, 0, -29, 0, 0,
  94, 0, 0, -4, 0, 0,
  64, 0, 0, -33, 0, 0,
  -63, 0, 0, 26, 0, 0,
  -38, 0, 0, 20, 0, 0,
  -43, 0, 0, 24, 0, 0,
  -45, 0, 0, 23, 0, 0,
  47, 0, 0, -24, 0, 0,
  -48, 0, 0, 25, 0, 0,
  45, 0, 0, -26, 0, 0,
  56, 0, 0, -25, 0, 0,
  88, 0, 0, 2, 0, 0,
  -75, 0, 0, 0, 0, 0,
  85, 0, 0, 0, 0, 0,
  49, 0, 0, -26, 0, 0,
  -74, 0, -3, -1, 0, -1,
  -39, 0, 0, 21, 0, 0,
  45, 0, 0, -20, 0, 0,
  51, 0, 0, -22, 0, 0,
  -40, 0, 0, 21, 0, 0,
  41, 0, 0, -21, 0, 0,
  -42, 0, 0, 24, 0, 0,
  -51, 0, 0, 22, 0, 0,
  -42, 0, 0, 22, 0, 0,
  39, 0, 0, -21, 0, 0,
  46, 0, 0, -18, 0, 0,
  -53, 0, 0, 22, 0, 0,
  82, 0, 0, -4, 0, 0,
  81, 0, -1, -4, 0, 0,
  47, 0, 0, -19, 0, 0,
  53, 0, 0, -23, 0, 0,
  -45, 0, 0, 22, 0, 0,
  -44, 0, 0, -2, 0, 0,
  -33, 0, 0, 16, 0, 0,
  -61, 0, 0, 1, 0, 0,
  28, 0, 0, -15, 0, 0,
  -38, 0, 0, 19, 0, 0,
  -33, 0, 0, 21, 0, 0,
  -60, 0, 0, 0, 0, 0,
  48, 0, 0, -10, 0, 0,
  27, 0, 0, -14, 0, 0,
  38, 0, 0, -20, 0, 0,
  31, 0, 0, -13, 0, 0,
  -29, 0, 0, 15, 0, 0,
  28, 0, 0, -15, 0, 0,
  -32, 0, 0, 15, 0, 0,
  45, 0, 0, -8, 0, 0,
  -44, 0, 0, 19, 0, 0,
  28, 0, 0, -15, 0, 0,
  -51, 0, 0, 0, 0, 0,
  -36, 0, 0, 20, 0, 0,
  44, 0, 0, -19, 0, 0,
  26, 0, 0, -14, 0, 0,
  -60, 0, 0, 2, 0, 0,
  35, 0, 0, -18, 0, 0,
  -27, 0, 0, 11, 0, 0,
  47, 0, 0, -1, 0, 0,
  36, 0, 0, -15, 0, 0,
  -36, 0, 0, 20, 0, 0,
  -35, 0, 0, 19, 0, 0,
  -37, 0, 0, 19, 0, 0,
  32, 0, 0, -16, 0, 0,
  35, 0, 0, -14, 0, 0,
  32, 0, 0, -13, 0, 0,
  65, 0, 0, -2, 0, 0,
  47, 0, 0, -1, 0, 0,
  32, 0, 0, -16, 0, 0,
  37, 0, 0, -16, 0, 0,
  -30, 0, 0, 15, 0, 0,
  -32, 0, 0, 16, 0, 0,
  -31, 0, 0, 13, 0, 0,
  37, 0, 0, -16, 0, 0,
  31, 0, 0, -13, 0, 0,
  49, 0, 0, -2, 0, 0,
  32, 0, 0, -13, 0, 0,
  23, 0, 0, -12, 0, 0,
  -43, 0, 0, 18, 0, 0,
  26, 0, 0, -11, 0, 0,
  -32, 0, 0, 14, 0, 0,
  -29, 0, 0, 14, 0, 0,
  -27, 0, 0, 12, 0, 0,
  30, 0, 0, 0, 0, 0,
  -11, 0, 0, 5, 0, 0,
  -21, 0, 0, 10, 0, 0,
  -34, 0, 0, 15, 0, 0,
  -10, 0, 0, 6, 0, 0,
  -36, 0, 0, 0, 0, 0,
  -9, 0, 0, 4, 0, 0,
  -12, 0, 0, 5, 0, 0,
  -21, 0, 0, 5, 0, 0,
  -29, 0, 0, -1, 0, 0,
  -15, 0, 0, 3, 0, 0,
  -20, 0, 0, 0, 0, 0,
  28, 0, 0, 0, 0, -2,
  17, 0, 0, 0, 0, 0,
  -22, 0, 0, 12, 0, 0,
  -14, 0, 0, 7, 0, 0,
  24, 0, 0, -11, 0, 0,
  11, 0, 0, -6, 0, 0,
  14, 0, 0, -6, 0, 0,
  24, 0, 0, 0, 0, 0,
  18, 0, 0, -8, 0, 0,
  -38, 0, 0, 0, 0, 0,
  -31, 0, 0, 0, 0, 0,
  -16, 0, 0, 8, 0, 0,
  29, 0, 0, 0, 0, 0,
  -18, 0, 0, 10, 0, 0,
  -10, 0, 0, 5, 0, 0,
  -17, 0, 0, 10, 0, 0,
  9, 0, 0, -4, 0, 0,
  16, 0, 0, -6, 0, 0,
  22, 0, 0, -12, 0, 0,
  20, 0, 0, 0, 0, 0,
  -13, 0, 0, 6, 0, 0,
  -17, 0, 0, 9, 0, 0,
  -14, 0, 0, 8, 0, 0,
  0, 0, 0, -7, 0, 0,
  14, 0, 0, 0, 0, 0,
  19, 0, 0, -10, 0, 0,
  -34, 0, 0, 0, 0, 0,
  -20, 0, 0, 8, 0, 0,
  9, 0, 0, -5, 0, 0,
  -18, 0, 0, 7, 0, 0,
  13, 0, 0, -6, 0, 0,
  17, 0, 0, 0, 0, 0,
  -12, 0, 0, 5, 0, 0,
  15, 0, 0, -8, 0, 0,
  -11, 0, 0, 3, 0, 0,
  13, 0, 0, -5, 0, 0,
  -18, 0, 0, 0, 0, 0,
  -35, 0, 0, 0, 0, 0,
  9, 0, 0, -4, 0, 0,
  -19, 0, 0, 10, 0, 0,
  -26, 0, 0, 11, 0, 0,
  8, 0, 0, -4, 0, 0,
  -10, 0, 0, 4, 0, 0,
  10, 0, 0, -6, 0, 0,
  -21, 0, 0, 9, 0, 0,
  -15, 0, 0, 0, 0, 0,
  9, 0, 0, -5, 0, 0,
  -29, 0, 0, 0, 0, 0,
  -19, 0, 0, 10, 0, 0,
  12, 0, 0, -5, 0, 0,
  22, 0, 0, -9, 0, 0,
  -10, 0, 0, 5, 0, 0,
  -20, 0, 0, 11, 0, 0,
  -20, 0, 0, 0, 0, 0,
  -17, 0, 0, 7, 0, 0,
  15, 0, 0, -3, 0, 0,
  8, 0, 0, -4, 0, 0,
  14, 0, 0, 0, 0, 0,
  -12, 0, 0, 6, 0, 0,
  25, 0, 0, 0, 0, 0,
  -13, 0, 0, 6, 0, 0,
  -14, 0, 0, 8, 0, 0,
  13, 0, 0, -5, 0, 0,
  -17, 0, 0, 9, 0, 0,
  -12, 0, 0, 6, 0, 0,
  -10, 0, 0, 5, 0, 0,
  10, 0, 0, -6, 0, 0,
  -15, 0, 0, 0, 0, 0,
  -22, 0, 0, 0, 0, 0,
  28, 0, 0, -1, 0, 0,
  15, 0, 0, -7, 0, 0,
  23, 0, 0, -10, 0, 0,
  12, 0, 0, -5, 0, 0,
  29, 0, 0, -1, 0, 0,
  -25, 0, 0, 1, 0, 0,
  22, 0, 0, 0, 0, 0,
  -18, 0, 0, 0, 0, 0,
  15, 0, 0, 3, 0, 0,
  -23, 0, 0, 0, 0, 0,
  12, 0, 0, -5, 0, 0,
  -8, 0, 0, 4, 0, 0,
  -19, 0, 0, 0, 0, 0,
  -10, 0, 0, 4, 0, 0,
  21, 0, 0, -9, 0, 0,
  23, 0, 0, -1, 0, 0,
  -16, 0, 0, 8, 0, 0,
  -19, 0, 0, 9, 0, 0,
  -22, 0, 0, 10, 0, 0,
  27, 0, 0, -1, 0, 0,
  16, 0, 0, -8, 0, 0,
  19, 0, 0, -8, 0, 0,
  9, 0, 0, -4, 0, 0,
  -9, 0, 0, 4, 0, 0,
  -9, 0, 0, 4, 0, 0,
  -8, 0, 0, 4, 0, 0,
  18, 0, 0, -9, 0, 0,
  16, 0, 0, -1, 0, 0,
  -10, 0, 0, 4, 0, 0,
  -23, 0, 0, 9, 0, 0,
  16, 0, 0, -1, 0, 0,
  -12, 0, 0, 6, 0, 0,
  -8, 0, 0, 4, 0, 0,
  30, 0, 0, -2, 0, 0,
  24, 0, 0, -10, 0, 0,
  10, 0, 0, -4, 0, 0,
  -16, 0, 0, 7, 0, 0,
  -16, 0, 0, 7, 0, 0,
  17, 0, 0, -7, 0, 0,
  -24, 0, 0, 10, 0, 0,
  -12, 0, 0, 5, 0, 0,
  -24, 0, 0, 11, 0, 0,
  -23, 0, 0, 9, 0, 0,
  -13, 0, 0, 5, 0, 0,
  -15, 0, 0, 7, 0, 0,
  0, 0, -1988, 0, 0, -1679,
  0, 0, -63, 0, 0, -27,
  -4, 0, 0, 0, 0, 0,
  0, 0, 5, 0, 0, 4,
  5, 0, 0, -3, 0, 0,
  0, 0, 364, 0, 0, 176,
  0, 0, -1044, 0, 0, -891,
  -3, 0, 0, 1, 0, 0,
  4, 0, 0, -2, 0, 0,
  0, 0, 330, 0, 0, 0,
  5, 0, 0, -2, 0, 0,
  3, 0, 0, -2, 0, 0,
  -3, 0, 0, 1, 0, 0,
  -5, 0, 0, 2, 0, 0,
  3, 0, 0, -1, 0, 0,
  3, 0, 0, 0, 0, 0,
  3, 0, 0, 0, 0, 0,
  0, 0, 5, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  4, 0, 0, -2, 0, 0,
  6, 0, 0, 0, 0, 0,
  5, 0, 0, -2, 0, 0,
  -7, 0, 0, 0, 0, 0,
  -12, 0, 0, 0, 0, 0,
  5, 0, 0, -3, 0, 0,
  3, 0, 0, -1, 0, 0,
  -5, 0, 0, 0, 0, 0,
  3, 0, 0, 0, 0, 0,
  -7, 0, 0, 3, 0, 0,
  7, 0, 0, -4, 0, 0,
  0, 0, -12, 0, 0, -10,
  4, 0, 0, -2, 0, 0,
  3, 0, 0, -2, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -7, 0, 0, 3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  -3, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  -3, 0, 0, 1, 0, 0,
  7, 0, 0, -3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  4, 0, 0, -2, 0, 0,
  -5, 0, 0, 3, 0, 0,
  5, 0, 0, 0, 0, 0,
  -5, 0, 0, 2, 0, 0,
  5, 0, 0, -2, 0, 0,
  -8, 0, 0, 3, 0, 0,
  9, 0, 0, 0, 0, 0,
  6, 0, 0, -3, 0, 0,
  -5, 0, 0, 2, 0, 0,
  3, 0, 0, 0, 0, 0,
  -7, 0, 0, 0, 0, 0,
  -3, 0, 0, 1, 0, 0,
  5, 0, 0, 0, 0, 0,
  3, 0, 0, 0, 0, 0,
  -3, 0, 0, 2, 0, 0,
  4, 0, 0, -2, 0, 0,
  3, 0, 0, -1, 0, 0,
  -5, 0, 0, 2, 0, 0,
  4, 0, 0, -2, 0, 0,
  9, 0, 0, -3, 0, 0,
  4, 0, 0, 0, 0, 0,
  4, 0, 0, -2, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -4, 0, 0, 2, 0, 0,
  9, 0, 0, -3, 0, 0,
  -4, 0, 0, 0, 0, 0,
  -4, 0, 0, 0, 0, 0,
  3, 0, 0, -2, 0, 0,
  8, 0, 0, 0, 0, 0,
  3, 0, 0, 0, 0, 0,
  -3, 0, 0, 2, 0, 0,
  3, 0, 0, -1, 0, 0,
  3, 0, 0, -1, 0, 0,
  -3, 0, 0, 1, 0, 0,
  6, 0, 0, -3, 0, 0,
  3, 0, 0, 0, 0, 0,
  -3, 0, 0, 1, 0, 0,
  -7, 0, 0, 0, 0, 0,
  9, 0, 0, 0, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -3, 0, 0, 0, 0, 0,
  -4, 0, 0, 0, 0, 0,
  -5, 0, 0, 3, 0, 0,
  -13, 0, 0, 0, 0, 0,
  -7, 0, 0, 0, 0, 0,
  10, 0, 0, 0, 0, 0,
  3, 0, 0, -1, 0, 0,
  10, 0, 13, 6, 0, -5,
  0, 0, 30, 0, 0, 14,
  0, 0, -162, 0, 0, -138,
  0, 0, 75, 0, 0, 0,
  -7, 0, 0, 4, 0, 0,
  -4, 0, 0, 2, 0, 0,
  4, 0, 0, -2, 0, 0,
  5, 0, 0, -2, 0, 0,
  5, 0, 0, -3, 0, 0,
  -3, 0, 0, 0, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -4, 0, 0, 2, 0, 0,
  -5, 0, 0, 2, 0, 0,
  6, 0, 0, 0, 0, 0,
  9, 0, 0, 0, 0, 0,
  5, 0, 0, 0, 0, 0,
  -7, 0, 0, 0, 0, 0,
  -3, 0, 0, 1, 0, 0,
  -4, 0, 0, 2, 0, 0,
  7, 0, 0, 0, 0, 0,
  -4, 0, 0, 0, 0, 0,
  4, 0, 0, 0, 0, 0,
  -6, 0, -3, 3, 0, 1,
  0, 0, -3, 0, 0, -2,
  11, 0, 0, 0, 0, 0,
  3, 0, 0, -1, 0, 0,
  11, 0, 0, 0, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -1, 0, 3, 3, 0, -1,
  4, 0, 0, -2, 0, 0,
  0, 0, -13, 0, 0, -11,
  3, 0, 6, 0, 0, 0,
  -7, 0, 0, 0, 0, 0,
  5, 0, 0, -3, 0, 0,
  -3, 0, 0, 1, 0, 0,
  3, 0, 0, 0, 0, 0,
  5, 0, 0, -3, 0, 0,
  -7, 0, 0, 3, 0, 0,
  8, 0, 0, -3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  11, 0, 0, 0, 0, 0,
  -3, 0, 0, 1, 0, 0,
  3, 0, 0, -1, 0, 0,
  -4, 0, 0, 2, 0, 0,
  8, 0, 0, -4, 0, 0,
  3, 0, 0, -1, 0, 0,
  11, 0, 0, 0, 0, 0,
  -6, 0, 0, 3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  -8, 0, 0, 4, 0, 0,
  -7, 0, 0, 3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  3, 0, 0, -1, 0, 0,
  6, 0, 0, -3, 0, 0,
  -6, 0, 0, 3, 0, 0,
  6, 0, 0, 0, 0, 0,
  6, 0, 0, -1, 0, 0,
  5, 0, 0, -2, 0, 0,
  -5, 0, 0, 2, 0, 0,
  -4, 0, 0, 0, 0, 0,
  -4, 0, 0, 2, 0, 0,
  4, 0, 0, 0, 0, 0,
  6, 0, 0, -3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  0, 0, -26, 0, 0, -11,
  0, 0, -10, 0, 0, -5,
  5, 0, 0, -3, 0, 0,
  -13, 0, 0, 0, 0, 0,
  3, 0, 0, -2, 0, 0,
  4, 0, 0, -2, 0, 0,
  7, 0, 0, -3, 0, 0,
  4, 0, 0, 0, 0, 0,
  5, 0, 0, 0, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -6, 0, 0, 2, 0, 0,
  -5, 0, 0, 2, 0, 0,
  -7, 0, 0, 3, 0, 0,
  5, 0, 0, -2, 0, 0,
  13, 0, 0, 0, 0, 0,
  -4, 0, 0, 2, 0, 0,
  -3, 0, 0, 0, 0, 0,
  5, 0, 0, -2, 0, 0,
  -11, 0, 0, 0, 0, 0,
  5, 0, 0, -2, 0, 0,
  4, 0, 0, 0, 0, 0,
  4, 0, 0, -2, 0, 0,
  -4, 0, 0, 2, 0, 0,
  6, 0, 0, -3, 0, 0,
  3, 0, 0, -2, 0, 0,
  -12, 0, 0, 0, 0, 0,
  4, 0, 0, 0, 0, 0,
  -3, 0, 0, 0, 0, 0,
  -4, 0, 0, 0, 0, 0,
  3, 0, 0, 0, 0, 0,
  3, 0, 0, -1, 0, 0,
  -3, 0, 0, 1, 0, 0,
  0, 0, -5, 0, 0, -2,
  -7, 0, 0, 4, 0, 0,
  6, 0, 0, -3, 0, 0,
  -3, 0, 0, 0, 0, 0,
  5, 0, 0, -3, 0, 0,
  3, 0, 0, -1, 0, 0,
  3, 0, 0, 0, 0, 0,
  -3, 0, 0, 1, 0, 0,
  -5, 0, 0, 3, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -3, 0, 0, 2, 0, 0,
  12, 0, 0, 0, 0, 0,
  3, 0, 0, -1, 0, 0,
  -4, 0, 0, 2, 0, 0,
  4, 0, 0, 0, 0, 0,
  6, 0, 0, 0, 0, 0,
  5, 0, 0, -3, 0, 0,
  4, 0, 0, -2, 0, 0,
  -6, 0, 0, 3, 0, 0,
  4, 0, 0, -2, 0, 0,
  6, 0, 0, -3, 0, 0,
  6, 0, 0, 0, 0, 0,
  -6, 0, 0, 3, 0, 0,
  3, 0, 0, -2, 0, 0,
  7, 0, 0, -4, 0, 0,
  4, 0, 0, -2, 0, 0,
  -5, 0, 0, 2, 0, 0,
  5, 0, 0, 0, 0, 0,
  -6, 0, 0, 3, 0, 0,
  -6, 0, 0, 3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  10, 0, 0, 0, 0, 0,
  -4, 0, 0, 2, 0, 0,
  7, 0, 0, 0, 0, 0,
  7, 0, 0, -3, 0, 0,
  4, 0, 0, 0, 0, 0,
  11, 0, 0, 0, 0, 0,
  5, 0, 0, -2, 0, 0,
  -6, 0, 0, 2, 0, 0,
  4, 0, 0, -2, 0, 0,
  3, 0, 0, -2, 0, 0,
  5, 0, 0, -2, 0, 0,
  -4, 0, 0, 2, 0, 0,
  -4, 0, 0, 2, 0, 0,
  -3, 0, 0, 2, 0, 0,
  4, 0, 0, -2, 0, 0,
  3, 0, 0, -1, 0, 0,
  -3, 0, 0, 1, 0, 0,
  -3, 0, 0, 1, 0, 0,
  -3, 0, 0, 2, 0, 0,
  };
  

}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following.

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


/*
* This class contains many constants for internal use only.
* It does not need to be instantiated.
*/
class SwephData {

  // Mean node seems to have a constant speed and distance?

  // Aus: sweodef.h:
  static final double M_PI = 3.14159265358979323846;

  // Aus sweph.h:
  static final int[] PNOINT2JPL = new int[] {SwephJPL.J_EARTH, SwephJPL.J_MOON,
                    SwephJPL.J_MERCURY, SwephJPL.J_VENUS, SwephJPL.J_MARS,
                    SwephJPL.J_JUPITER, SwephJPL.J_SATURN, SwephJPL.J_URANUS,
                    SwephJPL.J_NEPTUNE, SwephJPL.J_PLUTO, SwephJPL.J_SUN};
  static final int[] pnoint2jpl = PNOINT2JPL;

  /* planetary radii in meters */
  static final int NDIAM = (SweConst.SE_VESTA + 1);
  static final double pla_diam[] = {1392000000.0, /* Sun */
                           3476300.0, /* Moon */
                           2439000.0 * 2, /* Mercury */
                           6052000.0 * 2, /* Venus */
                           3397200.0 * 2, /* Mars */
                          71398000.0 * 2, /* Jupiter */
                          60000000.0 * 2, /* Saturn */
                          25400000.0 * 2, /* Uranus */
                          24300000.0 * 2, /* Neptune */
                           2500000.0 * 2, /* Pluto */
                           0, 0, 0, 0,    /* nodes and apogees */
                           6378140.0 * 2, /* Earth */
                                 0.0, /* Chiron */
                                 0.0, /* Pholus */
                            913000.0, /* Ceres */
                            523000.0, /* Pallas */
                            244000.0, /* Juno */
                            501000.0, /* Vesta */
                        };

  static final double J2000 = 2451545.0;        // 2000 January 1.5
  static final double B1950 = 2433282.42345905; // 1950 January 0.923
  static final double J1900 = 2415020.0;        // 1900 January 0.5

  static final int MPC_CERES = 1;
  static final int MPC_PALLAS = 2;
  static final int MPC_JUNO = 3;
  static final int MPC_VESTA = 4;
  static final int MPC_CHIRON = 2060;
  static final int MPC_PHOLUS = 5145;

  static final String SE_NAME_SUN = "Sun";
  static final String SE_NAME_MOON = "Moon";
  static final String SE_NAME_MERCURY = "Mercury";
  static final String SE_NAME_VENUS = "Venus";
  static final String SE_NAME_MARS = "Mars";
  static final String SE_NAME_JUPITER = "Jupiter";
  static final String SE_NAME_SATURN = "Saturn";
  static final String SE_NAME_URANUS = "Uranus";
  static final String SE_NAME_NEPTUNE = "Neptune";
  static final String SE_NAME_PLUTO = "Pluto";
  static final String SE_NAME_MEAN_NODE = "mean Node";
  static final String SE_NAME_TRUE_NODE = "true Node";
  static final String SE_NAME_MEAN_APOG = "mean Apogee";
  static final String SE_NAME_OSCU_APOG = "osc. Apogee";
  static final String SE_NAME_INTP_APOG = "intp. Apogee";
  static final String SE_NAME_INTP_PERG = "intp. Perigee";
  static final String SE_NAME_EARTH = "Earth";
  static final String SE_NAME_CERES = "Ceres";
  static final String SE_NAME_PALLAS = "Pallas";
  static final String SE_NAME_JUNO = "Juno";
  static final String SE_NAME_VESTA = "Vesta";
  static final String SE_NAME_CHIRON = "Chiron";
  static final String SE_NAME_PHOLUS = "Pholus";


  static final String SE_NAME_CUPIDO = "Cupido";
  static final String SE_NAME_HADES = "Hades";
  static final String SE_NAME_ZEUS = "Zeus";
  static final String SE_NAME_KRONOS = "Kronos";
  static final String SE_NAME_APOLLON = "Apollon";
  static final String SE_NAME_ADMETOS = "Admetos";
  static final String SE_NAME_VULKANUS = "Vulkanus";
  static final String SE_NAME_POSEIDON = "Poseidon";
  static final String SE_NAME_ISIS = "Isis";
  static final String SE_NAME_NIBIRU = "Nibiru";
  static final String SE_NAME_HARRINGTON = "Harrington";
  static final String SE_NAME_NEPTUNE_LEVERRIER = "Leverrier";
  static final String SE_NAME_NEPTUNE_ADAMS = "Adams";
  static final String SE_NAME_PLUTO_LOWELL = "Lowell";
  static final String SE_NAME_PLUTO_PICKERING = "Pickering";
  static final String SE_NAME_VULCAN = "Vulcan";
  static final String SE_NAME_WHITE_MOON = "White Moon";

  static final AyaInit[] ayanamsa = new AyaInit[] {
    new AyaInit(2433282.5, 24.042044444),  /* 0: Fagan/Bradley (Default) */
    new AyaInit(J1900, 360 - 337.53953),   /* 1: Lahiri (Robert Hand) */
    new AyaInit(J1900, 360 - 333.58695),   /* 2: De Luce (Robert Hand) */
    new AyaInit(J1900, 360 - 338.98556),   /* 3: Raman (Robert Hand) */
    new AyaInit(J1900, 360 - 341.33904),   /* 4: Ushashashi (Robert Hand) */
    new AyaInit(J1900, 360 - 337.636111),  /* 5: Krishnamurti (Robert Hand) */
    new AyaInit(J1900, 360 - 333.0369024), /* 6: Djwhal Khool; (Graham Dawson)
                                            *    Aquarius entered on 1 July 2117 */
    new AyaInit(J1900, 360 - 338.917778),  /* 7: Yukteshwar; (David Cochrane) */
    new AyaInit(J1900, 360 - 338.634444),  /* 8: JN Bhasin; (David Cochrane) */
    new AyaInit(1684532.5, -3.36667),      /* 9: Babylonian, Kugler 1 */
    new AyaInit(1684532.5, -4.76667),      /*10: Babylonian, Kugler 2 */
    new AyaInit(1684532.5, -5.61667),      /*11: Babylonian, Kugler 3 */
    new AyaInit(1684532.5, -4.56667),      /*12: Babylonian, Huber */
    new AyaInit(1673941, -5.079167),       /*13: Babylonian, Mercier;
                                            *    eta Piscium culminates with zero point */
    new AyaInit(1684532.5, -4.44088389),   /*14: t0 is defined by Aldebaran at 15 Taurus */
    new AyaInit(1674484, -9.33333),        /*15: Hipparchos */
    new AyaInit(1927135.8747793, 0),       /*16: Sassanian */
    new AyaInit(1746443.513, 0),           /*17: Galactic Center at 0 Sagittarius */
    new AyaInit(J2000, 0),                 /*18: J2000 */
    new AyaInit(J1900, 0),                 /*19: J1900 */
    new AyaInit(B1950, 0),                 /*20: B1950 */
        };

/*
 * earlier content
 */

  static final double PI = M_PI;   // 3.14159265358979323846, math.h
  static final double TWOPI = 2.0 * PI;

//  static final int ENDMARK = -99;

  static final int SEI_EPSILON = -2;
  static final int SEI_NUTATION = -1;
  static final int SEI_EMB = 0;
  static final int SEI_EARTH = 0;
  static final int SEI_SUN = 0;
  static final int SEI_MOON = 1;
  static final int SEI_MERCURY = 2;
  static final int SEI_VENUS = 3;
  static final int SEI_MARS = 4;
  static final int SEI_JUPITER = 5;
  static final int SEI_SATURN = 6;
  static final int SEI_URANUS = 7;
  static final int SEI_NEPTUNE = 8;
  static final int SEI_PLUTO = 9;
  static final int SEI_SUNBARY = 10;     // barycentric sun
  static final int SEI_ANYBODY = 11;     // any asteroid
  static final int SEI_CHIRON = 12;
  static final int SEI_PHOLUS = 13;
  static final int SEI_CERES = 14;
  static final int SEI_PALLAS = 15;
  static final int SEI_JUNO = 16;
  static final int SEI_VESTA = 17;

  static final int SEI_NPLANETS = 18;

  static final int SEI_MEAN_NODE = 0;
  static final int SEI_TRUE_NODE = 1;
  static final int SEI_MEAN_APOG = 2;
  static final int SEI_OSCU_APOG = 3;
  static final int SEI_INTP_APOG = 4;
  static final int SEI_INTP_PERG = 5;

  static final int SEI_NNODE_ETC = 6;

  static final int SEI_FLG_HELIO = 1;
  static final int SEI_FLG_ROTATE = 2;
  static final int SEI_FLG_ELLIPSE = 4;
  static final int SEI_FLG_EMBHEL = 8; // TRUE, if heliocentric earth is given
                                     // instead of barycentric sun
                                     // i.e. bary sun is computed from
                                     // barycentric and heliocentric earth

  static final int SEI_FILE_PLANET = 0;
  static final int SEI_FILE_MOON = 1;
  static final int SEI_FILE_MAIN_AST = 2;
  static final int SEI_FILE_ANY_AST = 3;
  static final int SEI_FILE_FIXSTAR = 4;

  // Aus swephexph.h:
  static final int SEI_FILE_TEST_ENDIAN = 0x616263;   // abc
  static final int SEI_FILE_BIGENDIAN = 0;
  static final int SEI_FILE_NOREORD = 0;
  static final int SEI_FILE_LITENDIAN = 1;
  static final int SEI_FILE_REORD = 2;

  static final int SEI_FILE_NMAXPLAN = 50;
  static final int SEI_FILE_EFPOSBEGIN = 500;

  static final String SE_FILE_SUFFIX = "se1";

  static final int SEI_NEPHFILES = 7;
  static final int SEI_CURR_FPOS = -1;

/* Chiron's orbit becomes chaotic
 * before 720 AD and after 4606 AD, because of close encounters
 * with Saturn. Accepting a maximum error of 5 degrees,
 * the ephemeris is good between the following dates:
 */
  static final double CHIRON_START = 1958470.5;      // 1.1.650
  static final double CHIRON_END = 3419437.5;        // 1.1.4650

/* Pholus's orbit is unstable as well, because he sometimes
 * approaches Saturn.
 * Accepting a maximum error of 5 degrees,
 * the ephemeris is good after the following date:
 */
  static final double PHOLUS_START = 314845.5;       // 1.1.-3850

  static final double MOSHPLEPH_START =  625000.5;
  static final double MOSHPLEPH_END =   2818000.5;
  static final double MOSHLUEPH_START =  625000.5;
  static final double MOSHLUEPH_END =   2818000.5;
  static final double MOSHNDEPH_START = -254900.5; // 14 Feb -5410 00:00 ET jul.
  static final double MOSHNDEPH_END =   3697000.5; // 11 Dec 5409 00:00 ET, greg.


  static final int MAXORD = 40;

  static final double NCTIES = 6.0;    // number of centuries per eph. file

  static final int NOT_AVAILABLE = -2;
  static final int BEYOND_EPH_LIMITS = -3;

  static final int J_TO_J2000 = 1;
  static final int J2000_TO_J = -1;


  // we always use Astronomical Almanac constants, if available
  static final double MOON_MEAN_DIST = 384400000.0;           // in m, AA 1996, F2
  static final double MOON_MEAN_INCL = 5.1453964;             // AA 1996, D2
  static final double MOON_MEAN_ECC = 0.054900489;            // AA 1996, F2
  // static final double SUN_EARTH_MRAT = 328900.561400;         Su/(Ea+Mo) AA 2006 K7
  static final double SUN_EARTH_MRAT = 332946.050895;         // Su / (Ea only) AA 2006 K7
  static final double EARTH_MOON_MRAT = (1 / 0.0123000383);   // AA 2006, K7
  static final double AUNIT = 1.49597870691e+11;              // au in meters, AA 2006 K6
  static final double CLIGHT = 2.99792458e+8;                 // m/s, AA 1996 K6
  static final double HELGRAVCONST = 1.32712440017987e+20;    // G * M(sun), m^3/sec^2, AA 2006 K6
  static final double GEOGCONST = 3.98600448e+14; // G * M(earth) m^3/sec^2, AA 1996 K6
  static final double KGAUSS = 0.01720209895; // Gaussian gravitational constant K6
  static final double KGAUSS_GEO = 0.0000298122353216;        // Earth only
  // static final double KGAUSS_GEO = 0.0000299502129737        // Earth + Moon
  static final double SUN_RADIUS = 959.63 / 3600 * SwissData.DEGTORAD;  // Meeus germ. p 391
  static final double EARTH_RADIUS = 6378136.6;               // AA 2006 K6
  /*static final double EARTH_OBLATENESS = (1.0/ 298.257223563); * AA 1998 K13 */
  static final double EARTH_OBLATENESS = (1.0/ 298.25642);    // AA 2006 K6
  static final double EARTH_ROT_SPEED = 7.2921151467e-5 * 86400; // in rad/day, expl. suppl., p 162

  static final double LIGHTTIME_AUNIT = (499.0047838061/3600/24); // 8.3167 minutes (days), AA 2006 K6

  /* node of ecliptic measured on ecliptic 2000 */
  static final double SSY_PLANE_NODE_E2000 = 107.582569 * SwissData.DEGTORAD;
  /* node of ecliptic measured on solar system rotation plane */
  static final double SSY_PLANE_NODE = 107.58883388 * SwissData.DEGTORAD;
  /* inclination of ecliptic against solar system rotation plane */
  static final double SSY_PLANE_INCL = 1.578701 * SwissData.DEGTORAD;

  static final double KM_S_TO_AU_CTY = 21.095;           // km/s to AU/century
  static final double MOON_SPEED_INTV = 0.00005;         // 4.32 seconds (in days)
  static final double PLAN_SPEED_INTV = 0.0001;          // 8.64 seconds (in days)
  static final double MEAN_NODE_SPEED_INTV = 0.001;
  static final double NODE_CALC_INTV = 0.0001;
  static final double NODE_CALC_INTV_MOSH = 0.1;
  static final double NUT_SPEED_INTV = 0.0001;
  static final double DEFL_SPEED_INTV = 0.0000005;


/*
 * stuff exported from swemplan.c and swemmoon.c
 * and constants used inside these functions.
************************************************************/

  static final double STR = 4.8481368110953599359e-6;   // radians per arc second


  // Aus sweph.c:
  static final int IS_PLANET = 0;
  static final int IS_MOON = 1;
  static final int IS_ANY_BODY = 2;
  static final int IS_MAIN_ASTEROID = 3;

  static final boolean DO_SAVE = true;
  static final boolean NO_SAVE = false;

//  java.io.RandomAccessFile fixfp = null;     // fixed stars


//  static final int pnoext2int[] = {SEI_SUN, SEI_MOON, SEI_MERCURY, SEI_VENUS,
//    SEI_MARS, SEI_JUPITER, SEI_SATURN, SEI_URANUS, SEI_NEPTUNE, SEI_PLUTO,
//    0, 0, 0, 0, SEI_EARTH, SEI_CHIRON, SEI_PHOLUS, SEI_CERES, SEI_PALLAS,
//    SEI_JUNO, SEI_VESTA, };


//////////////////////////////////////////////////////////////////////////////
// extensions: ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////
// SURYA: /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double SURYA_MAX_LON_SPEED = 1.025;
// NOTOPO, JPL: 1.0233362482825890 198.1481527339882689 656297.5935287680476904 /    nan    nan    nan

  static final double SURYA_MIN_LON_SPEED = 0.946;
// NOTOPO, JPL: 0.9495985191372013 13.6641834118152925 630178.1503921914845705 /    nan    nan    nan

  static final double SURYA_MAX_LON_ACCEL = 0.000735;
// NOTOPO, JPL: 0.0007321244674241 111.1489600158149074 632105.3974533881992102 632105.4891571882180870 /    nan    nan    nan

  static final double SURYA_MIN_LON_ACCEL = -0.000720;
// NOTOPO, JPL: -0.0007172603891239 281.9291936621758623 663685.2516582887619734 663685.3433620887808502 /    nan    nan    nan

  static final double SURYA_MAX_TOPO_LON_SPEED = 1.04;
// TOPO, SWI:   1.0384413287108927 0.0000000000000000 -199501.5087046779808588 / -0.5433742788 -4.7293263997 -1664.2795669022
// TOPO, JPL:   1.0365074888828785 209.2107463691459657 795098.6519823583075777 / -148.9   17.7 12497.5

  static final double SURYA_MIN_TOPO_LON_SPEED = 0.93;
// TOPO, SWI:   0.9349095448292457 0.0000000000000000 -224529.9592720646178350 -16.3604237359 -3.3169784104 3529.4848477192
// TOPO, JPL:   0.9365203548203047 30.4143819284346542 717121.0431665068026632 /  -79.7    7.4 -48617.2

  static final double SURYA_MAX_TOPO_LON_ACCEL = 0.06;
// TOPO, SWI:   0.0593799785863376
// TOPO, JPL:   0.0583456448574779 275.0416878063256263 2700635.1911227395758033 2700635.2918350920081139 /   11.0   52.2 -110000.0

  static final double SURYA_MIN_TOPO_LON_ACCEL = -0.06;
// TOPO, SWI:   -0.0594559646638496
// TOPO, JPL:   -0.0584748042751905 271.9731910425273895 1139219.1189967475365847 1139219.2191002487670630 /   11.0   52.2 -110000.0

  static final double SURYA_MAX_HELIO_LON_SPEED = 0;
  static final double SURYA_MIN_HELIO_LON_SPEED = 0;
  static final double SURYA_MAX_HELIO_LON_ACCEL = 0;
  static final double SURYA_MIN_HELIO_LON_ACCEL = 0;


  static final double SURYA_MAX_LAT_SPEED = 0.0000620;
// NOTOPO, JPL: 0.0000618025182438 241.4261311889077604 1113622.1226309132762253 /    nan    nan    nan

  static final double SURYA_MIN_LAT_SPEED = -0.0000618;
// NOTOPO, JPL: -0.0000614244567336 299.9816306303840747 1156413.5820919747930020 /    nan    nan    nan

  static final double SURYA_MAX_LAT_ACCEL = 0.0000203;
// NOTOPO, JPL: 0.0000200049293864 85.4713554114340468 1067082.5648221261799335 1067082.6565259261988103 /    nan    nan    nan

  static final double SURYA_MIN_LAT_ACCEL = -0.0000204;
// NOTOPO, JPL: -0.0000202677724199 267.1036516425933200 836064.9195209722965956 836065.0112247723154724 /    nan    nan    nan

  static final double SURYA_MAX_TOPO_LAT_SPEED = 0.0066;
// TOPO, SWI:   0.0064145372870949
// TOPO, JPL:   0.0063447811040511 167.6535710049226680 943711.7743394003482535 /  129.0    4.8 10365.7

  static final double SURYA_MIN_TOPO_LAT_SPEED = -0.0065;
// TOPO, SWI:   -0.0064584410123400
// TOPO, JPL:   -0.0063137486844727 183.6555443690479876 1222042.6236723833717406 /  -94.5   -3.3 33636.2

  static final double SURYA_MAX_TOPO_LAT_ACCEL = 0.025;
// TOPO, SWI:   0.0244212760934252
// TOPO, JPL:   0.0238296790897776 192.2272313218551290 632914.0236237654462457 632914.1249053360661492 /   11.0   52.2 -110000.0

  static final double SURYA_MIN_TOPO_LAT_ACCEL = -0.025;
// TOPO, SWI:   -0.0244146697145761
// TOPO, JPL:   -0.0238413888237050 204.3178283029897102 638404.4897474966710433 638404.5898247783770785 /   11.0   52.2 -110000.0

  static final double SURYA_MAX_HELIO_LAT_SPEED = 0;
  static final double SURYA_MIN_HELIO_LAT_SPEED = 0;
  static final double SURYA_MAX_HELIO_LAT_ACCEL = 0;
  static final double SURYA_MIN_HELIO_LAT_ACCEL = 0;


  static final double SURYA_MAX_DIST_SPEED = 0.000328;
// NOTOPO, JPL: 0.0003251647876611 285.1359892485851901 630451.5194200477562845 /    nan    nan    nan

  static final double SURYA_MIN_DIST_SPEED = -0.000327;
// NOTOPO, JPL: -0.0003247521770552 108.3678967045579498 669357.4068008563481271 /    nan    nan    nan

  static final double SURYA_MAX_DIST_ACCEL = 0.00000734;
// NOTOPO, JPL: 0.0000073151160377 197.0004801545529460 647895.7830748385749757 647895.8747786385938525 /    nan    nan    nan

  static final double SURYA_MIN_DIST_ACCEL = -0.00000694;
// NOTOPO, JPL: -0.0000069158807111 15.5783679317648520 641502.5609527225606143 641502.6526565225794911 /    nan    nan    nan

  static final double SURYA_MAX_TOPO_DIST_SPEED = 0.00059;
// TOPO, SWI:   0.0005789367418679
// TOPO, JPL:   0.0005633150154512 318.6451137771567801 1329557.3832753794267774 /   84.1    1.8 -19441.6

  static final double SURYA_MIN_TOPO_DIST_SPEED = -0.00058;
// TOPO, SWI:   -0.0005724228279118
// TOPO, JPL:   -0.0005647002245768 174.5410821021679340 2142079.3515738314017653 /  143.7    1.1 -26129.6

  static final double SURYA_MAX_TOPO_DIST_ACCEL = 0.00104;
// TOPO, SWI:   0.0010219054361193
// TOPO, JPL:   0.0010043877043150 178.6859059007219059 713984.7248655840521678 713984.8256328357383609 /   11.0   52.2 -110000.0

  static final double SURYA_MIN_TOPO_DIST_ACCEL = -0.0013;
// TOPO, SWI:   -0.0012818853764991
// TOPO, JPL:   -0.0010042541999776 357.1345657907744453 833598.1178349015535787 833598.2180397533811629 /   11.0   52.2 -110000.0

  static final double SURYA_MAX_HELIO_DIST_SPEED = 0;
  static final double SURYA_MIN_HELIO_DIST_SPEED = 0;
  static final double SURYA_MAX_HELIO_DIST_ACCEL = 0;
  static final double SURYA_MIN_HELIO_DIST_ACCEL = 0;



///////////////////////////////////////////////////////////////
// CHANDRA: ///////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double CHANDRA_MAX_LON_SPEED = 15.41;
// NOTOPO, JPL: 15.4041164556993593 180.5585719899691526 867780.5870537008158863 /    nan    nan    nan

  static final double CHANDRA_MIN_LON_SPEED = 11.75;
// NOTOPO, JPL: 11.7572903229686911 48.7868453140692111 1045632.5874787108041346 /    nan    nan    nan

  static final double CHANDRA_MAX_LON_ACCEL = 0.522;
// NOTOPO, JPL: 0.5186414758242096 126.4203023968987338 1065011.4344986998476088 1065011.5262024998664856 /    nan    nan    nan

  static final double CHANDRA_MIN_LON_ACCEL = -0.520;
// NOTOPO, JPL: -0.5185377158655800 124.9880532266025597 1139170.4634979651309550 1139170.5552017651498318 /    nan    nan    nan

  static final double CHANDRA_MAX_TOPO_LON_SPEED = 22.0;
// TOPO, SWI:   21.4309682969720328 179.1777778485675867 3558401.0245797489769757 / 123.7452556088 1.2763677912 -9647.8126131759
// TOPO, JPL:   21.1149235251773284 21.1660559007296314 2077012.0076510021463037 /  167.6    1.2 -56742.6

  static final double CHANDRA_MIN_TOPO_LON_SPEED = 6.0;
// TOPO, SWI:   6.2043978283097267 91.2062770401382892 110594.4898514153319411 -82.1318313870 -2.2805770007 3320.8680109613
// TOPO, JPL:   6.3597932870754974 7.2417677341565536 2248084.8536576554179192 /   72.4   -4.6 18046.7

  static final double CHANDRA_MAX_TOPO_LON_ACCEL = 23.5;
// TOPO, SWI:   22.9729155357766466
//              22.5191319837460533 189.8858251817875384 2303261.6343037686310709 2303261.7453831625171006 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   22.5728018782278816 188.2658986628977686 1030021.1688936793943867 1030021.2732220485340804 /   11.0   52.2 -110000.0

  static final double CHANDRA_MIN_TOPO_LON_ACCEL = -23.2;
// min topo3:   -38.1716335
// TOPO, SWI:   -22.9387038817123141
//              -22.5127674732828922 160.2778837680125719 218788.6020565493090544 218788.7164031058782712 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   -22.5391436800995280 164.1286691196248171 2558171.2196601303294301 2558171.3217258220538497 /   11.0   52.2 -110000.0

  static final double CHANDRA_MAX_HELIO_LON_SPEED = 1.0584;
// HELIO, SWI:   1.0582731664012499 340.9315601866028942 -198775.0513440131617244 / 

  static final double CHANDRA_MIN_HELIO_LON_SPEED = 0.9155;
// HELIO, SWI:   0.9157102465868880 159.3985924130032288 -205168.3651679001632147 / 

  static final double CHANDRA_MAX_HELIO_LON_ACCEL = 0.007875;
// HELIO, SWI:   0.0078730294316827 277.3484374693355790 203659.9220483523386065 203660.0137521523283795 / 

  static final double CHANDRA_MIN_HELIO_LON_ACCEL = -0.007888;
// HELIO, SWI:   -0.0078862144639317 62.5339410468777928 -71224.9695591411000350 -71224.8778553410957102 / 


  static final double CHANDRA_MAX_LAT_SPEED = 1.44;
// NOTOPO, JPL: 1.4161178854830674 179.4697049090585210 2804426.0038991500623524 /    nan    nan    nan

  static final double CHANDRA_MIN_LAT_SPEED = -1.44;
// NOTOPO, JPL: -1.4172129253432328 178.3605766215862332 628523.9972474509850144 /    nan    nan    nan

  static final double CHANDRA_MAX_LAT_ACCEL = 0.366;
// NOTOPO, JPL: 0.3639886778563629 178.7949269887757282 1886142.7578099258244038 1886142.8495137258432806 /    nan    nan    nan

  static final double CHANDRA_MIN_LAT_ACCEL = -0.366;
// NOTOPO, JPL: -0.3636913084572940 180.6303963665253036 912666.9377527404576540 912667.0294565404765308 /    nan    nan    nan

  static final double CHANDRA_MAX_TOPO_LAT_SPEED = 4.2;
// TOPO, SWI:   4.0196744317594568
// TOPO, JPL:   3.8905318518976895 4.1726025186527806 1045864.4757649956736714 /  -49.8    1.0 -330810.4

  static final double CHANDRA_MIN_TOPO_LAT_SPEED = -4.7;
// TOPO, SWI:   -4.1184649007547964
// TOPO, JPL:   -3.9483356515061541 8.3800829312503424 944132.7195180986309424 /  -82.7   16.8 -54378.5

  static final double CHANDRA_MAX_TOPO_LAT_ACCEL = 12.5;
// TOPO, SWI:   12.3783195665162751
// TOPO, JPL:   12.0090702595465828 156.9810838245764160 1658430.5072499848902225 1658430.6155795308295637 /   11.0   52.2 -110000.0

  static final double CHANDRA_MIN_TOPO_LAT_ACCEL = -12.5;
// TOPO, SWI:   -12.0415108646951037
// TOPO, JPL:   -11.8365401411952877 18.3511634305493487 713555.6669830741593614 713555.7701688770903274 /   11.0   52.2 -110000.0

  static final double CHANDRA_MAX_HELIO_LAT_SPEED = 0.003415;
// HELIO, SWI:   0.0034101386545078 126.4693244384440476 3019157.7850323482416570 / 

  static final double CHANDRA_MIN_HELIO_LAT_SPEED = -0.0034187;
// HELIO, SWI:   -0.0034163978380770 54.5835286233875010 1079647.8165857093408704 / 

  static final double CHANDRA_MAX_HELIO_LAT_ACCEL = 0.0008119;
// HELIO, SWI:   0.0008116345691465 81.4557765725807883 1916810.8899200353771448 1916810.9816238353960216 / 

  static final double CHANDRA_MIN_HELIO_LAT_ACCEL = -0.0008069;
// HELIO, SWI:   -0.0008067042857947 37.6793496389577811 963118.6057523223571479 963118.6974561223760247 / 


  static final double CHANDRA_MAX_DIST_SPEED = 0.000044;
// NOTOPO, JPL: 0.0000430106329181 118.0467546874002380 857921.8783288714475930 /    nan    nan    nan

  static final double CHANDRA_MIN_DIST_SPEED = -0.0000434;
// NOTOPO, JPL: -0.0000430670864277 117.1142513980806257 751632.3483938642311841 /    nan    nan    nan

  static final double CHANDRA_MAX_DIST_ACCEL = 0.0000140;
// NOTOPO, JPL: 0.0000137704986304 179.2396768958410860 867780.5870537008158863 867780.6787575008347631 /    nan    nan    nan

  static final double CHANDRA_MIN_DIST_ACCEL = -0.00000898;
// NOTOPO, JPL: -0.0000089378018376 90.1277326204999270 784496.9382487572729588 784497.0299525572918355 /    nan    nan    nan

  static final double CHANDRA_MAX_TOPO_DIST_SPEED = 0.00030;
// TOPO, SWI:   0.0002987444506570
// TOPO, JPL:   0.0002909664964957 284.8643480099901808 1080096.5486003318801522 /  144.6   -2.3 4895.6

  static final double CHANDRA_MIN_TOPO_DIST_SPEED = -0.00031;
// TOPO, SWI:   -0.0002975759131239
// TOPO, JPL:   -0.0002895923864196 55.7017996303879528 1362930.4575669008772820 /  167.6   -2.3 17165.7

  static final double CHANDRA_MAX_TOPO_DIST_ACCEL = 0.00099;
// TOPO, SWI:   0.0009695039477059
// TOPO, JPL:   0.0009507373452100 177.1836363491260897 827412.1154932569479570 827412.2165193189866841 /   11.0   52.2 -110000.0

  static final double CHANDRA_MIN_TOPO_DIST_ACCEL = -0.00098;
// TOPO, SWI:   -0.0009611955640193
// TOPO, JPL:   -0.0009452968840833 241.9355511752623897 733411.5362529422855005 733411.6373956773895770 /   11.0   52.2 -110000.0

  static final double CHANDRA_MAX_HELIO_DIST_SPEED = 0.0008899;
// HELIO, SWI:   0.0008894035707012 72.3250923160331212 -201971.5707002566778101 / 

  static final double CHANDRA_MIN_HELIO_DIST_SPEED = -0.000889;
// HELIO, SWI:   -0.0008886720697406 249.4270859464915020 -195578.6236915696354117 / 

  static final double CHANDRA_MAX_HELIO_DIST_ACCEL = 0.0001394;
// HELIO, SWI:   0.0001393197780529 338.4548057402580525 -210100.1038275501632597 -210100.0121237501734868 / 

  static final double CHANDRA_MIN_HELIO_DIST_ACCEL = -0.00013959;
// HELIO, SWI:   -0.0001395759805093 165.4174725364829044 -132478.9812908066669479 -132478.8895870066771749 / 



///////////////////////////////////////////////////////////////
// BUDHA: /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double BUDHA_MAX_LON_SPEED = 2.23;
// NOTOPO, SWI: 2.2121426791396726
//              2.2118740410345783 2.0229662866546647 3632579.7922155149281025
// NOTOPO, JPL: 2.1964845502320962 3.0367044971105202 2816224.3305718521587551 / 

  static final double BUDHA_MIN_LON_SPEED = -1.40;
// NOTOPO, SWI: -1.3908298594148474
//              -1.3898959805347326 0.5092469431197060 3682809.9214275842532516
// NOTOPO, JPL: -1.3521147816768901 3.0331619351929362 2777343.6256446754559875 / 

  static final double BUDHA_MAX_LON_ACCEL = 0.20;
// NOTOPO, SWI: 0.1967914822899190 14.2061443309504511
//              0.1968017050259578 14.4414680144461727 -175436.4430393589718733 -175436.0775205177196767
// NOTOPO, JPL: 0.1965936384404356 14.3754648083684629 643469.9357961784116924 643470.2695755218155682 / 

  static final double BUDHA_MIN_LON_ACCEL = -0.199;
// NOTOPO, JPL: -0.1986619469289480 14.0525985387717469 2385435.3617391046136618 2385435.5139587139710784 / 

  static final double BUDHA_MAX_TOPO_LON_SPEED = 2.3;
// TOPO, SWI:   2.2212980742115511 2.1541861391796004 3632579.8976156003773212 / 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   2.2019660581364016 3.0549461351521785 2794671.4474170133471489 /   11.0   52.2 -110000.0


  static final double BUDHA_MIN_TOPO_LON_SPEED = -1.49;
// TOPO, SWI:   -1.4063442078716697 0.1278834320364695 3606099.4173800637945533 25.4514719644 3.6416897111 -8080.5345996378
// TOPO, JPL:   -1.3655028210686915 3.0368029001502350 2726937.0293830074369907 /   11.0   52.2 -110000.0

  static final double BUDHA_MAX_TOPO_LON_ACCEL = 0.281;
// TOPO, SWI:   0.2720747632986203
//              0.2702626383612824 14.4371256403208434 -134531.0275387382425833 -134530.9010568788216915 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   0.2675637274842573 13.7209457445615612 2597974.1161503684706986 2597974.2541675390675664 /   11.0   52.2 -110000.0

  static final double BUDHA_MIN_TOPO_LON_ACCEL = -0.282;
// TOPO, JPL:   -0.2730133058585249 13.0135107334394888 2267820.7196086999028921 2267820.8311376208439469 /   11.0   52.2 -110000.0

  static final double BUDHA_MAX_HELIO_LON_SPEED = 6.358;
// HELIO, SWI:   6.3531535305329898 133.1008594391232975 3693190.0689586945809424 / 

  static final double BUDHA_MIN_HELIO_LON_SPEED = 2.743;
// HELIO, SWI:   2.7419144691190489 204.6191384842340995 1223669.8266647555865347 / 

  static final double BUDHA_MAX_HELIO_LON_ACCEL = 0.1547;
// HELIO, SWI:   0.1545118574744947 69.4456644722211678 3691507.8544511483050883 3691507.9461549483239651 / 

  static final double BUDHA_MIN_HELIO_LON_ACCEL = -0.1654;
// HELIO, SWI:   -0.1650067987113518 195.9518154132125858 3693288.5588399148546159 3693288.6505437148734927 / 


  static final double BUDHA_MAX_LAT_SPEED = 0.35;
// NOTOPO, SWI: 0.3461375049101383
// NOTOPO, JPL: 0.3459340957539888 3.1275672465673381 2046046.1421363854315132 / 

  static final double BUDHA_MIN_LAT_SPEED = -0.31;
// NOTOPO, SWI: -0.3029605350228085
// NOTOPO, JPL: -0.2959580096865397 4.5857649974633290 2786261.3525251694954932 / 

  static final double BUDHA_MAX_LAT_ACCEL = 0.036;
// NOTOPO, JPL: 0.0348286193410149 6.1558577433976609 656209.0999486010987312 656209.3120646663010120 / 

  static final double BUDHA_MIN_LAT_ACCEL = -0.044;
// NOTOPO, JPL: -0.0431614487026422 3.7132593670662573 2795997.5029838741756976 2795997.6633058190345764 / 

  static final double BUDHA_MAX_TOPO_LAT_SPEED = 0.37;
// TOPO, SWI:   0.3535327026595066
// TOPO, JPL:   0.3516211846308093 4.3248275513309125 2127856.8769019907340407 / -112.4   20.8 -471130.3

  static final double BUDHA_MIN_TOPO_LAT_SPEED = -0.34;
// TOPO, SWI:   -0.3110366765430237
// TOPO, JPL:   -0.3024348731924316 3.4445804868699952 2815115.3181047569960356 /   11.0   52.2 -110000.0

  static final double BUDHA_MAX_TOPO_LAT_ACCEL = 0.078;
// TOPO, SWI:   0.0709869852337391
// TOPO, JPL:   0.0681552201699322 5.8364023444659665 2681169.2107728449627757 2681169.3127622539177537 /   11.0   52.2 -110000.0

  static final double BUDHA_MIN_TOPO_LAT_ACCEL = -0.10;
// TOPO, SWI:   -0.0922493674654878
// TOPO, JPL:   -0.0729233751466286 3.0273764042146354 2815000.2646535192616284 2815000.4375549573451281 /   11.0   52.2 -110000.0

  static final double BUDHA_MAX_HELIO_LAT_SPEED = 0.7557;
// HELIO, SWI:   0.7553703671754021 16.3688380351721925 1325492.4990891152992845 / 

  static final double BUDHA_MIN_HELIO_LAT_SPEED = -0.4114;
// HELIO, SWI:   -0.4111362907117068 246.4339115609588760 3693212.3529820991680026 / 

  static final double BUDHA_MAX_HELIO_LAT_ACCEL = 0.05938;
// HELIO, SWI:   0.0593445105889032 270.4030522587243581 -249781.5302325247903354 -249781.4385287248005625 / 

  static final double BUDHA_MIN_HELIO_LAT_ACCEL = -0.07986;
// HELIO, SWI:   -0.0798194690969669 158.4460452903338989 3693194.0122220953926444 3693194.1039258954115212 / 


  static final double BUDHA_MAX_DIST_SPEED = 0.0286;
// NOTOPO, SWI: 0.0285361509872121
// NOTOPO, JPL: 0.0284435836536158 17.8220744613078921 2813056.3789104702882469 / 

  static final double BUDHA_MIN_DIST_SPEED = -0.0285;
// NOTOPO, SWI: -0.0283017805993105
// NOTOPO, JPL: -0.0282165685365427 341.9215268668302770 2782882.9571671239100397 / 

  static final double BUDHA_MAX_DIST_ACCEL = 0.00325;
// NOTOPO, SWI: 0.0032332968656052
// NOTOPO, JPL: 0.0032071536310416 3.0073281498403617 1478471.6755875691305846 1478474.2478824988938868 / 

  static final double BUDHA_MIN_DIST_ACCEL = -0.00150;
// NOTOPO, SWI: -0.0014746281509695
// NOTOPO, JPL: -0.0014443126861754 3.0209131307652735 1212364.5652429726906121 1212365.4193637575954199 / 

  static final double BUDHA_MAX_TOPO_DIST_SPEED = 0.031;
// TOPO, SWI:   0.0287123956183378
// TOPO, JPL:   0.0285904873909507 17.8171901085420359 2779452.2660587546415627 /   11.0   52.2 -110000.0

  static final double BUDHA_MIN_TOPO_DIST_SPEED = -0.031;
// TOPO, SWI:   -0.0284478735129602
// TOPO, JPL:   -0.0283720842286670 341.9244805616797294 2720424.8167121694423258 /   11.0   52.2 -110000.0

  static final double BUDHA_MAX_TOPO_DIST_ACCEL = 0.0045;
// TOPO, SWI:   0.0042518661363709
// TOPO, JPL:   0.0041135772523493 3.5253503113738702 823188.5811508881160989 823188.6866559227928519 /   11.0   52.2 -110000.0

  static final double BUDHA_MIN_TOPO_DIST_ACCEL = -0.0026;
// TOPO, SWI:   -0.0024527311665292 0.5167782633536149 -5744.8122126676598782
// TOPO, JPL:   -0.0024167702503400 3.3085032796661267 912476.0649550299858674 912476.1788295382866636 /   11.0   52.2 -110000.0

  static final double BUDHA_MAX_HELIO_DIST_SPEED = 0.005831;
// HELIO, SWI:   0.0058292395555195 220.7147987391139452 3689159.3201326648704708 / 

  static final double BUDHA_MIN_HELIO_DIST_SPEED = -0.005831;
// HELIO, SWI:   -0.0058292162358244 40.8008633501085569 3689566.6684123487211764 / 

  static final double BUDHA_MAX_HELIO_DIST_ACCEL = 0.00064693;
// HELIO, SWI:   0.0006468760807897 130.8217801248015064 3692837.7429590220563114 3692837.8346628220751882 / 

  static final double BUDHA_MIN_HELIO_DIST_ACCEL = -0.0002801;
// HELIO, SWI:   -0.0002799658485144 310.3739292524310827 3689626.8261051611043513 3689626.9178089611232281 / 



///////////////////////////////////////////////////////////////
// SHUKRA: ////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double SHUKRA_MAX_LON_SPEED = 1.266;
// NOTOPO, SWI: 1.2647832575015769 8.0946758136625334 -223273.6698087960830890
// NOTOPO, JPL: 1.2626880451301978 6.8592131288181690 655532.6087605641223490 / 

  static final double SHUKRA_MIN_LON_SPEED = -0.65;
// NOTOPO, SWI: -0.6442598039379197
//              -0.6433716551442837 0.1763535479380494 -92731.2864470719941892
// NOTOPO, JPL: -0.6342143262436917 3.0671365776595962 786068.8421976494137198 / 

  static final double SHUKRA_MAX_LON_ACCEL = 0.0427;
// NOTOPO, SWI: 0.0424074627825448 24.8562467442907575 -233439.0194156236830167 -233438.6142852465854958
// NOTOPO, JPL: 0.0422089427157020 25.5555337892983800 648281.9859329168684781 648282.5466118947369978 / 

  static final double SHUKRA_MIN_LON_ACCEL = -0.0432;
// NOTOPO, SWI: -0.0431008459219351
//              -0.0430347501870898 25.2030500717861798 -114352.8623767224780750 -114352.3139205740008038
// NOTOPO, JPL: -0.0428785353088984 25.7126449364186271 764448.4358926375862211 764448.7770163168897852 / 

  static final double SHUKRA_MAX_TOPO_LON_SPEED = 1.28;
// TOPO, SWI:   1.2730954589558330 5.3700635638143410 -119909.2988172726909397 / -134.0001301493 1.8017167065 -8673.2746795623
// TOPO, JPL:   1.2703027775692810 5.4922725269008765 661377.0886009712703526 /   94.5   -6.2 -491257.9

  static final double SHUKRA_MIN_TOPO_LON_SPEED = -0.70;
// TOPO, SWI:   -0.6936977087256924 1.2466270148142939 445643.9324010963318869 53.4798848587 -4.4726827850 -7886.1605683664
// TOPO, JPL:   -0.6676040834690141 3.6769337485729210 2802347.7158071650192142 /  117.3    9.6 -79312.5

  static final double SHUKRA_MAX_TOPO_LON_ACCEL = 0.246;
// TOPO, SWI:   0.2433226750300663
// TOPO, JPL:   0.2394634181851154 15.7214745858053107 2391279.1253627552650869 2391279.2436700705438852 /   11.0   52.2 -110000.0

  static final double SHUKRA_MIN_TOPO_LON_ACCEL = -0.245;
// TOPO, SWI:   -0.2440019874759702
//              -0.2392102393704883 17.8923225230373077 1870399.8055008733645082 1870399.9183341816533357 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   -0.2390424284021380 14.9008573529047226 2136669.7269426635466516 2136669.8495701653882861 /   11.0   52.2 -110000.0

  static final double SHUKRA_MAX_HELIO_LON_SPEED = 1.635;
// HELIO, SWI:   1.6345969963429665 28.5411734631320897 -246469.8309034941194113 / 

  static final double SHUKRA_MIN_HELIO_LON_SPEED = 1.565;
// HELIO, SWI:   1.5657235503354836 200.4625169758045615 -249508.2529085552669130 / 

  static final double SHUKRA_MAX_HELIO_LON_ACCEL = 0.0009600;
// HELIO, SWI:   0.0009598572231919 280.9144592768616917 -244738.7382710871752352 -244738.6465672871854622 / 

  static final double SHUKRA_MIN_HELIO_LON_ACCEL = -0.001066;
// HELIO, SWI:   -0.0010643800494512 123.9582701334205410 -243939.4479503763141111 -243939.3562465763243381 / 


  static final double SHUKRA_MAX_LAT_SPEED = 0.264;
// NOTOPO, SWI: 0.2626687595047291
// NOTOPO, JPL: 0.2624782757931561 11.9262022773096987 2731687.9197727106511593 / 

  static final double SHUKRA_MIN_LAT_SPEED = -0.251;
// NOTOPO, SWI: -0.2497768135289706
// NOTOPO, JPL: -0.2433475539005757 16.5902349882487457 2771998.1607629279606044 / 

  static final double SHUKRA_MAX_LAT_ACCEL = 0.0167;
// NOTOPO, SWI: 0.0165804236663561
//              0.0165804236663561 0.3206358128090869 -237545.8259068329643924
//              0.0165666745904057 1.1351846329151130 -237546.7287194099626504
// NOTOPO, JPL: 0.0162686363775788 3.2561579239047944 647092.7725445065880194 647096.1254414529539645 / 

  static final double SHUKRA_MIN_LAT_ACCEL = -0.0170;
// NOTOPO, SWI: -0.0168485103248528 0.9333608749641940 2927894.9631067705340683
// NOTOPO, JPL: -0.0166690055753542 3.1949847660659429 2750381.4620271674357355 2750384.3717524991370738 / 

  static final double SHUKRA_MAX_TOPO_LAT_SPEED = 0.29;
// TOPO, SWI:   0.2831649021588232
// TOPO, JPL:   0.2807925180336351 4.8540417206386053 1867489.0201850079465657 /  155.1    5.2 -228627.5

  static final double SHUKRA_MIN_TOPO_LAT_SPEED = -0.27;
// TOPO, SWI:   -0.2679560347521213
// TOPO, JPL:   -0.2575136019376459 11.7339008245196439 2662801.1060125296935439 /   98.9   35.9 -67809.4

  static final double SHUKRA_MAX_TOPO_LAT_ACCEL = 0.13;
// TOPO, SWI:   0.1378583409260294 46.1909521927493358 107038.4291893199551851 ???
// TOPO, JPL:   0.1097291552617890 6.1041719535868992 2541331.0570884267799556 2541331.1783968498930335 /   11.0   52.2 -110000.0

  static final double SHUKRA_MIN_TOPO_LAT_ACCEL = -0.113;
// TOPO, JPL:   -0.1096757005292673 4.5047168297550897 2798261.1054993667639792 2798261.2056133821606636 /   11.0   52.2 -110000.0

  static final double SHUKRA_MAX_HELIO_LAT_SPEED = 0.096175;
// HELIO, SWI:   0.0961600523665297 108.2438555838370746 3690694.4417449808679521 / 

  static final double SHUKRA_MIN_HELIO_LAT_SPEED = -0.09549;
// HELIO, SWI:   -0.0954633604190603 287.0851157642126736 3690355.9630191111937165 / 

  static final double SHUKRA_MAX_HELIO_LAT_ACCEL = 0.002635;
// HELIO, SWI:   0.0026336493450001 18.3791011964134228 3690638.0439079692587256 3690638.1356117692776024 / 

  static final double SHUKRA_MIN_HELIO_LAT_ACCEL = -0.00275;
// HELIO, SWI:   -0.0027399608503963 196.5127385813333944 3671649.8550760606303811 3671649.9467798606492579 / 


  static final double SHUKRA_MAX_DIST_SPEED = 0.00806;
// NOTOPO, SWI: 0.0080571513631017
// NOTOPO, JPL: 0.0080535495091922 45.7633608410767465 2709578.0732003846205771 / 

  static final double SHUKRA_MIN_DIST_SPEED = -0.0083;
// NOTOPO, SWI: -0.0082727691197702
// NOTOPO, JPL: -0.0082468779032532 45.1463900807501659 702493.7312306788517162 / 

  static final double SHUKRA_MAX_DIST_ACCEL = 0.000316;
// NOTOPO, SWI: 0.0003155080110194 0.2863655720027083 2456084.3681465862318873
// NOTOPO, JPL: 0.0003148617982150 3.3090977992377191 2459003.4718500413000584 2459006.3288830956444144 / 

  static final double SHUKRA_MIN_DIST_ACCEL = -0.0000625;
// NOTOPO, JPL: -0.0000621028061790 3.3456973295425030 628716.0880901443306357 628716.5565334432758391 / 

  static final double SHUKRA_MAX_TOPO_DIST_SPEED = 0.0084;
// TOPO, SWI:   0.0082875554200721
// TOPO, JPL:   0.0082556409498835 45.6687320289578338 1993688.0229605080094188 /   58.8   10.4 -195796.3

  static final double SHUKRA_MIN_TOPO_DIST_SPEED = -0.0086;
// TOPO, SWI:   -0.0085208451408857
// TOPO, JPL:   -0.0084076102734088 45.1293851548699507 885846.4561085053719580 /   23.5  -20.4 -1514448.1

  static final double SHUKRA_MAX_TOPO_DIST_ACCEL = 0.0015;
// TOPO, SWI:   0.0016133029911976 37.5183635742056012 1578004.9928161685820669
//              0.0015287997796808 34.0913638843335960 173686.5690354531398043
//              0.0013268597184979 0.4098277826846652 77186.5576645124237984
//              0.0013197716218647 2.7821530204166303 68429.5604983622906730
//              0.0013188910532682 2.6655471745887542 -117845.1594293188245501
//              0.0013187923505480 4.4488933416622478 -203677.0819703953166027
// TOPO, JPL:   0.0013027897288363 352.7189377535082713 996869.4578490457497537 996869.5620547852013260 /   11.0   52.2 -110000.0

  static final double SHUKRA_MIN_TOPO_DIST_ACCEL = -0.00108;
// TOPO, SWI:   -0.0010817151373617
// TOPO, JPL:   -0.0010497207173777 10.8307320066870307 959247.0450016697868705 959247.1561946503352374 /   11.0   52.2 -110000.0

  static final double SHUKRA_MAX_HELIO_DIST_SPEED = 0.0002173;
// HELIO, SWI:   0.0002170449137930 113.7931882800586578 -243721.0094988006749190 / 

  static final double SHUKRA_MIN_HELIO_DIST_SPEED = -0.0002172;
// HELIO, SWI:   -0.0002171265779028 293.5250849778951192 -249449.3790689618326724 / 

  static final double SHUKRA_MAX_HELIO_DIST_ACCEL = 0.000006264;
// HELIO, SWI:   0.0000062615247364 24.2892668796857656 -245124.3527500441705342 -245124.2610462441807613 / 

  static final double SHUKRA_MIN_HELIO_DIST_ACCEL = -0.000005947;
// HELIO, SWI:   -0.0000059448605507 203.6213932657772432 -249506.3271287554816809 -249506.2354249554919079 / 



///////////////////////////////////////////////////////////////
// MANGALA: ///////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double MANGALA_MAX_LON_SPEED = 0.794;
// NOTOPO, SWI: 0.7924011034802300
//              0.7923999077785300 11.1435914022693989 3637945.7966404478065670
// NOTOPO, JPL: 0.7916988325596889 6.9167119757790374 2801868.8330281274393201 / 

  static final double MANGALA_MIN_LON_SPEED = -0.404;
// NOTOPO, SWI: -0.4035876030446059 181.1075756175283971 -133381.5106629475776572
// NOTOPO, JPL: -0.4030886924891714 178.7517637163851987 765886.5689680018695071 / 

  static final double MANGALA_MAX_LON_ACCEL = 0.0146;
// NOTOPO, SWI: 0.0144201733055495 138.9408217217996935 3674267.4152489653788507 3674267.7395811337046325
// NOTOPO, JPL: 0.0143482099752648 140.2555642042337070 2775001.6652576737105846 2775002.1903921556659043 / 

  static final double MANGALA_MIN_LON_ACCEL = -0.0152;
// NOTOPO, SWI: -0.0151951611243569 139.3789158418101692 2995705.9497467507608235 2995706.3421629047952592
// NOTOPO, JPL: -0.0151820773782104 139.4438975414638549 2701669.7693393989466131 2701670.3199220290407538 / 

  static final double MANGALA_MAX_TOPO_LON_SPEED = 0.81;
// TOPO, SWI:   0.7978851329427278 10.6081894629459370 3637948.2466299664229155 / -73.1792811466 0.3048884826 -2277.6546379790
// TOPO, JPL:   0.7960217543847412 8.4886529063329021 2375236.6571041969582438 /  -55.8  -29.9 -148873.0

  static final double MANGALA_MIN_TOPO_LON_SPEED = -0.425;
// TOPO, SWI:   -0.4251354442483760 178.7310683058734924 910171.7125146181788296 164.9964835365 -3.6069752029 -1770.8396081481
// TOPO, JPL:   -0.4217527221879939 177.4278470210484215 1624600.6255326191894710 / -172.9    6.1 -11919880.7

  static final double MANGALA_MAX_TOPO_LON_ACCEL = 0.16;
// TOPO, SWI:   0.1594830996296811
// TOPO, JPL:   0.1581185147318458 164.8598694285395254 1587935.7841508002020419 1587935.8985285095404834 /   11.0   52.2 -110000.0

  static final double MANGALA_MIN_TOPO_LON_ACCEL = -0.159;
// TOPO, SWI:   -0.1600745968788799
// TOPO, JPL:   -0.1575627566541741 195.6087128096599201 1011543.7506678751669824 1011543.8712390246801078 /   11.0   52.2 -110000.0

  static final double MANGALA_MAX_HELIO_LON_SPEED = 0.6390;
// HELIO, SWI:   0.6389722961369398 38.5888496237665564 3692221.7685342952609062 / 

  static final double MANGALA_MIN_HELIO_LON_SPEED = 0.4337;
// HELIO, SWI:   0.4338204904498673 219.8718624697718553 3692568.0420831665396690 / 

  static final double MANGALA_MAX_HELIO_LON_ACCEL = 0.0010154;
// HELIO, SWI:   0.0010153217397727 321.7780423771454252 3644009.9629351710900664 3644010.0546389711089432 / 

  static final double MANGALA_MIN_HELIO_LON_ACCEL = -0.0010040;
// HELIO, SWI:   -0.0010038374801163 111.8068234376216026 3623648.4179941797628999 3623648.5096979797817767 / 


  static final double MANGALA_MAX_LAT_SPEED = 0.084;
// NOTOPO, SWI: 0.0838791710904641
// NOTOPO, JPL: 0.0826741249250192 149.2256722049210964 2775802.2559480732306838 / 

  static final double MANGALA_MIN_LAT_SPEED = -0.0839;
// NOTOPO, SWI: -0.0839678022834778
// NOTOPO, JPL: -0.0835340883879389 212.7210446501029537 642620.7923325931187719 / 

  static final double MANGALA_MAX_LAT_ACCEL = 0.0035;
// TOPO, SWI:   0.0150844307385327
// NOTOPO, JPL: 0.0034312254609595 179.0833441786972458 1864807.3567141420207918 1864807.9489276432432234 / 

  static final double MANGALA_MIN_LAT_ACCEL = -0.00209;
// NOTOPO, JL:  -0.0020809749032211 181.0128907777466907 641061.4951947031076998 641062.4194994299905375 / 

  static final double MANGALA_MAX_TOPO_LAT_SPEED = 0.095;
// TOPO, SWI:   0.0946720976575474
// TOPO, JPL:   0.0934035953265691 141.4811497310967923 2452914.9284494239836931 / -167.4   -2.0 -138827.1

  static final double MANGALA_MIN_TOPO_LAT_SPEED = -0.099;
// TOPO, SWI:   -0.0987979399086970
// TOPO, JPL:   -0.0983824901801166 215.6813984319298356 671476.8615393596701324 /  148.2   -4.8 -163423.1

  static final double MANGALA_MAX_TOPO_LAT_ACCEL = 0.0805;
// TOPO, SWI:   0.0815886852824428
// TOPO, JPL:   0.0790804782253402 180.4389968986509984 1968536.3902757749892771 1968536.4967305311001837 /   11.0   52.2 -110000.0

  static final double MANGALA_MIN_TOPO_LAT_ACCEL = -0.074;
// TOPO, SWI:   -0.0743551255625984 182.0980439241689623 1467039.2266495153307915
//              -0.0740879859432727 176.2125902326463347 1247878.3800865092780441
//              -0.0737518990689433 173.0047672387801754 1011562.5490168932592496
//              -0.0737143543505757 180.5839243595314088 965544.5294687077403069
// TOPO, JPL:   -0.0724526307717358 175.4123787295656030 1069278.4057305362075567 1069278.5368578748311847 /   11.0   52.2 -110000.0

  static final double MANGALA_MAX_HELIO_LAT_SPEED = 0.01994;
// HELIO, SWI:   0.0199363918750256 70.7836160760459450 3688837.9900173987261951 / 

  static final double MANGALA_MIN_HELIO_LAT_SPEED = -0.02097;
// HELIO, SWI:   -0.0209531861088103 175.4596345000853717 -247053.7089980290038511 / 

  static final double MANGALA_MAX_HELIO_LAT_ACCEL = 0.00023610;
// HELIO, SWI:   0.0002360833916200 297.3654306829167808 1563918.6192823941819370 1563918.7109861942008138 / 

  static final double MANGALA_MIN_HELIO_LAT_ACCEL = -0.0001698;
// HELIO, SWI:   -0.0001696921085373 111.0114103765569524 -238922.2413491358456668 -238922.1496453358558938 / 


  static final double MANGALA_MAX_DIST_SPEED = 0.0101;
// NOTOPO, SWI: 0.0100696780219029
// NOTOPO, JPL: 0.0100643683479973 269.1737141447110844 1168446.4021066790446639 / 

  static final double MANGALA_MIN_DIST_SPEED = -0.01028;
// NOTOPO, SWI: -0.0102784274030799
// NOTOPO, JPL: -0.0102749478825399 89.3012469145790249 2768620.8741885176859796 / 

  static final double MANGALA_MAX_DIST_ACCEL = 0.000234;
// NOTOPO, JPL: 0.0002316456520849 179.5008629993195086 627831.8675719088641927 627832.2966464573983103 / 

  static final double MANGALA_MIN_DIST_ACCEL = -0.0000695;
// NOTOPO, JPL: -0.0000691512115045 11.0863619757200809 2717708.7934102085418999 2717709.6335888337343931 / 

  static final double MANGALA_MAX_TOPO_DIST_SPEED = 0.0103;
// TOPO, SWI:   0.0102954964561265
// TOPO, JPL:   0.0102750877650412 268.7006393613465889 1006998.9210776721592993 /   73.4  -18.6 -558591.5

  static final double MANGALA_MIN_TOPO_DIST_SPEED = -0.0105;
// TOPO, SWI:   -0.0104995980338152
// TOPO, JPL:   -0.0104858185492511 87.8865272461379448 1857654.5719206309877336 /   -6.4  -17.5 -118807.5

  static final double MANGALA_MAX_TOPO_DIST_ACCEL = 0.00123;
// TOPO, SWI:   0.0131818153230207 284.9959789257900411 2332152.0145044443197548 ???
//              0.0012887713662012 66.6736237261732754 -199097.2332733191724401
//              0.0012319051338675 186.5730858460568982 -219956.4541361356095877
//              0.0012209446543432 191.8766370799966694 -237121.3987246403994504
// TOPO, JPL:   0.0012161423072440 177.4947770238408111 2709471.4839383927173913 2709471.5907205441035330 /   11.0   52.2 -110000.0

  static final double MANGALA_MIN_TOPO_DIST_ACCEL = -0.0011;
// TOPO, SWI:   -0.0011484037922081
// TOPO, JPL:   -0.0010620822452651 6.5326082583946175 2458748.4108516005799174 2458748.5186086511239409 /   11.0   52.2 -110000.0

  static final double MANGALA_MAX_HELIO_DIST_SPEED = 0.0013516;
// HELIO, SWI:   0.0013512901958924 128.7421869245407891 3692372.7129891263321042 / 

  static final double MANGALA_MIN_HELIO_DIST_SPEED = -0.0013516;
// HELIO, SWI:   -0.0013511444563732 308.7302742910854363 3692071.3743022643029690 / 

  static final double MANGALA_MAX_HELIO_DIST_ACCEL = 0.000015148;
// HELIO, SWI:   0.0000151459885774 38.5783203257149481 3688100.0495386468246579 3688100.1412424468435347 / 

  static final double MANGALA_MIN_HELIO_DIST_ACCEL = -0.000010287;
// HELIO, SWI:   -0.0000102844622590 204.9344476307170453 3488519.7507371641695499 3488519.8424409641884267 / 



///////////////////////////////////////////////////////////////
// GURU: //////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double GURU_MAX_LON_SPEED = 0.244;
// NOTOPO, SWI: 0.2440421007508337
//              0.2440259758282694 2.4045041461050332 3673053.9168258565478027
// NOTOPO, JPL: 0.2428335951258063 3.5461868267948500 2789118.9510614373721182 / 

  static final double GURU_MIN_LON_SPEED = -0.1369;
// NOTOPO, SWI: -0.1368829493523590
//              -0.1368820455359945 180.5832645904395974 -126113.4864928905444685
// NOTOPO, JPL: -0.1368635903173349 180.2193463784294352 692797.0914358530426398 / 

  static final double GURU_MAX_LON_ACCEL = 0.00354;
// NOTOPO, SWI: 0.0035312724306166 118.2817491102233305 943749.3540715674171224 943749.9294602031586692
// NOTOPO, JPL: 0.0035309507851668 118.5755994645865883 1502585.2467730506323278 1502585.3801854311022907 / 

  static final double GURU_MIN_LON_ACCEL = -0.00341;
// NOTOPO, SWI: -0.0034097053893441 119.9554019791229251 1983930.3803575735073537 1983931.0591147949453443
// NOTOPO, JPL: -0.0034095472991935 120.0438930832596185 1983930.2414474771358073 1983931.1471178678330034 / 

  static final double GURU_MAX_TOPO_LON_SPEED = 0.247;
// TOPO, SWI:   0.2460278822288060 2.1064740906293338 3322029.5618714890442789 / 96.3836141934 -9.9928840953 1721.5766618645
// TOPO, JPL:   0.2442154523229398 3.3737604511064614 2754425.1945888693444431 /  122.8   25.8 -897076.0

  static final double GURU_MIN_TOPO_LON_SPEED = -0.1405;
// TOPO, SWI:   -0.1403693939861765 179.9408142246988405 25463.4141226465580985 -91.5628546501 10.5366468238 -9284.9218899931
// TOPO, JPL:   -0.1396304331965231 180.0090680002970203 2248445.7305190265178680 /  -84.7    6.2 -317954.6

  static final double GURU_MAX_TOPO_LON_ACCEL = 0.0167;
// TOPO, SWI:   0.0166640244576276 233.6485834274197657 3647377.9916880093514919 3647378.0923984586261213 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   0.0166038808349592 139.5821134077839929 627013.4600588139146566 627013.5647328060586005 /   11.0   52.2 -110000.0

  static final double GURU_MIN_TOPO_LON_ACCEL = -0.0167;
// TOPO, SWI:   -0.2986882995560264
//              -0.0167151480688178 133.2242486904405609 3595432.6970099876634777 3595432.8167069852352142 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   -0.0164094314567562 143.2682748867993894 2768159.3273530141450465 2768159.4401315618306398 /   11.0   52.2 -110000.0

  static final double GURU_MAX_HELIO_LON_SPEED = 0.09287;
// HELIO, SWI:   0.0928627009268541 66.9911679618450080 3677495.4221044639125466 / 

  static final double GURU_MIN_HELIO_LON_SPEED = 0.074689;
// HELIO, SWI:   0.0746943113920974 250.5956808555321800 3675371.6537998267449439 / 

  static final double GURU_MAX_HELIO_LON_ACCEL = 0.000036229;
// HELIO, SWI:   0.0000362251116003 328.8083053523092758 3650403.1850572871044278 3650403.2767610871233046 / 

  static final double GURU_MIN_HELIO_LON_ACCEL = -0.000036650;
// HELIO, SWI:   -0.0000366474238688 109.3278113170298411 3093308.6523934118449688 3093308.7440972118638456 / 


  static final double GURU_MAX_LAT_SPEED = 0.0063;
// NOTOPO, SWI: 0.0079894240821371 0.0601560551081519 78316.4185760746622691
//              0.0066476398233534 110.1376464895660945 -221383.3737826585129369
//              0.0066473160629214 110.6666841914722283 -221383.9030312743270770
//              0.0066457814709434 111.5006250978595972 -221384.7351701248844620
// NOTOPO, JPL: 0.0061908432229009 112.4269545307679437 649380.0055553948041052 / 

  static final double GURU_MIN_LAT_SPEED = -0.0062;
// NOTOPO, SWI: -0.0082475742115319 0.0446656653053310 2372287.4256182522512972
//              -0.0081679544726280 0.0566917774685862 1999729.6744490496348590
//              -0.0078159575125308 0.0314825326859705 1284929.4563959073275328
//              -0.0071024444607525 0.0636199730191720 1038020.3583645855542272
//              -0.0066793857937898 0.0852753287601900 -205301.8630813817726448
//              -0.0066175032562629 246.6068273788177123 -221909.5236041555763222
//              -0.0066170859380376 247.3438921056017250 -221910.2942210272594821
//              -0.0066158312691210 248.0264418159172806 -221911.0099419929028954
//              -0.0066137971865199 248.7655093363266019 -221911.7872256411646958
// NOTOPO, JPL: -0.0061251895775237 248.6116143133203593 644464.3267154396744445 / 

  static final double GURU_MAX_LAT_ACCEL = 0.000164;
// NOTOPO, JPL: 0.0001631012173349 172.8998017132045675 688014.7479439852759242 688015.2237591258017346 / 

  static final double GURU_MIN_LAT_ACCEL = -0.000144;
// NOTOPO, JPL: -0.0001428277204568 180.4011236746345617 660078.9308878154261038 660079.5882852224167436 / 

  static final double GURU_MAX_TOPO_LAT_SPEED = 0.0074;
// TOPO, SWI:   0.0080521928636294 0.0566192805632610 918765.6333176256157458
//              0.0074940630316397 114.0953024122408124 -247314.5005948057223577
//              0.0074740423582702 117.1124623989528573 -247317.4677769242262002
//              0.0073365824436177 124.3399166578952872 -247324.4473215647449251
// TOPO, JPL:   0.0072166314932738 109.0304781092945063 701237.9247726293979213 /  -42.0    9.3 -11969401.6

  static final double GURU_MIN_TOPO_LAT_SPEED = -0.0074;
// TOPO, SWI:   -0.0080876975949050 0.0340482972944187 877668.4739827105076984
//              -0.0079257941735561 0.0548291341236222 353535.4688255244982429
//              -0.0074868031086838 244.7003594482700066 -195980.6305575540463906
//              -0.0074791206548048 239.8774896996048938 -226290.6132767098606564
//              -0.0074452255799583 252.2918423249091120 -226303.5950242244580295
//              -0.0074393971860641 253.1862647845265144 -226304.5564436963759363
// TOPO, JPL:   -0.0072441693905558 249.4712924749894398 648851.6447883903747424 /  178.5    4.1 -175983.9

  static final double GURU_MAX_TOPO_LAT_ACCEL = 0.0064;
// TOPO, SWI:   0.0064370403082856 160.9893348765497763 -243369.5462068344349973
// TOPO, JPL:   0.0062836812390572 173.4311152344720313 804886.0647488388931379 804886.1658009625971317 /   11.0   52.2 -110000.0

  static final double GURU_MIN_TOPO_LAT_ACCEL = -0.00601;
// TOPO, SWI:   -0.1037547091237699 0.0125813165357158 505110.7392954186070710
//              -0.0378655962663130 0.1083443186038267 -138278.1849216190457810
//              -0.0360539293255533 0.1266684501299267 -240004.5811667661473621
//              -0.0061777644919788 168.4064816875281565 -243376.0363520069804508
//              -0.0060227498357402 173.1109147544705138 -245394.4910242093901616
//              -0.0058877265072794 206.9527394385040679 -247797.8501246784289833
//              -0.0058695732378666 222.0752014979657929 -247811.8569919402361847
// TOPO, JPL:   -0.0060022250346072 176.9020558316282461 960847.4024146875599399 960847.5054992398945615 /   11.0   52.2 -110000.0

  static final double GURU_MAX_HELIO_LAT_SPEED = 0.0024277;
// HELIO, SWI:   0.0024274075351303 24.1982071435144270 -242259.2509269636939280 / 

  static final double GURU_MIN_HELIO_LAT_SPEED = -0.002620;
// HELIO, SWI:   -0.0026180011024933 209.3152760572297666 -231289.4589645870728418 / 

  static final double GURU_MAX_HELIO_LAT_ACCEL = 0.000013982;
// HELIO, SWI:   0.0000139791156248 290.1337720231981052 -156753.1605556995491497 -156753.0688518995593768 / 

  static final double GURU_MIN_HELIO_LAT_ACCEL = -0.000013189;
// HELIO, SWI:   -0.0000131838416505 100.2099435249254356 -163337.8602101652068086 -163337.7685063652170356 / 


  static final double GURU_MAX_DIST_SPEED = 0.0163;
// NOTOPO, SWI: 0.0162313440373101
// NOTOPO, JPL: 0.0162125062673481 269.9885757091312826 2746737.7407946651801467 / 

  static final double GURU_MIN_DIST_SPEED = -0.0164;
// NOTOPO, SWI: -0.0163119973755655
// NOTOPO, JPL: -0.0162962764487217 89.9528066433123001 2813565.0229882504791021 / 

  static final double GURU_MAX_DIST_ACCEL = 0.000325; // ???
// NOTOPO, SWI: 0.0028131695540130 252.0199342955070279 3389970.8170315762981772
//              0.0022264700183521 78.0262633819467624 2959356.3896456728689373
//              0.0021058202921303 56.3220986050345331 689082.5046896804124117
//              0.0014148556073934 312.1296276860581997 138881.9097125186235644
//              0.0003629278483912 175.2126664382685988 103648.3659716135007329
//              0.0003215421089300 179.8650599366537790 -130102.0682320412161062
//              0.0003215231118657 180.5493323734873172 -130102.6579265795007814
//              0.0003214350810835 180.8083546044778416 -130102.8811461286386475
// NOTOPO, JPL: 0.0003212791490395 179.1139733917144667 749437.0917171647306532 749437.5507154314545915 / 

  static final double GURU_MIN_DIST_ACCEL = -0.000225;
// NOTOPO, SWI: -0.0026706423885953 54.9988325446786490 2244330.1662299656309187
//              -0.0011107400422637 240.5622614243510213 1324971.5582129028625786
//              -0.0010463882202215 46.6627522885998758 -45687.3579329831190989
//              -0.0007706904056781 37.7983780909854090 -80098.6155146874953061
//              -0.0002399030274792 1.4728896000519569 -102383.2875191967032151
//              -0.0002340892813117 37.6730895540927406 -214825.2211170222435612
//              -0.0002202596930024 0.6216123376105145 -236411.7266815737239085
// NOTOPO, JPL: -0.0002200487479365 3.0727983914445929 820633.5672682302538306 820635.0164746360387653 / 

  static final double GURU_MAX_TOPO_DIST_SPEED = 0.0165;
// TOPO, SWI:   0.0164463865294178
// TOPO, JPL:   0.0163933358236029 269.7074039544052084 2798591.6030700867995620 /  -32.5  -27.2 -252818.2

  static final double GURU_MIN_TOPO_DIST_SPEED = -0.0166;
// TOPO, SWI:   -0.0165316055601204
// TOPO, JPL:   -0.0164783521489150 90.7489162720576417 2354449.6322963917627931 /  -52.4   -5.9 -559160.2

  static final double GURU_MAX_TOPO_DIST_ACCEL = 0.00133; // ???
// TOPO, SWI:   0.0207137582627566 173.7974512158892821 3371308.6819511819630861
//              0.0095682916573331 98.6288452876610506 2352478.9396295030601323
//              0.0017434341399401 3.7222567351049491 1672652.3170623441692442
//              0.0013784181224652 262.1285954707602173 385732.5318781036767177
//              0.0013364439220739 175.2229360370665177 220911.8912446679605637
//              0.0013343946830275 188.1894899974843725 -207878.5227978868060745
// TOPO, JPL:   0.0013140810305337 183.5053747524114840 1177835.8770452847238630 1177835.9799993557389826 /   11.0   52.2 -110000.0

  static final double GURU_MIN_TOPO_DIST_ACCEL = -0.00122;
// TOPO, SWI:   -0.0344816332659920 53.5806245234392833 -59632.7241606430397951
//              -0.0012291085316648 11.8839758867454179 -110381.6067325769108720
//              -0.0012237729790972 6.0617096993218524 -218870.4614361103449482
//              -0.0012218538662633 17.5817593377373669 -231605.5168245942331851
//              -0.0012137029216628 18.3605833587742779 -248803.3674780579749495
//              -0.0012040965556822 20.9413774401508306 -249151.5155578464036807
// TOPO, JPL:   -0.0012179154714779 8.0924125333128529 1401019.6981153180822730 1401019.8004333155695349 /   11.0   52.2 -110000.0

  static final double GURU_MAX_HELIO_DIST_SPEED = 0.00040998;
// HELIO, SWI:   0.0004099313964266 159.2065436807666003 3678526.9064470762386918 / 

  static final double GURU_MIN_HELIO_DIST_SPEED = -0.00040970;
// HELIO, SWI:   -0.0004096271887829 339.9366797673709470 3676519.6936722630634904 / 

  static final double GURU_MAX_HELIO_DIST_ACCEL = 0.00000077866;
// HELIO, SWI:   0.0000007786535735 63.4473366088961370 3504225.8605663971975446 3504225.9522701972164214 / 

  static final double GURU_MIN_HELIO_DIST_ACCEL = -0.0000006786;
// HELIO, SWI:   -0.0000006785337605 239.2603627683639331 3679550.5042628869414330 3679550.5959666869603097 / 



///////////////////////////////////////////////////////////////
// SHANI: /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double SHANI_MAX_LON_SPEED = 0.13404;
// NOTOPO, SWI: 0.1340290794104446
//              0.1340109648692031 2.1226092234817315 -163206.2606100863777101
// NOTOPO, JPL: 0.1327805183874537 3.0429635221465219 644396.1415654856245965 / 

  static final double SHANI_MIN_LON_SPEED = -0.084;
// NOTOPO, SWI: -0.0843874858704462
//              -0.0843863197679707 180.0316197536598963 -119529.3726371085940627
// NOTOPO, JPL: -0.0839205001027148 179.7538351952555615 634005.4940949525916949 / 

  static final double SHANI_MAX_LON_ACCEL = 0.00199;
// NOTOPO, SWI: 0.0019860635653615 108.7583081509525584 -238564.3131895941623952 -238563.9070349260582589
// NOTOPO, JPL: 0.0019704643133465 107.7955867333490403 773209.0539155729347840 773209.4716971723828465 / 

  static final double SHANI_MIN_LON_ACCEL = -0.00195;
// NOTOPO, SWI: -0.0019461144643805 250.6294677312978081 -162317.6448787293047644 -162317.4296173398906831
// NOTOPO, JPL: -0.0019411597276414 107.9127693051768802 881969.6117141979048029 881969.9048477461328730 / 

  static final double SHANI_MAX_TOPO_LON_SPEED = 0.134;
// TOPO, SWI:   0.1352241917838550 2.6437337111698298 -120105.1467321325326338 / -135.7469844874 -1.5235966413 -9149.1494438681
// TOPO, JPL:   0.1335384540876906 356.4228793916646509 859531.2081036102026701 /   11.0   52.2 -110000.0

  static final double SHANI_MIN_TOPO_LON_SPEED = -0.0855;
// TOPO, SWI:   -0.0857898683346270
//              -0.0857859482664416 180.4511195292874675 -205733.7354889601992909 57.1340338590 -6.0390360608 2936.3009470154
// TOPO, JPL:   -0.0849641804905260 180.3456957179522249 956896.5353130036965013 / -131.2  -32.9 -486057.8

  static final double SHANI_MAX_TOPO_LON_ACCEL = 0.0086;
// TOPO, SWI:   0.0088537626365099 (Problems up to 0.5749467950953074 observed...)
//              0.0086874752939179 130.3835869430225216 -228378.3960538489336614 -228378.2941615929012187 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   0.0085688265882089 235.0153479090199369 2399366.5584685457870364 2399366.6685493290424347 /   11.0   52.2 -110000.0

  static final double SHANI_MIN_TOPO_LON_ACCEL = -0.00864;
// TOPO, SWI:   -0.0086350102928645 240.9329383039785171 -217516.6292963425803464 -217516.5270764300366864 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   -0.0086289532791422 120.5645061952920400 1850273.4720761652570218 1850273.5765058014076203 /   11.0   52.2 -110000.0

  static final double SHANI_MAX_HELIO_LON_SPEED = 0.03929;
// HELIO, SWI:   0.0392863193240564 317.5875186572542361 -141323.4459846203099005 / 

  static final double SHANI_MIN_HELIO_LON_SPEED = 0.028729;
// HELIO, SWI:   0.0287253130874837 138.1279528643018466 -125169.3630964851909084 / 

  static final double SHANI_MAX_HELIO_LON_ACCEL = 0.000026497;
// HELIO, SWI:   0.0000264905932645 256.8403404043374394 -13884.8760147858520213 -13884.7843109858513344 / 

  static final double SHANI_MIN_HELIO_LON_ACCEL = -0.000026590;
// HELIO, SWI:   -0.0000265885415246 29.3553038569937002 -203927.2459388385759667 -203927.1542350385861937 / 


  static final double SHANI_MAX_LAT_SPEED = 0.0055;
// NOTOPO, SWI: 0.0088659593013574 0.0357855361262125 1216463.8803999235387892
//              0.0081800060242820 0.0636244767979335 -9686.2452881572171464
//              0.0055101641996105 103.1816729109932567 -248384.6794485895079561
//              0.0055092577650856 103.9915755785259250 -248385.4973858597222716
//              0.0055085351164070 104.2998464057047556 -248385.8082728039298672
//              0.0055061985781587 104.9731251070553526 -248386.4864187667553779
// NOTOPO, JPL: 0.0054479762180281 101.5087719957672618 633699.7182570304721594 / 

  static final double SHANI_MIN_LAT_SPEED = -0.0054;
// NOTOPO, SWI: -0.0093448258414916 0.0480108040459299 2405172.1235335594974458
//              -0.0091669774974187 0.0437628531739165 1017947.0968454070389271
//              -0.0082309467247685 0.0735537640593975 -46761.3712922931881621
//              -0.0059085247284603 0.0737067784886278 -186653.2304984880902339
//              -0.0054935401134247 256.1125920323701166 -227737.3836737677629571
//              -0.0054924209794990 256.8583947276435424 -227738.1576579157263041
//              -0.0054893589421577 257.5657401830940216 -227738.8932042158266995
//              -0.0054866869674104 257.9952243323996868 -227739.3405110478342976
//              -0.0054846770087000 258.2735656374735527 -227739.6306852521665860
// NOTOPO, JPL: -0.0052759566378740 255.1213087279579099 632794.2191756315296516 / 

  static final double SHANI_MAX_LAT_ACCEL = 0.000123;
// NOTOPO, JPL: 0.0001228331245459 182.3412334534269803 730035.7467638771049678 730036.3191362058278173 / 

  static final double SHANI_MIN_LAT_ACCEL = -0.000104;
// NOTOPO, JPL: -0.0001036095956202 181.2808113227449383 2541859.8319580527022481 2541860.2949275760911405 / 

  static final double SHANI_MAX_TOPO_LAT_SPEED = 0.006;
// TOPO, JPL:   0.0059829280424917 254.7257709873013880 1203859.3423178326338530 /  120.7    8.1 -268428.1

  static final double SHANI_MIN_TOPO_LAT_SPEED = -0.0059;
// TOPO, SWI:   -0.0092855309799147
// TOPO, JPL:   -0.0057956247321725 253.1921945803524636 632796.2324350061826408 / -170.8  -37.9 -11959137.5

  static final double SHANI_MAX_TOPO_LAT_ACCEL = 0.0032;
// TOPO, SWI:   0.1291812952134777 0.0193139412162679 652331.3204417930683121
//              0.1103411440697414 48.3201736850982115 337716.2472735045594163 ???
//              0.0406681081950653 0.1330846070859195 140796.5907405762118287
//              0.0248291370689390 0.1817467500329428 -25209.8627429512453091
//              0.0192489692315691 0.3364410508429501 -208203.9115095509332605
//              0.0154213763216727 0.0787234050482084 -229755.7019914422999136
//              0.0106410980662519 0.0625985933783042 -246369.5177199522149749
//              0.0033936272027591 196.6164942212680273 -249231.4910817339550704
//              0.0033477521784859 184.6683619648643742 -249600.4166902992583346
//              0.0032692627409362 158.9229430463847450 -249956.4608254602062516
//              0.0032065821914758 188.1027910938801142 -249983.3395146315742750
// TOPO, JPL:   0.0031905232971144 163.4044039250840399 665019.1348916188580915 665019.2585872148629278 /   11.0   52.2 -110000.0

  static final double SHANI_MIN_TOPO_LAT_ACCEL = -0.00301;
// TOPO, SWI:   -0.1943805609996636 0.0254947304431425 3093302.9852960119023919
//              -0.1535901747923263 0.0044428449655527 399030.9463442072155885
//              -0.0967942061450560 0.0375247351963210 33416.6073811288442812
//              -0.0244403526037960 0.1095505791075055 -63374.4509422093688045
//              -0.0222436811141467 0.0710847034876565 -208204.2186171786452178
//              -0.0105777641070009 0.4226321633859698 -229755.1313364572997671
//              -0.0076972631775804 0.8873846478899594 -246368.5475377420661971
//              -0.0031570907055125 133.9147902428757675 -249174.1276894060720224
//              -0.0031355393451151 160.1263956863335522 -249577.9961592703766655
//              -0.0031248092521445 146.5321463786839047 -249945.0155428809521254
//              -0.0030320551971996 215.1038187030328004 -250008.7760764319973532
// TOPO, JPL:   -0.0029976150401222 175.5931959224585910 643456.6917577013373375 643456.7943882376421243 /   11.0   52.2 -110000.0

  static final double SHANI_MAX_HELIO_LAT_SPEED = 0.0016789;
// TOPO, SWI:   0.0016787509915327 86.8382273056848675 1603490.4596589398570359 / 

  static final double SHANI_MIN_HELIO_LAT_SPEED = -0.001653;
// TOPO, SWI:   -0.0016511099048983 237.1846542050762139 -218721.8199911886476912 / 

  static final double SHANI_MAX_HELIO_LAT_ACCEL = 0.00001127;
// TOPO, SWI:   0.0000112505215212 280.4320180801719857 40481.4467037630238337 40481.5384075630208827 / 

  static final double SHANI_MIN_HELIO_LAT_ACCEL = -0.000011128;
// TOPO, SWI:   -0.0000111203157507 94.9581807129803082 13091.7225350638673262 13091.8142388638680131 / 



  static final double SHANI_MAX_DIST_SPEED = 0.0168;
// NOTOPO, SWI: 0.0167980101137831
// NOTOPO, JPL: 0.0167470550342229 270.1922148977790812 775126.5858114481670782 / 

  static final double SHANI_MIN_DIST_SPEED = -0.0169;
// NOTOPO, SWI: -0.0168541607915517
// NOTOPO, JPL: -0.0168033574476849 90.2359820156960382 887610.1793931820429862 / 

  static final double SHANI_MAX_DIST_ACCEL = 0.000322;
// NOTOPO, JPL: 0.0003217576664089 180.6124093899778131 924759.4654094257857651 924760.1071097153471783 / 

  static final double SHANI_MIN_DIST_ACCEL = -0.00027;
// NOTOPO, JPL: -0.0002649687841804 3.1537517381507030 940823.5889109726995230 940828.3583899141522124 / 

  static final double SHANI_MAX_TOPO_DIST_SPEED = 0.017;
// TOPO, SWI:   0.0170041976808882
// TOPO, JPL:   0.0168998454699344 272.9172717291329491 784956.1169768150430173 /   83.1   20.2 -559218.8

  static final double SHANI_MIN_TOPO_DIST_SPEED = -0.01702;
// TOPO, SWI:   -0.0170839780153652
// TOPO, JPL:   -0.0170159989383753 90.6219157816285019 929959.2261485378257930 /  -34.6   16.0 -275006.2

  static final double SHANI_MAX_TOPO_DIST_ACCEL = 0.00133;
// TOPO, JPL:   0.0013147485636233 187.2595322712119810 773528.1895404278766364 773528.3051549824886024 /   11.0   52.2 -110000.0

  static final double SHANI_MIN_TOPO_DIST_ACCEL = -0.00127;
// TOPO, JPL:   -0.0012570696593106 5.8823054507581105 1155577.9214635647367686 1155578.0259339711628854 /   11.0   52.2 -110000.0

  static final double SHANI_MAX_HELIO_DIST_SPEED = 0.00043914;
// HELIO, SWI:   0.0004391103911836 46.9611293867110717 -138912.4613790891889948 / 

  static final double SHANI_MIN_HELIO_DIST_SPEED = -0.00044091;
// HELIO, SWI:   -0.0004408927261835 227.7000305924591714 -122231.1733443466218887 / 

  static final double SHANI_MAX_HELIO_DIST_ACCEL = 0.00000043248;
// HELIO, SWI:   0.0000004324331078 308.5743196638426298 -109287.1819737361656735 -109287.0902699361613486 / 

  static final double SHANI_MIN_HELIO_DIST_ACCEL = -0.00000041039;
// HELIO, SWI:   -0.0000004103761552 171.0750927467988731 681864.8851704276166856 681864.9768742276355624 / 



///////////////////////////////////////////////////////////////
// URANUS: ////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double URANUS_MAX_LON_SPEED = 0.067;
// NOTOPO, SWI: 0.0672787417212825 2.2044883144310603 -198847.3157617567048874
// NOTOPO, JPL: 0.0635219827469326 3.0865801839384801 1120454.5702892334666103 / 

  static final double URANUS_MIN_LON_SPEED = -0.044;
// NOTOPO, SWI: -0.0439753677256215
//              -0.0439749353957933 179.1371858363940532 2805890.5954912416636944
// NOTOPO, JPL: -0.0439737691898081 179.7845571918695100 2805891.2095267488621175 / 

  static final double URANUS_MAX_LON_ACCEL = 0.000929;
// NOTOPO, SWI: 0.0009287961354995 96.5197421388259897 3663572.4564131293445826 3663573.4440292418003082
// NOTOPO, JPL: 0.0009282638132935 97.8842174477335902 2529097.6063587637618184 2529098.3723707860335708 / 

  static final double URANUS_MIN_LON_ACCEL = -0.000975;
// NOTOPO, SWI: -0.0009749151187470 99.5153225338921601 74425.5413598613231443 74426.1704895895527443
// NOTOPO, JPL: -0.0009743654979471 101.0515095115334816 2501959.5002480042167008 2501960.0762184909544885 / 

  static final double URANUS_MAX_TOPO_LON_SPEED = 0.067;
// TOPO, SWI:   0.0678142990549242
//              0.0659933143859741 2.6624668048619782 -229528.4862648595299106 / 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   0.0639666873114370 3.7716406512730885 1181818.1529458123259246 /  -36.6  -13.9 -1936737.7

  static final double URANUS_MIN_TOPO_LON_SPEED = -0.045;
// TOPO, SWI:   -0.0446931660419553 181.3720736420628157 995316.5729154800064862 -148.1483065444 23.8884500241 -8408.4451827214
// TOPO, JPL:   -0.0445080603496004 177.0986226535454193 2558587.0008950615301728 / -146.4    7.0 -302922.1

  static final double URANUS_MAX_TOPO_LON_ACCEL = 0.00408;
// TOPO, SWI:   0.0040746860036361 250.1776503311332363 995014.1325893194880337 995014.2447810187004507 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   0.0040768658697398 258.9330392610905847 688949.3911929061869159 688949.4914812404895201 /   11.0   52.2 -110000.0

  static final double URANUS_MIN_TOPO_LON_ACCEL = -0.00414;
// TOPO, SWI:   -0.0041389274636002 108.3810328551985265 -229420.5110600728949066 -229420.4092381796508562 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   -0.0041032458702222 111.1018605931466396 1149396.9018011584412307 1149397.0059658905956894 /   11.0   52.2 -110000.0

  static final double URANUS_MAX_HELIO_LON_SPEED = 0.013090;
// HELIO, SWI:   0.0130882638262029 111.5468703607783283 1088462.0190283237025142 / 

  static final double URANUS_MIN_HELIO_LON_SPEED = 0.010609;
// HELIO, SWI:   0.0106057318592638 247.7111524234007902 -246053.6790591405297164 / 

  static final double URANUS_MAX_HELIO_LON_ACCEL = 0.000023908;
// HELIO, SWI:   0.0000239057128440 55.1741574780599464 2338284.2142169936560094 2338284.3059207936748862 / 

  static final double URANUS_MIN_HELIO_LON_ACCEL = -0.000024088;
// HELIO, SWI:   -0.0000240835966127 268.6367915745514097 2936605.7491439552977681 2936605.8408477553166449 / 



  static final double URANUS_MAX_LAT_SPEED = 0.00082;
// NOTOPO, JPL: 0.0008167139359186 101.7249222392620567 630392.2795268078334630 / 

  static final double URANUS_MIN_LAT_SPEED = -0.00079;
// NOTOPO, JPL: -0.0007872844416086 94.5979876900013466 632406.4064464361872524 / 

  static final double URANUS_MAX_LAT_ACCEL = 0.000073;
// NOTOPO, JPL: 0.0000725796777657 3.0532664846880948 2473394.5464777238667011 2473397.1248878035694361 / 

  static final double URANUS_MIN_LAT_ACCEL = -0.000078;
// NOTOPO, JPL: -0.0000770026994627 3.0639491173097326 2603143.1314133340492845 2603145.6577144251205027 / 

  static final double URANUS_MAX_TOPO_LAT_SPEED = 0.0011;
// TOPO, JPL:   0.0010938727239962 86.5558131871995897 967133.4299628505250439 / -119.3  -19.8 -139450.6

  static final double URANUS_MIN_TOPO_LAT_SPEED = -0.0011;
// TOPO, JPL:   -0.0010622759299074 96.7133449758128023 2255928.0951205361634493 /  111.7   -5.9 -34208.6

  static final double URANUS_MAX_TOPO_LAT_ACCEL = 0.0018;
// TOPO, JPL:   0.0017903892764677 149.1340385089452809 2389696.5752421738579869 2389696.6956723732873797 /  -32.4  -63.4 -1536076.6

  static final double URANUS_MIN_TOPO_LAT_ACCEL = -0.0014;
// TOPO, JPL:   -0.0013941980551326 203.0822592660931605 813099.1251212942879647 813099.2264039237052202 /   11.0   52.2 -110000.0

  static final double URANUS_MAX_HELIO_LAT_SPEED = 0.00022338;
// HELIO, JPL:   0.0002233250140170 41.8609649530837373 -232778.2701574210368562 / 

  static final double URANUS_MIN_HELIO_LAT_SPEED = -0.00020480;
// HELIO, JPL:   -0.0002047722620604 266.4268762187493280 3670764.7299982784315944 / 

  static final double URANUS_MAX_HELIO_LAT_ACCEL = 0.0000105550;
// HELIO, JPL:   0.0000105547883555 264.3991595674906421 113.7090552419799820 113.8007590419799868 / 

  static final double URANUS_MIN_HELIO_LAT_ACCEL = -0.000010525;
// HELIO, JPL:   -0.0000105121516815 261.6553900943002873 183379.9934958140074741 183380.0851996139972471 / 



  static final double URANUS_MAX_DIST_SPEED = 0.0174;
// NOTOPO, SWI: 0.0173920870984149
// NOTOPO, JPL: 0.0173585770210396 90.0711143387830475 703751.9874883674783632 / 

  static final double URANUS_MIN_DIST_SPEED = -0.0174;
// NOTOPO, SWI: -0.0173768671135560
// NOTOPO, JPL: -0.0173396482859767 90.1712916619785716 625941.9552030125632882 / 

  static final double URANUS_MAX_DIST_ACCEL = 0.00032;
// NOTOPO, SWI: 0.0124048986737664 20.5447553654863668 697587.8714966527186334
//              0.0005308301000862 194.0508279385882133 89653.0467164388392121
//              0.0004054523102576 231.6225436385040837 -237907.2030542625288945
//              0.0003186821836528 178.6186060500050701 -238595.9672204693779349
//              0.0003184016477014 178.6329745040906971 -238595.9806884480349254
//              0.0003183838157893 179.5486894765174952 -238596.8390383592632134
// NOTOPO, JPL: 0.0003182930717874 180.4026778810304563 898832.5701296664774418 898833.3199369597714394 / 

  static final double URANUS_MIN_DIST_ACCEL = -0.00029;
// NOTOPO, SWI: -0.0070443778023334 56.5696520951671431 1915268.8080441316124052
//              -0.0024268224701898 222.2131202933724694 1622588.7918466471601278
//              -0.0017978805103116 112.0036669852078717 1034069.5693735613022000
//              -0.0017711586866005 299.6443816880482132 316745.1417552463826723
//              -0.0009565967124733 34.2481328372568896 -97158.9052647117496235
//              -0.0002965673693959 3.1728844936351379 -126771.9740064809302567
//              -0.0002953008853553 16.8151157502424269 -220272.7407736064051278
//              -0.0002870073111414 2.3807250107649054 -223242.7754700276127551
//              -0.0002869421133855 1.4524556291287922 -223243.7389360640954692
//              -0.0002868014122837 1.1682960365388055 -223244.0338751582312398
//              -0.0002867361242725 3.7817533448034055 -223980.3368454804876819
//              -0.0002865876339975 2.4346127875054151 -223981.7355972216755617
// NOTOPO, JPL: -0.0002869171845722 3.2030561927724648 760035.8014352507889271 760040.9284781528403983 / 

  static final double URANUS_MAX_TOPO_DIST_SPEED = 0.0177;
// TOPO, SWI:   0.0176107889477238
// TOPO, JPL:   0.0175545304775976 92.9313722310350556 1440106.4267600025050342 /  168.4   10.7 -96661.6

  static final double URANUS_MIN_TOPO_DIST_SPEED = -0.0176;
// TOPO, SWI:   -0.0175993482429765
// TOPO, JPL:   -0.0175275406010507 89.7400205375481050 964177.0357202672166750 /   40.8   16.0 -877247.0

  static final double URANUS_MAX_TOPO_DIST_ACCEL = 0.0014;
// TOPO, SWI:   0.0189433989824949 174.5079152323185099 657074.3099226328777149
//              0.0183572432261317 224.5189864726799556 63373.2618242262324202
//              0.0013319739502499 182.7145275240009425 -174644.4776922487071715
//              0.0013240294434584 168.9088235694555067 -174657.4400828294456005
//              0.0013224702513523 167.7986954449400230 -175744.5029267666395754
//              0.0013215195981625 183.3128958273755984 -205701.3786467498575803
// TOPO, JPL:   0.0013896236227717 149.1340385089452809 2389696.5752421738579869 2389696.6956723732873797 /  -32.4  -63.4 -1536076.6

  static final double URANUS_MIN_TOPO_DIST_ACCEL = -0.0013;
// TOPO, SWI:   -0.0074983375520822 237.2702478815059806 2190097.4634127663448453
//              -0.0036695677976724 95.1997580518125233 318393.4452091892017052
//              -0.0015032462816689 29.4131290187358729 -153420.1933402899012435
//              -0.0012987197092415 8.8866741555319493 -159656.5122229879780207
//              -0.0012951371415311 5.1144519034210418 -161148.4825953901745379
//              -0.0012921027532530 10.9717383066954142 -222148.3436549269245006
//              -0.0012787761964680 6.4137141371829784 -223621.4039706184703391
// TOPO, JPL:   -0.0012774206853281 3.0570588538432162 1278670.8627330390736461 1278670.9655325952917337 /   11.0   52.2 -110000.0

  static final double URANUS_MAX_HELIO_DIST_SPEED = 0.00020103;
// HELIO, SWI:   0.0002010212034231 153.3372547826185439 -223983.7840346018201672 / 

  static final double URANUS_MIN_HELIO_DIST_SPEED = -0.00020132;
// HELIO, SWI:   -0.0002013124794718 337.3898947707736511 -146220.1537926742166746 / 

  static final double URANUS_MAX_HELIO_DIST_ACCEL = 0.00000028679;
// HELIO, SWI:   0.0000002867524483 182.7399978283868620 3664209.6506691290996969 3664209.7423729291185737 / 

  static final double URANUS_MIN_HELIO_DIST_ACCEL = -0.000000229;
// HELIO, SWI:   -0.0000002281013543 284.1433658391011363 552562.9856628114357591 552563.0773666114546359 / 



///////////////////////////////////////////////////////////////
// NEPTUNE: ///////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double NEPTUNE_MAX_LON_SPEED = 0.040;
// NOTOPO, SWI: 0.0435201332499242
//              0.0396972276200028 2.0827344696075443 2575780.0351443360559642
// NOTOPO, JPL: 0.0380456461242105 3.1532708267034764 2514772.0896095521748066 / 

  static final double NEPTUNE_MIN_LON_SPEED = -0.0286;
// NOTOPO, SWI: -0.0285951074753113 179.8185040704009623 -114773.5779159839439671
// NOTOPO, JPL: -0.0285175042960974 180.4726995259502189 789980.0941408453509212 / 

  static final double NEPTUNE_MAX_LON_ACCEL = 0.000612;
// NOTOPO, SWI: 0.0006117892571967 95.0693851270330867 1141011.6886422061361372 1141011.9912163538392633
// NOTOPO, JPL: 0.0006117853683019 94.6052391940140183 659604.8761492961784825 659605.1621642899699509 / 

  static final double NEPTUNE_MIN_LON_ACCEL = -0.000606;
// NOTOPO, SWI: -0.0006059351401622 95.1618440250847897 196771.1343181393167470 196771.7955272420076653
// NOTOPO, JPL: -0.0006003368094838 98.0787203190911896 917049.5164440356893465 917049.9205574790248647 / 

  static final double NEPTUNE_MAX_TOPO_LON_SPEED = 0.043; // ???
// TOPO, SWI:   0.0422970690081757 2.2898781842913536 2453407.6579371863044798 / 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   0.0383563887565795 3.0390931791095852 826906.0045657418668270 /  135.2    5.9 -547814.0

  static final double NEPTUNE_MIN_TOPO_LON_SPEED = -0.0295;
// TOPO, SWI:   -0.0290291625574319 180.5744992676552840 426167.0060721903573722
//              -0.0290038106992851 178.5349119796019011 188768.7348955178749748 112.9643788335 -12.4859860679 4158.5890999517
// TOPO, JPL:   -0.0288775621192141 177.7015335690367692 1088009.2940130003262311 /  -44.5    2.8 -84124.2

  static final double NEPTUNE_MAX_TOPO_LON_ACCEL = 0.00253;
// TOPO, SWI:   0.0025292120034634 (SY problem up to 0.2261463302930795 observed)
//              0.0042628483667480 122.0246905452054591 3521196.7267022081650794 3493290.0288146338425577 -133.4574916488 45.5312312476 -3817.1061038599
//              0.0025187380665741 260.4326793894730372 3493289.9254662604071200 55089.2956650374981109 11.0000000000 52.2400000000 -110000.0000000000
//              0.0025184397438746 93.8376591582873800 55089.1874535102106165 -125715.4170647663704585 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   0.0025131255216818 95.6708957219361480 892959.2571875500725582 892959.3594027562066913 /   11.0   52.2 -110000.0

  static final double NEPTUNE_MIN_TOPO_LON_ACCEL = -0.00252;
// TOPO, SWI:   -0.0025161885478298 (SY problem down to -0.3324043321743462 observed)
//              -0.0025049885835764 97.7823583964682399 2414925.5690259789116681 2414925.6727004703134298 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   -0.0025029416562368 100.6905068192704391 1577057.7301410164218396 1577057.8535416696686298 /   11.0   52.2 -110000.0

  static final double NEPTUNE_MAX_HELIO_LON_SPEED = 0.006223;
// HELIO, SWI:   0.0062210422773312 70.1380457739352892 3010726.3542510126717389 / 

  static final double NEPTUNE_MIN_HELIO_LON_SPEED = 0.00584;
// HELIO, SWI:   0.0058488995461196 237.4227749445460915 2859057.8062149924226105 / 

  static final double NEPTUNE_MAX_HELIO_LON_ACCEL = 0.000023804;
// HELIO, SWI:   0.0000237971572304 127.6252871364863921 3677792.9092317251488566 3677793.0009355251677334 / 

  static final double NEPTUNE_MIN_HELIO_LON_ACCEL = -0.000023845;
// HELIO, SWI:   -0.0000238415559796 342.9175515044154849 2936605.7491439552977681 2936605.8408477553166449 / 



  static final double NEPTUNE_MAX_LAT_SPEED = 0.0013;
// NOTOPO, JPL: 0.0012992698973563 94.8672612292906479 666219.2212012477684766 / 

  static final double NEPTUNE_MIN_LAT_SPEED = -0.0013;
// NOTOPO, JPL: -0.0012783972113913 268.1060882042605158 663109.7084374728146940 / 

  static final double NEPTUNE_MAX_LAT_ACCEL = 0.000069;
// NOTOPO, JPL: 0.0000688858521642 3.0106510603266088 2269663.3859712700359523 2269665.7029609824530780 / 

  static final double NEPTUNE_MIN_LAT_ACCEL = -0.000065;
// NOTOPO, JPL: -0.0000645053184318 3.1813985225708450 2059463.7634919909760356 2059466.4900546479038894 / 

  static final double NEPTUNE_MAX_TOPO_LAT_SPEED = 0.00156;
// TOPO, SWI:   0.0090000517239580 0.0524548520168651 1972364.6034868198912591
//              0.0089956406518853 0.0582866623987570 1491690.9895345694385469
//              0.0089730249324625 0.0600284356005858 1341026.7986733743455261
//              0.0080895274797669 0.0723554736281216 -161993.2757087929057889
//              0.0060016807506635 0.0288506759888136 -221526.1047314178140368
//              0.0035285398313926 0.0632601727365483 -221893.4920628319960088
//              0.0015526225326993 98.6415321471926347 -235230.4668798064230941
//              0.0015499860150981 88.2389236872085405 -235587.4842110734607559
//              0.0015467816098779 91.2033835105225421 -236325.4807206140249036
//              0.0015466858680102 92.1773040803388710 -236326.4611918719019741
// TOPO, JPL:   0.0014551000399715 95.4889062662710444 785651.9289954347768798 /   93.5   11.4 -889863.7

  static final double NEPTUNE_MIN_TOPO_LAT_SPEED = -0.00143;
// TOPO, JPL:   -0.0014127851155073 96.1163954950283568 755520.3564604987623170 /  133.6   16.3 -11928444.7

  static final double NEPTUNE_MAX_TOPO_LAT_ACCEL = 0.00087;
// TOPO, JPL:   0.0008698934809757 151.6828949764235404 659917.2505363596137613 659917.3554017660208046 /   11.0   52.2 -110000.0

  static final double NEPTUNE_MIN_TOPO_LAT_ACCEL = -0.000854;
// TOPO, JPL:   -0.0008534031453892 170.1151339811219145 807974.2306540678255260 807974.3415011959150434 /   11.0   52.2 -110000.0

  static final double NEPTUNE_MAX_HELIO_LAT_SPEED = 0.0002670;
// HELIO, SWI:   0.0002669265664204 61.2047535648150500 18880.4332063072251913 / 

  static final double NEPTUNE_MIN_HELIO_LAT_SPEED = -0.0002728;
// HELIO, SWI:   -0.0002726129273091 237.4938887399886198 -190757.8466299072606489 / 

  static final double NEPTUNE_MAX_HELIO_LAT_ACCEL = 0.0000106092;
// HELIO, SWI:   0.0000106088151780 266.6996026887903213 292495.4105916777625680 292495.5022954777814448 / 

  static final double NEPTUNE_MIN_HELIO_LAT_ACCEL = -0.000010590;
// HELIO, SWI:   -0.0000105890480006 93.8859591550667005 203741.5384303432365414 203741.6301341432263143 / 



  static final double NEPTUNE_MAX_DIST_SPEED = 0.0175;
// NOTOPO, SWI: 0.0174167945328918
// NOTOPO, JPL: 0.0174065088712856 90.0141956230224594 716570.6086513907648623 / 

  static final double NEPTUNE_MIN_DIST_SPEED = -0.0175;
// NOTOPO, SWI: -0.0174181120306995
// NOTOPO, JPL: -0.0174082572247792 90.1133447416499962 864489.7592409640783444 / 

  static final double NEPTUNE_MAX_DIST_ACCEL = 0.000316;
// NOTOPO, SWI: 0.0135819670381752 48.2733891582497563 5525.0933320791637016
//              0.0029873866850574 69.0549169938272769 -192795.6600356508279219
//              0.0004085467817404 165.5440851032710725 -235295.4374565259495284
//              0.0003252402971657 163.9956620539999506 -235661.4083584317122586
//              0.0003154919293185 177.7271030118340036 -235674.4588167968322523
//              0.0003154876427962 179.4769426327440272 -236411.0038810773694422
//              0.0003154687802688 180.1591877981425398 -236411.6524607480387203
// NOTOPO, JPL: 0.0003155423489853 181.7260481566145245 730447.6796687617897987 730448.2887378348968923 / 

  static final double NEPTUNE_MIN_DIST_ACCEL = -0.0003;
// NOTOPO, SWI: -0.0926625037231506 173.2327775500569942 708404.3574317961465567
//              -0.0051669956985789 111.0832620716790444 -227659.2020879369229078
//              -0.0003041835232219 7.0299840806517295 -234383.0605990467884112
//              -0.0002863472168228 2.3091629537422023 -250198.7555277845531236
//              -0.0002862723385372 3.1424049270648595 -250199.6271795822540298
//              -0.0002862542929178 3.4005205436072288 -250199.8970782387768850
//              -0.0002861746751199 4.0429712268202422 -250200.5686231650470290
// NOTOPO, JPL: -0.0002952785868367 3.2715414145909278 639491.6505929509876296 639495.8581704762764275 / 

  static final double NEPTUNE_MAX_TOPO_DIST_SPEED = 0.0177;
// TOPO, SWI:   0.0176337286177421
// TOPO, JPL:   0.0175995232752972 88.9667806227172662 778309.2456948457984254 /   42.3    6.9 -489807.4

  static final double NEPTUNE_MIN_TOPO_DIST_SPEED = -0.0177;
// TOPO, SWI:   -0.0176367861495518
// TOPO, JPL:   -0.0176267292572482 87.5072744454238318 1890876.3556474931538105 /  148.4    4.0 -106588.7

  static final double NEPTUNE_MAX_TOPO_DIST_ACCEL = 0.00135;
// TOPO, SWI:   0.6461977268067690 25.3701797814048433 1939634.5921939297113568
//              0.0041164964926524 206.4912262049541027 480897.9479083669139072
//              0.0037451465792928 136.6200955115339752 441925.1899133427650668
//              0.0014718970994787 93.5523667367900771 44993.4780828971197479
//              0.0013515382920695 211.2758559578730058 -162885.4319869252503850
//              0.0013232817060093 189.9636687918127222 -231644.2943363734520972
//              0.0013096974841549 189.6233126453089426 -232746.2574978842749260
// TOPO, JPL:   0.0013092533141867 189.5421929498741918 1087653.0362668419256806 1087653.1421054021921009 /   11.0   52.2 -110000.0

  static final double NEPTUNE_MIN_TOPO_DIST_ACCEL = -0.00129;
// TOPO, SWI:   -0.1132083825141817 142.5236047281373715 1681538.3904155539348722
//              -0.0792670482834736 154.3516542613503475 821240.9412590151187032
//              -0.0035286930591954 8.2707438707448304 434060.6570531763718463
//              -0.0020499282815566 327.4975658185502994 368987.5497646926087327
//              -0.0018412778091957 66.0445618612218794 -210436.4600420471979305
//              -0.0012986500971886 2.5730292615316017 -217119.1991163263737690
//              -0.0012882855151135 0.7261626876730247 -232184.3240317180461716
//              -0.0012688484178225 14.7256797835751740 -232201.2589514517167117
//              -0.0012600964431873 13.3128784618060649 -232567.3151242690801155
// TOPO, JPL:   -0.0012849455246221 5.7304803388833534 997431.1147520339582115 997431.2203086471417919 /   11.0   52.2 -110000.0

  static final double NEPTUNE_MAX_HELIO_DIST_SPEED = 0.000038700;
// HELIO, SWI:   0.0000386974135181 154.8074701018816199 2785346.2917598192580044 / 

  static final double NEPTUNE_MIN_HELIO_DIST_SPEED = -0.000038379;
// HELIO, SWI:   -0.0000383762733639 345.2953618997685226 2936999.6169650363735855 / 

  static final double NEPTUNE_MAX_HELIO_DIST_ACCEL = 0.00000022853;
// HELIO, SWI:   0.0000002284812407 46.7912725459401528 1212586.9639134742319584 1212587.0556172742508352 / 

  static final double NEPTUNE_MIN_HELIO_DIST_ACCEL = -0.00000023012;
// HELIO, SWI:   -0.0000002300982060 44.5153582367412142 3664209.6506691290996969 3664209.7423729291185737 / 



///////////////////////////////////////////////////////////////
// PLUTO: /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double PLUTO_MAX_LON_SPEED = 0.041;
// NOTOPO, SWI: 0.0409947189148399
// NOTOPO, JPL: 0.0408338960827420 3.1371236364667254 732954.4751370932208374 / 

  static final double PLUTO_MIN_LON_SPEED = -0.0284;
// NOTOPO, SWI: -0.0283698947779465
// NOTOPO, JPL: -0.0283272575709131 179.1674723407538181 1632754.8288194262422621 / 

  static final double PLUTO_MAX_LON_ACCEL = 0.000601;
// NOTOPO, JPL: 0.0005990791437332 97.3066735347333349 822701.2720944840693846 822702.0496401527198032 / 

  static final double PLUTO_MIN_LON_ACCEL = -0.00065; // ????
// NOTOPO, SWI: -0.0007143739642233 (SY problem down to -0.1089928395917400 observed)
// NOTOPO, JPL: -0.0006327247387071 94.8617743602447092 1632669.1280191596597433 1632669.6611433816142380 / 

  static final double PLUTO_MAX_TOPO_LON_SPEED = 0.0413;
// TOPO, SWI:   0.0412884373492034
// TOPO, JPL:   0.0411060581436741 3.1111305873843946 643830.5274781107436866 /   11.0   52.2 -110000.0

  static final double PLUTO_MIN_TOPO_LON_SPEED = -0.0288;
// TOPO, SWI:   -0.0286905230717167
// TOPO, JPL:   -0.0286678286669824 176.7873496422886319 2718300.2481787498109043 /  -23.0   -6.5 -11682194.0

  static final double PLUTO_MAX_TOPO_LON_ACCEL = 0.00253;
// TOPO, JPL:   0.0025178590195568 104.4522615939965249 2809692.6709229107946157 2809692.8023088881745934 /   11.0   52.2 -110000.0

  static final double PLUTO_MIN_TOPO_LON_ACCEL = -0.0026; // ????
// TOPO, SWI:   -0.0372004141085517 (SY problem down to -0.4008096521768991 observed)
// TOPO, JPL:   -0.0025588306695524 99.9199502376179680 2720792.5705627049319446 2720792.6829605293460190 /   11.0   52.2 -110000.0

  static final double PLUTO_MAX_HELIO_LON_SPEED = 0.0072091;
// HELIO, SWI:   0.0072088030257401 141.4754733876560522 374029.9928188612684608 / 

  static final double PLUTO_MIN_HELIO_LON_SPEED = 0.0025030;
// HELIO, SWI:   0.0025038612299076 100.0560887010465336 3675727.0060248998925090 / 

  static final double PLUTO_MAX_HELIO_LON_ACCEL = 0.000024137;
// HELIO, JPL:   0.0000241301797422 165.8455639910309571 2528934.2135650380514562 2528934.3052688380703330 / 

  static final double PLUTO_MIN_HELIO_LON_ACCEL = -0.00002406;
// HELIO, SWI:   -0.0000240489865306 286.6552384956450510 2997969.9888531868346035 2997970.0805569868534803 / 



  static final double PLUTO_MAX_LAT_SPEED = 0.0101;
// NOTOPO, SWI: 0.0099918860824316
// NOTOPO, JPL: 0.0099791426368035 94.4854202402405292 639883.3305302684893832 / 

  static final double PLUTO_MIN_LAT_SPEED = -0.00998;
// NOTOPO, SWI: -0.0099656330945712
// NOTOPO, JPL: -0.0099307674698353 93.1252446492206047 732853.5206388467922807 / 

  static final double PLUTO_MAX_LAT_ACCEL = 0.000159;
// NOTOPO, JPL: 0.0001577503032733 5.4037598154724265 641999.4772995261009783 642000.1200399320805445 / 

  static final double PLUTO_MIN_LAT_ACCEL = -0.000188;
// NOTOPO, JPL: -0.0001858085104703 177.6618672571143804 1000479.4034898622194305 1000480.3014068943448365 / 

  static final double PLUTO_MAX_TOPO_LAT_SPEED = 0.0102;
// TOPO, SWI:   0.0101887620952181
// TOPO, JPL:   0.0101587910721185 93.3203292923736569 729735.3805221099173650 /   11.0   52.2 -110000.0

  static final double PLUTO_MIN_TOPO_LAT_SPEED = -0.011;
// TOPO, SWI:   -0.0109564169565936
// TOPO, JPL:   -0.0101079839297460 92.3334029317985596 733222.3447666474385187 /   11.0   52.2 -110000.0

  static final double PLUTO_MAX_TOPO_LAT_ACCEL = 0.0013;
// TOPO, SWI:   0.1146408060915522 0.0754882456864365 713120.5580753037938848
//              0.0941206511202854 49.4010660634788081 456088.8688647721428424
//              0.0255255252969479 0.1806868458375845 116473.0549504257651279
//              0.0253178489595343 0.2471611952441393 -4971.5581980942633891
//              0.0121348936844913 0.1709038475643752 -62866.7451490048188134
//              0.0095585608319143 0.0073487506721790 -62866.9096804023429286
//              0.0045413279302522 0.5515540013628879 -152719.6797022641985677
//              0.0040083267072832 0.5350913166472111 -184677.7962954391550738
//              0.0023768429757906 0.2974980519578878 -242574.1132811341085471
//              0.0011173870417524 56.2797968672246895 -250713.2092755420599133
//              0.0010944966591291 64.0983224175128328 -250721.2586086901428644
//              0.0009852994797639 129.8867192572130307 -250891.6895662871829700
// TOPO, JPL:   0.0012931870141345 12.5130488940067437 640168.3879828155040741 640168.4985908751841635 /   11.0   52.2 -110000.0

  static final double PLUTO_MIN_TOPO_LAT_ACCEL = -0.0014;
// TOPO, SWI:   -0.1323288495285307 0.0571969808381283 1883765.3306468296796083
//              -0.0743827345599630 0.1194495083565243 713120.6057449358049780
//              -0.0347908909623849 0.1204501519061694 -152720.3629573613288812
//              -0.0088254384157201 0.1686240986828693 -152720.4120519654243253
//              -0.0033765420206368 0.1258497784927819 -184678.5095836789405439
//              -0.0017693116405143 0.4127381851168934 -242573.3918600576289464
//              -0.0012369578816304 188.1500182824425451 -250464.4232595347566530
//              -0.0011875762707375 171.6292642547027185 -250481.3294816084962804
//              -0.0011793623663488 171.5160188829716787 -250849.2928314248274546
//              -0.0011041529654153 131.2960704322420895 -250890.2601939455198590
// TOPO, JPL:   -0.0013933132467849 197.2859828842642855 641088.3418429015437141 641088.4793755571590737 /   11.0   52.2 -110000.0

  static final double PLUTO_MAX_HELIO_LAT_SPEED = 0.0012607;
// HELIO, SWI:   0.0012600819392323 57.2872964838035443 270894.4887934313155711 / 

  static final double PLUTO_MIN_HELIO_LAT_SPEED = -0.00170212;
// HELIO, SWI:   -0.0017020708716681 259.3240138417087337 2093270.8266607588157058 / 

  static final double PLUTO_MAX_HELIO_LAT_ACCEL = 0.000010674;
// HELIO, SWI:   0.0000106729980166 268.7168290608726124 754530.7011939855292439 754530.7928977855481207 / 

  static final double PLUTO_MIN_HELIO_LAT_ACCEL = -0.000010758;
// HELIO, SWI:   -0.0000107544293760 87.6044789431522020 -169539.6964996735623572 -169539.6047958735725842 / 



  static final double PLUTO_MAX_DIST_SPEED = 0.01805;
// NOTOPO, SWI: 0.0180201864709247
// NOTOPO, JPL: 0.0179673538522285 89.7263334479476384 747190.6329123422037810 / 

  static final double PLUTO_MIN_DIST_SPEED = -0.01805;
// NOTOPO, SWI: -0.0180372446419509
// NOTOPO, JPL: -0.0180007004030953 90.0245545393799773 626294.2538914401084185 / 

  static final double PLUTO_MAX_DIST_ACCEL = 0.000315;
// NOTOPO, SWI: 0.0407853605615538 83.8263720967590871 3624026.5748034995049238
//              0.0069468201512656 196.2677638094518784 1815013.3748994071502239
//              0.0048377509693545 47.2315784566411594 -143964.7589193212625105
//              0.0006369295143076 196.0402002069912157 -234332.2497064112685621
//              0.0003005188008673 176.0412684223048814 -241282.3776702757168096
//              0.0002952326969226 176.8597734140736861 -242751.7179506011016201
//              0.0002935577048952 177.7294647668737753 -243854.2899573702889029
//              0.0002935450072931 177.8110411867463938 -243854.3732949701952748
// NOTOPO, JPL: 0.0003136979868652 179.6743020621852907 1341170.5058408293407410 1341171.2995680202730000 / 

  static final double PLUTO_MIN_DIST_ACCEL = -0.000296;
// NOTOPO, SWI: -0.0152198272306129 237.8828584819669913 690902.4017224303679541
//              -0.0096311018334681 1.4497561645164865 307184.0997986468719319
//              -0.0026457749260651 331.2636077184097871 73186.7185329681087751
//              -0.0019568281177972 40.5484034124101242 -136261.9220611743803602
//              -0.0006521190722939 30.9038516469837532 -223109.5922839867707808
//              -0.0003360489734281 17.5393798737692634 -245493.2611005441867746
//              -0.0002946613707863 2.5375739709260188 -245508.5060571530484594
//              -0.0002946504435585 1.7204731079822864 -245509.3345663794898428
//              -0.0002946048677604 1.5721621402714163 -245509.4849347961135209
//              -0.0002944878278406 1.0907226602467972 -245509.9730266212136485
// NOTOPO, JPL: -0.0002959509564196 3.2369661234292266 1645067.6523841423913836 1645072.8514915483538061 / 

  static final double PLUTO_MAX_TOPO_DIST_SPEED = 0.0183;
// TOPO, SWI:   0.0182120589472379
// TOPO, JPL:   0.0181415307873287 89.7000340036246655 1108803.2886870261281729 /  -58.1    8.6 -108903.9

  static final double PLUTO_MIN_TOPO_DIST_SPEED = -0.0183;
// TOPO, SWI:   -0.0182358280933419
// TOPO, JPL:   -0.0181426062874089 88.6500692581212064 625559.5932220611721277 /   11.0   52.2 -110000.0

  static final double PLUTO_MAX_TOPO_DIST_ACCEL = 0.00135;
// TOPO, SWI:   0.0130128963192127 17.1368763588973749 1241262.9272272512316704
//              0.0023151043479321 111.4547636320583877 52165.7623227584044798
//              0.0017030775099116 178.4354706217193325 -175329.3589742311451118
//              0.0016646685105212 238.7184089560146276 -227044.6033776346594095
//              0.0014068279408472 55.1948022699443754 -240060.5752828968106769
//              0.0012963542904493 191.5096459801829099 -241665.2621815337915905
//              0.0012948705921776 169.6181203906081123 -244213.2961760257894639
// TOPO, JPL:   0.0013027104602608 180.1840886067463998 793263.3965677092783153 793263.5139706216286868 /   11.0   52.2 -110000.0

  static final double PLUTO_MIN_TOPO_DIST_ACCEL = -0.0013;
// TOPO, SWI:   -0.0179021842533406 214.6365146216283222 1198529.3581569930538535
//              -0.0032151436390044 3.9705683390313311 -20364.6199331984498713
//              -0.0028143398711598 252.9002190420136458 -35995.5853714871991542
//              -0.0013100334546386 2.1773699952934749 -154186.4357591727748513
//              -0.0013036739026851 3.6193122178814860 -156028.3848112957202829
//              -0.0013024841249698 13.3133296954911486 -242927.3159189936995972
//              -0.0012885072393509 17.9576457466834825 -243693.2539283887890633
//              -0.0012856628157103 13.0601184579426786 -244763.3268022972624749
//              -0.0012845931611976 2.0770303236098471 -246978.2600213123077992
//              -0.0012587293344394 12.3076703741073743 -247335.2735762960510328
//              -0.0012440334269146 19.5256853756665123 -248430.3081937007373199
//              -0.0012362014952662 13.8258049766299678 -249199.2258719038800336
//              -0.0012140398754897 15.1842583574879768 -249568.1970763951831032
// TOPO, JPL:   -0.0012825097800167 4.0535447294597020 830888.3153882571496069 830888.4365303290542215 /   11.0   52.2 -110000.0

  static final double PLUTO_MAX_HELIO_DIST_SPEED = 0.00071348;
// HELIO, SWI:   0.0007134175023050 324.8716158612946288 2735406.4197531393729150 / 

  static final double PLUTO_MIN_HELIO_DIST_SPEED = -0.00071142;
// HELIO, SWI:   -0.0007113947288229 145.8224897655158827 2704813.3901402419432998 / 

  static final double PLUTO_MAX_HELIO_DIST_ACCEL = 0.0000002773;
// HELIO, SWI:   0.0000002770034822 202.0136437752347263 1545703.6768922447226942 1545703.7685960447415709 / 

  static final double PLUTO_MIN_HELIO_DIST_ACCEL = -0.00000022049;
// HELIO, SWI:   -0.0000002204703871 62.1682780441932366 1340427.7467753896489739 1340427.8384791896678507 / 



///////////////////////////////////////////////////////////////
// MNODE: /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double MNODE_MAX_LON_SPEED = -0.0528;
// NOTOPO, JPL: -0.0528841758228763 87.4506108213789730 2800705.2652022368274629 / 

  static final double MNODE_MIN_LON_SPEED = -0.0531;
// NOTOPO, SWI: -0.0530037505698459
// NOTOPO, JPL: -0.0530021964831903 124.0050853633128298 644588.8616734195966274 / 

  static final double MNODE_MAX_LON_ACCEL = 0.0000249;
// NOTOPO, JPL: 0.0000248040638846 201.9963197288654442 1977761.7032133250031620 1977761.8148180888965726 / 

  static final double MNODE_MIN_LON_ACCEL = -0.0000244;
// NOTOPO, JPL: -0.0000242121990862 268.1333251052160449 2773317.7025739247910678 2773317.8079387117177248 / 

  /**
  * There is no menaing in calculating topocentric positions of mean elements,
  * so it more an academic kind of exercise...
  */
  static final double MNODE_MAX_TOPO_LON_SPEED = -0.0528;
// TOPO, JPL:   -0.0528842254910542 87.4505199997736327 2800705.2666699616238475 /   11.0   52.2 -110000.0

  static final double MNODE_MIN_TOPO_LON_SPEED = -0.0531;
// TOPO, SWI:   -0.0530037595813937
// TOPO, JPL:   -0.0530022464081250 123.9781716707397123 644588.8357337675988674 /  176.5  -37.7 -10953765.3

  static final double MNODE_MAX_TOPO_LON_ACCEL = 0.0000247;
// TOPO, JPL:   0.0000243945457281 63.5362877416933571 1291321.3731930041685700 1291321.4759153190534562 /   11.0   52.2 -110000.0

  static final double MNODE_MIN_TOPO_LON_ACCEL = -0.0000252;
// TOPO, JPL:   -0.0000251435327552 136.9860162044397498 2480991.0153021169826388 2480991.1231008274480700 /   11.0   52.2 -110000.0

// No heliocentric positions for the mean node...
  static final double MNODE_MAX_HELIO_LON_SPEED = 1./0.;
  static final double MNODE_MIN_HELIO_LON_SPEED = 1./0.;
  static final double MNODE_MAX_HELIO_LON_ACCEL = 1./0.;
  static final double MNODE_MIN_HELIO_LON_ACCEL = 1./0.;



  static final double MNODE_MAX_LAT_SPEED = 0.;
// NOTOPO, JPL: 0.0000000000000000 42.7373829367315352 625361.7029183002887294 / 

  static final double MNODE_MIN_LAT_SPEED = 0.;
// NOTOPO, JPL: 0.0000000000000000 42.7373829367315352 625361.7029183002887294 / 

  static final double MNODE_MAX_LAT_ACCEL = 0.;
// NOTOPO, JPL: 0.0000000000000000 42.7373829367315352 625361.5000000000000000 625361.7029183002887294 / 

  static final double MNODE_MIN_LAT_ACCEL = 0.;
// NOTOPO, JPL: 0.0000000000000000 42.7373829367315352 625361.5000000000000000 625361.7029183002887294 / 

  static final double MNODE_MAX_TOPO_LAT_SPEED = 0.;
// TOPO, JPL:   0.0000000000000000 42.5366762476106146 625361.8994183215545490 /   11.0   52.2 -110000.0

  static final double MNODE_MIN_TOPO_LAT_SPEED = 0.;
// TOPO, JPL:   0.0000000000000000 42.5366762476106146 625361.8994183215545490 /   11.0   52.2 -110000.0

  static final double MNODE_MAX_TOPO_LAT_ACCEL = 0.;
// TOPO, SWI:   0.0000000000000000 42.5366762476106146 625361.5000000000000000 625361.8994183215545490 /   11.0   52.2 -110000.0

  static final double MNODE_MIN_TOPO_LAT_ACCEL = 0.;
// TOPO, JPL:   0.0000000000000000 42.5366762476106146 625361.5000000000000000 625361.8994183215545490 /   11.0   52.2 -110000.0

// No heliocentric positions for the mean node...
  static final double MNODE_MAX_HELIO_LAT_SPEED = 1./0.;
  static final double MNODE_MIN_HELIO_LAT_SPEED = 1./0.;
  static final double MNODE_MAX_HELIO_LAT_ACCEL = 1./0.;
  static final double MNODE_MIN_HELIO_LAT_ACCEL = 1./0.;



  static final double MNODE_MAX_DIST_SPEED = 0.;
// NOTOPO, JPL: 0.0000000000000000 42.7373829367315352 625361.7029183002887294 / 

  static final double MNODE_MIN_DIST_SPEED = 0.;
// NOTOPO, JPL: 0.0000000000000000 42.7373829367315352 625361.7029183002887294 / 

  static final double MNODE_MAX_DIST_ACCEL = 0.;
// NOTOPO, JPL: 0.0000000000000000 42.7373829367315352 625361.5000000000000000 625361.7029183002887294 / 

  static final double MNODE_MIN_DIST_ACCEL = 0.;
// NOTOPO, JPL: 0.0000000000000000 42.7373829367315352 625361.5000000000000000 625361.7029183002887294 / 

  static final double MNODE_MAX_TOPO_DIST_SPEED = 0.;
// TOPO, JPL:   0.0000000000000000 42.5366762476106146 625361.8994183215545490 /   11.0   52.2 -110000.0

  static final double MNODE_MIN_TOPO_DIST_SPEED = 0.;
// TOPO, JPL:   0.0000000000000000 42.5366762476106146 625361.8994183215545490 /   11.0   52.2 -110000.0

  static final double MNODE_MAX_TOPO_DIST_ACCEL = 0.;
// TOPO, JPL:   0.0000000000000000 42.5366762476106146 625361.5000000000000000 625361.8994183215545490 /   11.0   52.2 -110000.0

  static final double MNODE_MIN_TOPO_DIST_ACCEL = 0.;
// TOPO, JPL:   0.0000000000000000 42.5366762476106146 625361.5000000000000000 625361.8994183215545490 /   11.0   52.2 -110000.0

// No heliocentric positions for the mean node...
  static final double MNODE_MAX_HELIO_DIST_SPEED = 1./0.;
  static final double MNODE_MIN_HELIO_DIST_SPEED = 1./0.;
  static final double MNODE_MAX_HELIO_DIST_ACCEL = 1./0.;
  static final double MNODE_MIN_HELIO_DIST_ACCEL = 1./0.;



///////////////////////////////////////////////////////////////
// TNODE: /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double TNODE_MAX_LON_SPEED = 0.0328;
// NOTOPO, JPL: 0.0326855962208268 28.5243572070390314 722775.8339081415906549 / 

  static final double TNODE_MIN_LON_SPEED = -0.261;
// NOTOPO, JPL: -0.2601780541622186 87.0307941091399471 871073.2885009105084464 / 

  static final double TNODE_MAX_LON_ACCEL = 0.054;
// NOTOPO, JPL: 0.0539136658625242 96.3340571413317832 1139185.0864348253235221 1139185.4419494222383946 / 

  static final double TNODE_MIN_LON_ACCEL = -0.054;
// NOTOPO, JPL: -0.0539712493483143 92.9162103985022156 687359.6763768544187769 687359.7991852302802727 / 

  static final double TNODE_MAX_TOPO_LON_SPEED = 0.0328;
// TOPO, SWI:   0.0327411094922690 (maybe much more, e.g. 0.4216115680677051)
//              0.4216115680677051 13.8633424027789545 3585899.6871486338786781
//              0.3996447565119488 191.6855534133834738 1843240.2456777647603303
//              0.2235892399173331 148.7626066628442913 30120.7841977981188393
//              0.0327411094922690 30.7612542764135526 -146545.2495332568651065
//              0.0325982260105773 208.4145973857591798 -224358.2317474005394615
//              0.0323529232146644 30.5854516341142357 -247697.1525798988586757
// TOPO, JPL:   0.0327082146129712 28.6110973826417876 722775.7452402360504493 /   11.0   52.2 -110000.0

  static final double TNODE_MIN_TOPO_LON_SPEED = -0.261;
// TOPO, SWI:   -0.2607482296372162 maybe much less, e.g. -0.5493115235934243)
//              -0.5493115235934243 42.7298002047974705 250061.6466701690806076
//              -0.5077009885677132 241.4997864307243276 39158.6958460557289072
//              -0.2607482296372162 93.1224119348595707 -69475.6147848475084174
//              -0.2605016817789270 93.1145743769104968 -76060.9473834989621537
//              -0.2594970823080265 84.6379656825472466 -140703.5355969415395521
//              -0.2594213076977080 84.6888169562490134 -140703.5749870793370064
//              -0.2581229158578309 91.1754560203589222 -168092.5823965377057903
// TOPO, JPL:   -0.2603922043003269 87.2476101631761765 864487.7687863860046491 /   -9.6  -71.6 -451209.5

  static final double TNODE_MAX_TOPO_LON_ACCEL = 0.054;
// TOPO, SWI:   0.0563873394044947 (maybe much more, e.g. 4.7468566498283602)
//              4.7468566498283602 241.5981374622122644 39158.7957134488242446
//              0.3122228876570153 148.7626066628442913 30120.7841977981188393
//              0.0563873394044947 164.3187040187730190 -140084.0362958694167901
//              0.0537976700912474 87.6324656033127383 -154224.3777706396358553
//              0.0537427144570444 87.6659956936547076 -154224.4070253355603199
//              0.0536532049411242 94.8920470111433900 -212281.3224629964388441
// TOPO, JPL:   0.0538962795836710 86.2171194267930332 2066563.6492133960127831 2066563.8136807992123067 /   11.0   52.2 -110000.0

  static final double TNODE_MIN_TOPO_LON_ACCEL = -0.054;
// TOPO, SWI:   -0.0539831464262423 maybe much less, e.g. -5.6865435545693899)
//              -5.6865435545693899 148.7128969225232140 30120.8330104324704735
//              -0.0539831464262423 94.8056785030036338 -195131.4903258501726668
//              -0.0536432799836339 95.3676455106551941 -201717.3139034592604730
//              -0.0536428549665791 87.1500816759324408 -240018.2256629223702475
//              -0.0535586258892041 87.2176697339374840 -246603.5270144374808297
// TOPO, JPL:   -0.0539120620264503 84.8636084025309998 738831.5274397874018177 738831.8096256844000891 /   11.0   52.2 -110000.0

// No heliocentric positions for the true node...
  static final double TNODE_MAX_HELIO_LON_SPEED = 1./0.;
  static final double TNODE_MIN_HELIO_LON_SPEED = 1./0.;
  static final double TNODE_MAX_HELIO_LON_ACCEL = 1./0.;
  static final double TNODE_MIN_HELIO_LON_ACCEL = 1./0.;



  static final double TNODE_MAX_LAT_SPEED = 0.;
// NOTOPO, JPL: 0.0000000000000000 41.0794032263436293 625361.7998687432846054 / 

  static final double TNODE_MIN_LAT_SPEED = 0.;
// NOTOPO, JPL: 0.0000000000000000 41.0794032263436293 625361.7998687432846054 / 

  static final double TNODE_MAX_LAT_ACCEL = 0.;
// NOTOPO, JPL: 0.0000000000000000 41.0794032263436293 625361.5000000000000000 625361.7998687432846054 / 

  static final double TNODE_MIN_LAT_ACCEL = 0.;
// NOTOPO, JPL: 0.0000000000000000 41.0794032263436293 625361.5000000000000000 625361.7998687432846054 / 

  static final double TNODE_MAX_TOPO_LAT_SPEED = 0.;
// TOPO, JPL:   0.0000000000000000 40.3789042855210027 625362.4439763929694891 /   11.0   52.2 -110000.0

  static final double TNODE_MIN_TOPO_LAT_SPEED = 0.;
// TOPO, JPL:   0.0000000000000000 40.3789042855210027 625362.4439763929694891 /   11.0   52.2 -110000.0

  static final double TNODE_MAX_TOPO_LAT_ACCEL = 0.;
// TOPO, JPL:   0.0000000000000000 40.3789042855210027 625361.5000000000000000 625362.4439763929694891 /   11.0   52.2 -110000.0

  static final double TNODE_MIN_TOPO_LAT_ACCEL = 0.;
// TOPO, JPL:   0.0000000000000000 40.3789042855210027 625361.5000000000000000 625362.4439763929694891 /   11.0   52.2 -110000.0

// No heliocentric positions for the true node...
  static final double TNODE_MAX_HELIO_LAT_SPEED = 1./0.;
  static final double TNODE_MIN_HELIO_LAT_SPEED = 1./0.;
  static final double TNODE_MAX_HELIO_LAT_ACCEL = 1./0.;
  static final double TNODE_MIN_HELIO_LAT_ACCEL = 1./0.;



  static final double TNODE_MAX_DIST_SPEED = 0.0000228;
// NOTOPO, SWI: 0.0000227657371966
// NOTOPO, JPL: 0.0000213536998323 120.1149812893362423 754925.7251749879214913 / 

  static final double TNODE_MIN_DIST_SPEED = -0.0000216;
// NOTOPO, SWI: -0.0000215585382077
// NOTOPO, JPL: -0.0000213990807928 114.3803667754305309 861213.9748676187591627 / 

  static final double TNODE_MAX_DIST_ACCEL = 0.00000835;
// NOTOPO, SWI: 0.0000750703538360 33.0382069743494640 1046857.9201584004331380
//              0.0000295730661174 132.1285899593370914 751004.2467315234243870
//              0.0000229566919869 6.1158485301780985 277754.1283083962043747
//              0.0000131148016195 196.2613424548156615 -14958.5557277744010207
//              0.0000083076652793 99.7438212565191975 -15397.8175420094139554
//              0.0000083031871586 98.6244788123381824 -225448.4339384726190474
//              0.0000082342371095 98.9047249793631238 -238618.8604936520860065
// NOTOPO, JPL: 0.0000083367008151 88.5064147393362077 674539.7194071344565600 674540.0587246073409915 / 

  static final double TNODE_MIN_DIST_ACCEL = -0.0000086;
// NOTOPO, SWI: -0.0002872607354344 106.8098325992096846 655114.2552040057489648
//              -0.0000161941268880 76.5510956058315912 347687.6100133685395122
//              -0.0000088751590264 169.1897512402919688 238764.2694866273377556
//              -0.0000085451497521 181.7548695594740877 197156.1960955614340492
//              -0.0000085156406539 177.1760048851402587 61286.1568801726316451
//              -0.0000084695707129 189.9098971100671918 -78.2180907315612757
//              -0.0000084538261730 1.7385989643092614 -30746.1787060799397295
//              -0.0000084417926183 173.1584750134485660 -67999.0639539538824465
//              -0.0000084251014809 174.0109261711857016 -129363.5261933571891859
//              -0.0000084210976167 3.0071993379622199 -247382.2838002044882160
// NOTOPO, JPL: -0.0000085231218245 179.9598301820871882 1073062.1182626546360552 1073062.7212474753614515 / 

  static final double TNODE_MAX_TOPO_DIST_SPEED = 0.000022; // ????
// TOPO, SWI:   0.0000320574867052
// TOPO, JPL:   0.0000213717861342 115.0970956228481725 1284910.9963867058977485 /   11.0   52.2 -110000.0

  static final double TNODE_MIN_TOPO_DIST_SPEED = -0.000022; // ????
// TOPO, SWI:   -0.0000332648162204
// TOPO, JPL:   -0.0000214083084746 114.3533718935811976 854628.5975370522355661 /   11.0   52.2 -110000.0

  static final double TNODE_MAX_TOPO_DIST_ACCEL = 0.00000835;
// TOPO, SWI:   0.0001074598743278 271.3472021376313705 2657201.8088382319547236
//              0.0000634652596772 193.5558352806767743 1221774.3783414242789149
//              0.0000538869946502 73.4934083541807581 31.3934498392767622
//              0.0000094186598250 173.4454735818177369 -92606.7031143940985203
//              0.0000083076607859 90.8051476176185872 -194780.8783414751815144
//              0.0000083008875115 98.4001552972325442 -225448.6528204880887643
//              0.0000082571491516 98.8692616102437398 -232033.5335670034401119
//              0.0000082542040884 98.3977016616702684 -232033.9945917097211350
//              0.0000082231815334 98.3834756777576303 -238619.3730163456057198
//              0.0000082187722697 98.9192470588687058 -245204.2546059744490776
// TOPO, JPL:   0.0000083343622490 92.4754649371095070 1027046.1513708923012018 1027046.5722648203372955 /   11.0   52.2 -110000.0

  static final double TNODE_MIN_TOPO_DIST_ACCEL = -0.00000856;
// TOPO, SWI:   -0.0001068121184233 79.6861647504438793 1764819.9418648579157889
//              -0.0000784099630606 109.2705757601478638 323742.6587682426907122
//              -0.0000433144853973 58.9190511727564825 87048.6964661899837665
//              -0.0000110202297946 32.7308601455830797 72582.4401404987002024
//              -0.0000085451174671 177.4027674611190264 61285.9358465782570420
//              -0.0000085190648985 177.2361821151802133 54700.7609249259112403
//              -0.0000084900566429 177.5682195794680638 48115.0708514538491727
//              -0.0000084618897872 1.6125954998670124 -30746.0549506582174217
//              -0.0000084498993674 173.1389537705036332 -67999.0444112504046643
//              -0.0000084444766972 2.9733688488841779 -240796.9001949433586560
// TOPO, JPL:   -0.0000085540381454 179.8284028667385996 1073062.4194052561651915 1073062.5930666599888355 /   11.0   52.2 -110000.0

// No heliocentric positions for the true node...
  static final double TNODE_MAX_HELIO_DIST_SPEED = 1./0.;
  static final double TNODE_MIN_HELIO_DIST_SPEED = 1./0.;
  static final double TNODE_MAX_HELIO_DIST_ACCEL = 1./0.;
  static final double TNODE_MIN_HELIO_DIST_ACCEL = 1./0.;



///////////////////////////////////////////////////////////////
// MEAN APOGEE (Lilith): //////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double MAPOGEE_MAX_LON_SPEED = 0.114;
// NOTOPO, SWI: 0.1121653709615447 171.4183485768921855 -20247.9275854335137410 /

  static final double MAPOGEE_MIN_LON_SPEED = 0.113;
// NOTOPO, SWI: 0.1106781849512775 155.0229802098288587 3691627.6196139729581773 /

  static final double MAPOGEE_MAX_LON_ACCEL = 0.000031;
// NOTOPO, SWI: 0.0000298963063733 176.2375763415385279 2052295.3679211242124438 2052295.4596249242313206 /

  static final double MAPOGEE_MIN_LON_ACCEL = -0.000031;
// NOTOPO, SWI: -0.0000295882829889 175.2747769062336261 3351880.2633748375810683 3351880.3550786375999451 /

  /**
  * There is no meaning in calculating topocentric positions of mean elements,
  * so it's more an academic kind of exercise...
  */
  static final double MAPOGEE_MAX_TOPO_LON_SPEED = 0.12;
// TOPO, SWI:   0.1121653709615447 171.4193176938157990 -20247.9275854335137410 /   11.0   52.2 -110000.0

  static final double MAPOGEE_MIN_TOPO_LON_SPEED = 0.12;
// TOPO, SWI:   0.1106781849512775 155.0249784415171632 3691627.6196139729581773 /   11.0   52.2 -110000.0

  static final double MAPOGEE_MAX_TOPO_LON_ACCEL = 0.000031;
// TOPO, SWI:   0.0000298963063733 176.2375550073117836 2052295.3679211242124438 2052295.4596249242313206 /   11.0   52.2 -110000.0

  static final double MAPOGEE_MIN_TOPO_LON_ACCEL = 0.000031;
// TOPO, SWI:   -0.0000295882829889 175.2733719410060758 3351880.2633748375810683 3351880.3550786375999451 /   11.0   52.2 -110000.0

// No heliocentric positions for the mean apogee...
  static final double MAPOGEE_MAX_HELIO_LON_SPEED = 1./0;
  static final double MAPOGEE_MIN_HELIO_LON_SPEED = 1./0;
  static final double MAPOGEE_MAX_HELIO_LON_ACCEL = 1./0;
  static final double MAPOGEE_MIN_HELIO_LON_ACCEL = 1./0;



  static final double MAPOGEE_MAX_LAT_SPEED = 0.0155;
// NOTOPO, SWI: 0.0147669600244497 35.7349613823479899 21906.1083835298886697 /

  static final double MAPOGEE_MIN_LAT_SPEED = -0.016;
// NOTOPO, SWI: -0.0147667204296584 65.1007928354346177 -202554.1649415917054284 /

  static final double MAPOGEE_MAX_LAT_ACCEL = 0.000052;
// NOTOPO, SWI: 0.0000509580837833 37.3869576813376341 -217351.3984041414805688 -217351.3067003414907958 /

  static final double MAPOGEE_MIN_LAT_ACCEL = -0.0000525;
// NOTOPO, SWI: -0.0000509600661787 118.7068399888771921 -183404.4857239273260348 -183404.3940201273362618 /

  static final double MAPOGEE_MAX_TOPO_LAT_SPEED = 0.0156;
// TOPO, SWI:   0.0147669600244497 35.7347328272297773 21906.1083835298886697 /   11.0   52.2 -110000.0

  static final double MAPOGEE_MIN_TOPO_LAT_SPEED = -0.0156;
// TOPO, SWI:   -0.0147667204296584 65.1005044490689500 -202554.1649415917054284 /   11.0   52.2 -110000.0

  static final double MAPOGEE_MAX_TOPO_LAT_ACCEL = 0.000052;
// TOPO, SWI:   0.0000509580837833 37.3849474793524905 -217351.3984041414805688 -217351.3067003414907958 /   11.0   52.2 -110000.0

  static final double MAPOGEE_MIN_TOPO_LAT_ACCEL = -0.000052;
// TOPO, SWI:   -0.0000509600661787 118.7088490938103007 -183404.4857239273260348 -183404.3940201273362618 /   11.0   52.2 -110000.0

// No heliocentric positions for the mean apogee...
  static final double MAPOGEE_MAX_HELIO_LAT_SPEED = 1./0.;
  static final double MAPOGEE_MIN_HELIO_LAT_SPEED = 1./0.;
  static final double MAPOGEE_MAX_HELIO_LAT_ACCEL = 1./0.;
  static final double MAPOGEE_MIN_HELIO_LAT_ACCEL = 1./0.;



  static final double MAPOGEE_MAX_DIST_SPEED = 0.0;
// NOTOPO, SWI: 0.0000000000000000 153.9140009625195944 -250900.4082962000102270 /

  static final double MAPOGEE_MIN_DIST_SPEED = 0.0;
// NOTOPO, SWI: 0.0000000000000000 153.9140009625195944 -250900.4082962000102270 /

  static final double MAPOGEE_MAX_DIST_ACCEL = 0.0;
// NOTOPO, SWI: 0.0000000000000000 153.9140009625195944 -250900.5000000000000000 -250900.4082962000102270 /

  static final double MAPOGEE_MIN_DIST_ACCEL = 0.0;
// NOTOPO, SWI: 0.0000000000000000 153.9140009625195944 -250900.5000000000000000 -250900.4082962000102270 /

  static final double MAPOGEE_MAX_TOPO_DIST_SPEED = 0.0;
// TOPO, SWI:   0.0000000000000000 153.9145909096549758 -250900.4082962000102270 /   11.0   52.2 -110000.0

  static final double MAPOGEE_MIN_TOPO_DIST_SPEED = 0.0;
// TOPO, SWI:   0.0000000000000000 153.9145909096549758 -250900.4082962000102270 /   11.0   52.2 -110000.0

  static final double MAPOGEE_MAX_TOPO_DIST_ACCEL = 0.0;
// TOPO, SWI:   0.0000000000000000 153.9145909096549758 -250900.5000000000000000 -250900.4082962000102270 /   11.0   52.2 -110000.0

  static final double MAPOGEE_MIN_TOPO_DIST_ACCEL = 0.0;
// TOPO, SWI:   0.0000000000000000 153.9145909096549758 -250900.5000000000000000 -250900.4082962000102270 /   11.0   52.2 -110000.0

// No heliocentric positions for the mean apogee...
  static final double MAPOGEE_MAX_HELIO_DIST_SPEED = 1./0.;
  static final double MAPOGEE_MIN_HELIO_DIST_SPEED = 1./0.;
  static final double MAPOGEE_MAX_HELIO_DIST_ACCEL = 1./0.;
  static final double MAPOGEE_MIN_HELIO_DIST_ACCEL = 1./0.;



///////////////////////////////////////////////////////////////
// OSCULATING APOGEE: /////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double OAPOGEE_MAX_LON_SPEED = 6.5; // ???
// NOTOPO, SWI: 6.4501881852206120 51.4501951186205417 -192938.6546974640514236 / 

  static final double OAPOGEE_MIN_LON_SPEED = -3.9; // ???
// NOTOPO, SWI: -3.8568329741612786 327.1051657192288644 952676.2940441728569567 / 

  static final double OAPOGEE_MAX_LON_ACCEL = 2.12; // ???
// NOTOPO, SWI: 2.1151738152920152 143.6690056903030097 -245174.6981362385558896 -245174.6064324385661166 / 
// NOTOPO, SWI: 68.8787395144798609 3.8564123971073627 3023084.6334529565647244 3023084.7251567565836012 / 

  static final double OAPOGEE_MIN_LON_ACCEL = -2.2; // ???
// NOTOPO, SWI: -2.1096024893535170 143.4068176495207751 -249560.7074821494170465 -249560.6157783494272735 / 
// NOTOPO, SWI: -68.7513727700735160 4.0511925710936225 3023084.5417491565458477 3023084.6334529565647244 / 


  static final double OAPOGEE_MAX_TOPO_LON_SPEED = 6.48;
// TOPO, SWI:   6.4501881852206120 51.4502023281719403 -192938.6546974640514236 /   11.0   52.2 -110000.0

  static final double OAPOGEE_MIN_TOPO_LON_SPEED = -7.12;
// TOPO, SWI:   -7.0806304799046380 143.8027715810329141 1558491.3132858769968152 /   11.0   52.2 -110000.0

  static final double OAPOGEE_MAX_TOPO_LON_ACCEL = 5; // ???
// TOPO, SWI:   68.8787395144798609 3.8580903985037480 3023084.6334529565647244 3023084.7251567565836012 /   11.0   52.2 -110000.0
//              63.9872302885751765 144.0092304116939772 1558491.3132858769968152 1558491.4049896770156920 /   11.0   52.2 -110000.0
//              39.3377041951937372 228.1266855756707344 283568.0456598401069641 283568.1373636401258409 /   11.0   52.2 -110000.0
//              27.1259498225640598 139.0024744868594553 4522.5526478360743567 4522.6443516360741341 /   11.0   52.2 -110000.0
//              16.6192118670799154 70.6530432475572070 -232639.9808270364592317 -232639.8891232364694588 /   11.0   52.2 -110000.0
//              6.2484834256332844 162.4015420783792933 -244323.2283533335139509 -244323.1366495335241780 /   11.0   52.2 -110000.0
//              2.1151738152920152 143.6687348149947070 -245174.6981362385558896 -245174.6064324385661166 /   11.0   52.2 -110000.0
//              2.1140625042967844 40.3462406699342750 -249914.3173349099815823 -249914.2256311099918094 /   11.0   52.2 -110000.0

  static final double OAPOGEE_MIN_TOPO_LON_ACCEL = -6; // ???
// TOPO, SWI:   -68.7513727700735160 4.0522117857734941 3023084.5417491565458477 3023084.6334529565647244 /   11.0   52.2 -110000.0
//              -63.1344312027849526 143.8027715810329141 1558491.2215820769779384 1558491.3132858769968152 /   11.0   52.2 -110000.0
//              -38.3539882176728710 228.2301401740423046 283567.9539560400880873 283568.0456598401069641 /   11.0   52.2 -110000.0
//              -28.2206339938587618 139.1529738354334995 4522.4609440360745793 4522.5526478360743567 /   11.0   52.2 -110000.0
//              -15.6219121723360033 70.5833973243496189 -232640.0725308364490047 -232639.9808270364592317 /   11.0   52.2 -110000.0
//              -6.8065556784793078 162.6669361211922933 -244323.1366495335241780 -244323.0449457335344050 /   11.0   52.2 -110000.0
//              -2.1096024893535170 143.4072179488592269 -249560.7074821494170465 -249560.6157783494272735 /   11.0   52.2 -110000.0
//              -2.1063563353104215 143.2649365032625894 -249560.7991859494068194 -249560.7074821494170465 /   11.0   52.2 -110000.0
//              -2.0971288046634711 143.1044706967556976 -249560.8908897493965924 -249560.7991859494068194 /   11.0   52.2 -110000.0
//              -2.0820170020217095 142.9259022058182040 -249560.9825935493863653 -249560.8908897493965924 /   11.0   52.2 -110000.0

// No heliocentric positions for the osculating apogee...
  static final double OAPOGEE_MAX_HELIO_LON_SPEED = 1./0.;
  static final double OAPOGEE_MIN_HELIO_LON_SPEED = 1./0.;
  static final double OAPOGEE_MAX_HELIO_LON_ACCEL = 1./0.;
  static final double OAPOGEE_MIN_HELIO_LON_ACCEL = 1./0.;



  static final double OAPOGEE_MAX_LAT_SPEED = 0.595;
// NOTOPO, SWI: 0.5893596598716220 143.8036338266929306 1558491.3132858769968152 / 

  static final double OAPOGEE_MIN_LAT_SPEED = -0.592;
// NOTOPO, SWI: -0.5870851313647680 49.7434145533308083 1018.1836346420270729 / 

  static final double OAPOGEE_MAX_LAT_ACCEL = 0.198;
// NOTOPO, SWI: 5.2379339742474871 143.8036338266929306 1558491.2215820769779384 1558491.3132858769968152 / 
// NOTOPO, SWI: 0.1916322763674306 143.5136355060204210 -245174.6064324385661166 -245174.5147286385763437 / 

  static final double OAPOGEE_MIN_LAT_ACCEL = -0.184;
// NOTOPO, SWI: -5.3074179738566309 144.0103775442132132 1558491.3132858769968152 1558491.4049896770156920 / 
// NOTOPO, SWI: -0.1809284876020955 28.3181513796215825 -247714.8016921552771237 -247714.7099883552873507 / 

  static final double OAPOGEE_MAX_TOPO_LAT_SPEED = 0.595;
// TOPO, SWI:   0.5893596598716220 143.8027715810329141 1558491.3132858769968152 /   11.0   52.2 -110000.0

  static final double OAPOGEE_MIN_TOPO_LAT_SPEED = -0.593;
// TOPO, SWI:   -0.5870851313647680 49.7445176215321965 1018.1836346420270729 /   11.0   52.2 -110000.0

  static final double OAPOGEE_MAX_TOPO_LAT_ACCEL = 0.22; // ???
// TOPO, SWI:   5.2379339742474871 143.8027715810329141 1558491.2215820769779384 1558491.3132858769968152 /   11.0   52.2 -110000.0
//              3.0200105792156928 228.2301401740423046 283567.9539560400880873 283568.0456598401069641 /   11.0   52.2 -110000.0
//              1.5421732353411270 139.0024744868594553 4522.5526478360743567 4522.6443516360741341 /   11.0   52.2 -110000.0
//              1.3399341407278487 25.9927360270757504 -123771.7054806192754768 -123771.6137768192711519 /   11.0   52.2 -110000.0
//              0.8791241418544614 3.6129702330721898 -158821.2646530689089559 -158821.1729492689191829 /   11.0   52.2 -110000.0
//              0.6174781877730624 25.3356290167430700 -220956.8250045393942855 -220956.7333007394045126 /   11.0   52.2 -110000.0
//              0.5180504015512793 162.6669361211922933 -244323.1366495335241780 -244323.0449457335344050 /   11.0   52.2 -110000.0
//              0.1916322763674306 143.5140928603327950 -245174.6064324385661166 -245174.5147286385763437 /   11.0   52.2 -110000.0
//              0.1913092612021543 143.6687348149947070 -245174.6981362385558896 -245174.6064324385661166 /   11.0   52.2 -110000.0
//              0.1904665318092549 143.8058931802814300 -245174.7898400385456625 -245174.6981362385558896 /   11.0   52.2 -110000.0

  static final double OAPOGEE_MIN_TOPO_LAT_ACCEL = -0.2; // ???
// TOPO, SWI:   -5.3074179738566309 144.0092304116939772 1558491.3132858769968152 1558491.4049896770156920 /   11.0   52.2 -110000.0
//              -3.0984889620765821 228.1266855756707344 283568.0456598401069641 283568.1373636401258409 /   11.0   52.2 -110000.0
//              -1.6106363493553451 139.1529738354334995 4522.4609440360745793 4522.5526478360743567 /   11.0   52.2 -110000.0
//              -1.3214413016746980 25.7427903268498994 -123771.7971844192798017 -123771.7054806192754768 /   11.0   52.2 -110000.0
//              -0.9177284313575792 3.8646709050026971 -158821.1729492689191829 -158821.0812454689294100 /   11.0   52.2 -110000.0
//              -0.6359196220717301 25.0807399124825565 -220956.9167083393840585 -220956.8250045393942855 /   11.0   52.2 -110000.0
//              -0.4832935516415320 162.4015420783792933 -244323.2283533335139509 -244323.1366495335241780 /   11.0   52.2 -110000.0
//              -0.1809284876020955 28.3175426999310389 -247714.8016921552771237 -247714.7099883552873507 /   11.0   52.2 -110000.0
//              -0.1809136636167950 28.4003784255750134 -247714.8933959552668966 -247714.8016921552771237 /   11.0   52.2 -110000.0
//              -0.1803819052966495 28.5008495027587117 -247714.9850997552566696 -247714.8933959552668966 /   11.0   52.2 -110000.0

// No heliocentric positions for the osculating apogee...
  static final double OAPOGEE_MAX_HELIO_LAT_SPEED = 1./0.;
  static final double OAPOGEE_MIN_HELIO_LAT_SPEED = 1./0.;
  static final double OAPOGEE_MAX_HELIO_LAT_ACCEL = 1./0.;
  static final double OAPOGEE_MIN_HELIO_LAT_ACCEL = 1./0.;



  static final double OAPOGEE_MAX_DIST_SPEED = 0.0000336;
// NOTOPO, SWI: 0.0000331796025315 162.0559695927080668 452119.5383907356299460 / 

  static final double OAPOGEE_MIN_DIST_SPEED = -0.0000388;
// NOTOPO, SWI: -0.0000383564726112 143.8036338266929306 1558491.3132858769968152 / 

  static final double OAPOGEE_MAX_DIST_ACCEL = 0.000320;
// NOTOPO, SWI: 0.0003181723806385 169.5186135516686647 2652297.0998720317147672 2652297.1915758317336440 / 
// NOTOPO, SWI: 0.0002526325991030 144.0103775442132132 1558491.3132858769968152 1558491.4049896770156920 / 

  static final double OAPOGEE_MIN_DIST_ACCEL = -0.000332;
// NOTOPO, SWI: -0.0003276915355732 169.7783440308482739 2652297.0081682316958904 2652297.0998720317147672 / 
//              -0.0002657804181765 182.5429926387725459 2509784.9928602962754667 2509785.0845640962943435 / 
//              -0.0002592273381945 172.6663900642790281 1523992.8939415756613016 1523992.9856453756801784 / 
//              -0.0002362703260975 168.7598572310744771 790186.7893097251653671 790186.8810135251842439 / 
//              -0.0001845736992394 5.6648800904843659 268220.1308734808117151 268220.2225772808305919 / 
//              -0.0001843270910099 7.6690589634641526 31029.9945569982301095 31030.0862607982307964 / 
//              -0.0001371165189919 23.9210545917084403 17776.2277504989542649 17776.3194542989549518 / 
//              -0.0001314032632600 181.2666291901276168 -112088.6413600682863034 -112088.5496562682819786 / 
//              -0.0001294350298969 288.3207414549888767 -135454.9530080747790635 -135454.8613042747892905 / 

  static final double OAPOGEE_MAX_TOPO_DIST_SPEED = 0.0000348;
// TOPO, SWI:   0.0000331796025315 162.0554913950485059 452119.5383907356299460 /   11.0   52.2 -110000.0

  static final double OAPOGEE_MIN_TOPO_DIST_SPEED = -0.0000389;
// TOPO, SWI:   -0.0000383564726112 143.8027715810329141 1558491.3132858769968152 /   11.0   52.2 -110000.0
//              -0.0000315798154516 23.9192331902883808 17776.3194542989549518 /   11.0   52.2 -110000.0
//              -0.0000241174282212 155.6392038260355548 -53672.7705354545687442 /   11.0   52.2 -110000.0
//              -0.0000211044112260 121.5534461342293469 -122065.7396891388198128 /   11.0   52.2 -110000.0
//              -0.0000211036580721 125.5142614515566066 -128651.0812712493934669 /   11.0   52.2 -110000.0
//              -0.0000211016670089 125.4218652089164294 -128651.1729750493977917 /   11.0   52.2 -110000.0
//              -0.0000210813177137 126.7646050449078530 -248072.7216235153609887 /   11.0   52.2 -110000.0

  static final double OAPOGEE_MAX_TOPO_DIST_ACCEL = 0.00033; // ???
// TOPO, SWI:   0.0003181723806385 169.5192878024524816 2652297.0998720317147672 2652297.1915758317336440 /   11.0   52.2 -110000.0
//              0.0002526325991030 144.0092304116939772 1558491.3132858769968152 1558491.4049896770156920 /   11.0   52.2 -110000.0
//              0.0002502732154425 85.7828267135280811 1115992.2334243906661868 1115992.3251281906850636 /   11.0   52.2 -110000.0
//              0.0002284639283837 168.5027117890790578 790186.8810135251842439 790186.9727173252031207 /   11.0   52.2 -110000.0
//              0.0001835563725124 228.1266855756707344 283568.0456598401069641 283568.1373636401258409 /   11.0   52.2 -110000.0
//              0.0001749102115120 7.9453619854307647 31030.0862607982307964 31030.1779645982314833 /   11.0   52.2 -110000.0
//              0.0001441806335868 288.2482328493130694 -135454.8613042747892905 -135454.7696004747995175 /   11.0   52.2 -110000.0
//              0.0000917497105162 70.6530432475572070 -232639.9808270364592317 -232639.8891232364694588 /   11.0   52.2 -110000.0
//              0.0000254462819288 162.6669361211922933 -244323.1366495335241780 -244323.0449457335344050 /   11.0   52.2 -110000.0
//              0.0000087540238561 75.0022159568096640 -247684.8145495586213656 -247684.7228457586315926 /   11.0   52.2 -110000.0

  static final double OAPOGEE_MIN_TOPO_DIST_ACCEL = -0.00033; // ???
// TOPO, SWI:   -0.0003276915355732 169.7786058997761813 2652297.0081682316958904 2652297.0998720317147672 /   11.0   52.2 -110000.0
//              -0.0002657804181765 182.5439230812184519 2509784.9928602962754667 2509785.0845640962943435 /   11.0   52.2 -110000.0
//              -0.0002592273381945 172.6651545647018509 1523992.8939415756613016 1523992.9856453756801784 /   11.0   52.2 -110000.0
//              -0.0002362703260975 168.7615556959068215 790186.7893097251653671 790186.8810135251842439 /   11.0   52.2 -110000.0
//              -0.0001845736992394 5.6647024559301231 268220.1308734808117151 268220.2225772808305919 /   11.0   52.2 -110000.0
//              -0.0001843270910099 7.6692836371472595 31029.9945569982301095 31030.0862607982307964 /   11.0   52.2 -110000.0
//              -0.0001371165189919 23.9192331902883808 17776.2277504989542649 17776.3194542989549518 /   11.0   52.2 -110000.0
//              -0.0001314032632600 181.2675240107135437 -112088.6413600682863034 -112088.5496562682819786 /   11.0   52.2 -110000.0
//              -0.0001294350298969 288.3190436616176271 -135454.9530080747790635 -135454.8613042747892905 /   11.0   52.2 -110000.0
//              -0.0000768871688103 70.5833973243496189 -232640.0725308364490047 -232639.9808270364592317 /   11.0   52.2 -110000.0

// No heliocentric positions for the osculating apogee...
  static final double OAPOGEE_MAX_HELIO_DIST_SPEED = 1./0.;
  static final double OAPOGEE_MIN_HELIO_DIST_SPEED = 1./0.;
  static final double OAPOGEE_MAX_HELIO_DIST_ACCEL = 1./0.;
  static final double OAPOGEE_MIN_HELIO_DIST_ACCEL = 1./0.;



///////////////////////////////////////////////////////////////
// CHIRON: ////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double CHIRON_MAX_LON_SPEED = 0.1481;
// NOTOPO, SWI: 0.1480541138387438 3.0740725914689051 3402199.5112853837199509 / 

  static final double CHIRON_MIN_LON_SPEED = -0.08136;
// NOTOPO, SWI: -0.0813530877869733 180.0686031515706134 3308856.5058411695063114 / 

  static final double CHIRON_MAX_LON_ACCEL = 0.001985;
// NOTOPO, SWI: 0.0019801438410056 109.7728890158056601 3327189.3793181432411075 3327189.4710219432599843 / 

  static final double CHIRON_MIN_LON_ACCEL = -0.002076;
// NOTOPO, SWI: -0.0020747099147952 111.6956737843569840 3309175.6350652351975441 3309175.7267690352164209 / 

  static final double CHIRON_MAX_TOPO_LON_SPEED = 0.1490;
// TOPO, SWI:   0.1489717923918477 3.3015476297053965 3402199.7863967837765813 /   11.0   52.2 -110000.0
//              0.1489000930139661 3.3084944836917316 3383573.7358711496926844 /   11.0   52.2 -110000.0
//              0.1488674087003523 3.1787404119984615 3383565.8493443480692804 /   11.0   52.2 -110000.0
//              0.1488641986878703 3.2546857316454236 3383565.7576405480504036 /   11.0   52.2 -110000.0
//              0.1487769883398207 4.0070844371211933 3383564.8406025478616357 /   11.0   52.2 -110000.0
//              0.1487356870615033 4.0830131173854625 3383564.7488987478427589 /   11.0   52.2 -110000.0
//              0.1486723911311650 3.1677442396438664 3309431.7637786879204214 /   11.0   52.2 -110000.0

  static final double CHIRON_MIN_TOPO_LON_SPEED = -0.0826;
// TOPO, SWI:   -0.0825014372969852 180.3730621099178677 3309239.7360214483924210 /   11.0   52.2 -110000.0
//              -0.0824803407349744 180.8683156676808323 3308855.7722107693552971 /   11.0   52.2 -110000.0
//              -0.0824177489223616 181.9679239843536038 3308854.7634689691476524 /   11.0   52.2 -110000.0
//              -0.0823555145289969 179.7832444562579326 3290976.7408400890417397 /   11.0   52.2 -110000.0
//              -0.0823300256388445 180.8740004754742756 3290975.7320982888340950 /   11.0   52.2 -110000.0
//              -0.0822512864730052 181.9651412905404868 3290974.7233564886264503 /   11.0   52.2 -110000.0

  static final double CHIRON_MAX_TOPO_LON_ACCEL = 0.00892;
// TOPO, SWI:   0.0089131503936917 124.2443559490036051 3402437.8494616327807307 3402437.9411654327996075 /   11.0   52.2 -110000.0
//              0.0089090822815819 128.1161399302476127 3383807.8556725978851318 3383807.9473763979040086 /   11.0   52.2 -110000.0
//              0.0088971243336819 129.1261206601918161 3383806.8469307976774871 3383806.9386345976963639 /   11.0   52.2 -110000.0
//              0.0088769507698403 121.7964641216075279 3365193.8183447662740946 3365193.9100485662929714 /   11.0   52.2 -110000.0
//              0.0088754328039959 126.7151491328518205 3309290.8150380589067936 3309290.9067418589256704 /   11.0   52.2 -110000.0
//              0.0088669302536330 127.7250936822676266 3309289.8062962586991489 3309289.8980000587180257 /   11.0   52.2 -110000.0
//              0.0088605847296487 128.1742917738054643 3291025.8023730991408229 3291025.8940768991596997 /   11.0   52.2 -110000.0
//              0.0088405189631605 126.2570116687934103 3254883.7758210594765842 3254883.8675248594954610 /   11.0   52.2 -110000.0

  static final double CHIRON_MIN_TOPO_LON_ACCEL = -0.0091;
// TOPO, SWI:   -0.0090863634942317 127.9953303268456182 3383709.6409027776680887 3383709.7326065776869655 /   11.0   52.2 -110000.0
//              -0.0090786243171420 124.2419074628229509 3291307.6081505571492016 3291307.6998543571680784 /   11.0   52.2 -110000.0
//              -0.0090687107562786 123.1988879343719532 3291306.5994087569415569 3291306.6911125569604337 /   11.0   52.2 -110000.0
//              -0.0090479052698771 123.2118015100172670 3254778.5915624378249049 3254778.6832662378437817 /   11.0   52.2 -110000.0
//              -0.0090294153326601 122.1702012647674849 3254777.5828206376172602 3254777.6745244376361370 /   11.0   52.2 -110000.0
//              -0.0090047664866320 124.4892293237568310 3236524.5833534803241491 3236524.6750572803430259 /   11.0   52.2 -110000.0
//              -0.0090011195922285 123.4479228112854514 3236523.5746116801165044 3236523.6663154801353812 /   11.0   52.2 -110000.0
//              -0.0089920734222631 116.3014079648567076 3236516.6051228786818683 3236516.6968266787007451 /   11.0   52.2 -110000.0

  static final double CHIRON_MAX_HELIO_LON_SPEED = 0.048572;
// HELIO, SWI:   0.0485696184226494 210.6292818961332500 3402299.8352426043711603 / 

  static final double CHIRON_MIN_HELIO_LON_SPEED = 0.008467;
// HELIO, SWI:   0.0084676412770711 7.9994504859662445 1972799.5418591485358775 / 

  static final double CHIRON_MAX_HELIO_LON_ACCEL = 0.000036235;
// HELIO, SWI:   0.0000362290392015 139.3639511965011764 2609641.5330954394303262 2609641.6247992394492030 / 

  static final double CHIRON_MIN_HELIO_LON_ACCEL = -0.000035949;
// HELIO, SWI:   -0.0000359436743759 236.7714997834970632 1984188.3284872928634286 1984188.4201910928823054 / 



  static final double CHIRON_MAX_LAT_SPEED = 0.01538;
// NOTOPO, SWI: 0.0153624827772349 102.6165618129904260 1961882.4795783013105392 / 

  static final double CHIRON_MIN_LAT_SPEED = -0.01344;
// NOTOPO, SWI: -0.0134015639639669 100.8229034758880971 1960974.0617353143170476 / 

  static final double CHIRON_MAX_LAT_ACCEL = 0.000313;
// NOTOPO, SWI: 0.0003120510640977 180.2079026388219347 1961426.9868036075495183 1961427.0785074075683951 / 

  static final double CHIRON_MIN_LAT_ACCEL = -0.0002607;
// NOTOPO, SWI: -0.0002606661345476 180.9513472004433652 3385660.3641367792151868 3385660.4558405792340636 / 

  static final double CHIRON_MAX_TOPO_LAT_SPEED = 0.01574;
// TOPO, SWI:   0.0157158804791694 103.1350783881219257 1961881.9293555011972785 /   11.0   52.2 -110000.0

  static final double CHIRON_MIN_TOPO_LAT_SPEED =  -0.01368;
// TOPO, SWI:   -0.0136753781839591 100.6408976348296562 1960973.8783277142792940 /   11.0   52.2 -110000.0

  static final double CHIRON_MAX_TOPO_LAT_ACCEL = 0.0033643;
// TOPO, SWI:   0.0033640008466397 187.5099508835257325 3327114.9158325279131532 3327115.0075363279320300 /   11.0   52.2 -110000.0

  static final double CHIRON_MIN_TOPO_LAT_ACCEL = -0.003132;
// TOPO, SWI:   -0.0031313162870054 172.0627858902915932 3309247.3474368499591947 3309247.4391406499780715 /   11.0   52.2 -110000.0

  static final double CHIRON_MAX_HELIO_LAT_SPEED = 0.0066239;
// HELIO, SWI:   0.0066237790923881 216.3748108685314548 3402418.3165522287599742 / 

  static final double CHIRON_MIN_HELIO_LAT_SPEED = -0.0018657;
// HELIO, SWI:   -0.0018655429271156 77.1567753378589742 1958964.8314769007265568 / 

  static final double CHIRON_MAX_HELIO_LAT_ACCEL = 0.000011620;
// HELIO, SWI:   0.0000116182791852 123.0107161248320011 2270556.9202190404757857 2270557.0119228404946625 / 

  static final double CHIRON_MIN_HELIO_LAT_ACCEL = -0.000017098;
// HELIO, SWI:   -0.0000170952824726 236.6709356405359870 1984185.3939656922593713 1984185.4856694922782481 / 



  static final double CHIRON_MAX_DIST_SPEED = 0.01867;
// NOTOPO, SWI: 0.0186687186661194 89.8594372958532404 1965684.1523118838667870 / 

  static final double CHIRON_MIN_DIST_SPEED = -0.018683;
// NOTOPO, SWI: -0.0186798337268007 89.9240497610385319 1959837.3931340803392231 / 

  static final double CHIRON_MAX_DIST_ACCEL = 0.0003195;
// NOTOPO, SWI: 0.0003193379260309 182.3116645050504587 1997516.4670782363973558 1997516.5587820364162326 / 

  static final double CHIRON_MIN_DIST_ACCEL = -0.0002838;
// NOTOPO, SWI: -0.0002836526097651 4.8222989523558191 3410765.1047261469066143 3410765.1964299469254911 / 

  static final double CHIRON_MAX_TOPO_DIST_SPEED = 0.01883;
// TOPO, SWI:   0.0188233620020445 90.3952504368265863 1965683.6020890837535262 /   11.0   52.2 -110000.0

  static final double CHIRON_MIN_TOPO_DIST_SPEED = -0.01884;
// TOPO, SWI:   -0.0188346064034555 90.1041779471860309 1959837.5765416803769767 /   11.0   52.2 -110000.0

  static final double CHIRON_MAX_TOPO_DIST_ACCEL = 0.001324;
// TOPO, SWI:   0.0013219984219904 176.9248835345475186 3143009.6332842307165265 3143009.7249880307354033 /   11.0   52.2 -110000.0

  static final double CHIRON_MIN_TOPO_DIST_ACCEL = -0.001288;
// TOPO, SWI:   -0.0012870584145483 3.8110903955230242 3407815.8188137398101389 3407815.9105175398290157 /   11.0   52.2 -110000.0

  static final double CHIRON_MAX_HELIO_DIST_SPEED = 0.00208240;
// HELIO, SWI:   0.0020823844446079 297.3789092132498695 3404556.1155382688157260 / 

  static final double CHIRON_MIN_HELIO_DIST_SPEED = -0.0020787;
// HELIO, SWI:   -0.0020784488318901 118.8114000790392595 3418967.7345264353789389 / 

  static final double CHIRON_MAX_HELIO_DIST_ACCEL = 0.0000023777;
// HELIO, SWI:   0.0000023775763518 234.3434779952800682 1984118.6335992785170674 1984118.7253030785359442 / 

  static final double CHIRON_MIN_HELIO_DIST_ACCEL = -0.0000012240;
// HELIO, SWI:   -0.0000012238324524 36.2854788469465461 3079932.5499982465989888 3079932.6417020466178656 / 



///////////////////////////////////////////////////////////////
// PHOLUS: ////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double PHOLUS_MAX_LON_SPEED = 0.144;
// NOTOPO, SWI: 0.1430390048688713 3.0018759003319389 1380444.5295483474619687 / 

  static final double PHOLUS_MIN_LON_SPEED = -0.083;
// NOTOPO, SWI: -0.0828157902880158 179.7977542274780092 499611.6481260322034359 / 

  static final double PHOLUS_MAX_LON_ACCEL = 0.00202;
// NOTOPO, SWI: 0.0020122954067407 250.4580115964574247 2644830.9388484153896570 2644831.0305522154085338 / 

  static final double PHOLUS_MIN_LON_ACCEL = -0.00203;
// NOTOPO, SWI: -0.0020284765596128 106.4528548042683269 1380561.7270047715865076 1380561.8187085716053843 / 

  static final double PHOLUS_MAX_TOPO_LON_SPEED = 0.146;
// TOPO, SWI:   0.1439957406349812 3.2250695042433364 1380444.8046597475185990 /   11.0   52.2 -110000.0

  static final double PHOLUS_MIN_TOPO_LON_SPEED = -0.084;
// TOPO, SWI:   -0.0839987813309506 179.2933161401986979 1380247.8248973069712520 /   11.0   52.2 -110000.0

  static final double PHOLUS_MAX_TOPO_LON_ACCEL = 0.009147;
// TOPO, SWI:   0.0091450347895675 239.9890081597793028 2644820.5763190132565796 2644820.6680228132754564 /   11.0   52.2 -110000.0

  static final double PHOLUS_MIN_TOPO_LON_ACCEL = -0.0092;
// TOPO, SWI:   -0.0092168184439935 120.6341533482896864 1380575.6659823744557798 1380575.7576861744746566 /   11.0   52.2 -110000.0
//              -0.0091874059736348 119.5928634512433320 1380574.6572405742481351 1380574.7489443742670119 /   11.0   52.2 -110000.0
//              -0.0091624468224833 113.4872818940185084 1380568.6964935730211437 1380568.7881973730400205 /   11.0   52.2 -110000.0

  static final double PHOLUS_MAX_HELIO_LON_SPEED = 0.0456612;
// HELIO, SWI:   0.0456609358781905 65.7822048348128021 1410993.2662258357740939 / 

  static final double PHOLUS_MIN_HELIO_LON_SPEED = 0.0031847;
// HELIO, SWI:   0.0031842151382474 325.5701466942194315 3275615.5272782593965530 / 

  static final double PHOLUS_MAX_HELIO_LON_ACCEL = 0.000036611;
// HELIO, SWI:   0.0000366087844347 354.7972316220040625 1100835.7000273913145065 1100835.7917311913333833 / 

  static final double PHOLUS_MIN_HELIO_LON_ACCEL = -0.000035427;
// HELIO, SWI:   -0.0000354231241491 193.9198256398891544 3127255.9274583202786744 3127256.0191621202975512 / 



  static final double PHOLUS_MAX_LAT_SPEED = 0.0475;
// NOTOPO, SWI: 0.0473701962087067 101.2407213700385284 414557.9325731243006885 / 

  static final double PHOLUS_MIN_LAT_SPEED = -0.0359;
// NOTOPO, SWI: -0.0357901310934522 260.3881605591503217 413648.1391731370240450 / 

  static final double PHOLUS_MAX_LAT_ACCEL = 0.0008841;
// NOTOPO, SWI: 0.0008840458493128 178.8421732320428248 356766.7480240282602608 356766.8397278282791376 / 

  static final double PHOLUS_MIN_LAT_ACCEL = -0.000759;
// NOTOPO, SWI: -0.0007570203592937 180.6651743873322573 3576610.1414826177060604 3576610.2331864177249372 / 

  static final double PHOLUS_MAX_TOPO_LAT_SPEED = 0.0482;
// TOPO, SWI:   0.0479262918531750 101.6024232723681564 414557.5657579242251813 /   11.0   52.2 -110000.0

  static final double PHOLUS_MIN_TOPO_LAT_SPEED = -0.03636;
// TOPO, SWI:   -0.0363434864549000 260.9139978749386160 413647.5889503369107842 /   11.0   52.2 -110000.0

  static final double PHOLUS_MAX_TOPO_LAT_ACCEL = 0.00490;
// TOPO, SWI:   0.0048908505871406 174.7805307547260441 327546.6160012134350836 327546.7077050134539604 /   11.0   52.2 -110000.0

  static final double PHOLUS_MIN_TOPO_LAT_ACCEL = -0.00485;
// TOPO, SWI:   -0.0048340812417941 177.7122471828694756 753901.2418693765066564 753901.3335731765255332 /   11.0   52.2 -110000.0

  static final double PHOLUS_MAX_HELIO_LAT_SPEED = 0.020809;
// HELIO, SWI:   0.0208062133404151 158.8349313067455739 3669112.3147844588384032 / 

  static final double PHOLUS_MIN_HELIO_LAT_SPEED = -0.0036998;
// HELIO, SWI:   -0.0036986077672756 287.4455222305808775 524014.3961262553930283 / 

  static final double PHOLUS_MAX_HELIO_LAT_ACCEL = 0.000022898;
// HELIO, SWI:   0.0000228925156391 83.2525679446732170 2644221.2919858898967505 2644221.3836896899156272 / 

  static final double PHOLUS_MIN_HELIO_LAT_ACCEL = -0.000020868;
// HELIO, SWI:   -0.0000208633733225 88.5324223296608324 557487.5669863456860185 557487.6586901457048953 / 



  static final double PHOLUS_MAX_DIST_SPEED = 0.01806;
// NOTOPO, SWI: 0.0180349697932286 89.9276577797021730 3232343.9887937521561980 / 

  static final double PHOLUS_MIN_DIST_SPEED = -0.01822;
// NOTOPO, SWI: -0.0182018374571414 269.9133809896678713 1220418.5556976068764925 / 

  static final double PHOLUS_MAX_DIST_ACCEL = 0.0003200;
// NOTOPO, SWI: 0.0003198939404534 181.1007820742507874 2515483.2791445897892118 2515483.3708483898080885 / 

  static final double PHOLUS_MIN_DIST_ACCEL = -0.000297;
// NOTOPO, SWI: -0.0002962981658906 3.0285369280505847 1726161.3446497116237879 1726161.4363535116426647 / 

  static final double PHOLUS_MAX_TOPO_DIST_SPEED = 0.0183;
// TOPO, SWI:   0.0181956127909753 89.2383177748068306 3198371.7658539591357112 /   11.0   52.2 -110000.0

  static final double PHOLUS_MIN_TOPO_DIST_SPEED = -0.0185;
// TOPO, SWI:   -0.0183544820569711 269.6209267595401684 1735800.7185656907968223 /   -6.5   10.0 -36495.0

  static final double PHOLUS_MAX_TOPO_DIST_ACCEL = 0.00133;
// TOPO, SWI:   0.0013199233848670 176.1644418230122824 328681.7256378470920026 328681.8173416471108794 /   11.0   52.2 -110000.0

  static final double PHOLUS_MIN_TOPO_DIST_ACCEL = -0.00131;
// TOPO, SWI:   -0.0012945286051854 5.3012108376544518 341827.8321857531554997 341827.9238895531743765 /   11.0   52.2 -110000.0

  static final double PHOLUS_MAX_HELIO_DIST_SPEED = 0.0026983;
// HELIO, SWI:   0.0026970137849065 235.3099015822475337 3261453.0675147441215813 / 

  static final double PHOLUS_MIN_HELIO_DIST_SPEED = -0.0026987;
// HELIO, SWI:   -0.0026966131696737 55.6846751377110891 3289876.9354419950395823 / 

  static final double PHOLUS_MAX_HELIO_DIST_ACCEL = 0.0000030692;
// HELIO, SWI:   0.0000030688045009 116.5166479772393586 2415496.5167966079898179 2415496.6085004080086946 / 

  static final double PHOLUS_MIN_HELIO_DIST_ACCEL = -0.0000013359;
// HELIO, SWI:   -0.0000013356357022 232.3020067156864457 1206607.5965995639562607 1206607.6883033639751375 / 



///////////////////////////////////////////////////////////////
// CERES: /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double CERES_MAX_LON_SPEED = 0.47778;
// NOTOPO, SWI: 0.4777666356215652 3.0324656934870404 185995.7526867222914007 / 
//              0.4777642988236352 3.0761477279855853 185995.6609829223016277 / 
//              0.4777619074362583 3.1198327283156004 185995.5692791223118547 / 
//              0.4777594307344309 3.1635206984532260 185995.4775753223220818 / 
//              0.4777568808639132 3.2072116422655199 185995.3858715223323088 / 
//              0.4777542508895744 3.2509055634800461 185995.2941677223425359 / 
//              0.4777515768352859 3.2946024657497333 185995.2024639223527629 / 
//              0.4777487789409632 3.3383023526224065 185995.1107601223629899 / 

  static final double CERES_MIN_LON_SPEED = -0.2397;
// NOTOPO, SWI: -0.2394155931521627 180.9535211335031022 -222502.4008495670277625 / 

  static final double CERES_MAX_LON_ACCEL = 0.00784;
// NOTOPO, SWI: 0.0078289390844326 133.4978630172743124 510566.3134061666205525 510566.4051099666394293 / 

  static final double CERES_MIN_LON_ACCEL = -0.007809;
// NOTOPO, SWI: -0.0078072571959892 130.4420718528908196 465234.0988314351998270 465234.1905352352187037 / 

  static final double CERES_MAX_TOPO_LON_SPEED = 0.482;
// TOPO, SWI:   0.4806279624676904 4.3625891276860784 411366.6296802815049887 /  173.1   -6.3 -11378587.8

  static final double CERES_MIN_TOPO_LON_SPEED = -0.2462;
// TOPO, SWI:   -0.2461003811501000 181.4669672059693539 1131117.3308579281438142 / -129.0  -17.8 -828356.8

  static final double CERES_MAX_TOPO_LON_ACCEL = 0.04415;
// TOPO, SWI:   0.0441050298988982 150.3410264648743464 -182363.4641864434233867 -182363.3724826434336137 /   11.0   52.2 -110000.0

  static final double CERES_MIN_TOPO_LON_ACCEL = -0.0434;
// TOPO, SWI:   -0.0433571856487273 207.6654377673990837 -174011.8157137748203240 -174011.7240099748305511 /   11.0   52.2 -110000.0
  static final double CERES_MAX_HELIO_LON_SPEED = 0.27746;
// HELIO, SWI:   0.2774373104493407 344.3180307541163074 328950.0553979817777872 / 

  static final double CERES_MIN_HELIO_LON_SPEED = 0.1684273;
// HELIO, SWI:   0.1684271766463872 114.0812546781709074 -233676.2337669208936859 / 

  static final double CERES_MAX_HELIO_LON_ACCEL = 0.00024858;
// HELIO, SWI:   0.0002485770464934 301.1003542281761725 660015.7211855300702155 660015.8128893300890923 / 

  static final double CERES_MIN_HELIO_LON_ACCEL = -0.00026465;
// HELIO, SWI:   -0.0002646379191784 42.8006609833073668 155992.9287402682821266 155993.0204440682718996 / 



  static final double CERES_MAX_LAT_SPEED = 0.111909;
// NOTOPO, SWI: 0.1119085703807672 230.4962443443751852 944518.8742172936908901 / 

  static final double CERES_MIN_LAT_SPEED = -0.10943;
// NOTOPO, SWI: -0.1094225739941136 229.6607842571642095 73275.5509175217594020 / 

  static final double CERES_MAX_LAT_ACCEL = 0.003567;
// NOTOPO, SWI: 0.0035661165770005 181.2599309066658009 638379.2183128762990236 638379.3100166763179004 / 

  static final double CERES_MIN_LAT_ACCEL = -0.003284;
// NOTOPO, SWI: -0.0032820437433540 181.8053550152060609 2429693.7367416098713875 2429693.8284454098902643 / 

  static final double CERES_MAX_TOPO_LAT_SPEED = 0.1141;
// TOPO, SWI:   0.1140411323414252 230.5901796426277599 944518.9659210937097669 /   11.0   52.2 -110000.0

  static final double CERES_MIN_TOPO_LAT_SPEED = -0.11225;
// TOPO, SWI:   -0.1122208999929153 229.3833179571449818 73275.8260289217723766 /   11.0   52.2 -110000.0

  static final double CERES_MAX_TOPO_LAT_ACCEL = 0.0254;
// TOPO, SWI:   0.0253261491592657 173.9892913208469167 268361.6298369099386036 268361.7215407099574804 /   11.0   52.2 -110000.0

  static final double CERES_MIN_TOPO_LAT_ACCEL = -0.0241;
// TOPO, SWI:   -0.0239939019469919 183.8734151551513776 2318640.3432149500586092 2318640.4349187500774860 /   11.0   52.2 -110000.0

  static final double CERES_MAX_HELIO_LAT_SPEED = 0.049023;
// HELIO, SWI:   0.0490219454332673 81.6032687032516151 1529831.5831849775277078 / 

  static final double CERES_MIN_HELIO_LAT_SPEED = -0.047271;
// HELIO, SWI:   -0.0472702444220485 275.1918003463811715 -226166.9764009583450388 / 

  static final double CERES_MAX_HELIO_LAT_ACCEL = 0.000239747;
// HELIO, SWI:   0.0002397455950067 355.4826630735737467 524032.0076971384696662 524032.0994009384885430 / 

  static final double CERES_MIN_HELIO_LAT_ACCEL = -0.00020807;
// HELIO, SWI:   -0.0002080590305120 162.7032273885286315 2401106.9111617254093289 2401107.0028655254282057 / 



  static final double CERES_MAX_DIST_SPEED = 0.014525;
// NOTOPO, SWI: 0.0145226090702615 269.7300533033773604 51956.8934201937372563 / 

  static final double CERES_MIN_DIST_SPEED = -0.014456;
// NOTOPO, SWI: -0.0144538692662622 90.1670995513909475 668137.8350494019687176 / 

  static final double CERES_MAX_DIST_ACCEL = 0.0003006;
// NOTOPO, SWI: 0.0003005001344585 179.9786405989519267 3150598.4922678046859801 3150598.5839716047048569 / 

  static final double CERES_MIN_DIST_ACCEL = -0.0001636;
// NOTOPO, SWI: -0.0001635521463653 5.9181909524265421 -226934.1703916727856267 -226934.0786878727958538 / 

  static final double CERES_MAX_TOPO_DIST_SPEED = 0.01468;
// TOPO, SWI:   0.0146733008601036 269.8692339596657348 51957.0768277937313542 /   11.0   52.2 -110000.0

  static final double CERES_MIN_TOPO_DIST_SPEED = -0.01462;
// TOPO, SWI:   -0.0146138855659326 86.3103676911969728 531883.0265074669150636 /  177.5  -24.2 -501202.5

  static final double CERES_MAX_TOPO_DIST_ACCEL = 0.001298;
// TOPO, SWI:   0.0012964886413124 182.4703138984704935 2424087.4249274558387697 2424087.5166312558576465 /   11.0   52.2 -110000.0

  static final double CERES_MIN_TOPO_DIST_ACCEL = -0.001166;
// TOPO, SWI:   -0.0011640345749492 3.6983149068529428 721675.2471308223903179 721675.3388346224091947 /   11.0   52.2 -110000.0

  static final double CERES_MAX_HELIO_DIST_SPEED = 0.0012446382;
// HELIO, SWI:   0.0012446378569740 37.4746477943157430 -151710.9188170618726872 / 

  static final double CERES_MIN_HELIO_DIST_SPEED = -0.001241531;
// HELIO, SWI:   -0.0012415292009989 216.0540189475452166 -174287.8441517440369353 / 

  static final double CERES_MAX_HELIO_DIST_ACCEL = 0.0000061;
// HELIO, SWI:   0.0000062671882131 308.0209947368476833 -9142.5057015503298317 -9142.4139977503291448 / 
//               0.0000060920849110 302.5895126988224320 -214292.5264516826136969 -214292.4347478826239239 / 
//               0.0000060672395041 315.0534466719661850 -219292.4927385250048246 -219292.4010347250150517 / 
//               0.0000059913481450 301.0341203922127420 -234476.6245332316320855 -234476.5328294316423126 / 
//               0.0000059913330337 300.9341944843166061 -234476.9913484315911774 -234476.8996446316014044 / 

  static final double CERES_MIN_HELIO_DIST_ACCEL = -0.00000387;
// HELIO, SWI:   -0.0000040561392437 130.6881282588998090 -45292.5104765242504072 -45292.4187727242533583 / 
//               -0.0000039832202638 115.5746221904016693 -151292.5660815085284412 -151292.4743777085386682 / 
//               -0.0000038986028271 117.7361182290603665 -230292.5469548982509878 -230292.4552510982612148 / 
//               -0.0000038776218051 123.4429244133885675 -235301.7753255396091845 -235301.6836217396194115 / 
//               -0.0000036831608444 120.0036776603818538 -242046.8649261873797514 -242046.7732223873899784 / 
//               -0.0000036831246216 119.6478465992768321 -242048.9741135871445294 -242048.8824097871547565 / 



///////////////////////////////////////////////////////////////
// PALLAS: ////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double PALLAS_MAX_LON_SPEED = 0.7687;
// NOTOPO, SWI: 0.7686577156240990 32.6826593275708319 763251.8242795807309449 / 

  static final double PALLAS_MIN_LON_SPEED = -0.3482;
// NOTOPO, SWI: -0.3480103650280001 188.2428820087783663 1553351.3152948189526796 / 

  static final double PALLAS_MAX_LON_ACCEL = 0.01561;
// NOTOPO, SWI: 0.0156058787797183 227.7993455802007361 1127163.0401198901236057 1127163.1318236901424825 / 

  static final double PALLAS_MIN_LON_ACCEL = -0.01499;
// NOTOPO, SWI: -0.0149870229389337 137.0960812067706058 953670.7300515775568783 953670.8217553775757551 / 

  static final double PALLAS_MAX_TOPO_LON_SPEED = 0.7730;
// TOPO, SWI:   0.7727375825263879 32.5338603708758427 763251.1823529805988073 /   11.0   52.2 -110000.0

  static final double PALLAS_MIN_TOPO_LON_SPEED = -0.3570;
// TOPO, SWI:   -0.3568630455363278 187.3672800435400632 1553350.6733682188205421 /   11.0   52.2 -110000.0

  static final double PALLAS_MAX_TOPO_LON_ACCEL = 0.12775;
// TOPO, SWI:   0.1276646150711513 200.2821257335236282 1066540.1339300111867487 1066540.2256338112056255 /   11.0   52.2 -110000.0

  static final double PALLAS_MIN_TOPO_LON_ACCEL = -0.1280;
// TOPO, SWI:   -0.1275523489409923 162.0494099119480325 1036210.7527421680279076 1036210.8444459680467844 /   11.0   52.2 -110000.0

  static final double PALLAS_MAX_HELIO_LON_SPEED = 0.626831;
// HELIO, SWI:   0.6268306846308698 91.1059919192205712 884577.5106691550463438 / 

  static final double PALLAS_MIN_HELIO_LON_SPEED = 0.11145519;
// HELIO, SWI:   0.1114552070211848 279.2994254625075428 974769.6652485206723213 / 

  static final double PALLAS_MAX_HELIO_LON_ACCEL = 0.0026825;
// HELIO, SWI:   0.0026823019091048 47.5470618806543683 945156.5824426249600947 945156.6741464249789715 / 

  static final double PALLAS_MIN_HELIO_LON_ACCEL = -0.0026481;
// HELIO, SWI:   -0.0026480777481555 132.5672826335605521 823992.3864448838867247 823992.4781486839056015 / 


  static final double PALLAS_MAX_LAT_SPEED = 0.54900;
// NOTOPO, SWI: 0.5489987284427638 220.3149710435475583 1341262.7098745615221560 / 

  static final double PALLAS_MIN_LAT_SPEED = -0.5261;
// NOTOPO, SWI: -0.5260505334591784 137.1199630180018687 552576.3744176141917706 / 

  static final double PALLAS_MAX_LAT_ACCEL = 0.013324;
// NOTOPO, SWI: 0.0133170995158400 178.5971431648006558 1058149.1445244839414954 1058149.2362282839603722 / 

  static final double PALLAS_MIN_LAT_ACCEL = -0.008125;
// NOTOPO, SWI: -0.0081208918879644 179.0967761057272867 3650050.1254272144287825 3650050.2171310144476593 / 

  static final double PALLAS_MAX_TOPO_LAT_SPEED = 0.5518;
// TOPO, SWI:   0.5514034636248931 219.7222463949811413 1341262.0679479613900185 /   11.0   52.2 -110000.0

  static final double PALLAS_MIN_TOPO_LAT_SPEED = -0.5288;
// TOPO, SWI:   -0.5283528453731177 137.0348432082705017 552576.2827138141728938 /   11.0   52.2 -110000.0

  static final double PALLAS_MAX_TOPO_LAT_ACCEL = 0.0506;
// TOPO, SWI:   0.0505440495851551 166.1589453476826748 1005919.0618161326274276 1005919.1535199326463044 /   11.0   52.2 -110000.0

  static final double PALLAS_MIN_TOPO_LAT_ACCEL = -0.02938;
// TOPO, SWI:   -0.0293331524448678 126.7981590869007960 945281.7581296507269144 945281.8498334507457912 /   11.0   52.2 -110000.0

  static final double PALLAS_MAX_HELIO_LAT_SPEED = 0.2002976;
// HELIO, SWI:   0.2002970299068924 147.9454562477744446 1642897.0497878515161574 / 

  static final double PALLAS_MIN_HELIO_LAT_SPEED = -0.18542288;
// HELIO, SWI:   -0.1854227988613183 33.8965137331595656 65607.0040497601003153 / 

  static final double PALLAS_MAX_HELIO_LAT_ACCEL = 0.002821069;
// HELIO, SWI:   0.0028210659673938 89.7033526411191957 914902.2149631972424686 914902.3066669972613454 / 

  static final double PALLAS_MIN_HELIO_LAT_ACCEL = -0.00077783;
// HELIO, SWI:   -0.0007778158504460 263.2692245322652980 3683805.9273989629000425 3683806.0191027629189193 / 


  static final double PALLAS_MAX_DIST_SPEED = 0.01780;
// NOTOPO, SWI: 0.0177931137581742 90.2087939680378668 359247.4319596183486283 / 

  static final double PALLAS_MIN_DIST_SPEED = -0.01778;
// NOTOPO, SWI: -0.0177625237907836 90.6665282726177679 1003903.5039955177344382 / 

  static final double PALLAS_MAX_DIST_ACCEL = 0.0003338;
// NOTOPO, SWI: 0.0003335778677097 179.2854886873622888 3582423.4332146937958896 3582423.5249184938147664 / 

  static final double PALLAS_MIN_DIST_ACCEL = -0.000185;
// NOTOPO, SWI: -0.0001830286208040 3.3557067566372609 7275.4090200293921953 7275.5007238293919727 / 

  static final double PALLAS_MAX_TOPO_DIST_SPEED = 0.0180;
// TOPO, SWI:   0.0179770261137918 89.7135420368768024 307019.0560389829333872 /  -84.2   12.8 -1010223.4

  static final double PALLAS_MIN_TOPO_DIST_SPEED = -0.01799;
// TOPO, SWI:   -0.0179277764260068 92.9359376809836562 1138681.0400527711026371 /  -60.5  -28.1 -304337.2

  static final double PALLAS_MAX_TOPO_DIST_ACCEL = 0.001342;
// TOPO, SWI:   0.0013392917835449 177.4530450449256307 3582424.8087716940790415 3582424.9004754940979183 /   11.0   52.2 -110000.0

  static final double PALLAS_MIN_TOPO_DIST_ACCEL = -0.001189;
// TOPO, SWI:   -0.0011860774463715 3.2592270766529623 430242.5881544323638082 430242.6798582323826849 /   11.0   52.2 -110000.0

  static final double PALLAS_MAX_HELIO_DIST_SPEED = 0.004602944;
// HELIO, SWI:   0.0046029420326655 182.0166384844820300 884788.7962243985384703 / 

  static final double PALLAS_MIN_HELIO_DIST_SPEED = -0.004618;
// HELIO, SWI:   -0.0046019064249017 3.0030496706249696 884375.1203825133852661 / 

  static final double PALLAS_MAX_HELIO_DIST_ACCEL = 0.000044661;
// HELIO, SWI:   0.0000446593610039 92.7153166862132423 884579.9866717555560172 884580.0783755555748940 / 

  static final double PALLAS_MIN_HELIO_DIST_ACCEL = -0.0000083;
// HELIO, SWI:   -0.0000083837025426 307.1394614930052285 892457.4347971770912409 892457.5265009771101177 / 
//               -0.0000082714108244 303.8713764766425243 570657.4292597360908985 570657.5209635361097753 / 
//               -0.0000081380835045 229.6195496313166018 566657.4929105127230287 566657.5846143127419055 / 
//               -0.0000081003590577 229.3250482032393336 489157.5110689597204328 489157.6027727597393095 / 
//               -0.0000080489323803 299.2581956488377273 466157.4643938252702355 466157.5560976252891123 / 
//               -0.0000079978719271 237.3447256569042167 420157.4627473563887179 420157.5544511564075947 / 
//               -0.0000079557765155 295.9741661292506478 392007.5140707618556917 392007.6057745618745685 / 
//               -0.0000079212547894 236.3212171589642026 391507.4532492589205503 391507.5449530589394271 / 
//               -0.0000078966543510 283.9911233584992942 370007.4973348332569003 370007.5890386332757771 / 
//               -0.0000078780440678 232.0829097892447237 332507.4292083140462637 332507.5209121140651405 / 
//               -0.0000078235459296 242.9886021314076743 277007.4641026896424592 277007.5558064896613359 / 



///////////////////////////////////////////////////////////////
// JUNO: //////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double JUNO_MAX_LON_SPEED = 0.61473;
// NOTOPO, SWI: 0.6146053027885862 3.0207770033097177 455484.8844438283704221 / 

  static final double JUNO_MIN_LON_SPEED = -0.26366;
// NOTOPO, SWI: -0.2635702314463906 176.4603001677942018 917821.8805481982417405 / 

  static final double JUNO_MAX_LON_ACCEL = 0.00968;
// NOTOPO, SWI: 0.0096521056725605 223.5657354388314388 2775505.5569797935895622 2775505.6486835936084390 / 

  static final double JUNO_MIN_LON_ACCEL = -0.009779;
// NOTOPO, SWI: -0.0097770099496968 134.2071021455841446 2558889.6266564042307436 2558889.7183602042496204 / 

  static final double JUNO_MAX_TOPO_LON_SPEED = 0.6178;
// TOPO, SWI:   0.6177579562282278 3.1242366061235884 455484.6093324283137918 /   11.0   52.2 -110000.0

  static final double JUNO_MIN_TOPO_LON_SPEED = -0.2702;
// TOPO, SWI:   -0.2700462848173433 178.3284778322341708 1994998.4152454445138574 /   10.5    6.2 26183.8

  static final double JUNO_MAX_TOPO_LON_ACCEL = 0.0682;
// TOPO, SWI:   0.0681052448548100 161.4226779983857796 466646.7041669259779155 466646.7958707259967923 /   11.0   52.2 -110000.0

  static final double JUNO_MIN_TOPO_LON_ACCEL = -0.06812;
// TOPO, SWI:   -0.0680295849841816 200.6302232294483474 484149.2914385288022459 484149.3831423288211226 /   11.0   52.2 -110000.0

  static final double JUNO_MAX_HELIO_LON_SPEED = 0.42012063;
// HELIO, SWI:   0.4201205332870313 279.2926544406239486 436374.5461502945981920 / 

  static final double JUNO_MIN_HELIO_LON_SPEED = 0.1363890;
// HELIO, SWI:   0.1363892738361045 128.9178280656598758 838735.4229663186706603 / 

  static final double JUNO_MAX_HELIO_LON_ACCEL = 0.00087833;
// HELIO, SWI:   0.0008783112457574 229.2099143903356548 514309.9376343372277915 514310.0293381372466683 / 

  static final double JUNO_MIN_HELIO_LON_ACCEL = -0.00086738;
// HELIO, SWI:   -0.0008673141411609 328.7655693863320607 297900.9827875904738903 297901.0744913904927671 / 



  static final double JUNO_MAX_LAT_SPEED = 0.2118;
// NOTOPO, SWI: 0.2115232264222861 222.7722963248323254 3377842.6179019818082452 / 

  static final double JUNO_MIN_LAT_SPEED = -0.2069;
// NOTOPO, SWI: -0.2065361586712064 136.6027376454728994 2181175.2465410535223782 / 

  static final double JUNO_MAX_LAT_ACCEL = 0.006619;
// NOTOPO, SWI: 0.0066135614041763 179.1664993515285573 2603458.4987997785210609 2603458.5905035785399377 / 

  static final double JUNO_MIN_LAT_ACCEL = -0.006030;
// NOTOPO, SWI: -0.0060275909794300 181.9945617272934442 484165.3396035321056843 484165.4313073321245611 / 

  static final double JUNO_MAX_TOPO_LAT_SPEED = 0.213;
// TOPO, SWI:   0.2126309502078609 223.4282736786784085 3377843.2598285819403827 /   11.0   52.2 -110000.0

  static final double JUNO_MIN_TOPO_LAT_SPEED = -0.2089;
// TOPO, SWI:   -0.2086688323370115 139.0806473010803472 2163642.0302002443931997 /   11.0   52.2 -110000.0

  static final double JUNO_MAX_TOPO_LAT_ACCEL = 0.02594;
// TOPO, SWI:   0.0258535654741205 198.3318338500047275 1966069.2192849749699235 1966069.3109887749888003 /   11.0   52.2 -110000.0

  static final double JUNO_MIN_TOPO_LAT_ACCEL = -0.02464;
// TOPO, SWI:   -0.0245920430039919 202.0764882154254849 1213967.1061037583276629 1213967.1978075583465397 /   11.0   52.2 -110000.0

  static final double JUNO_MAX_HELIO_LAT_SPEED = 0.09100508;
// HELIO, SWI:   0.0910050500438649 153.8584841083539345 3674260.7539663980714977 / 

  static final double JUNO_MIN_HELIO_LAT_SPEED = -0.09178865;
// HELIO, SWI:   -0.0917886248725829 354.6859336527865594 1597975.7599410046823323 / 

  static final double JUNO_MAX_HELIO_LAT_ACCEL = 0.000645883;
// HELIO, SWI:   0.0006458698334771 78.1937538906792469 2759598.8909399192780256 2759598.9826437192969024 / 

  static final double JUNO_MIN_HELIO_LAT_ACCEL = -0.000592596;
// HELIO, SWI:   -0.0005925862393346 278.6764356039605559 544706.3542999941855669 544706.4460037942044437 / 



  static final double JUNO_MAX_DIST_SPEED = 0.01631;
// NOTOPO, SWI: 0.0162843725535575 269.8813621922874972 231229.7524772776814643 / 

  static final double JUNO_MIN_DIST_SPEED = -0.01649;
// NOTOPO, SWI: -0.0164764537230936 89.9887526575049321 684496.3257119692862034 / 

  static final double JUNO_MAX_DIST_ACCEL = 0.0003149;
// NOTOPO, SWI: 0.0003146412451505 178.6391503901720341 -206763.4610649222740903 -206763.3693611222843174 / 

  static final double JUNO_MIN_DIST_ACCEL = -0.00018013;
// NOTOPO, SWI: -0.0001800895034604 6.5747992238695758 1460177.4116578395478427 1460177.5033616395667195 / 

  static final double JUNO_MAX_TOPO_DIST_SPEED = 0.016457;
// TOPO, SWI:   0.0164458526908689 269.9540185768486822 231229.8441810776712373 /   11.0   52.2 -110000.0

  static final double JUNO_MIN_TOPO_DIST_SPEED = -0.01666;
// TOPO, SWI:   -0.0166376942595072 89.9879486043953989 684496.3257119692862034 /   11.0   52.2 -110000.0

  static final double JUNO_MAX_TOPO_DIST_ACCEL = 0.001315;
// TOPO, SWI:   0.0013139474105691 183.9292561302711704 -249875.5266275143076200 -249875.4349237143178470 /   11.0   52.2 -110000.0

  static final double JUNO_MIN_TOPO_DIST_ACCEL = -0.001185;
// TOPO, SWI:   -0.0011839973541814 3.6642235798218792 1777218.5401971009559929 1777218.6319009009748697 /   11.0   52.2 -110000.0

  static final double JUNO_MAX_HELIO_DIST_SPEED = 0.0029944744;
// HELIO, SWI:   0.0029944742421910 14.0830267598934977 514712.2422050200402737 / 

  static final double JUNO_MIN_HELIO_DIST_SPEED = -0.002995286;
// HELIO, SWI:   -0.0029952820410565 189.5654180917034068 436114.7492848411202431 / 

  static final double JUNO_MAX_HELIO_DIST_ACCEL = 0.00002158148;
// HELIO, SWI:   0.0000215814030565 279.7164455065137076 436375.4631882947869599 436375.5548920948058367 / 

  static final double JUNO_MIN_HELIO_DIST_ACCEL = -0.0000125;
// HELIO, SWI:   -0.0000129385192114 60.6887235114672734 424157.4908003797754645 424157.5825041797943413 / 
//               -0.0000126223274562 51.2769392021547858 268007.4697612370364368 268007.5614650370553136 / 
//               -0.0000118634345139 125.8309285684769492 251007.5110210720158648 251007.6027248720056377 / 
//               -0.0000116633334884 121.5491441573151690 145857.4579501986154355 145857.5496539986052085 / 
//               -0.0000116025216557 41.7419909479435773 111857.4487667413341114 111857.5404705413384363 / 



///////////////////////////////////////////////////////////////
// VESTA: /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double VESTA_MAX_LON_SPEED = 0.5540;
// NOTOPO, SWI: 0.5537145358291486 3.4594766840702391 3691240.5378740932792425 / 

  static final double VESTA_MIN_LON_SPEED = -0.2695;
// NOTOPO, SWI: -0.2681925747406844 178.9036210722504165 -18711.7972316220075299 / 

  static final double VESTA_MAX_LON_ACCEL = 0.00876;
// NOTOPO, SWI: 0.0087089656900730 132.7090084801200476 -235969.1038780651870184 -235969.0121742651972454 / 

  static final double VESTA_MIN_LON_ACCEL = -0.00877;
// NOTOPO, SWI: -0.0087360726786455 136.0235910262570087 -213351.9205751875124406 -213351.8288713875226676 / 

  static final double VESTA_MAX_TOPO_LON_SPEED = 0.5568;
// TOPO, SWI:   0.5564630419112789 4.0953310268746463 3691241.9134310935623944 /   11.0   52.2 -110000.0

  static final double VESTA_MIN_TOPO_LON_SPEED = -0.2770;
// TOPO, SWI:   -0.2768575189637789 180.2074959215284764 -79716.9379980540543329 /   59.1    4.2 -185631.4

  static final double VESTA_MAX_TOPO_LON_ACCEL = 0.05581;
// TOPO, SWI:   0.0557979863799293 153.3262276308298624 2980627.6998240170069039 2980627.7915278170257807 /   11.0   52.2 -110000.0

  static final double VESTA_MIN_TOPO_LON_ACCEL = -0.05541;
// TOPO, SWI:   -0.0553938266966353 204.5059433071201909 2433058.2574605024419725 2433058.3491643024608493 /   11.0   52.2 -110000.0

  static final double VESTA_MAX_HELIO_LON_SPEED = 0.3379980;
// HELIO, SWI:   0.3379979804926766 346.3524783779499785 3687288.7460198798216879 / 

  static final double VESTA_MIN_HELIO_LON_SPEED = 0.22067514;
// HELIO, SWI:   0.2206752048320799 156.3012849424309536 3673335.2792166075669229 / 

  static final double VESTA_MAX_HELIO_LON_ACCEL = 0.00029479;
// HELIO, SWI:   0.0002947717048992 264.7782960565963890 3669802.1152094802819192 3669802.2069132803007960 / 

  static final double VESTA_MIN_HELIO_LON_ACCEL = -0.00033568;
// HELIO, SWI:   -0.0003356340736213 56.5318299251946428 3657020.8980818493291736 3657020.9897856493480504 / 



  static final double VESTA_MAX_LAT_SPEED = 0.09498;
// NOTOPO, SWI: 0.0949061717951902 134.5788001112487393 997159.9733573296107352 / 

  static final double VESTA_MIN_LAT_SPEED = -0.09798;
// NOTOPO, SWI: -0.0978818455277392 221.9589752205408217 3628935.6922880681231618 / 

  static final double VESTA_MAX_LAT_ACCEL = 0.003088;
// NOTOPO, SWI: 0.0030855189558008 180.5228408503361095 3658222.9514924967661500 3658223.0431962967850268 / 

  static final double VESTA_MIN_LAT_ACCEL = -0.003171;
// NOTOPO, SWI: -0.0031687600670683 179.2334880945888358 1723706.6217720857821405 1723706.7134758858010173 / 

  static final double VESTA_MAX_TOPO_LAT_SPEED = 0.09843;
// TOPO, SWI:   0.0983095167802877 136.2849559385317662 1115136.1336578321643174 / -148.8   41.9 -674884.2

  static final double VESTA_MIN_TOPO_LAT_SPEED = -0.1011;
// TOPO, SWI:   -0.1009420346676514 222.0511621045546917 3628935.6005842681042850 /   11.0   52.2 -110000.0

  static final double VESTA_MAX_TOPO_LAT_ACCEL = 0.02671;
// TOPO, SWI:   0.0266237797541972 174.0709493647357249 3639562.6954494556412101 3639562.7871532556600869 /   11.0   52.2 -110000.0

  static final double VESTA_MIN_TOPO_LAT_ACCEL = -0.02858;
// TOPO, SWI:   -0.0285105960855562 188.7065455088097963 854022.9966522655449808 854023.0883560655638576 /   11.0   52.2 -110000.0

  static final double VESTA_MAX_HELIO_LAT_SPEED = 0.0387172;
// HELIO, SWI:   0.0387170156464209 82.7494549858227657 258667.0709152178023942 / 

  static final double VESTA_MIN_HELIO_LAT_SPEED = -0.04107737;
// HELIO, SWI:   -0.0410773444150950 291.7615350016681646 3028336.6017838376574218 / 

  static final double VESTA_MAX_HELIO_LAT_ACCEL = 0.00022967;
// HELIO, SWI:   0.0002296552965727 14.5432114071000864 3691348.1981353154405951 3691348.2898391154594719 / 

  static final double VESTA_MIN_HELIO_LAT_ACCEL = -0.00022729;
// HELIO, SWI:   -0.0002272717071074 190.9356162095806155 1658758.9643733166158199 1658759.0560771166346967 / 



  static final double VESTA_MAX_DIST_SPEED = 0.01421;
// NOTOPO, SWI: 0.0141837555735652 269.6068375203445271 3674450.9476476372219622 / 

  static final double VESTA_MIN_DIST_SPEED = -0.01422;
// NOTOPO, SWI: -0.0140297476891311 89.9781908424814674 3686841.7816985878162086 / 

  static final double VESTA_MAX_DIST_ACCEL = 0.000299;
// NOTOPO, SWI: 0.0002978698252524 180.0039928852636706 2818260.8030701945535839 2818260.8947739945724607 / 

  static final double VESTA_MIN_DIST_ACCEL = -0.0001321;
// NOTOPO, SWI: -0.0001318403868464 8.9533490479961131 -241814.3040894133155234 -241814.2123856133257505 / 

  static final double VESTA_MAX_TOPO_DIST_SPEED = 0.01438;
// TOPO, SWI:   0.0143333054520008 269.6069738247148280 3674450.9476476372219622 /   11.0   52.2 -110000.0

  static final double VESTA_MIN_TOPO_DIST_SPEED = -0.01420;
// TOPO, SWI:   -0.0141862722224344 89.3481771752887255 3686840.9563643876463175 /   11.0   52.2 -110000.0

  static final double VESTA_MAX_TOPO_DIST_ACCEL = 0.001300;
// TOPO, SWI:   0.0012958625593180 180.2574992837387526 1447421.6881866138428450 1447421.7798904138617218 /   11.0   52.2 -110000.0

  static final double VESTA_MIN_TOPO_DIST_ACCEL = -0.001138;
// TOPO, SWI:   -0.0011308958276606 3.9923375021191925 1659420.6072904528118670 1659420.6989942528307438 /   11.0   52.2 -110000.0

  static final double VESTA_MAX_HELIO_DIST_SPEED = 0.001193567;
// HELIO, SWI:   0.0011935629514952 71.1813997280709856 3687558.8137109354138374 / 

  static final double VESTA_MIN_HELIO_DIST_SPEED = -0.001193051;
// HELIO, SWI:   -0.0011930505631128 251.3940719982379903 3686986.2151836175471544 / 

  static final double VESTA_MAX_HELIO_DIST_ACCEL = 0.0000070;
// HELIO, SWI:   0.0000070831126369 339.2996995770586750 3638223.4531539799645543 3638223.5448577799834311 / 
//               0.0000070274330974 339.0703934649927191 3581223.4889914467930794 3581223.5806952468119562 / 
//               0.0000069026704888 333.2435038124803555 3574579.8237914792262018 3574579.9154952792450786 / 
//               0.0000069026669303 333.0894541149062889 3574579.3652724791318178 3574579.4569762791506946 / 
//               0.0000069025930570 333.0586445287072479 3574579.2735686791129410 3574579.3652724791318178 / 
//               0.0000069025901919 332.9970256988889332 3574579.0901610790751874 3574579.1818648790940642 / 
//               0.0000069025421235 332.9354073213774541 3574578.9067534790374339 3574578.9984572790563107 / 

  static final double VESTA_MIN_HELIO_DIST_ACCEL = -0.0000048;
// HELIO, SWI:   -0.0000048393488576 149.0475104580058030 3575223.4927638117223978 3575223.5844676117412746 / 
//               -0.0000047011995439 157.7193670289059355 3526223.4930035253055394 3526223.5847073253244162 / 
//               -0.0000046664596348 136.6765493333416259 3510223.4724952317774296 3510223.5641990317963064 / 
//               -0.0000045970719083 129.9309411371636145 3219932.4341252767480910 3219932.5258290767669678 / 
//               -0.0000045477285294 116.9683110659760246 3011787.4589210310950875 3011787.5506248311139643 / 



///////////////////////////////////////////////////////////////
// INTERPOLATED LUNAR APOGEE: /////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double INTPAPOG_MAX_LON_SPEED = 0.240442;
// NOTOPO, SWI: 0.2404397685248938 89.8053235290185228 -225439.3984518394863699 / 

  static final double INTPAPOG_MIN_LON_SPEED = -0.155670;
// NOTOPO, SWI: -0.1556655965864008 181.3399982738732206 -248811.1206210330128670 / 

  static final double INTPAPOG_MAX_LON_ACCEL = 0.0103163;
// NOTOPO, SWI: 0.0103153290223904 161.0071618862759806 -213377.5059353846590966 -213377.4142315846693236 / 

  static final double INTPAPOG_MIN_LON_ACCEL = -0.0103726;
// NOTOPO, SWI: -0.0103706122872579 200.8631529108065763 -203530.1684848828590475 -203530.0767810828692745 / 

  static final double INTPAPOG_MAX_TOPO_LON_SPEED = 0.240440;
// TOPO, SWI:   0.2404397685248938 89.8070148752872228 -225439.3984518394863699 /   11.0   52.2 -110000.0

  static final double INTPAPOG_MIN_TOPO_LON_SPEED = -0.1556659;
// TOPO, SWI:   -0.1556655965864008 181.3381794957473687 -248811.1206210330128670 /   11.0   52.2 -110000.0

  static final double INTPAPOG_MAX_TOPO_LON_ACCEL = 0.0103158;
// TOPO, SWI:   0.0103153290223904 161.0054436817775922 -213377.5059353846590966 -213377.4142315846693236 /   11.0   52.2 -110000.0

  static final double INTPAPOG_MIN_TOPO_LON_ACCEL = -0.0103707;
// TOPO, SWI:   -0.0103706122872579 200.8622494083237200 -203530.1684848828590475 -203530.0767810828692745 /   11.0   52.2 -110000.0

// No heliocentric positions for the interpolated lunar apogee...
  static final double INTPAPOG_MAX_HELIO_LON_SPEED = 1./0.;
  static final double INTPAPOG_MIN_HELIO_LON_SPEED = 1./0.;
  static final double INTPAPOG_MAX_HELIO_LON_ACCEL = 1./0.;
  static final double INTPAPOG_MIN_HELIO_LON_ACCEL = 1./0.;


  static final double INTPAPOG_MAX_LAT_SPEED = 0.031604;
// NOTOPO, SWI: 0.0315994798603946 87.9936727871609463 113881.2599290367797948 / 

  static final double INTPAPOG_MIN_LAT_SPEED = -0.031613;
// NOTOPO, SWI: -0.0316127256048458 90.0716920369863772 86498.3218401453632396 / 

  static final double INTPAPOG_MAX_LAT_ACCEL = 0.00109429;
// NOTOPO, SWI: 0.0010942503832445 159.2212151742582193 129241.3713183611835120 129241.4630221611878369 / 

  static final double INTPAPOG_MIN_LAT_ACCEL = -0.0010990;
// NOTOPO, SWI: -0.0010988461699215 159.2054935712743031 193893.8341646414774004 193893.9258684414671734 / 

  static final double INTPAPOG_MAX_TOPO_LAT_SPEED = 0.03159950;
// TOPO, SWI:   0.0315994798603946 87.9958094942441136 113881.2599290367797948 /   11.0   52.2 -110000.0

  static final double INTPAPOG_MIN_TOPO_LAT_SPEED = -0.031610;
// TOPO, SWI:   -0.0316127256048458 90.0695815720781354 86498.3218401453632396 /   11.0   52.2 -110000.0

  static final double INTPAPOG_MAX_TOPO_LAT_ACCEL = 0.00109428;
// TOPO, SWI:   0.0010942503832445 159.2203358042442574 129241.3713183611835120 129241.4630221611878369 /   11.0   52.2 -110000.0

  static final double INTPAPOG_MIN_TOPO_LAT_ACCEL = -0.00109888;
// TOPO, SWI:   -0.0010988461699215 159.2044287384800043 193893.8341646414774004 193893.9258684414671734 /   11.0   52.2 -110000.0

// No heliocentric positions for the interpolated lunar apogee...
  static final double INTPAPOG_MAX_HELIO_LAT_SPEED = 1./0.;
  static final double INTPAPOG_MIN_HELIO_LAT_SPEED = 1./0.;
  static final double INTPAPOG_MAX_HELIO_LAT_ACCEL = 1./0.;
  static final double INTPAPOG_MIN_HELIO_LAT_ACCEL = 1./0.;


  static final double INTPAPOG_MAX_DIST_SPEED = 0.00000026577;
// NOTOPO, SWI: 0.0000002657689017 53.6816352061185000 117431.3891386042087106 / 

  static final double INTPAPOG_MIN_DIST_SPEED = -0.00000026575;
// NOTOPO, SWI: -0.0000002657174555 53.4782487399821207 73067.1998839119332843 / 

  static final double INTPAPOG_MAX_DIST_ACCEL = 0.0000000080677;
// NOTOPO, SWI: 0.0000000080672739 90.8251587442524198 -225234.3487550623540301 -225234.2570512623642571 / 

  static final double INTPAPOG_MIN_DIST_ACCEL = -0.000000006945;
// NOTOPO, SWI: -0.0000000069406502 20.5051785050152091 -228442.5144939045712817 -228442.4227901045815088 / 

  static final double INTPAPOG_MAX_TOPO_DIST_SPEED = 0.00000026584;
// TOPO, SWI:   0.0000002657689017 53.6811086900653294 117431.3891386042087106 /   11.0   52.2 -110000.0

  static final double INTPAPOG_MIN_TOPO_DIST_SPEED = -0.00000026578;
// TOPO, SWI:   -0.0000002657174555 53.4794988864201173 73067.1998839119332843 /   11.0   52.2 -110000.0

  static final double INTPAPOG_MAX_TOPO_DIST_ACCEL = 0.0000000080677;
// TOPO, SWI:   0.0000000080672739 90.8246001429053251 -225234.3487550623540301 -225234.2570512623642571 /   11.0   52.2 -110000.0

  static final double INTPAPOG_MIN_TOPO_DIST_ACCEL = -0.0000000069411;
// TOPO, SWI:   -0.0000000069406502 20.5045668379371619 -228442.5144939045712817 -228442.4227901045815088 /   11.0   52.2 -110000.0

// No heliocentric positions for the interpolated lunar apogee...
  static final double INTPAPOG_MAX_HELIO_DIST_SPEED = 1./0.;
  static final double INTPAPOG_MIN_HELIO_DIST_SPEED = 1./0.;
  static final double INTPAPOG_MAX_HELIO_DIST_ACCEL = 1./0.;
  static final double INTPAPOG_MIN_HELIO_DIST_ACCEL = 1./0.;



///////////////////////////////////////////////////////////////
// INTERPOLATED LUNAR PERIGEE: ////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double INTPPERG_MAX_LON_SPEED = 0.583372;
// NOTOPO, SWI: 0.5833691782377636 180.7541537466819648 -195482.2429977803840302 / 

  static final double INTPPERG_MIN_LON_SPEED = -2.33189;
// NOTOPO, SWI: -2.3318574545550006 90.4900510056987173 -225440.0403784394147806 / 

  static final double INTPPERG_MAX_LON_ACCEL = 0.185425;
// NOTOPO, SWI: 0.1854155305874408 75.5854712193087153 -225435.3634846399363596 -225435.2717808399465866 / 

  static final double INTPPERG_MIN_LON_ACCEL = -0.185357;
// NOTOPO, SWI: -0.1853488568522996 105.1872612317180256 -225444.8089760388829745 -225444.7172722388932016 / 

  static final double INTPPERG_MAX_TOPO_LON_SPEED = 0.583371;
// TOPO, SWI:   0.5833691782377636 180.7521396528094044 -195482.2429977803840302 /   11.0   52.2 -110000.0

  static final double INTPPERG_MIN_TOPO_LON_SPEED = -2.33188;
// TOPO, SWI:   -2.3318574545550006 90.4891309374753803 -225440.0403784394147806 /   11.0   52.2 -110000.0

  static final double INTPPERG_MAX_TOPO_LON_ACCEL = 0.185418;
// TOPO, SWI:   0.1854155305874408 75.5833331251805873 -225435.3634846399363596 -225435.2717808399465866 /   11.0   52.2 -110000.0

  static final double INTPPERG_MIN_TOPO_LON_ACCEL = -0.185353;
// TOPO, SWI:   -0.1853488568522996 105.1878730265365505 -225444.8089760388829745 -225444.7172722388932016 /   11.0   52.2 -110000.0

// No heliocentric positions for the interpolated lunar apogee...
  static final double INTPPERG_MAX_HELIO_LON_SPEED = 1./0.;
  static final double INTPPERG_MIN_HELIO_LON_SPEED = 1./0.;
  static final double INTPPERG_MAX_HELIO_LON_ACCEL = 1./0.;
  static final double INTPPERG_MIN_HELIO_LON_ACCEL = 1./0.;


  static final double INTPPERG_MAX_LAT_SPEED = 0.193078;
// NOTOPO, SWI: 0.1930717143394080 90.0115560113064532 113883.4608202368835919 / 

  static final double INTPPERG_MIN_LAT_SPEED = -0.193022;
// NOTOPO, SWI: -0.1930161983476893 89.4196971936011806 86497.8633211453416152 / 

  static final double INTPPERG_MAX_LAT_ACCEL = 0.016642;
// NOTOPO, SWI: 0.0166359116524948 76.2925199859609791 49235.2163400813224143 49235.3080438813194633 / 

  static final double INTPPERG_MIN_LAT_ACCEL = -0.016678;
// NOTOPO, SWI: -0.0166704364156631 102.9727818515069657 21849.5271389294648543 21849.6188427294655412 / 

  static final double INTPPERG_MAX_TOPO_LAT_SPEED = 0.193073;
// TOPO, SWI:   0.1930717143394080 90.0105331109555209 113883.4608202368835919 /   11.0   52.2 -110000.0

  static final double INTPPERG_MIN_TOPO_LAT_SPEED = -0.193018;
// TOPO, SWI:   -0.1930161983476893 89.4192992318445903 86497.8633211453416152 /   11.0   52.2 -110000.0

  static final double INTPPERG_MAX_TOPO_LAT_ACCEL = 0.016639;
// TOPO, SWI:   0.0166359116524948 76.2903781852012628 49235.2163400813224143 49235.3080438813194633 /   11.0   52.2 -110000.0

  static final double INTPPERG_MIN_TOPO_LAT_ACCEL = -0.016674;
// TOPO, SWI:   -0.0166704364156631 102.9735765715234663 21849.5271389294648543 21849.6188427294655412 /   11.0   52.2 -110000.0

// No heliocentric positions for the interpolated lunar apogee...
  static final double INTPPERG_MAX_HELIO_LAT_SPEED = 1./0.;
  static final double INTPPERG_MIN_HELIO_LAT_SPEED = 1./0.;
  static final double INTPPERG_MAX_HELIO_LAT_ACCEL = 1./0.;
  static final double INTPPERG_MIN_HELIO_LAT_ACCEL = 1./0.;


  static final double INTPPERG_MAX_DIST_SPEED = 0.00000143617;
// NOTOPO, SWI: 0.0000014361421628 141.2208548421972978 -170288.1829151900892612 / 

  static final double INTPPERG_MIN_DIST_SPEED = -0.00000143606;
// NOTOPO, SWI: -0.0000014360402824 139.9198637739893059 -162611.6578180461947341 / 

  static final double INTPPERG_MAX_DIST_ACCEL = 0.0000000294169;
// NOTOPO, SWI: 0.0000000294167244 180.4954568523366447 -134123.4138322232756764 -134123.3221284232859034 / 

  static final double INTPPERG_MIN_DIST_ACCEL = -0.00000015879;
// NOTOPO, SWI: -0.0000001587702460 89.4060875782472237 -194761.3594260607787874 -194761.2677222607890144 / 

  static final double INTPPERG_MAX_TOPO_DIST_SPEED = 0.00000143615;
// TOPO, SWI:   0.0000014361421628 141.2194617019951295 -170288.1829151900892612 /   11.0   52.2 -110000.0

  static final double INTPPERG_MIN_TOPO_DIST_SPEED = -0.00000143607;
// TOPO, SWI:   -0.0000014360402824 139.9202523240743119 -162611.6578180461947341 /   11.0   52.2 -110000.0

  static final double INTPPERG_MAX_TOPO_DIST_ACCEL = 0.000000029418;
// TOPO, SWI:   0.0000000294167244 180.4935094803453808 -134123.4138322232756764 -134123.3221284232859034 /   11.0   52.2 -110000.0

  static final double INTPPERG_MIN_TOPO_DIST_ACCEL = -0.00000015880;
// TOPO, SWI:   -0.0000001587702460 89.4081386018435751 -194761.3594260607787874 -194761.2677222607890144 /   11.0   52.2 -110000.0

// No heliocentric positions for the interpolated lunar apogee...
  static final double INTPPERG_MAX_HELIO_DIST_SPEED = 1./0.;
  static final double INTPPERG_MIN_HELIO_DIST_SPEED = 1./0.;
  static final double INTPPERG_MAX_HELIO_DIST_ACCEL = 1./0.;
  static final double INTPPERG_MIN_HELIO_DIST_ACCEL = 1./0.;



///////////////////////////////////////////////////////////////
// SURYA S max notopo:  1.0243864993
// SURYA S min notopo:  0.9486638198
// SURYA S max topo3:   1.0388159322
// SURYA S min topo3:   0.9347718616
// CHANDRA max notopo:  15.4042491124
// CHANDRA min notopo: 11.7571075192
// CHANDRA max topo3:   21.5666962324
// CHANDRA min topo3:  6.1294391379
// CHANDRA max notopo:  0.5186888
// CHANDRA min notopo:  -0.5188292
// CHANDRA max topo3:   38.1641267
// CHANDRA min topo3:   -38.1716335
// BUDHA max notopo:  2.2121102506 //??? 2.2537837349
// BUDHA min notopo:  -1.3908278667
// BUDHA max topo3:   2.2229697247
// BUDHA min topo3:   -1.4125035236
// BUDHA max notopo:  0.1968066, everything beyond seems to be unexact
//                         calculation due to too much nearness to the sun!
// BUDHA min notopo: -0.1986822, everything beyond seems to be unexact
//                         calculation due to too much nearness to the sun!
// BUDHA max topo3: 8.4292471 // SY-Problem? Realistic: 0.3244554
// BUDHA min topo3: -34.4871693 // SY-Problem? Realistic: -0.3282049
// SHUKRA max notopo: 1.2644483889
// SHUKRA max topo3:  1.2733039990
// SHUKRA min notopo: -0.6437175784
// SHUKRA min topo3:  -0.6963885604 // Sy-Problem???
// SHUKRA max notopo:  0.0423762, everything beyond seems to be unexact
//                         calculation due to too much nearness to the sun!
// SHUKRA min notopo: -0.0430388, everything beyond seems to be unexact
//                         calculation due to too much nearness to the sun!
// SHUKRA max topo3: 1.1127520 // SY-Problem? Realistic: 0.3878079
// SHUKRA min topo3: -2.9288472 // SY-Problem? Realistic: -0.3884931
// MANGALA max notopo: 0.7924011226
// MANGALA max topo3:  0.7985878049
// MANGALA min notopo: -0.4035104555
// MANGALA min topo3:  -0.4261278855
// MANGALA max notopo:  0.0144224, everything beyond seems to be unexact
//                     calculation due to too much nearness to the sun!
// MANGALA min notopo: -0.0152010, everything beyond seems to be unexact
//                     calculation due to too much nearness to the sun!
// MANGALA max topo3:   5.3859140 // SY-Problem? Realistic: 0.2652052
// MANGALA min topo3:   -0.7430761 // SY-Problem? Realistic: -0.2653766
// SHANI max notopo: 0.1338471290 // Sy-Problem 0.1342611535?
// SHANI max topo3:  0.1353554794
// SHANI min notopo: -0.0842836027
// SHANI min topo3:  -0.0860881714
// SHANI max notopo:  0.0020007, everything beyond seems to be unexact
//                         calculation due to too much nearness to the sun!
// SHANI min notopo: -0.0019460, everything beyond seems to be unexact
//                         calculation due to too much nearness to the sun!
// SHANI max topo3: 47.8021777 // SY-problem? Realistic: 0.0135465
// SHANI min topo3: -9.9611508 // SY-problem? Realistic: -0.0134697
// GURU S max notopo: 0.2440423861
// GURU S min notopo: -0.1368372415
// GURU S max topo3:  0.2465672865
// GURU S min topo3:  -0.1403921701
// GURU A max notopo:  0.0036155, everything beyond seems to be unexact
//                    calculation due to too much nearness to the sun!
// GURU A min notopo: -0.0034178, everything beyond seems to be unexact
//                    calculation due to too much nearness to the sun!
// GURU A max topo3: 3.6034504 // SY-problem? Realistic: 0.0266245
// GURU A min topo3: -16.4451885 // SY-problem? Realistic: -0.0267212
// URANUS A max notopo:  0.0009501, everything beyond seems to be unexact
//                      calculation due to too much nearness to the sun!
// URANUS A min notopo: -0.0009897, everything beyond seems to be unexact
//                      calculation due to too much nearness to the sun!
// URANUS A max topo3: 8.4594472 // SY-problem? Realistic: 0.0063635
// URANUS A min topo3: -44.1816134 // SY-problem? Realistic: -0.0064026
// URANUS S max notopo: 0.0637152951 // Sy-Problem beyond?
// URANUS S max topo3:  0.0681905640
// URANUS S min notopo: -0.0439752018
// URANUS S min topo3:  -0.0447987374
// NEPTUNE A max notopo:  0.0006291, everything beyond seems to be unexact
//                       calculation due to too much nearness to the sun!
// NEPTUNE A min notopo: -0.0006255, everything beyond seems to be unexact
//                       calculation due to too much nearness to the sun!
// NEPTUNE A max topo3: 5.9498810 // SY-problem? Realistic: 0.0039052
// NEPTUNE A min topo3: -12.7924566 // SY-problem? Realistic: -0.0038898
// NEPTUNE S max notopo: 0.0381288654 // Sy-Problem? 0.0432424224
// NEPTUNE S max topo3:  0.0437376690
// NEPTUNE S min notopo: -0.0285824820
// NEPTUNE S min topo3:  -0.0290549670
// PLUTO A max notopo:  0.0006226, everything beyond seems to be unexact
//                     calculation due to too much nearness to the sun!
// PLUTO A min notopo: -0.0006607, everything beyond seems to be unexact
//                     calculation due to too much nearness to the sun!
// PLUTO A max topo3: 1.2429646 // SY-problem? Realistic: 0.0040215
// PLUTO A min topo3: -1.7390824 // SY-problem? Realistic: -0.0040603
// PLUTO S max notopo: 0.0409935333
// PLUTO S max topo3:  0.0414652881
// PLUTO S min notopo: -0.0283697947
// PLUTO S min topo3:  -0.0289179185
// MNODE A max notopo:  0.0000508
// MNODE A min notopo: -0.0000508
// MNODE A max topo3:  0.0000508
// MNODE A min topo3: -0.0000508
// MNODE S max notopo: -0.0528817186
// MNODE S max topo3:  -0.0528817186
// MNODE S min notopo: -0.0530035225
// MNODE S min topo3:  -0.0530035225
// TNODE A max notopo: 573.1032358  // Errors in calculations???
// TNODE A min notopo: -444.7164997 // Errors in calculations???
// TNODE A max topo3: 695.8627388 // Errors in calculations???
// TNODE A min topo3: -444.6272115 // Errors in calculations???
// TNODE S max notopo: 0.4448616947
// TNODE S max topo3:  0.4448616947
// TNODE S min notopo: -0.5805968771
// TNODE S min topo3:  -0.5805968771
///////////////////////////////////////////////////////////////



  // Speeds and accelerations in longitudinal direction:
  // Maximum geocentric speeds in longitudinal direction:
  static final double[] maxLonSpeed = new double[]
      {SURYA_MAX_LON_SPEED,   CHANDRA_MAX_LON_SPEED, BUDHA_MAX_LON_SPEED,
       SHUKRA_MAX_LON_SPEED,  MANGALA_MAX_LON_SPEED, GURU_MAX_LON_SPEED,
       SHANI_MAX_LON_SPEED,   URANUS_MAX_LON_SPEED,  NEPTUNE_MAX_LON_SPEED,
       PLUTO_MAX_LON_SPEED,   MNODE_MAX_LON_SPEED,   TNODE_MAX_LON_SPEED,
       MAPOGEE_MAX_LON_SPEED, OAPOGEE_MAX_LON_SPEED, 1./0,
       CHIRON_MAX_LON_SPEED,  PHOLUS_MAX_LON_SPEED,  CERES_MAX_LON_SPEED,
       PALLAS_MAX_LON_SPEED,  JUNO_MAX_LON_SPEED,    VESTA_MAX_LON_SPEED,
       INTPAPOG_MAX_LON_SPEED,INTPPERG_MAX_LON_SPEED};
  // Minimum geocentric speeds in longitudinal direction:
  static final double[] minLonSpeed = new double[]
      {SURYA_MIN_LON_SPEED,   CHANDRA_MIN_LON_SPEED, BUDHA_MIN_LON_SPEED,
       SHUKRA_MIN_LON_SPEED,  MANGALA_MIN_LON_SPEED, GURU_MIN_LON_SPEED,
       SHANI_MIN_LON_SPEED,   URANUS_MIN_LON_SPEED,  NEPTUNE_MIN_LON_SPEED,
       PLUTO_MIN_LON_SPEED,   MNODE_MIN_LON_SPEED,   TNODE_MIN_LON_SPEED,
       MAPOGEE_MIN_LON_SPEED, OAPOGEE_MIN_LON_SPEED, 1./0,
       CHIRON_MIN_LON_SPEED,  PHOLUS_MIN_LON_SPEED,  CERES_MIN_LON_SPEED,
       PALLAS_MIN_LON_SPEED,  JUNO_MIN_LON_SPEED,    VESTA_MIN_LON_SPEED,
       INTPAPOG_MIN_LON_SPEED,INTPPERG_MIN_LON_SPEED};

  // Maximum topocentric speeds in longitudinal direction, up to 50000m
  // altitude:
  static final double[] maxTopoLonSpeed = new double[]
      {SURYA_MAX_TOPO_LON_SPEED,   CHANDRA_MAX_TOPO_LON_SPEED,
       BUDHA_MAX_TOPO_LON_SPEED,   SHUKRA_MAX_TOPO_LON_SPEED,
       MANGALA_MAX_TOPO_LON_SPEED, GURU_MAX_TOPO_LON_SPEED,
       SHANI_MAX_TOPO_LON_SPEED,   URANUS_MAX_TOPO_LON_SPEED,
       NEPTUNE_MAX_TOPO_LON_SPEED, PLUTO_MAX_TOPO_LON_SPEED,
       MNODE_MAX_TOPO_LON_SPEED,   TNODE_MAX_TOPO_LON_SPEED,
       MAPOGEE_MAX_TOPO_LON_SPEED, OAPOGEE_MAX_TOPO_LON_SPEED,
       1./0,                       CHIRON_MAX_TOPO_LON_SPEED,
       PHOLUS_MAX_TOPO_LON_SPEED,  CERES_MAX_TOPO_LON_SPEED,
       PALLAS_MAX_TOPO_LON_SPEED,  JUNO_MAX_TOPO_LON_SPEED,
       VESTA_MAX_TOPO_LON_SPEED,   INTPAPOG_MAX_TOPO_LON_SPEED,
       INTPPERG_MAX_TOPO_LON_SPEED};
  // Minimum topocentric speeds in longitudinal direction, up to 50000m
  // altitude:
  static final double[] minTopoLonSpeed = new double[]
      {SURYA_MIN_TOPO_LON_SPEED,   CHANDRA_MIN_TOPO_LON_SPEED,
       BUDHA_MIN_TOPO_LON_SPEED,   SHUKRA_MIN_TOPO_LON_SPEED,
       MANGALA_MIN_TOPO_LON_SPEED, GURU_MIN_TOPO_LON_SPEED,
       SHANI_MIN_TOPO_LON_SPEED,   URANUS_MIN_TOPO_LON_SPEED,
       NEPTUNE_MIN_TOPO_LON_SPEED, PLUTO_MIN_TOPO_LON_SPEED,
       MNODE_MIN_TOPO_LON_SPEED,   TNODE_MIN_TOPO_LON_SPEED,
       MAPOGEE_MIN_TOPO_LON_SPEED, OAPOGEE_MIN_TOPO_LON_SPEED,
       1./0,                       CHIRON_MIN_TOPO_LON_SPEED,
       PHOLUS_MIN_TOPO_LON_SPEED,  CERES_MIN_TOPO_LON_SPEED,
       PALLAS_MIN_TOPO_LON_SPEED,  JUNO_MIN_TOPO_LON_SPEED,
       VESTA_MIN_TOPO_LON_SPEED,   INTPAPOG_MIN_TOPO_LON_SPEED,
       INTPPERG_MIN_TOPO_LON_SPEED};

  // Maximum heliocentric speeds in longitudinal direction:
  static final double[] maxHelioLonSpeed = new double[]
      {SURYA_MAX_HELIO_LON_SPEED,   CHANDRA_MAX_HELIO_LON_SPEED,
       BUDHA_MAX_HELIO_LON_SPEED,   SHUKRA_MAX_HELIO_LON_SPEED,
       MANGALA_MAX_HELIO_LON_SPEED, GURU_MAX_HELIO_LON_SPEED,
       SHANI_MAX_HELIO_LON_SPEED,   URANUS_MAX_HELIO_LON_SPEED,
       NEPTUNE_MAX_HELIO_LON_SPEED, PLUTO_MAX_HELIO_LON_SPEED,
       MNODE_MAX_HELIO_LON_SPEED,   TNODE_MAX_HELIO_LON_SPEED,
       MAPOGEE_MAX_HELIO_LON_SPEED, OAPOGEE_MAX_HELIO_LON_SPEED,
       1./0,                        CHIRON_MAX_HELIO_LON_SPEED,
       PHOLUS_MAX_HELIO_LON_SPEED,  CERES_MAX_HELIO_LON_SPEED,
       PALLAS_MAX_HELIO_LON_SPEED,  JUNO_MAX_HELIO_LON_SPEED,
       VESTA_MAX_HELIO_LON_SPEED,   INTPAPOG_MAX_HELIO_LON_SPEED,
       INTPPERG_MAX_HELIO_LON_SPEED};
  // Minimum heliocentric speeds in longitudinal direction:
  static final double[] minHelioLonSpeed = new double[]
      {SURYA_MIN_HELIO_LON_SPEED,   CHANDRA_MIN_HELIO_LON_SPEED,
       BUDHA_MIN_HELIO_LON_SPEED,   SHUKRA_MIN_HELIO_LON_SPEED,
       MANGALA_MIN_HELIO_LON_SPEED, GURU_MIN_HELIO_LON_SPEED,
       SHANI_MIN_HELIO_LON_SPEED,   URANUS_MIN_HELIO_LON_SPEED,
       NEPTUNE_MIN_HELIO_LON_SPEED, PLUTO_MIN_HELIO_LON_SPEED,
       MNODE_MIN_HELIO_LON_SPEED,   TNODE_MIN_HELIO_LON_SPEED,
       MAPOGEE_MIN_HELIO_LON_SPEED, OAPOGEE_MIN_HELIO_LON_SPEED,
       1./0,                        CHIRON_MIN_HELIO_LON_SPEED,
       PHOLUS_MIN_HELIO_LON_SPEED,  CERES_MIN_HELIO_LON_SPEED,
       PALLAS_MIN_HELIO_LON_SPEED,  JUNO_MIN_HELIO_LON_SPEED,
       VESTA_MIN_HELIO_LON_SPEED,   INTPAPOG_MIN_HELIO_LON_SPEED,
       INTPPERG_MIN_HELIO_LON_SPEED};

  // Maximum geocentric accelerations in longitudinal direction:
  static final double[] maxLonAccel = new double[]
      {SURYA_MAX_LON_ACCEL,   CHANDRA_MAX_LON_ACCEL, BUDHA_MAX_LON_ACCEL,
       SHUKRA_MAX_LON_ACCEL,  MANGALA_MAX_LON_ACCEL, GURU_MAX_LON_ACCEL,
       SHANI_MAX_LON_ACCEL,   URANUS_MAX_LON_ACCEL,  NEPTUNE_MAX_LON_ACCEL,
       PLUTO_MAX_LON_ACCEL,   MNODE_MAX_LON_ACCEL,   TNODE_MAX_LON_ACCEL,
       MAPOGEE_MAX_LON_ACCEL, OAPOGEE_MAX_LON_ACCEL, 1./0,
       CHIRON_MAX_LON_ACCEL,  PHOLUS_MAX_LON_ACCEL,  CERES_MAX_LON_ACCEL,
       PALLAS_MAX_LON_ACCEL,  JUNO_MAX_LON_ACCEL,    VESTA_MAX_LON_ACCEL,
       INTPAPOG_MAX_LON_ACCEL,INTPPERG_MAX_LON_ACCEL};
  // Minimum geocentric accelerations in longitudinal direction:
  static final double[] minLonAccel = new double[]
      {SURYA_MIN_LON_ACCEL,   CHANDRA_MIN_LON_ACCEL, BUDHA_MIN_LON_ACCEL,
       SHUKRA_MIN_LON_ACCEL,  MANGALA_MIN_LON_ACCEL, GURU_MIN_LON_ACCEL,
       SHANI_MIN_LON_ACCEL,   URANUS_MIN_LON_ACCEL,  NEPTUNE_MIN_LON_ACCEL,
       PLUTO_MIN_LON_ACCEL,   MNODE_MIN_LON_ACCEL,   TNODE_MIN_LON_ACCEL,
       MAPOGEE_MIN_LON_ACCEL, OAPOGEE_MIN_LON_ACCEL, 1./0,
       CHIRON_MIN_LON_ACCEL,  PHOLUS_MIN_LON_ACCEL,  CERES_MIN_LON_ACCEL,
       PALLAS_MIN_LON_ACCEL,  JUNO_MIN_LON_ACCEL,    VESTA_MIN_LON_ACCEL,
       INTPAPOG_MIN_LON_ACCEL,INTPPERG_MIN_LON_ACCEL};

  // Maximum topocentric accelerations in longitudinal direction, up to
  // 50000m altitude:
  static final double[] maxTopoLonAccel = new double[]
      {SURYA_MAX_TOPO_LON_ACCEL,   CHANDRA_MAX_TOPO_LON_ACCEL,
       BUDHA_MAX_TOPO_LON_ACCEL,   SHUKRA_MAX_TOPO_LON_ACCEL,
       MANGALA_MAX_TOPO_LON_ACCEL, GURU_MAX_TOPO_LON_ACCEL,
       SHANI_MAX_TOPO_LON_ACCEL,   URANUS_MAX_TOPO_LON_ACCEL,
       NEPTUNE_MAX_TOPO_LON_ACCEL, PLUTO_MAX_TOPO_LON_ACCEL,
       MNODE_MAX_TOPO_LON_ACCEL,   TNODE_MAX_TOPO_LON_ACCEL,
       MAPOGEE_MAX_TOPO_LON_ACCEL, OAPOGEE_MAX_TOPO_LON_ACCEL,
       1./0,                       CHIRON_MAX_TOPO_LON_ACCEL,
       PHOLUS_MAX_TOPO_LON_ACCEL,  CERES_MAX_TOPO_LON_ACCEL,
       PALLAS_MAX_TOPO_LON_ACCEL,  JUNO_MAX_TOPO_LON_ACCEL,
       VESTA_MAX_TOPO_LON_ACCEL,   INTPAPOG_MAX_TOPO_LON_ACCEL,
       INTPPERG_MAX_TOPO_LON_ACCEL};
  // Minimum topocentric accelerations in longitudinal direction, up to
  // 50000m altitude:
  static final double[] minTopoLonAccel = new double[]
      {SURYA_MIN_TOPO_LON_ACCEL,   CHANDRA_MIN_TOPO_LON_ACCEL,
       BUDHA_MIN_TOPO_LON_ACCEL,   SHUKRA_MIN_TOPO_LON_ACCEL,
       MANGALA_MIN_TOPO_LON_ACCEL, GURU_MIN_TOPO_LON_ACCEL,
       SHANI_MIN_TOPO_LON_ACCEL,   URANUS_MIN_TOPO_LON_ACCEL,
       NEPTUNE_MIN_TOPO_LON_ACCEL, PLUTO_MIN_TOPO_LON_ACCEL,
       MNODE_MIN_TOPO_LON_ACCEL,   TNODE_MIN_TOPO_LON_ACCEL,
       MAPOGEE_MIN_TOPO_LON_ACCEL, OAPOGEE_MIN_TOPO_LON_ACCEL,
       1./0,                       CHIRON_MIN_TOPO_LON_ACCEL,
       PHOLUS_MIN_TOPO_LON_ACCEL,  CERES_MIN_TOPO_LON_ACCEL,
       PALLAS_MIN_TOPO_LON_ACCEL,  JUNO_MIN_TOPO_LON_ACCEL,
       VESTA_MIN_TOPO_LON_ACCEL,   INTPAPOG_MIN_TOPO_LON_ACCEL,
       INTPPERG_MIN_TOPO_LON_ACCEL};

  // Maximum heliocentric accelerations in longitudinal direction:
  static final double[] maxHelioLonAccel = new double[]
      {SURYA_MAX_HELIO_LON_ACCEL,   CHANDRA_MAX_HELIO_LON_ACCEL,
       BUDHA_MAX_HELIO_LON_ACCEL,   SHUKRA_MAX_HELIO_LON_ACCEL,
       MANGALA_MAX_HELIO_LON_ACCEL, GURU_MAX_HELIO_LON_ACCEL,
       SHANI_MAX_HELIO_LON_ACCEL,   URANUS_MAX_HELIO_LON_ACCEL,
       NEPTUNE_MAX_HELIO_LON_ACCEL, PLUTO_MAX_HELIO_LON_ACCEL,
       MNODE_MAX_HELIO_LON_ACCEL,   TNODE_MAX_HELIO_LON_ACCEL,
       MAPOGEE_MAX_HELIO_LON_ACCEL, OAPOGEE_MAX_HELIO_LON_ACCEL,
       1./0,                        CHIRON_MAX_HELIO_LON_ACCEL,
       PHOLUS_MAX_HELIO_LON_ACCEL,  CERES_MAX_HELIO_LON_ACCEL,
       PALLAS_MAX_HELIO_LON_ACCEL,  JUNO_MAX_HELIO_LON_ACCEL,
       VESTA_MAX_HELIO_LON_ACCEL,   INTPAPOG_MAX_HELIO_LON_ACCEL,
       INTPPERG_MAX_HELIO_LON_ACCEL};
  // Minimum heliocentric accelerations in longitudinal direction:
  static final double[] minHelioLonAccel = new double[]
      {SURYA_MIN_HELIO_LON_ACCEL,   CHANDRA_MIN_HELIO_LON_ACCEL,
       BUDHA_MIN_HELIO_LON_ACCEL,   SHUKRA_MIN_HELIO_LON_ACCEL,
       MANGALA_MIN_HELIO_LON_ACCEL, GURU_MIN_HELIO_LON_ACCEL,
       SHANI_MIN_HELIO_LON_ACCEL,   URANUS_MIN_HELIO_LON_ACCEL,
       NEPTUNE_MIN_HELIO_LON_ACCEL, PLUTO_MIN_HELIO_LON_ACCEL,
       MNODE_MIN_HELIO_LON_ACCEL,   TNODE_MIN_HELIO_LON_ACCEL,
       MAPOGEE_MIN_HELIO_LON_ACCEL, OAPOGEE_MIN_HELIO_LON_ACCEL,
       1./0,                        CHIRON_MIN_HELIO_LON_ACCEL,
       PHOLUS_MIN_HELIO_LON_ACCEL,  CERES_MIN_HELIO_LON_ACCEL,
       PALLAS_MIN_HELIO_LON_ACCEL,  JUNO_MIN_HELIO_LON_ACCEL,
       VESTA_MIN_HELIO_LON_ACCEL,   INTPAPOG_MIN_HELIO_LON_ACCEL,
       INTPPERG_MIN_HELIO_LON_ACCEL};




  // Speeds and accelerations in latitudinal direction:
  // Maximum geocentric speeds in latitudinal direction:
  static final double[] maxLatSpeed = new double[]
      {SURYA_MAX_LAT_SPEED,   CHANDRA_MAX_LAT_SPEED, BUDHA_MAX_LAT_SPEED,
       SHUKRA_MAX_LAT_SPEED,  MANGALA_MAX_LAT_SPEED, GURU_MAX_LAT_SPEED,
       SHANI_MAX_LAT_SPEED,   URANUS_MAX_LAT_SPEED,  NEPTUNE_MAX_LAT_SPEED,
       PLUTO_MAX_LAT_SPEED,   MNODE_MAX_LAT_SPEED,   TNODE_MAX_LAT_SPEED,
       MAPOGEE_MAX_LAT_SPEED, OAPOGEE_MAX_LAT_SPEED, 1./0,
       CHIRON_MAX_LAT_SPEED,  PHOLUS_MAX_LAT_SPEED,  CERES_MAX_LAT_SPEED,
       PALLAS_MAX_LAT_SPEED,  JUNO_MAX_LAT_SPEED,    VESTA_MAX_LAT_SPEED,
       INTPAPOG_MAX_LAT_SPEED,INTPPERG_MAX_LAT_SPEED};
  // Minimum geocentric speeds in latitudinal direction:
  static final double[] minLatSpeed = new double[]
      {SURYA_MIN_LAT_SPEED,   CHANDRA_MIN_LAT_SPEED, BUDHA_MIN_LAT_SPEED,
       SHUKRA_MIN_LAT_SPEED,  MANGALA_MIN_LAT_SPEED, GURU_MIN_LAT_SPEED,
       SHANI_MIN_LAT_SPEED,   URANUS_MIN_LAT_SPEED,  NEPTUNE_MIN_LAT_SPEED,
       PLUTO_MIN_LAT_SPEED,   MNODE_MIN_LAT_SPEED,   TNODE_MIN_LAT_SPEED,
       MAPOGEE_MIN_LAT_SPEED, OAPOGEE_MIN_LAT_SPEED, 1./0,
       CHIRON_MIN_LAT_SPEED,  PHOLUS_MIN_LAT_SPEED,  CERES_MIN_LAT_SPEED,
       PALLAS_MIN_LAT_SPEED,  JUNO_MIN_LAT_SPEED,    VESTA_MIN_LAT_SPEED,
       INTPAPOG_MIN_LAT_SPEED,INTPPERG_MIN_LAT_SPEED};

  // Maximum topocentric speeds in latitudinal direction, up to 50000m
  // altitude:
  static final double[] maxTopoLatSpeed = new double[]
      {SURYA_MAX_TOPO_LAT_SPEED,   CHANDRA_MAX_TOPO_LAT_SPEED,
       BUDHA_MAX_TOPO_LAT_SPEED,   SHUKRA_MAX_TOPO_LAT_SPEED,
       MANGALA_MAX_TOPO_LAT_SPEED, GURU_MAX_TOPO_LAT_SPEED,
       SHANI_MAX_TOPO_LAT_SPEED,   URANUS_MAX_TOPO_LAT_SPEED,
       NEPTUNE_MAX_TOPO_LAT_SPEED, PLUTO_MAX_TOPO_LAT_SPEED,
       MNODE_MAX_TOPO_LAT_SPEED,   TNODE_MAX_TOPO_LAT_SPEED,
       MAPOGEE_MAX_TOPO_LAT_SPEED, OAPOGEE_MAX_TOPO_LAT_SPEED,
       1./0,                       CHIRON_MAX_TOPO_LAT_SPEED,
       PHOLUS_MAX_TOPO_LAT_SPEED,  CERES_MAX_TOPO_LAT_SPEED,
       PALLAS_MAX_TOPO_LAT_SPEED,  JUNO_MAX_TOPO_LAT_SPEED,
       VESTA_MAX_TOPO_LAT_SPEED,   INTPAPOG_MAX_TOPO_LAT_SPEED,
       INTPPERG_MAX_TOPO_LAT_SPEED};
  // Minimum topocentric speeds in latitudinal direction, up to 50000m
  // altitude:
  static final double[] minTopoLatSpeed = new double[]
      {SURYA_MIN_TOPO_LAT_SPEED,   CHANDRA_MIN_TOPO_LAT_SPEED,
       BUDHA_MIN_TOPO_LAT_SPEED,   SHUKRA_MIN_TOPO_LAT_SPEED,
       MANGALA_MIN_TOPO_LAT_SPEED, GURU_MIN_TOPO_LAT_SPEED,
       SHANI_MIN_TOPO_LAT_SPEED,   URANUS_MIN_TOPO_LAT_SPEED,
       NEPTUNE_MIN_TOPO_LAT_SPEED, PLUTO_MIN_TOPO_LAT_SPEED,
       MNODE_MIN_TOPO_LAT_SPEED,   TNODE_MIN_TOPO_LAT_SPEED,
       MAPOGEE_MIN_TOPO_LAT_SPEED, OAPOGEE_MIN_TOPO_LAT_SPEED,
       1./0,                       CHIRON_MIN_TOPO_LAT_SPEED,
       PHOLUS_MIN_TOPO_LAT_SPEED,  CERES_MIN_TOPO_LAT_SPEED,
       PALLAS_MIN_TOPO_LAT_SPEED,  JUNO_MIN_TOPO_LAT_SPEED,
       VESTA_MIN_TOPO_LAT_SPEED,   INTPAPOG_MIN_TOPO_LAT_SPEED,
       INTPPERG_MIN_TOPO_LAT_SPEED};

  // Maximum heliocentric speeds in latitudinal direction:
  static final double[] maxHelioLatSpeed = new double[]
      {SURYA_MAX_HELIO_LAT_SPEED,   CHANDRA_MAX_HELIO_LAT_SPEED,
       BUDHA_MAX_HELIO_LAT_SPEED,   SHUKRA_MAX_HELIO_LAT_SPEED,
       MANGALA_MAX_HELIO_LAT_SPEED, GURU_MAX_HELIO_LAT_SPEED,
       SHANI_MAX_HELIO_LAT_SPEED,   URANUS_MAX_HELIO_LAT_SPEED,
       NEPTUNE_MAX_HELIO_LAT_SPEED, PLUTO_MAX_HELIO_LAT_SPEED,
       MNODE_MAX_HELIO_LAT_SPEED,   TNODE_MAX_HELIO_LAT_SPEED,
       MAPOGEE_MAX_HELIO_LAT_SPEED, OAPOGEE_MAX_HELIO_LAT_SPEED,
       1./0,                        CHIRON_MAX_HELIO_LAT_SPEED,
       PHOLUS_MAX_HELIO_LAT_SPEED,  CERES_MAX_HELIO_LAT_SPEED,
       PALLAS_MAX_HELIO_LAT_SPEED,  JUNO_MAX_HELIO_LAT_SPEED,
       VESTA_MAX_HELIO_LAT_SPEED,   INTPAPOG_MAX_HELIO_LAT_SPEED,
       INTPPERG_MAX_HELIO_LAT_SPEED};
  // Minimum heliocentric speeds in latitudinal direction:
  static final double[] minHelioLatSpeed = new double[]
      {SURYA_MIN_HELIO_LAT_SPEED,   CHANDRA_MIN_HELIO_LAT_SPEED,
       BUDHA_MIN_HELIO_LAT_SPEED,   SHUKRA_MIN_HELIO_LAT_SPEED,
       MANGALA_MIN_HELIO_LAT_SPEED, GURU_MIN_HELIO_LAT_SPEED,
       SHANI_MIN_HELIO_LAT_SPEED,   URANUS_MIN_HELIO_LAT_SPEED,
       NEPTUNE_MIN_HELIO_LAT_SPEED, PLUTO_MIN_HELIO_LAT_SPEED,
       MNODE_MIN_HELIO_LAT_SPEED,   TNODE_MIN_HELIO_LAT_SPEED,
       MAPOGEE_MIN_HELIO_LAT_SPEED, OAPOGEE_MIN_HELIO_LAT_SPEED,
       1./0,                        CHIRON_MIN_HELIO_LAT_SPEED,
       PHOLUS_MIN_HELIO_LAT_SPEED,  CERES_MIN_HELIO_LAT_SPEED,
       PALLAS_MIN_HELIO_LAT_SPEED,  JUNO_MIN_HELIO_LAT_SPEED,
       VESTA_MIN_HELIO_LAT_SPEED,   INTPAPOG_MAX_HELIO_LAT_SPEED,
       INTPPERG_MIN_HELIO_LAT_SPEED};

  // Maximum geocentric accelerations in latitudinal direction:
  static final double[] maxLatAccel = new double[]
      {SURYA_MAX_LAT_ACCEL,   CHANDRA_MAX_LAT_ACCEL, BUDHA_MAX_LAT_ACCEL,
       SHUKRA_MAX_LAT_ACCEL,  MANGALA_MAX_LAT_ACCEL, GURU_MAX_LAT_ACCEL,
       SHANI_MAX_LAT_ACCEL,   URANUS_MAX_LAT_ACCEL,  NEPTUNE_MAX_LAT_ACCEL,
       PLUTO_MAX_LAT_ACCEL,   MNODE_MAX_LAT_ACCEL,   TNODE_MAX_LAT_ACCEL,
       MAPOGEE_MAX_LAT_ACCEL, OAPOGEE_MAX_LAT_ACCEL, 1./0,
       CHIRON_MAX_LAT_ACCEL,  PHOLUS_MAX_LAT_ACCEL,  CERES_MAX_LAT_ACCEL,
       PALLAS_MAX_LAT_ACCEL,  JUNO_MAX_LAT_ACCEL,    VESTA_MAX_LAT_ACCEL,
       INTPAPOG_MAX_LAT_ACCEL,INTPPERG_MAX_LAT_ACCEL};
  // Minimum geocentric accelerations in latitudinal direction:
  static final double[] minLatAccel = new double[]
      {SURYA_MIN_LAT_ACCEL,   CHANDRA_MIN_LAT_ACCEL, BUDHA_MIN_LAT_ACCEL,
       SHUKRA_MIN_LAT_ACCEL,  MANGALA_MIN_LAT_ACCEL, GURU_MIN_LAT_ACCEL,
       SHANI_MIN_LAT_ACCEL,   URANUS_MIN_LAT_ACCEL,  NEPTUNE_MIN_LAT_ACCEL,
       PLUTO_MIN_LAT_ACCEL,   MNODE_MIN_LAT_ACCEL,   TNODE_MIN_LAT_ACCEL,
       MAPOGEE_MIN_LAT_ACCEL, OAPOGEE_MIN_LAT_ACCEL, 1./0,
       CHIRON_MIN_LAT_ACCEL,  PHOLUS_MIN_LAT_ACCEL,  CERES_MIN_LAT_ACCEL,
       PALLAS_MIN_LAT_ACCEL,  JUNO_MIN_LAT_ACCEL,    VESTA_MIN_LAT_ACCEL,
       INTPAPOG_MIN_LAT_ACCEL,INTPPERG_MIN_LAT_ACCEL};

  // Maximum topocentric accelerations in latitudinal direction, up to
  // 50000m altitude:
  static final double[] maxTopoLatAccel = new double[]
      {SURYA_MAX_TOPO_LAT_ACCEL,   CHANDRA_MAX_TOPO_LAT_ACCEL,
       BUDHA_MAX_TOPO_LAT_ACCEL,   SHUKRA_MAX_TOPO_LAT_ACCEL,
       MANGALA_MAX_TOPO_LAT_ACCEL, GURU_MAX_TOPO_LAT_ACCEL,
       SHANI_MAX_TOPO_LAT_ACCEL,   URANUS_MAX_TOPO_LAT_ACCEL,
       NEPTUNE_MAX_TOPO_LAT_ACCEL, PLUTO_MAX_TOPO_LAT_ACCEL,
       MNODE_MAX_TOPO_LAT_ACCEL,   TNODE_MAX_TOPO_LAT_ACCEL,
       MAPOGEE_MAX_TOPO_LAT_ACCEL, OAPOGEE_MAX_TOPO_LAT_ACCEL,
       1./0,                       CHIRON_MAX_TOPO_LAT_ACCEL,
       PHOLUS_MAX_TOPO_LAT_ACCEL,  CERES_MAX_TOPO_LAT_ACCEL,
       PALLAS_MAX_TOPO_LAT_ACCEL,  JUNO_MAX_TOPO_LAT_ACCEL,
       VESTA_MAX_TOPO_LAT_ACCEL,   INTPAPOG_MAX_TOPO_LAT_ACCEL,
       INTPPERG_MAX_TOPO_LAT_ACCEL};
  // Minimum topocentric accelerations in latitudinal direction, up to
  // 50000m altitude:
  static final double[] minTopoLatAccel = new double[]
      {SURYA_MIN_TOPO_LAT_ACCEL,   CHANDRA_MIN_TOPO_LAT_ACCEL,
       BUDHA_MIN_TOPO_LAT_ACCEL,   SHUKRA_MIN_TOPO_LAT_ACCEL,
       MANGALA_MIN_TOPO_LAT_ACCEL, GURU_MIN_TOPO_LAT_ACCEL,
       SHANI_MIN_TOPO_LAT_ACCEL,   URANUS_MIN_TOPO_LAT_ACCEL,
       NEPTUNE_MIN_TOPO_LAT_ACCEL, PLUTO_MIN_TOPO_LAT_ACCEL,
       MNODE_MIN_TOPO_LAT_ACCEL,   TNODE_MIN_TOPO_LAT_ACCEL,
       MAPOGEE_MIN_TOPO_LAT_ACCEL, OAPOGEE_MIN_TOPO_LAT_ACCEL,
       1./0,                       CHIRON_MIN_TOPO_LAT_ACCEL,
       PHOLUS_MIN_TOPO_LAT_ACCEL,  CERES_MIN_TOPO_LAT_ACCEL,
       PALLAS_MIN_TOPO_LAT_ACCEL,  JUNO_MIN_TOPO_LAT_ACCEL,
       VESTA_MIN_TOPO_LAT_ACCEL,   INTPAPOG_MIN_TOPO_LAT_ACCEL,
       INTPPERG_MIN_TOPO_LAT_ACCEL};

  // Maximum heliocentric accelerations in latitudinal direction:
  static final double[] maxHelioLatAccel = new double[]
      {SURYA_MAX_HELIO_LAT_ACCEL,   CHANDRA_MAX_HELIO_LAT_ACCEL,
       BUDHA_MAX_HELIO_LAT_ACCEL,   SHUKRA_MAX_HELIO_LAT_ACCEL,
       MANGALA_MAX_HELIO_LAT_ACCEL, GURU_MAX_HELIO_LAT_ACCEL,
       SHANI_MAX_HELIO_LAT_ACCEL,   URANUS_MAX_HELIO_LAT_ACCEL,
       NEPTUNE_MAX_HELIO_LAT_ACCEL, PLUTO_MAX_HELIO_LAT_ACCEL,
       MNODE_MAX_HELIO_LAT_ACCEL,   TNODE_MAX_HELIO_LAT_ACCEL,
       MAPOGEE_MAX_HELIO_LAT_ACCEL, OAPOGEE_MAX_HELIO_LAT_ACCEL,
       1./0,                        CHIRON_MAX_HELIO_LAT_ACCEL,
       PHOLUS_MAX_HELIO_LAT_ACCEL,  CERES_MAX_HELIO_LAT_ACCEL,
       PALLAS_MAX_HELIO_LAT_ACCEL,  JUNO_MAX_HELIO_LAT_ACCEL,
       VESTA_MAX_HELIO_LAT_ACCEL,   INTPAPOG_MAX_HELIO_LAT_ACCEL,
       INTPPERG_MAX_HELIO_LAT_ACCEL};
  // Minimum heliocentric accelerations in latitudinal direction:
  static final double[] minHelioLatAccel = new double[]
      {SURYA_MIN_HELIO_LAT_ACCEL,   CHANDRA_MIN_HELIO_LAT_ACCEL,
       BUDHA_MIN_HELIO_LAT_ACCEL,   SHUKRA_MIN_HELIO_LAT_ACCEL,
       MANGALA_MIN_HELIO_LAT_ACCEL, GURU_MIN_HELIO_LAT_ACCEL,
       SHANI_MIN_HELIO_LAT_ACCEL,   URANUS_MIN_HELIO_LAT_ACCEL,
       NEPTUNE_MIN_HELIO_LAT_ACCEL, PLUTO_MIN_HELIO_LAT_ACCEL,
       MNODE_MIN_HELIO_LAT_ACCEL,   TNODE_MIN_HELIO_LAT_ACCEL,
       MAPOGEE_MIN_HELIO_LAT_ACCEL, OAPOGEE_MIN_HELIO_LAT_ACCEL,
       1./0,                        CHIRON_MIN_HELIO_LAT_ACCEL,
       PHOLUS_MIN_HELIO_LAT_ACCEL,  CERES_MIN_HELIO_LAT_ACCEL,
       PALLAS_MIN_HELIO_LAT_ACCEL,  JUNO_MIN_HELIO_LAT_ACCEL,
       VESTA_MIN_HELIO_LAT_ACCEL,   INTPAPOG_MIN_HELIO_LAT_ACCEL,
       INTPPERG_MIN_HELIO_LAT_ACCEL};




  // Speeds and accelerations in the distance to the earth:
  // Maximum geocentric speeds in the distance to the earth:
  static final double[] maxDistSpeed = new double[]
      {SURYA_MAX_DIST_SPEED,   CHANDRA_MAX_DIST_SPEED, BUDHA_MAX_DIST_SPEED,
       SHUKRA_MAX_DIST_SPEED,  MANGALA_MAX_DIST_SPEED, GURU_MAX_DIST_SPEED,
       SHANI_MAX_DIST_SPEED,   URANUS_MAX_DIST_SPEED,  NEPTUNE_MAX_DIST_SPEED,
       PLUTO_MAX_DIST_SPEED,   MNODE_MAX_DIST_SPEED,   TNODE_MAX_DIST_SPEED,
       MAPOGEE_MAX_DIST_SPEED, OAPOGEE_MAX_DIST_SPEED, 1./0.,
       CHIRON_MAX_DIST_SPEED,  PHOLUS_MAX_DIST_SPEED,  CERES_MAX_DIST_SPEED,
       PALLAS_MAX_DIST_SPEED,  JUNO_MAX_DIST_SPEED,    VESTA_MAX_DIST_SPEED,
       INTPAPOG_MAX_DIST_SPEED,INTPPERG_MAX_DIST_SPEED};
  // Minimum geocentric speeds in the direction of the distance to the earth:
  static final double[] minDistSpeed = new double[]
      {SURYA_MIN_DIST_SPEED,   CHANDRA_MIN_DIST_SPEED, BUDHA_MIN_DIST_SPEED,
       SHUKRA_MIN_DIST_SPEED,  MANGALA_MIN_DIST_SPEED, GURU_MIN_DIST_SPEED,
       SHANI_MIN_DIST_SPEED,   URANUS_MIN_DIST_SPEED,  NEPTUNE_MIN_DIST_SPEED,
       PLUTO_MIN_DIST_SPEED,   MNODE_MIN_DIST_SPEED,   TNODE_MIN_DIST_SPEED,
       MAPOGEE_MIN_DIST_SPEED, OAPOGEE_MIN_DIST_SPEED, 1./0.,
       CHIRON_MIN_DIST_SPEED,  PHOLUS_MIN_DIST_SPEED,  CERES_MIN_DIST_SPEED,
       PALLAS_MIN_DIST_SPEED,  JUNO_MIN_DIST_SPEED,    VESTA_MIN_DIST_SPEED,
       INTPAPOG_MIN_DIST_SPEED,INTPPERG_MIN_DIST_SPEED};

  // Maximum topocentric speeds in the distance to the earth:
  static final double[] maxTopoDistSpeed = new double[]
      {SURYA_MAX_TOPO_DIST_SPEED,   CHANDRA_MAX_TOPO_DIST_SPEED,
       BUDHA_MAX_TOPO_DIST_SPEED,   SHUKRA_MAX_TOPO_DIST_SPEED,
       MANGALA_MAX_TOPO_DIST_SPEED, GURU_MAX_TOPO_DIST_SPEED,
       SHANI_MAX_TOPO_DIST_SPEED,   URANUS_MAX_TOPO_DIST_SPEED,
       NEPTUNE_MAX_TOPO_DIST_SPEED, PLUTO_MAX_TOPO_DIST_SPEED,
       MNODE_MAX_TOPO_DIST_SPEED,   TNODE_MAX_TOPO_DIST_SPEED,
       MAPOGEE_MAX_TOPO_DIST_SPEED, OAPOGEE_MAX_TOPO_DIST_SPEED,
       1./0.,                       CHIRON_MAX_TOPO_DIST_SPEED,
       PHOLUS_MAX_TOPO_DIST_SPEED,  CERES_MAX_TOPO_DIST_SPEED,
       PALLAS_MAX_TOPO_DIST_SPEED,  JUNO_MAX_TOPO_DIST_SPEED,
       VESTA_MAX_TOPO_DIST_SPEED,   INTPAPOG_MAX_TOPO_DIST_SPEED,
       INTPPERG_MAX_TOPO_DIST_SPEED};
  // Minimum topocentric speeds in the distance to the earth:
  static final double[] minTopoDistSpeed = new double[]
      {SURYA_MIN_TOPO_DIST_SPEED,   CHANDRA_MIN_TOPO_DIST_SPEED,
       BUDHA_MIN_TOPO_DIST_SPEED,   SHUKRA_MIN_TOPO_DIST_SPEED,
       MANGALA_MIN_TOPO_DIST_SPEED, GURU_MIN_TOPO_DIST_SPEED,
       SHANI_MIN_TOPO_DIST_SPEED,   URANUS_MIN_TOPO_DIST_SPEED,
       NEPTUNE_MIN_TOPO_DIST_SPEED, PLUTO_MIN_TOPO_DIST_SPEED,
       MNODE_MIN_TOPO_DIST_SPEED,   TNODE_MIN_TOPO_DIST_SPEED,
       MAPOGEE_MIN_TOPO_DIST_SPEED, OAPOGEE_MIN_TOPO_DIST_SPEED,
       1./0.,                       CHIRON_MIN_TOPO_DIST_SPEED,
       PHOLUS_MIN_TOPO_DIST_SPEED,  CERES_MIN_TOPO_DIST_SPEED,
       PALLAS_MIN_TOPO_DIST_SPEED,  JUNO_MIN_TOPO_DIST_SPEED,
       VESTA_MIN_TOPO_DIST_SPEED,   INTPAPOG_MIN_TOPO_DIST_SPEED,
       INTPPERG_MIN_TOPO_DIST_SPEED};

  // Maximum speeds in the distance to the sun:
  static final double[] maxHelioDistSpeed = new double[]
      {SURYA_MAX_HELIO_DIST_SPEED,   CHANDRA_MAX_HELIO_DIST_SPEED,
       BUDHA_MAX_HELIO_DIST_SPEED,   SHUKRA_MAX_HELIO_DIST_SPEED,
       MANGALA_MAX_HELIO_DIST_SPEED, GURU_MAX_HELIO_DIST_SPEED,
       SHANI_MAX_HELIO_DIST_SPEED,   URANUS_MAX_HELIO_DIST_SPEED,
       NEPTUNE_MAX_HELIO_DIST_SPEED, PLUTO_MAX_HELIO_DIST_SPEED,
       MNODE_MAX_HELIO_DIST_SPEED,   TNODE_MAX_HELIO_DIST_SPEED,
       MAPOGEE_MAX_HELIO_DIST_SPEED, OAPOGEE_MAX_HELIO_DIST_SPEED,
       1./0.,                        CHIRON_MAX_HELIO_DIST_SPEED,
       PHOLUS_MAX_HELIO_DIST_SPEED,  CERES_MAX_HELIO_DIST_SPEED,
       PALLAS_MAX_HELIO_DIST_SPEED,  JUNO_MAX_HELIO_DIST_SPEED,
       VESTA_MAX_HELIO_DIST_SPEED,   INTPAPOG_MAX_HELIO_DIST_SPEED,
       INTPPERG_MAX_HELIO_DIST_SPEED};
  // Minimum speeds in the distance to the sun:
  static final double[] minHelioDistSpeed = new double[]
      {SURYA_MIN_HELIO_DIST_SPEED,   CHANDRA_MIN_HELIO_DIST_SPEED,
       BUDHA_MIN_HELIO_DIST_SPEED,   SHUKRA_MIN_HELIO_DIST_SPEED,
       MANGALA_MIN_HELIO_DIST_SPEED, GURU_MIN_HELIO_DIST_SPEED,
       SHANI_MIN_HELIO_DIST_SPEED,   URANUS_MIN_HELIO_DIST_SPEED,
       NEPTUNE_MIN_HELIO_DIST_SPEED, PLUTO_MIN_HELIO_DIST_SPEED,
       MNODE_MIN_HELIO_DIST_SPEED,   TNODE_MIN_HELIO_DIST_SPEED,
       MAPOGEE_MIN_HELIO_DIST_SPEED, OAPOGEE_MIN_HELIO_DIST_SPEED,
       1./0.,                        CHIRON_MIN_HELIO_DIST_SPEED,
       PHOLUS_MIN_HELIO_DIST_SPEED,  CERES_MIN_HELIO_DIST_SPEED,
       PALLAS_MIN_HELIO_DIST_SPEED,  JUNO_MIN_HELIO_DIST_SPEED,
       VESTA_MIN_HELIO_DIST_SPEED,   INTPAPOG_MIN_HELIO_DIST_SPEED,
       INTPPERG_MIN_HELIO_DIST_SPEED};

  // Maximum geocentric accelerations in the distance to the earth:
  static final double[] maxDistAccel = new double[]
      {SURYA_MAX_DIST_ACCEL,   CHANDRA_MAX_DIST_ACCEL, BUDHA_MAX_DIST_ACCEL,
       SHUKRA_MAX_DIST_ACCEL,  MANGALA_MAX_DIST_ACCEL, GURU_MAX_DIST_ACCEL,
       SHANI_MAX_DIST_ACCEL,   URANUS_MAX_DIST_ACCEL,  NEPTUNE_MAX_DIST_ACCEL,
       PLUTO_MAX_DIST_ACCEL,   MNODE_MAX_DIST_ACCEL,   TNODE_MAX_DIST_ACCEL,
       MAPOGEE_MAX_DIST_ACCEL, OAPOGEE_MAX_DIST_ACCEL, 1./0.,
       CHIRON_MAX_DIST_ACCEL,  PHOLUS_MAX_DIST_ACCEL,  CERES_MAX_DIST_ACCEL,
       PALLAS_MAX_DIST_ACCEL,  JUNO_MAX_DIST_ACCEL,    VESTA_MAX_DIST_ACCEL,
       INTPAPOG_MAX_DIST_ACCEL,INTPPERG_MAX_DIST_ACCEL};
  // Minimum geocentric accelerations in the distance to the earth:
  static final double[] minDistAccel = new double[]
      {SURYA_MIN_DIST_ACCEL,   CHANDRA_MIN_DIST_ACCEL, BUDHA_MIN_DIST_ACCEL,
       SHUKRA_MIN_DIST_ACCEL,  MANGALA_MIN_DIST_ACCEL, GURU_MIN_DIST_ACCEL,
       SHANI_MIN_DIST_ACCEL,   URANUS_MIN_DIST_ACCEL,  NEPTUNE_MIN_DIST_ACCEL,
       PLUTO_MIN_DIST_ACCEL,   MNODE_MIN_DIST_ACCEL,   TNODE_MIN_DIST_ACCEL,
       MAPOGEE_MIN_DIST_ACCEL, OAPOGEE_MIN_DIST_ACCEL, 1./0.,
       CHIRON_MIN_DIST_ACCEL,  PHOLUS_MIN_DIST_ACCEL,  CERES_MIN_DIST_ACCEL,
       PALLAS_MIN_DIST_ACCEL,  JUNO_MIN_DIST_ACCEL,    VESTA_MIN_DIST_ACCEL,
       INTPAPOG_MIN_DIST_ACCEL,INTPPERG_MIN_DIST_ACCEL};

  // Maximum topocentric accelerations in the distance to the earth:
  static final double[] maxTopoDistAccel = new double[]
      {SURYA_MAX_TOPO_DIST_ACCEL,   CHANDRA_MAX_TOPO_DIST_ACCEL,
       BUDHA_MAX_TOPO_DIST_ACCEL,   SHUKRA_MAX_TOPO_DIST_ACCEL,
       MANGALA_MAX_TOPO_DIST_ACCEL, GURU_MAX_TOPO_DIST_ACCEL,
       SHANI_MAX_TOPO_DIST_ACCEL,   URANUS_MAX_TOPO_DIST_ACCEL,
       NEPTUNE_MAX_TOPO_DIST_ACCEL, PLUTO_MAX_TOPO_DIST_ACCEL,
       MNODE_MAX_TOPO_DIST_ACCEL,   TNODE_MAX_TOPO_DIST_ACCEL,
       MAPOGEE_MAX_TOPO_DIST_ACCEL, OAPOGEE_MAX_TOPO_DIST_ACCEL,
       1./0.,                       CHIRON_MAX_TOPO_DIST_ACCEL,
       PHOLUS_MAX_TOPO_DIST_ACCEL,  CERES_MAX_TOPO_DIST_ACCEL,
       PALLAS_MAX_TOPO_DIST_ACCEL,  JUNO_MAX_TOPO_DIST_ACCEL,
       VESTA_MAX_TOPO_DIST_ACCEL,   INTPAPOG_MAX_TOPO_DIST_ACCEL,
       INTPPERG_MAX_TOPO_DIST_ACCEL};
  // Minimum topocentric accelerations in the distance to the earth:
  static final double[] minTopoDistAccel = new double[]
      {SURYA_MIN_TOPO_DIST_ACCEL,   CHANDRA_MIN_TOPO_DIST_ACCEL,
       BUDHA_MIN_TOPO_DIST_ACCEL,   SHUKRA_MIN_TOPO_DIST_ACCEL,
       MANGALA_MIN_TOPO_DIST_ACCEL, GURU_MIN_TOPO_DIST_ACCEL,
       SHANI_MIN_TOPO_DIST_ACCEL,   URANUS_MIN_TOPO_DIST_ACCEL,
       NEPTUNE_MIN_TOPO_DIST_ACCEL, PLUTO_MIN_TOPO_DIST_ACCEL,
       MNODE_MIN_TOPO_DIST_ACCEL,   TNODE_MIN_TOPO_DIST_ACCEL,
       MAPOGEE_MIN_TOPO_DIST_ACCEL, OAPOGEE_MIN_TOPO_DIST_ACCEL,
       1./0.,                       CHIRON_MIN_TOPO_DIST_ACCEL,
       PHOLUS_MIN_TOPO_DIST_ACCEL,  CERES_MIN_TOPO_DIST_ACCEL,
       PALLAS_MIN_TOPO_DIST_ACCEL,  JUNO_MIN_TOPO_DIST_ACCEL,
       VESTA_MIN_TOPO_DIST_ACCEL,   INTPAPOG_MIN_TOPO_DIST_ACCEL,
       INTPPERG_MIN_TOPO_DIST_ACCEL};

  // Maximum accelerations in the distance to the sun:
  static final double[] maxHelioDistAccel = new double[]
      {SURYA_MAX_HELIO_DIST_ACCEL,   CHANDRA_MAX_HELIO_DIST_ACCEL,
       BUDHA_MAX_HELIO_DIST_ACCEL,   SHUKRA_MAX_HELIO_DIST_ACCEL,
       MANGALA_MAX_HELIO_DIST_ACCEL, GURU_MAX_HELIO_DIST_ACCEL,
       SHANI_MAX_HELIO_DIST_ACCEL,   URANUS_MAX_HELIO_DIST_ACCEL,
       NEPTUNE_MAX_HELIO_DIST_ACCEL, PLUTO_MAX_HELIO_DIST_ACCEL,
       MNODE_MAX_HELIO_DIST_ACCEL,   TNODE_MAX_HELIO_DIST_ACCEL,
       MAPOGEE_MAX_HELIO_DIST_ACCEL, OAPOGEE_MAX_HELIO_DIST_ACCEL,
       1./0.,                        CHIRON_MAX_HELIO_DIST_ACCEL,
       PHOLUS_MAX_HELIO_DIST_ACCEL,  CERES_MAX_HELIO_DIST_ACCEL,
       PALLAS_MAX_HELIO_DIST_ACCEL,  JUNO_MAX_HELIO_DIST_ACCEL,
       VESTA_MAX_HELIO_DIST_ACCEL,   INTPAPOG_MAX_HELIO_DIST_ACCEL,
       INTPPERG_MAX_HELIO_DIST_ACCEL};
  // Minimum accelerations in the distance to the sun:
  static final double[] minHelioDistAccel = new double[]
      {SURYA_MIN_HELIO_DIST_ACCEL,   CHANDRA_MIN_HELIO_DIST_ACCEL,
       BUDHA_MIN_HELIO_DIST_ACCEL,   SHUKRA_MIN_HELIO_DIST_ACCEL,
       MANGALA_MIN_HELIO_DIST_ACCEL, GURU_MIN_HELIO_DIST_ACCEL,
       SHANI_MIN_HELIO_DIST_ACCEL,   URANUS_MIN_HELIO_DIST_ACCEL,
       NEPTUNE_MIN_HELIO_DIST_ACCEL, PLUTO_MIN_HELIO_DIST_ACCEL,
       MNODE_MIN_HELIO_DIST_ACCEL,   TNODE_MIN_HELIO_DIST_ACCEL,
       MAPOGEE_MIN_HELIO_DIST_ACCEL, OAPOGEE_MIN_HELIO_DIST_ACCEL,
       1./0.,                        CHIRON_MIN_HELIO_DIST_ACCEL,
       PHOLUS_MIN_HELIO_DIST_ACCEL,  CERES_MIN_HELIO_DIST_ACCEL,
       PALLAS_MIN_HELIO_DIST_ACCEL,  JUNO_MIN_HELIO_DIST_ACCEL,
       VESTA_MIN_HELIO_DIST_ACCEL,   INTPAPOG_MIN_HELIO_DIST_ACCEL,
       INTPPERG_MIN_HELIO_DIST_ACCEL};

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

  /**
  * Just to inhibit instantiation of this class, which is never necessary.
  */
  private SwephData() { }
}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class SwephJPL {
  static final int J_MERCURY =  0;
  static final int J_VENUS   =  1;
  static final int J_EARTH   =  2;
  static final int J_MARS    =  3;
  static final int J_JUPITER =  4;
  static final int J_SATURN  =  5;
  static final int J_URANUS  =  6;
  static final int J_NEPTUNE =  7;
  static final int J_PLUTO   =  8;
  static final int J_MOON    =  9;
  static final int J_SUN     = 10;
  static final int J_SBARY   = 11;
  static final int J_EMB     = 12;
  static final int J_NUT     = 13;
  static final int J_LIB     = 14;

  JplSave js=new JplSave();


  SwissEph  sw=null;
  SwissData swed=null;
  SwissLib  sl=null;



  SwephJPL(SwissEph sw, SwissData swed, SwissLib sl) {
    this.sw=sw;
    this.swed=swed;
    this.sl=sl;
    if (this.sw==null) { this.sw=new SwissEph(); }
    if (this.swed==null) { this.swed=new SwissData(); }
    if (this.sl==null) { this.sl=new SwissLib(); }
  }


  /*
   * This subroutine opens the file jplfname, with a phony record length,
   * reads the first record, and uses the info to compute ksize,
   * the number of single precision words in a record.
   * RETURN: ksize (record size of ephemeris data)
   * jplfptr is opened on return.
   */
  private int fsizer(StringBuffer serr) throws SwissephException {
    /* Local variables */
    int ncon;
    double emrat;
    int numde;
    double au, ss[]=new double[3];
    int i;
    int ksize;
    String ttl="";  // JAVA: Not used???
    try {
      // throws SwissephException, if null or maybe for other reasons:
      js.jplfptr = sw.swi_fopen(SwephData.SEI_FILE_PLANET, js.jplfname, js.jplfpath, serr);
      /* ttl = ephemeris title, e.g.
       * "JPL Planetary Ephemeris DE404/LE404
       *  Start Epoch: JED=   625296.5-3001 DEC 21 00:00:00
       *  Final Epoch: JED=  2817168.5 3001 JAN 17 00:00:00c */
//    fread((void *) &ttl[0], 1, 252, js->jplfptr);
      for(int m=0; m<252; m++) {
        ttl+=(char)js.jplfptr.readByte();
      }
    /* cnam = names of constants */
//    fread((void *) js->ch_cnam, 1, 6*400, js->jplfptr);
      for(int m=0; m<6*400; m++) {
        ttl+=(char)js.jplfptr.readByte();
      }
      /* ss[0] = start epoch of ephemeris
       * ss[1] = end epoch
       * ss[2] = segment size in days */
//    fread((void *) &ss[0], sizeof(double), 3, js->jplfptr);
      for(int m=0; m<3; m++) {
        ss[m]=js.jplfptr.readDouble();
      }
// Don't mind "reorder"...
//    /* reorder ? */
//    if (ss[2] < 1 || ss[2] > 200)
//      js.do_reorder = true;
//    else
//      js.do_reorder = false;
      for (i = 0; i < 3; i++)
        js.eh_ss[i] = ss[i];
//    if (js.do_reorder)
//      reorder((char *) &js->eh_ss[0], sizeof(double), 3);
      /* ncon = number of constants */
//    fread((void *) &ncon, sizeof(long), 1, js->jplfptr);
        ncon=js.jplfptr.readInt();
//    if (js->do_reorder)
//      reorder((char *) &ncon, sizeof(long), 1);
      /* au = astronomical unit */
//    fread((void *) &au, sizeof(double), 1, js->jplfptr);
      au=js.jplfptr.readDouble();
//    if (js->do_reorder)
//      reorder((char *) &au, sizeof(double), 1);
      /* emrat = earth moon mass ratio */
//    fread((void *) &emrat, sizeof(double), 1, js->jplfptr);
      emrat=js.jplfptr.readDouble();
//    if (js->do_reorder)
//      reorder((char *) &emrat, sizeof(double), 1);
      /* ipt[i+0]: coefficients of planet i start at buf[ipt[i+0]-1]
       * ipt[i+1]: number of coefficients (interpolation order - 1)
       * ipt[i+2]: number of intervals in segment */
//    fread((void *) &js->eh_ipt[0], sizeof(long), 36, js->jplfptr);
      for(int m=0; m<36; m++) {
        js.eh_ipt[m]=js.jplfptr.readInt();
      }
//    if (js->do_reorder)
//      reorder((char *) &js->eh_ipt[0], sizeof(long), 36);
      /* numde = number of jpl ephemeris "404" with de404 */
//    fread((void *) &numde, sizeof(long), 1, js->jplfptr);
        numde=js.jplfptr.readInt();
//    if (js->do_reorder)
//      reorder((char *) &numde, sizeof(long), 1);
      js.jplfptr.seek(0);
      /*  find the number of ephemeris coefficients from the pointers */
    } catch (java.io.IOException ioe) {
      throw new SwissephException(1./0., SwissephException.FILE_READ_ERROR,
          SweConst.ERR, ioe.getMessage());
    }
    switch (numde) {
      case 403:
      case 405:
        ksize = 2036;
        break;
      case 404:
      case 406:
        ksize = 1456;
        break;
      case 200:
        ksize = 1652;
        break;
      case 102:
        ksize = 1652;     /* de102 is filled with blanks to length of de200 */
        break;
      default:
        if (serr != null) {
          serr.setLength(0);
          serr.append("unknown numde value "+numde+";");
        }
        throw new SwissephException(1./0., SwissephException.DATA_FILE_ERROR,
            SweConst.ERR, serr);
    }
    return ksize;
  }

  /*
   *     This subroutine reads the jpl planetary ephemeris
   *     and gives the position and velocity of the point 'ntarg'
   *     with respect to 'ncent'.
   *     calling sequence parameters:
   *       et = d.p. julian ephemeris date at which interpolation
   *            is wanted.
   *       ** note the entry dpleph for a doubly-dimensioned time **
   *          the reason for this option is discussed in the
   *          subroutine state
   *     ntarg = integer number of 'target' point.
   *     ncent = integer number of center point.
   *            the numbering convention for 'ntarg' and 'ncent' is:
   *                0 = mercury           7 = neptune
   *                1 = venus             8 = pluto
   *                2 = earth             9 = moon
   *                3 = mars             10 = sun
   *                4 = jupiter          11 = solar-system barycenter
   *                5 = saturn           12 = earth-moon barycenter
   *                6 = uranus           13 = nutations (longitude and obliq)
   *                                     14 = librations, if on eph file
   *             (if nutations are wanted, set ntarg = 13. for librations,
   *              set ntarg = 14. set ncent=0.)
   *      rrd = output 6-word d.p. array containing position and velocity
   *            of point 'ntarg' relative to 'ncent'. the units are au and
   *            au/day. for librations the units are radians and radians
   *            per day. in the case of nutations the first four words of
   *            rrd will be set to nutations and rates, having units of
   *            radians and radians/day.
   *            The option is available to have the units in km and km/sec.
   *            For this, set do_km=TRUE (default FALSE).
   */
  int swi_pleph(double et, int ntarg, int ncent, double[] rrd,
                StringBuffer serr) throws SwissephException {
    int i, retc;
    int list[]=new int[12];
    double[] pv = js.pv;
    double[] pvsun = js.pvsun;
    for (i = 0; i < 6; ++i)
      rrd[i] = 0.0;
    if (ntarg == ncent) {
      return 0;
    }
    for (i = 0; i < 12; ++i)
      list[i] = 0;
    /*     check for nutation call */
    if (ntarg == J_NUT) {
      if (js.eh_ipt[34] > 0) {
        list[10] = 2;
        return(state(et, list, false, pv, pvsun, rrd, serr));
      } else {
        if (serr != null) {
          serr.setLength(0);
          serr.append("No nutations on the JPL ephemeris file;");
        }
        throw new SwissephException(et, SwissephException.UNDEFINED,
            SwephData.NOT_AVAILABLE, serr);
      }
    }
    if (ntarg == J_LIB) {
      if (js.eh_ipt[37] > 0) {
        list[11] = 2;
        // throws SwissephException by itself:
        retc = state(et, list, false, pv, pvsun, rrd, serr);
        for (i = 0; i < 6; ++i) {
          rrd[i] = pv[i + 60];
        }
        return 0;
      } else {
        if (serr != null) {
          serr.setLength(0);
          serr.append("No librations on the ephemeris file;");
        }
        throw new SwissephException(et, SwissephException.DATA_FILE_ERROR,
            SwephData.NOT_AVAILABLE, serr);
      }
    }
    /* set up proper entries in 'list' array for state call */
    if (ntarg < J_SUN) {
      list[ntarg] = 2;
    }
    if (ntarg == J_MOON)  /* Mooon needs Earth */ {
      list[J_EARTH] = 2;
    }
    if (ntarg == J_EARTH)         /* Earth needs Moon */ {
      list[J_MOON] = 2;
    }
    if (ntarg == J_EMB)   /* EMB needs Earth */ {
      list[J_EARTH] = 2;
    }
    if (ncent < J_SUN) {
      list[ncent] = 2;
    }
    if (ncent == J_MOON)  /* Mooon needs Earth */ {
      list[J_EARTH] = 2;
    }
    if (ncent == J_EARTH)         /* Earth needs Moon */ {
      list[J_MOON] = 2;
    }
    if (ncent == J_EMB)   /* EMB needs Earth */ {
      list[J_EARTH] = 2;
    }
    // throws SwissephException by itself:
    retc = state(et, list, true, pv, pvsun, rrd, serr);
    if (ntarg == J_SUN || ncent == J_SUN) {
      for (i = 0; i < 6; ++i)
        pv[i + 6*J_SUN] = pvsun[i];
    }
    if (ntarg == J_SBARY || ncent == J_SBARY) {
      for (i = 0; i < 6; ++i) {
        pv[i + 6*J_SBARY] = 0.;
      }
    }
    if (ntarg == J_EMB || ncent == J_EMB) {
      for (i = 0; i < 6; ++i)
        pv[i + 6*J_EMB] = pv[i + 6*J_EARTH];
    }
    if ((ntarg==J_EARTH && ncent==J_MOON) || (ntarg == J_MOON && ncent==J_EARTH)){
      for (i = 0; i < 6; ++i)
        pv[i + 6*J_EARTH] = 0.;

    } else {
      if (list[J_EARTH] == 2) {
        for (i = 0; i < 6; ++i)
          pv[i + 6*J_EARTH] -= pv[i + 6*J_MOON] / (js.eh_emrat + 1.);
      }
      if (list[J_MOON] == 2) {
        for (i = 0; i < 6; ++i) {
          pv[i + 6*J_MOON] += pv[i + 6*J_EARTH];
        }
      }
    }
    for (i = 0; i < 6; ++i)
      rrd[i] = pv[i + ntarg * 6] - pv[i + ncent * 6];
    return SweConst.OK;
  }

  /*
   *  This subroutine differentiates and interpolates a
   *  set of chebyshev coefficients to give pos, vel, acc, and jerk
   *  calling sequence parameters:
   *    input:
   *     buf   1st location of array of d.p. chebyshev coefficients of position
   *        t   is dp fractional time in interval covered by
   *            coefficients at which interpolation is wanted, 0 <= t <= 1
   *     intv   is dp length of whole interval in input time units.
   *      ncf   number of coefficients per component
   *      ncm   number of components per set of coefficients
   *       na   number of sets of coefficients in full array
   *            (i.e., number of sub-intervals in full interval)
   *       ifl   int flag: =1 for positions only
   *                      =2 for pos and vel
   *                      =3 for pos, vel, and acc
   *                      =4 for pos, vel, acc, and jerk
   *    output:
   *      pv   d.p. interpolated quantities requested.
   *           assumed dimension is pv(ncm,fl).
   */
  /* Initialized data */
  int np_interp, nv_interp;
  int nac_interp;
  int njk_interp;
  double twot = 0.;
  private int interp(double[] buf, int bufOffs, double t, double intv,
                     int ncfin, int ncmin, int nain, int ifl, double[] pv,
                     int pvOffs) {
    /* Initialized data */
    double[] pc = js.pc;
    double[] vc = js.vc;
    double[] ac = js.ac;
    double[] jc = js.jc;
    int ncf = (int) ncfin;
    int ncm = (int) ncmin;
    int na = (int) nain;
    /* Local variables */
    double temp;
    int i, j, ni;
    double tc;
    double dt1, bma;
    double bma2, bma3;
    /*
     | get correct sub-interval number for this set of coefficients and then
     | get normalized chebyshev time within that subinterval.
     */
    if (t >= 0) {
      dt1 = Math.floor(t);
    } else {
      dt1 = -Math.floor(-t);
    }
    temp = na * t;
    ni = (int) (temp - dt1);
    /* tc is the normalized chebyshev time (-1 <= tc <= 1) */
    tc = ((temp % 1.0) + dt1) * 2. - 1.;
    /*
     *  check to see whether chebyshev time has changed,
     *  and compute new polynomial values if it has.
     *  (the element pc(2) is the value of t1(tc) and hence
     *  contains the value of tc on the previous call.)
     */
    if (tc != pc[1]) {
      np_interp = 2;
      nv_interp = 3;
      nac_interp = 4;
      njk_interp = 5;
      pc[1] = tc;
      twot = tc + tc;
    }
    /*
     *  be sure that at least 'ncf' polynomials have been evaluated
     *  and are stored in the array 'pc'.
     */
    if (np_interp < ncf) {
      for (i = np_interp; i < ncf; ++i)
        pc[i] = twot * pc[i - 1] - pc[i - 2];
      np_interp = ncf;
    }
    /*  interpolate to get position for each component */
    for (i = 0; i < ncm; ++i) {
      pv[pvOffs + i] = 0.;
      for (j = ncf-1; j >= 0; --j)
        pv[pvOffs + i] += pc[j] * buf[bufOffs + j + (i + ni * ncm) * ncf];
    }
    if (ifl <= 1) {
      return 0;
    }
    /*
     *       if velocity interpolation is wanted, be sure enough
     *       derivative polynomials have been generated and stored.
     */
    bma = (na + na) / intv;
    vc[2] = twot + twot;
    if (nv_interp < ncf) {
      for (i = nv_interp; i < ncf; ++i)
        vc[i] = twot * vc[i - 1] + pc[i - 1] + pc[i - 1] - vc[i - 2];
      nv_interp = ncf;
    }
    /*       interpolate to get velocity for each component */
    for (i = 0; i < ncm; ++i) {
      pv[pvOffs + i + ncm] = 0.;
      for (j = ncf-1; j >= 1; --j)
        pv[pvOffs + i + ncm] += vc[j] * buf[bufOffs + j + (i + ni * ncm) * ncf];
      pv[pvOffs + i + ncm] *= bma;
    }
    if (ifl == 2) {
      return 0;
    }
    /*       check acceleration polynomial values, and */
    /*       re-do if necessary */
    bma2 = bma * bma;
    ac[3] = pc[1] * 24.;
    if (nac_interp < ncf) {
      nac_interp = ncf;
      for (i = nac_interp; i < ncf; ++i)
        ac[i] = twot * ac[i - 1] + vc[i - 1] * 4. - ac[i - 2];
    }
    /*       get acceleration for each component */
    for (i = 0; i < ncm; ++i) {
      pv[pvOffs + i + ncm * 2] = 0.;
      for (j = ncf-1; j >= 2; --j)
        pv[pvOffs + i + ncm * 2] += ac[j] * buf[bufOffs + j + (i + ni * ncm) * ncf];
      pv[pvOffs + i + ncm * 2] *= bma2;
    }
    if (ifl == 3) {
      return 0;
    }
    /*       check jerk polynomial values, and */
    /*       re-do if necessary */
    bma3 = bma * bma2;
    jc[4] = pc[1] * 192.;
    if (njk_interp < ncf) {
      njk_interp = ncf;
      for (i = njk_interp; i < ncf; ++i)
        jc[i] = twot * jc[i - 1] + ac[i - 1] * 6. - jc[i - 2];
    }
    /*       get jerk for each component */
    for (i = 0; i < ncm; ++i) {
      pv[pvOffs + i + ncm * 3] = 0.;
      for (j = ncf-1; j >= 3; --j)
        pv[pvOffs + i + ncm * 3] += jc[j] * buf[bufOffs + j + (i + ni * ncm) * ncf];
      pv[pvOffs + i + ncm * 3] *= bma3;
    }
    return 0;
  }

  /*
   | ********** state ********************
   | this subroutine reads and interpolates the jpl planetary ephemeris file
   |  calling sequence parameters:
   |  input:
   |     et    dp julian ephemeris epoch at which interpolation is wanted.
   |     list  12-word integer array specifying what interpolation
   |           is wanted for each of the bodies on the file.
   |                      list(i)=0, no interpolation for body i
   |                             =1, position only
   |                             =2, position and velocity
   |            the designation of the astronomical bodies by i is:
   |                      i = 0: mercury
   |                        = 1: venus
   |                        = 2: earth-moon barycenter, NOT earth!
   |                        = 3: mars
   |                        = 4: jupiter
   |                        = 5: saturn
   |                        = 6: uranus
   |                        = 7: neptune
   |                        = 8: pluto
   |                        = 9: geocentric moon
   |                        =10: nutations in longitude and obliquity
   |                        =11: lunar librations (if on file)
   |            If called with list = NULL, only the header records are read and
   |            stored in the global areas.
   |  do_bary   short, if true, barycentric, if false, heliocentric.
   |              only the 9 planets 0..8 are affected by it.
   |  output:
   |       pv   dp 6 x 11 array that will contain requested interpolated
   |            quantities.  the body specified by list(i) will have its
   |            state in the array starting at pv(1,i).  (on any given
   |            call, only those words in 'pv' which are affected by the
   |            first 10 'list' entries (and by list(11) if librations are
   |            on the file) are set.  the rest of the 'pv' array
   |            is untouched.)  the order of components starting in
   |            pv is: x,y,z,dx,dy,dz.
   |            all output vectors are referenced to the earth mean
   |            equator and equinox of epoch. the moon state is always
   |            geocentric; the other nine states are either heliocentric
   |            or solar-system barycentric, depending on the setting of
   |            common flags (see below).
   |            lunar librations, if on file, are put into pv(k,10) if
   |            list(11) is 1 or 2.
   |    pvsun   dp 6-word array containing the barycentric position and
   |            velocity of the sun.
   |      nut   dp 4-word array that will contain nutations and rates,
   |            depending on the setting of list(10).  the order of
   |            quantities in nut is:
   |                     d psi  (nutation in longitude)
   |                     d epsilon (nutation in obliquity)
   |                     d psi dot
   |                     d epsilon dot
   |  globals used:
   |    do_km   logical flag defining physical units of the output states.
   |            TRUE = return km and km/sec, FALSE = return au and au/day
   |            default value = FALSE  (km determines time unit
   |            for nutations and librations.  angle unit is always radians.)
   */
  int irecsz_state;
  int nrl_state, lpt_state[]=new int[3], ncoeffs_state;
  private int state(double et, int[] list, boolean do_bary, double[] pv,
                    double[] pvsun, double[] nut, StringBuffer serr)
      throws SwissephException {
    int i, j, k;
    long flen;
    int nseg, nb;
    double[] buf = js.buf;
    double aufac=0., s, t=0., intv=0.;
    int nrecl, ksize;
    int nr;
    double et_mn, et_fr;
    int[] ipt = js.eh_ipt;
    String ch_ttl="";  // JAVA: Not used???
    boolean ferr=false;
    try {
      if (js.jplfptr == null ||
          (js.jplfptr.fp == null && js.jplfptr.sk == null)) {
        // fsizer() throws SwissephException
        ksize = fsizer(serr); /* the number of single precision words in a record */
        nrecl = 4;
        if (ksize < 0) {
          if (serr != null && ksize != SwephData.NOT_AVAILABLE) {
            serr.setLength(0);
            serr.append("fsizer does not work");/**/
          }
          throw new SwissephException(et, SwissephException.DATA_FILE_ERROR,  // Or is it some other error???
              (int)ksize, serr);
        }
        irecsz_state = nrecl * ksize;     /* record size in bytes */
        ncoeffs_state = ksize / 2;        /* # of coefficients, doubles */
        /* ttl = ephemeris title, e.g.
         * "JPL Planetary Ephemeris DE404/LE404
         *  Start Epoch: JED=   625296.5-3001 DEC 21 00:00:00
         *  Final Epoch: JED=  2817168.5 3001 JAN 17 00:00:00c */
//      fread((void *) &ch_ttl[0], 1, 252, js.jplfptr);
        for(int m=0;m<252;m++) {
          ch_ttl+=(char)js.jplfptr.readByte();
        }
        /* cnam = names of constants */
//      fread((void *) js.ch_cnam, 1, 2400, js.jplfptr);
        for(int m=0;m<2400;m++) {
          js.ch_cnam+=(char)js.jplfptr.readByte();
        }
        /* ss[0] = start epoch of ephemeris
         * ss[1] = end epoch
         * ss[2] = segment size in days */
//      fread((void *) &js.eh_ss[0], sizeof(double), 3, js.jplfptr);
        for(int m=0;m<3;m++) {
          js.eh_ss[m]=js.jplfptr.readDouble();
        }
//      if (js.do_reorder)
//        reorder((char *) &js.eh_ss[0], sizeof(double), 3);
        /* ncon = number of constants */
//      fread((void *) &js.eh_ncon, sizeof(long), 1, js.jplfptr);
        js.eh_ncon=js.jplfptr.readInt();
//      if (js.do_reorder)
//        reorder((char *) &js.eh_ncon, sizeof(long), 1);
        /* au = astronomical unit */
//      fread((void *) &js.eh_au, sizeof(double), 1, js.jplfptr);
        js.eh_au=js.jplfptr.readDouble();
//      if (js.do_reorder)
//        reorder((char *) &js.eh_au, sizeof(double), 1);
        /* emrat = earth moon mass ratio */
//      fread((void *) &js.eh_emrat, sizeof(double), 1, js.jplfptr);
        js.eh_emrat=js.jplfptr.readDouble();
//      if (js.do_reorder)
//        reorder((char *) &js.eh_emrat, sizeof(double), 1);
        /* ipt[i+0]: coefficients of planet i start at buf[ipt[i+0]-1]
         * ipt[i+1]: number of coefficients (interpolation order - 1)
         * ipt[i+2]: number of intervals in segment */
//      fread((void *) &ipt[0], sizeof(long), 36, js.jplfptr);
        for(int m=0;m<36;m++) {
          ipt[m]=js.jplfptr.readInt();
        }
//      if (js.do_reorder)
//        reorder((char *) &ipt[0], sizeof(long), 36);
        /* numde = number of jpl ephemeris "404" with de404 */
//      fread((void *) &js.eh_denum, sizeof(long), 1, js.jplfptr);
        js.eh_denum=js.jplfptr.readInt();
//      if (js.do_reorder)
//        reorder((char *) &js.eh_denum, sizeof(long), 1);
//      fread((void *) &lpt[0], sizeof(long), 3, js.jplfptr);
        for(int m=0;m<3;m++) {
          lpt_state[m]=js.jplfptr.readInt();
        }
//      if (js.do_reorder)
//        reorder((char *) &lpt[0], sizeof(long), 3);
        /* cval[]:  other constants in next record */
//      fseek(js.jplfptr, 1L * irecsz, 0);
        js.jplfptr.seek(1L * irecsz_state);
//      fread((void *) &js.eh_cval[0], sizeof(double), 400, js.jplfptr);
        for(int m=0;m<400;m++) {
          js.eh_cval[m]=js.jplfptr.readDouble();
        }
//      if (js.do_reorder)
//        reorder((char *) &js.eh_cval[0], sizeof(double), 400);
        js.jplfptr.seek(2L * irecsz_state);
        for (i = 0; i < 3; ++i)
          ipt[i + 36] = lpt_state[i];
        nrl_state = 0;
        /* is file length correct? */
        /* file length */
//      fseek(js.jplfptr, 0L, SEEK_END);
//      flen = ftell(js.jplfptr);
        flen=js.jplfptr.length();
        /* # of segments in file */
        nseg = (int) ((js.eh_ss[1] - js.eh_ss[0]) / js.eh_ss[2]);
        /* sum of all cheby coeffs of all planets and segments */
        for(i = 0, nb = 0; i < 13; i++) {
          k = 3;
          if (i == 11) {
            k = 2;
          }
          nb += (ipt[i*3+1] * ipt[i*3+2]) * k * nseg;
        }
        /* add start and end epochs of segments */
        nb += 2 * nseg;
        /* doubles to bytes */
        nb *= 8;
        /* add size of header and constants section */
        nb += 2 * ksize * nrecl;
        if (flen != nb
          /* some of our files are one record too long */
          && flen - nb != ksize * nrecl) {
          if (serr != null) {
            serr.setLength(0);
            serr.append("JPL ephemeris file is mutilated; length = "+flen+" instead of "+nb+".");
            if (serr.length() + js.jplfname.length() < SwissData.AS_MAXCH - 1) {
              serr.setLength(0); // Nanu???
              serr.append("JPL ephemeris file "+js.jplfname+" is mutilated; length = "+flen+" instead of "+nb+".");
            }
          }
          throw new SwissephException(et, SwissephException.FILE_READ_ERROR,
              SweConst.ERR, serr);
        }
      }
      if (list == null) {
        return 0;
      }
      s = et - .5;
      et_mn = Math.floor(s);
      et_fr = s - et_mn;    /* fraction of days since previous midnight */
      et_mn += .5;  /* midnight before epoch */
      /*       error return for epoch out of range */
      if (et < js.eh_ss[0] || et > js.eh_ss[1]) {
        if (serr != null) {
          serr.setLength(0);
          serr.append("jd "+et+" outside JPL eph. range "+js.eh_ss[0]+" .. "+js.eh_ss[1]+";");
        }
        throw new SwissephException(et, SwissephException.OUT_OF_TIME_RANGE,
            SwephData.BEYOND_EPH_LIMITS, serr);
      }
      /*       calculate record # and relative time in interval */
      nr = (int) ((et_mn - js.eh_ss[0]) / js.eh_ss[2]) + 2;
      if (et_mn == js.eh_ss[1]) {
        --nr;       /* end point of ephemeris, use last record */
      }
      t = (et_mn - ((nr - 2) * js.eh_ss[2] + js.eh_ss[0]) + et_fr) / js.eh_ss[2];
      /* read correct record if not in core */
      if (nr != nrl_state) {
        nrl_state = nr;
        js.jplfptr.seek(nr * irecsz_state);
        for (k = 1; k <= ncoeffs_state; ++k) {
//        if ( fread((void *) &buf[k - 1], sizeof(double), 1, js.jplfptr) != 1) {

          buf[k - 1]=js.jplfptr.readDouble();
//        }
//        if (js.do_reorder)
//          reorder((char *) &buf[k-1], sizeof(double), 1);
        }
      }
      if (js.do_km) {
        intv = js.eh_ss[2] * 86400.;
        aufac = 1.;
      } else {
        intv = js.eh_ss[2];
        aufac = 1. / js.eh_au;
      }
      /*   interpolate ssbary sun */
    } catch (java.io.EOFException ef) {
      ferr=true;
    } catch (java.io.IOException ie) {
      ferr=true;
    }
    if (ferr) {
      if (serr != null) {
        serr.setLength(0);
        serr.append("Read error in JPL eph. at "+et+"\n");
      }
      throw new SwissephException(et, SwissephException.FILE_READ_ERROR,
          SweConst.ERR, serr);
    }
    interp(buf, (int) ipt[30] - 1, t, intv, ipt[31], 3, ipt[32], 2, pvsun, 0);
    for (i = 0; i < 6; ++i) {
      pvsun[i] *= aufac;
    }
    /*   check and interpolate whichever bodies are requested */
    for (i = 0; i < 10; ++i) {
      if (list[i] > 0) {
        interp(buf, (int) ipt[i * 3] - 1, t, intv, ipt[i * 3 + 1], 3,
               ipt[i * 3 + 2], list[i], pv, i * 6);
        for (j = 0; j < 6; ++j) {
          if (i < 9 && ! do_bary) {
            pv[j + i * 6] = pv[j + i * 6] * aufac - pvsun[j];
          } else {
            pv[j + i * 6] *= aufac;
          }
        }
      }
    }
    /*       do nutations if requested (and if on file) */
    if (list[10] > 0 && ipt[34] > 0) {
      interp(buf, (int) ipt[33] - 1, t, intv, ipt[34], 2, ipt[35],
               list[10], nut, 0);
    }
    /*       get librations if requested (and if on file) */
    if (list[11] > 0 && ipt[37] > 0) {
      interp(buf, (int) ipt[36] - 1, t, intv, ipt[37], 3, ipt[38], list[1],
              pv, 60);
    }
    return SweConst.OK;
  }

  /*
   *  this entry obtains the constants from the ephemeris file
   *  call state to initialize the ephemeris and read in the constants
   */
  private int read_const_jpl(double[] ss,  StringBuffer serr) throws SwissephException {
    int i;
    // throws SwissephException if !SweConst.OK:
    state(0.0, null, false, null, null, null, serr);

    for (i = 0; i < 3; i++)
      ss[i] = js.eh_ss[i];
    return SweConst.OK;
  }

//  void reorder(char *x, int size, int number) {
//    int i, j;
//    char s[8];
//    char *sp1 = x;
//    char *sp2 = &s[0];
//    for (i = 0; i < number; i++) {
//      for (j = 0; j < size; j++)
//        *(sp2 + j) = *(sp1 + size - j - 1);
//      for (j = 0; j < size; j++)
//        *(sp1 + j) = *(sp2 + j);
//      sp1 += size;
//    }
//  }

  void swi_close_jpl_file() {
    if (js != null) {
      try {
        if (js.jplfptr != null) {
          js.jplfptr.close();
        }
      } catch (java.io.IOException e) {
      }
      if (js.jplfname != null) {
        js.jplfname = null;
      }
      if (js.jplfpath != null) {
        js.jplfpath = null;
      }
      js = null;
    }
  }

  int swi_open_jpl_file(double[] ss, String fname, String fpath,
                                StringBuffer serr) throws SwissephException {
    int retc = SweConst.OK;
    /* if open, return */
    if (js != null && js.jplfptr != null) {
      return SweConst.OK;
    }
    js=new JplSave();
/*
    if ((js = (struct jpl_save *) CALLOC(1, sizeof(struct jpl_save))) == null
      || (js.jplfname = MALLOC(strlen(fname)+1)) == null
      || (js.jplfpath = MALLOC(strlen(fpath)+1)) == null
      ) {
      if (serr != null)
        strcpy(serr, "error in malloc() with JPL ephemeris.");
      return SweConst.ERR;
    }
*/
    js.jplfname=fname;
    js.jplfpath=fpath;
    try {
      retc = read_const_jpl(ss, serr);
    } catch (SwissephException se) {
      swi_close_jpl_file();
      throw se;
    }

    /* intializations for function interpol() */
    js.pc[0] = 1;
    js.pc[1] = 2;
    js.vc[1] = 1;
    js.ac[2] = 4;
    js.jc[3] = 24;

    return retc;
  }

  int swi_get_jpl_denum() {
    return js.eh_denum;
  }

  double[] getJPLRange(String fname) throws SwissephException {
    double start=0./0., end=0./0.;
    FilePtr fp = null;
    try {
      fp = sw.swi_fopen(SwephData.SEI_FILE_PLANET, fname, swed.ephepath, null);
      fp.seek(252+6*400);
      start = fp.readDouble();
      end = fp.readDouble();
    } catch (SwissephException e) {
      throw e;
    } catch (Exception e) {
    }
    try { fp.close(); } catch (Exception e) { }
    return new double[]{start, end};
  }
}


class JplSave {
  String jplfname=null;
  String jplfpath=null;
  FilePtr jplfptr=null;
//  boolean do_reorder;
  double eh_cval[]=new double[400];
  double eh_ss[]=new double[3], eh_au, eh_emrat;
  int eh_denum, eh_ncon, eh_ipt[]=new int[39];
  String ch_cnam="";
  double pv[]=new double[78];
  double pvsun[]=new double[6];
  double buf[]=new double[1500];
  double pc[]=new double[18], vc[]=new double[18],
         ac[]=new double[18], jc[]=new double[18];
  boolean do_km;
}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class SwephMosh {

  SwissLib sl=null;
  SwissEph sw=null;
  SwissData swed=null;
  Swemmoon sm=null;
  SweDate sd=null;


  private static final double TIMESCALE=3652500.0;
  private static final int FICT_GEO=1;
  private static final int pnoint2msh[] = {2, 2, 0, 1, 3, 4, 5, 6, 7, 8};

  /* From Simon et al (1994)  */
  private static final double freqs[] = {
  /* Arc sec per 10000 Julian years.  */
    53810162868.8982,
    21066413643.3548,
    12959774228.3429,
    6890507749.3988,
    1092566037.7991,
    439960985.5372,
    154248119.3933,
    78655032.0744,
    52272245.1795
  };

  private static final double phases[] = {
  /* Arc sec.  */
    252.25090552 * 3600.,
    181.97980085 * 3600.,
    100.46645683 * 3600.,
    355.43299958 * 3600.,
    34.35151874 * 3600.,
    50.07744430 * 3600.,
    314.05500511 * 3600.,
    304.34866548 * 3600.,
    860492.1546,
  };

  double ss[][]=new double[9][24];
  double cc[][]=new double[9][24];



  SwephMosh(SwissLib sl, SwissEph sw, SwissData swed) {
    this.sl    = sl;
    this.sw    = sw;
    this.swed  = swed;
    this.sm    = new Swemmoon();
    if (this.sl   ==null) { this.sl   =new SwissLib(); }
    if (this.sw   ==null) { this.sw   =new SwissEph(); }
    if (this.swed ==null) { this.swed =new SwissData(); }
  }



  private int swi_moshplan2 (double J, int iplm, double[] pobj) {
    int i, j, k, m, k1, ip, np, nt;
    byte p[]; int pOff=0;
    double pl[], pb[], pr[]; int plOff=0, pbOff=0, prOff=0;
    double su, cu, sv, cv, T;
    double t, sl, sb, sr;
    Plantbl plan = planets[iplm];

    T = (J - SwephData.J2000) / TIMESCALE;
    /* Calculate sin( i*MM ), etc. for needed multiple angles.  */
    for (i = 0; i < 9; i++) {
      if ((j = plan.max_harmonic[i]) > 0) {
        sr = (sm.mods3600 (freqs[i] * T) + phases[i]) * SwephData.STR;
        sscc (i, sr, j);
      }
    }

    /* Point to start of table of arguments. */
    p = plan.arg_tbl;
    /* Point to tabulated cosine and sine amplitudes.  */
    pl = plan.lon_tbl;
    pb = plan.lat_tbl;
    pr = plan.rad_tbl;
    sl = 0.0;
    sb = 0.0;
    sr = 0.0;

    for (;;)
      {
        /* argument of sine and cosine */
        /* Number of periodic arguments. */
        np = p[pOff++];
        if (np < 0) {
          break;
        }
        if (np == 0) {                       /* It is a polynomial term.  */
            nt = p[pOff++];
            /* Longitude polynomial. */
            cu = pl[plOff++];
            for (ip = 0; ip < nt; ip++)
              {
                cu = cu * T + pl[plOff++];
              }
            sl +=  sm.mods3600 (cu);
            /* Latitude polynomial. */
            cu = pb[pbOff++];
            for (ip = 0; ip < nt; ip++)
              {
                cu = cu * T + pb[pbOff++];
              }
            sb += cu;
            /* Radius polynomial. */
            cu = pr[prOff++];
            for (ip = 0; ip < nt; ip++)
              {
                cu = cu * T + pr[prOff++];
              }
            sr += cu;
            continue;
          }
        k1 = 0;
        cv = 0.0;
        sv = 0.0;
        for (ip = 0; ip < np; ip++)
          {
            /* What harmonic.  */
            j = p[pOff++];
            /* Which planet.  */
            m = p[pOff++] - 1;
            if (j!=0) {
                k = j;
                if (j < 0) {
                  k = -k;
                }
                k -= 1;
                su = ss[m][k];    /* sin(k*angle) */
                if (j < 0) {
                  su = -su;
                }
                cu = cc[m][k];
                if (k1 == 0) {               /* set first angle */
                    sv = su;
                    cv = cu;
                    k1 = 1;
                  }
                else
                  {               /* combine angles */
                    t = su * cv + cu * sv;
                    cv = cu * cv - su * sv;
                    sv = t;
                  }
              }
          }
        /* Highest power of T.  */
        nt = p[pOff++];
        /* Longitude. */
        cu = pl[plOff++];
        su = pl[plOff++];
        for (ip = 0; ip < nt; ip++)
          {
            cu = cu * T + pl[plOff++];
            su = su * T + pl[plOff++];
          }
        sl += cu * cv + su * sv;
        /* Latitiude. */
        cu = pb[pbOff++];
        su = pb[pbOff++];
        for (ip = 0; ip < nt; ip++)
          {
            cu = cu * T + pb[pbOff++];
            su = su * T + pb[pbOff++];
          }
        sb += cu * cv + su * sv;
        /* Radius. */
        cu = pr[prOff++];
        su = pr[prOff++];
        for (ip = 0; ip < nt; ip++)
          {
            cu = cu * T + pr[prOff++];
            su = su * T + pr[prOff++];
          }
        sr += cu * cv + su * sv;
      }
    pobj[0] = SwephData.STR * sl;
    pobj[1] = SwephData.STR * sb;
    pobj[2] = SwephData.STR * plan.distance * sr + plan.distance;
    return SweConst.OK;
  }

  /* Moshier ephemeris.
   * computes heliocentric cartesian equatorial coordinates of
   * equinox 2000
   * for earth and a planet
   * tjd          julian day
   * ipli         internal SWEPH planet number
   * xp           array of 6 doubles for planet's position and speed
   * xe                                  earth's
   * serr         error string
   */
  int swi_moshplan(double tjd, int ipli, boolean do_save, double[] xpret,
                   double[] xeret, StringBuffer serr) {
    int i;
    boolean do_earth = false;
    double dx[]=new double[3], x2[]=new double[3],
           xxe[]=new double[6], xxp[]=new double[6];
    double xp[], xe[];
    double dt;
    String s;
    int iplm = pnoint2msh[ipli];
    PlanData pdp = swed.pldat[ipli];
    PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
    double seps2000 = swed.oec2000.seps;
    double ceps2000 = swed.oec2000.ceps;
    if (do_save) {
      xp = pdp.x;
      xe = pedp.x;
    } else {
      xp = xxp;
      xe = xxe;
    }
    if (do_save || ipli == SwephData.SEI_EARTH || xeret != null) {
      do_earth = true;
    }
    /* tjd beyond ephemeris limits, give some margin for spped at edge */
    if (tjd < SwephData.MOSHPLEPH_START - 0.3 ||
        tjd > SwephData.MOSHPLEPH_END + 0.3) {
      if (serr != null) {
        serr.setLength(0);
        s="jd "+tjd+" outside Moshier planet range "+
          SwephData.MOSHPLEPH_START+" .. "+
          SwephData.MOSHPLEPH_END+" ";
        if (serr.length() + s.length() < SwissData.AS_MAXCH) {
          serr.append(s);
        }
      }
      return(SweConst.ERR);
    }
    /* earth, for geocentric position */
    if (do_earth) {
      if (tjd == pedp.teval && pedp.iephe == SweConst.SEFLG_MOSEPH) {
        xe = pedp.x;
      } else {
        /* emb */
        swi_moshplan2(tjd, pnoint2msh[SwephData.SEI_EMB], xe); /* emb hel. ecl. 2000 polar */
        sl.swi_polcart(xe, xe);                        /* to cartesian */
        sl.swi_coortrf2(xe, xe, -seps2000, ceps2000);/* and equator 2000 */
        embofs_mosh(tjd, xe);               /* emb -> earth */
        if (do_save) {
          pedp.teval = tjd;
          pedp.xflgs = -1;
          pedp.iephe = SweConst.SEFLG_MOSEPH;
        }
        /* one more position for speed. */
        swi_moshplan2(tjd - SwephData.PLAN_SPEED_INTV, pnoint2msh[SwephData.SEI_EMB], x2);
        sl.swi_polcart(x2, x2);
        sl.swi_coortrf2(x2, x2, -seps2000, ceps2000);
        embofs_mosh(tjd - SwephData.PLAN_SPEED_INTV, x2);/**/
        for (i = 0; i <= 2; i++)
          dx[i] = (xe[i] - x2[i]) / SwephData.PLAN_SPEED_INTV;
        /* store speed */
        for (i = 0; i <= 2; i++) {
          xe[i+3] = dx[i];
        }
      }
      if (xeret != null) {
        for (i = 0; i <= 5; i++) {
          xeret[i] = xe[i];
        }
      }
    }
    /* earth is the planet wanted */
    if (ipli == SwephData.SEI_EARTH) {
      xp = xe;
    } else {
      /* other planet */
      /* if planet has already been computed, return */
      if (tjd == pdp.teval && pdp.iephe == SweConst.SEFLG_MOSEPH) {
        xp = pdp.x;
      } else {
        swi_moshplan2(tjd, iplm, xp);
        sl.swi_polcart(xp, xp);
        sl.swi_coortrf2(xp, xp, -seps2000, ceps2000);
        if (do_save) {
          pdp.teval = tjd;/**/
          pdp.xflgs = -1;
          pdp.iephe = SweConst.SEFLG_MOSEPH;
        }
        /* one more position for speed.
         * the following dt gives good speed for light-time correction
         */
        dt = SwephData.PLAN_SPEED_INTV;
        swi_moshplan2(tjd - dt, iplm, x2);
        sl.swi_polcart(x2, x2);
        sl.swi_coortrf2(x2, x2, -seps2000, ceps2000);
        for (i = 0; i <= 2; i++)
          dx[i] = (xp[i] - x2[i]) / dt;
        /* store speed */
        for (i = 0; i <= 2; i++) {
          xp[i+3] = dx[i];
        }
      }
      if (xpret != null) {
        for (i = 0; i <= 5; i++) {
          xpret[i] = xp[i];
        }
      }
    }
    return(SweConst.OK);
  }


  /* Prepare lookup table of sin and cos ( i*Lj )
   * for required multiple angles
   */
  private void sscc (int k, double arg, int n) {
    double cu, su, cv, sv, s;
    int i;

    su = Math.sin (arg);
    cu = Math.cos (arg);
    ss[k][0] = su;                /* sin(L) */
    cc[k][0] = cu;                /* cos(L) */
    sv = 2.0 * su * cu;
    cv = cu * cu - su * su;
    ss[k][1] = sv;                /* sin(2L) */
    cc[k][1] = cv;
    for (i = 2; i < n; i++)
      {
        s = su * cv + cu * sv;
        cv = cu * cv - su * sv;
        sv = s;
        ss[k][i] = sv;            /* sin( i+1 L ) */
        cc[k][i] = cv;
      }
  }


  /* Adjust position from Earth-Moon barycenter to Earth
   *
   * J = Julian day number
   * xemb = rectangular equatorial coordinates of Earth
   */
  private void embofs_mosh(double tjd, double xemb[]) {
    double T, M, a, L, B, p;
    double smp, cmp, s2mp, c2mp, s2d, c2d, sf, cf;
    double s2f, sx, cx, xyz[]=new double[6];
    double seps = swed.oec.seps;
    double ceps = swed.oec.ceps;
    int i;
    /* Short series for position of the Moon
     */
    T = (tjd-SwephData.J1900)/36525.0;
    /* Mean anomaly of moon (MP) */
    a = sl.swe_degnorm(((1.44e-5*T + 0.009192)*T + 477198.8491)*T + 296.104608);
    a *= SwissData.DEGTORAD;
    smp = Math.sin(a);
    cmp = Math.cos(a);
    s2mp = 2.0*smp*cmp;           /* sin(2MP) */
    c2mp = cmp*cmp - smp*smp;     /* cos(2MP) */
    /* Mean elongation of moon (D) */
    a = sl.swe_degnorm(((1.9e-6*T - 0.001436)*T + 445267.1142)*T + 350.737486);
    a  = 2.0 * SwissData.DEGTORAD * a;
    s2d = Math.sin(a);
    c2d = Math.cos(a);
    /* Mean distance of moon from its ascending node (F) */
    a = sl.swe_degnorm((( -3.e-7*T - 0.003211)*T + 483202.0251)*T + 11.250889);
    a  *= SwissData.DEGTORAD;
    sf = Math.sin(a);
    cf = Math.cos(a);
    s2f = 2.0*sf*cf;      /* sin(2F) */
    sx = s2d*cmp - c2d*smp;       /* sin(2D - MP) */
    cx = c2d*cmp + s2d*smp;       /* cos(2D - MP) */
    /* Mean longitude of moon (LP) */
    L = ((1.9e-6*T - 0.001133)*T + 481267.8831)*T + 270.434164;
    /* Mean anomaly of sun (M) */
    M = sl.swe_degnorm((( -3.3e-6*T - 1.50e-4)*T + 35999.0498)*T + 358.475833);
    /* Ecliptic longitude of the moon */
    L =   L
          + 6.288750*smp
          + 1.274018*sx
          + 0.658309*s2d
          + 0.213616*s2mp
          - 0.185596*Math.sin( SwissData.DEGTORAD * M )
          - 0.114336*s2f;
    /* Ecliptic latitude of the moon */
    a = smp*cf;
    sx = cmp*sf;
    B =     5.128189*sf
          + 0.280606*(a+sx)               /* sin(MP+F) */
          + 0.277693*(a-sx)               /* sin(MP-F) */
          + 0.173238*(s2d*cf - c2d*sf);   /* sin(2D-F) */
    B *= SwissData.DEGTORAD;
    /* Parallax of the moon */
    p =    0.950724
          +0.051818*cmp
          +0.009531*cx
          +0.007843*c2d
          +0.002824*c2mp;
    p *= SwissData.DEGTORAD;
    /* Elongation of Moon from Sun
     */
    L = sl.swe_degnorm(L);
    L *= SwissData.DEGTORAD;
    /* Distance in au */
    a = 4.263523e-5/Math.sin(p);
    /* Convert to rectangular ecliptic coordinates */
    xyz[0] = L;
    xyz[1] = B;
    xyz[2] = a;
    sl.swi_polcart(xyz, xyz);
    /* Convert to equatorial */
    sl.swi_coortrf2(xyz, xyz, -seps, ceps);
    /* Precess to equinox of J2000.0 */
    sl.swi_precess(xyz, tjd, SwephData.J_TO_J2000);/**/
    /* now emb -> earth */
    for (i = 0; i <= 2; i++)
      xemb[i] -= xyz[i] / (SwephData.EARTH_MOON_MRAT + 1.0);
  }

  /* orbital elements of planets that are computed from osculating elements
   *   epoch
   *   equinox
   *   mean anomaly,
   *   semi axis,
   *   eccentricity,
   *   argument of perihelion,
   *   ascending node
   *   inclination
   */
                                  /* use James Neely's revised elements
                                   *      of Uranian planets*/
  static final String plan_fict_nam[] =
    {"Cupido", "Hades", "Zeus", "Kronos",
     "Apollon", "Admetos", "Vulkanus", "Poseidon",
     "Isis-Transpluto", "Nibiru", "Harrington",
     "Leverrier", "Adams",
     "Lowell", "Pickering",};

  String swi_get_fict_name(int ipl, String snam) {
    if (snam==null) { snam=""; }
    StringBuffer sbnam=new StringBuffer(snam);
    if (read_elements_file(ipl, 0, null, null,
         null, null, null, null, null, null,
         sbnam, null, null) == SweConst.ERR) {
      return "name not found";
    }
    return sbnam.toString();
  }

  private static final double plan_oscu_elem[][]=new double[][] {
    {SwephData.J1900, SwephData.J1900, 163.7409, 40.99837, 0.00460, 171.4333, 129.8325, 1.0833},/* Cupido Neely */
    {SwephData.J1900, SwephData.J1900,  27.6496, 50.66744, 0.00245, 148.1796, 161.3339, 1.0500},/* Hades Neely */
    {SwephData.J1900, SwephData.J1900, 165.1232, 59.21436, 0.00120, 299.0440,   0.0000, 0.0000},/* Zeus Neely */
    {SwephData.J1900, SwephData.J1900, 169.0193, 64.81960, 0.00305, 208.8801,   0.0000, 0.0000},/* Kronos Neely */
    {SwephData.J1900, SwephData.J1900, 138.0533, 70.29949, 0.00000,   0.0000,   0.0000, 0.0000},/* Apollon Neely */
    {SwephData.J1900, SwephData.J1900, 351.3350, 73.62765, 0.00000,   0.0000,   0.0000, 0.0000},/* Admetos Neely */
    {SwephData.J1900, SwephData.J1900,  55.8983, 77.25568, 0.00000,   0.0000,   0.0000, 0.0000},/* Vulcanus Neely */
    {SwephData.J1900, SwephData.J1900, 165.5163, 83.66907, 0.00000,   0.0000,   0.0000, 0.0000},/* Poseidon Neely */
    /* Isis-Transpluto; elements from "Die Sterne" 3/1952, p. 70ff.
     * Strubell does not give an equinox. 1945 is taken to best reproduce
     * ASTRON ephemeris. (This is a strange choice, though.)
     * The epoch is 1772.76. The year is understood to have 366 days.
     * The fraction is counted from 1 Jan. 1772 */
    {2368547.66, 2431456.5, 0.0, 77.775, 0.3, 0.7, 0, 0},
    /* Nibiru, elements from Christian Woeltge, Hannover */
    {1856113.380954, 1856113.380954, 0.0, 234.8921, 0.981092, 103.966, -44.567, 158.708},
    /* Harrington, elements from Astronomical Journal 96(4), Oct. 1988 */
    {2374696.5, SwephData.J2000, 0.0, 101.2, 0.411, 208.5, 275.4, 32.4},
    /* Leverrier's Neptune,
          according to W.G. Hoyt, "Planets X and Pluto", Tucson 1980, p. 63 */
    {2395662.5, 2395662.5, 34.05, 36.15, 0.10761, 284.75, 0, 0},
    /* Adam's Neptune */
    {2395662.5, 2395662.5, 24.28, 37.25, 0.12062, 299.11, 0, 0},
    /* Lowell's Pluto */
    {2425977.5, 2425977.5, 281, 43.0, 0.202, 204.9, 0, 0},
    /* Pickering's Pluto */
    {2425977.5, 2425977.5, 48.95, 55.1, 0.31, 280.1, 100, 15}, /**/
  };

  /* computes a planet from osculating elements *
   * tjd          julian day
   * ipl          body number
   * ipli         body number in planetary data structure
   * iflag        flags
   */
  int swi_osc_el_plan(double tjd, double xp[], int ipl, int ipli,
                      double[] xearth, double[] xsun, StringBuffer serr) {
    double pqr[]=new double[9], x[]=new double[6];
    double eps, K, fac, rho, cose, sine;
    double alpha, beta, zeta, sigma, M2, Msgn, M_180_or_0;
    DblObj tjd0=new DblObj();
    DblObj tequ=new DblObj();
    DblObj mano=new DblObj();
    DblObj sema=new DblObj();
    DblObj ecce=new DblObj();
    DblObj parg=new DblObj();
    DblObj node=new DblObj();
    DblObj incl=new DblObj();
    double dmot;
    double cosnode, sinnode, cosincl, sinincl, cosparg, sinparg;
    double M, E;
    PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
    PlanData pdp = swed.pldat[ipli];
    IntObj fict_ifl = new IntObj(); fict_ifl.val = 0;
    int i;
    /* orbital elements, either from file or, if file not found,
     * from above built-in set
     */
    if (read_elements_file(ipl, tjd, tjd0, tequ,
         mano, sema, ecce, parg, node, incl,
         null, fict_ifl, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    dmot = 0.9856076686 * SwissData.DEGTORAD / sema.val / Math.sqrt(sema.val);
                                                            /* daily motion */
    if ((fict_ifl.val & FICT_GEO) != 0) {
      dmot /= Math.sqrt(SwephData.SUN_EARTH_MRAT);
    }
    cosnode = Math.cos(node.val);
    sinnode = Math.sin(node.val);
    cosincl = Math.cos(incl.val);
    sinincl = Math.sin(incl.val);
    cosparg = Math.cos(parg.val);
    sinparg = Math.sin(parg.val);
    /* Gaussian vector */
    pqr[0] = cosparg * cosnode - sinparg * cosincl * sinnode;
    pqr[1] = -sinparg * cosnode - cosparg * cosincl * sinnode;
    pqr[2] = sinincl * sinnode;
    pqr[3] = cosparg * sinnode + sinparg * cosincl * cosnode;
    pqr[4] = -sinparg * sinnode + cosparg * cosincl * cosnode;
    pqr[5] = -sinincl * cosnode;
    pqr[6] = sinparg * sinincl;
    pqr[7] = cosparg * sinincl;
    pqr[8] = cosincl;
    /* Kepler problem */
    E = M = sl.swi_mod2PI(mano.val + (tjd - tjd0.val) * dmot); /* mean anomaly of date*/
    /* better E for very high eccentricity and small M */
    if (ecce.val > 0.975) {
      M2 = M * SwissData.RADTODEG;
      if (M2 > 150 && M2 < 210) {
        M2 -= 180;
        M_180_or_0 = 180;
      } else
        M_180_or_0 = 0;
      if (M2 > 330) {
        M2 -= 360;
      }
      if (M2 < 0) {
        M2 = -M2;
        Msgn = -1;
      } else {
        Msgn = 1;
      }
      if (M2 < 30) {
        M2 *= SwissData.DEGTORAD;
        alpha = (1 - ecce.val) / (4 * ecce.val + 0.5);
        beta = M2 / (8 * ecce.val + 1);
        zeta = Math.pow(beta + Math.sqrt(beta * beta + alpha * alpha), 1/3);
        sigma = zeta - alpha / 2;
        sigma = sigma - 0.078 * sigma * sigma * sigma * sigma * sigma / (1 + ecce.val)
  ;
        E = Msgn * (M2 + ecce.val * (3 * sigma - 4 * sigma * sigma * sigma))
                          + M_180_or_0;
      }
    }
    E = sl.swi_kepler(E, M, ecce.val);
    /* position and speed, referred to orbital plane */
    if ((fict_ifl.val & FICT_GEO) != 0) {
      K = SwephData.KGAUSS_GEO / Math.sqrt(sema.val); 
    } else {
      K = SwephData.KGAUSS / Math.sqrt(sema.val);
    }
    cose = Math.cos(E);
    sine = Math.sin(E);
    fac = Math.sqrt((1 - ecce.val) * (1 + ecce.val));
    rho = 1 - ecce.val * cose;
    x[0] = sema.val * (cose - ecce.val);
    x[1] = sema.val * fac * sine;
    x[3] = -K * sine / rho;
    x[4] = K * fac * cose / rho;
    /* transformation to ecliptic */
    xp[0] = pqr[0] * x[0] + pqr[1] * x[1];
    xp[1] = pqr[3] * x[0] + pqr[4] * x[1];
    xp[2] = pqr[6] * x[0] + pqr[7] * x[1];
    xp[3] = pqr[0] * x[3] + pqr[1] * x[4];
    xp[4] = pqr[3] * x[3] + pqr[4] * x[4];
    xp[5] = pqr[6] * x[3] + pqr[7] * x[4];
    /* transformation to equator */
    eps = sl.swi_epsiln(tequ.val);
    sl.swi_coortrf(xp, xp, -eps);
    sl.swi_coortrf(xp, 3, xp, 3, -eps);
    /* precess to J2000 */
    if (tequ.val != SwephData.J2000) {
      sl.swi_precess(xp, tequ.val, SwephData.J_TO_J2000);
      sl.swi_precess(xp, 3, tequ.val, SwephData.J_TO_J2000);
    }
    /* to solar system barycentre */
    if ((fict_ifl.val & FICT_GEO) != 0) {
      for (i = 0; i <= 5; i++) {
        xp[i] += xearth[i];
      }
    } else {
      for (i = 0; i <= 5; i++) {    
        xp[i] += xsun[i];
      }
    }
    if (pdp.x == xp) {
      pdp.teval = tjd;   /* for precession! */
      pdp.iephe = pedp.iephe;
    }
    return SweConst.OK;
  }

  /* note: input parameter tjd is required for T terms in elements */
  private int read_elements_file(int ipl, double tjd,
                                 DblObj tjd0, DblObj tequ,
                                 DblObj mano, DblObj sema, DblObj ecce,
                                 DblObj parg, DblObj node, DblObj incl,
                                 StringBuffer pname, IntObj fict_ifl,
                                 StringBuffer serr) {
    int i, iline, iplan, retc, ncpos;
    FilePtr fp = null;
    String s, sp;
    int spIdx=0;
    String cpos[]=new String[20], serri="";
    boolean elem_found = false;
    double tt = 0;
    /* -1, because file information is not saved, file is always closed */
    if ((fp = sw.swi_fopen(-1, SweConst.SE_FICTFILE, swed.ephepath, serr)) == null) {
      /* file does not exist, use built-in bodies */
      if (ipl >= SweConst.SE_NFICT_ELEM) {
        if (serr != null) {
          serr.append("error no elements for fictitious body no ").append(ipl);
        }
        return SweConst.ERR;
      }
      if (tjd0 != null) {
        tjd0.val = plan_oscu_elem[ipl][0];                   /* epoch */
      }
      if (tequ != null) {
        tequ.val = plan_oscu_elem[ipl][1];                   /* equinox */
      }
      if (mano != null) {
        mano.val = plan_oscu_elem[ipl][2] * SwissData.DEGTORAD; /* mean anomaly */
      }
      if (sema != null) {
        sema.val = plan_oscu_elem[ipl][3];                   /* semi-axis */
      }
      if (ecce != null) {
        ecce.val = plan_oscu_elem[ipl][4];                   /* eccentricity */
      }
      if (parg != null) {
        parg.val = plan_oscu_elem[ipl][5] * SwissData.DEGTORAD; /* arg. of peri. */
      }
      if (node != null) {
        node.val = plan_oscu_elem[ipl][6] * SwissData.DEGTORAD;  /* asc. node */
      }
      if (incl != null) {
        incl.val = plan_oscu_elem[ipl][7] * SwissData.DEGTORAD; /* inclination*/
      }
      if (pname != null) {
        pname.setLength(0);
        pname.append(plan_fict_nam[ipl]);
      }
      return SweConst.OK;
    }
    /*
     * find elements in file
     */
    iline = 0;
    iplan = -1;
    try {
//    while (fgets(s, AS_MAXCH, fp) != null)
      while ((s=fp.readLine()) != null) {
        s=s.trim();
//        iline++;
//        spIdx = 0;
//        while(s.charAt(spIdx) == ' ' || s.charAt(spIdx) == '\t')
//          spIdx++;
//        s=s.substring(spIdx);
        sp = s;
        spIdx=0;
        char ch=s.charAt(spIdx);
        if (ch == '#' || ch=='\r' || ch=='\n' || ch=='\0') {
          continue;
        }
//    if ((sp = strchr(s, '#')) != NULL)
//      *sp = '\0';
        sp = null;
        if ((spIdx = s.indexOf('#')) >= 0) {
          s = s.substring(0,s.indexOf('#'));
          sp = "";
        }
        ncpos = sl.swi_cutstr(s, ",", cpos, 20);
        serri="error in file "+SweConst.SE_FICTFILE+", line "+
              iline+":";
        if (ncpos < 9) {
          if (serr != null) {
            serr.setLength(0);
            serr.append(serri).append(" nine elements required");
          }
          return SweConst.ERR;
        }
        iplan++;
        if (iplan != ipl) {
          continue;
        }
        elem_found = true;
        /* epoch of elements */
        if (tjd0 != null) {
          sp = cpos[0];
//          for (i = 0; i < 5; i++)
//       sp[i] = tolower(sp[i]);
          sp=sp.length()<=5?sp.toLowerCase():
                               sp.substring(0,5).toLowerCase()+sp.substring(5);
          if (sp.startsWith("j2000")) {
            tjd0.val = SwephData.J2000;
          } else if (sp.startsWith("b1950")) {
            tjd0.val = SwephData.B1950;
          } else if (sp.startsWith("j1900")) {
            tjd0.val = SwephData.J1900;
          } else if (sp.charAt(0) == 'j' || sp.charAt(0) == 'b') {
            if (serr != null) {
              serr.setLength(0);
              serr.append(serri).append(" invalid epoch");
            }
//          goto return_err;
            fp.close(); return SweConst.ERR;
          } else
            tjd0.val = SwissLib.atof(sp);
          tt = tjd - tjd0.val;
        }
        /* equinox */
        if (tequ != null) {
          sp = cpos[1];
          spIdx=0;
          while(sp.charAt(spIdx) == ' ' || sp.charAt(spIdx) == '\t')
            spIdx++;
//          for (i = 0; i < 5; i++)
//       sp[i] = tolower(sp[i]);
          sp=sp.substring(spIdx);
          sp=sp.length()<5?sp.toLowerCase():
                               sp.substring(0,5).toLowerCase()+sp.substring(5);
          if (sp.startsWith("j2000")) {
            tequ.val = SwephData.J2000;
          } else if (sp.startsWith("b1950")) {
            tequ.val = SwephData.B1950;
          } else if (sp.startsWith("j1900")) {
            tequ.val = SwephData.J1900;
          } else if (sp.startsWith("jdate")) {
            tequ.val = tjd;
          } else if (sp.charAt(0) == 'j' || sp.charAt(0) == 'b') {
            if (serr != null) {
              serr.setLength(0);
              serr.append(serri).append(" invalid equinox");
            }
//          goto return_err;
            fp.close(); return SweConst.ERR;
          } else {
//        *tequ = atof(sp);
            tequ.val = SwissLib.atof(sp);
          }
        }
        /* mean anomaly t0 */
        if (mano != null) {
          retc = check_t_terms(tt, cpos[2], mano);
          mano.val = sl.swe_degnorm(mano.val);
          if (retc == SweConst.ERR) {
            if (serr != null) {
              serr.append(serri).append(" mean anomaly value invalid");
            }
//          goto return_err;
            fp.close(); return SweConst.ERR;
          }
          /* if mean anomaly has t terms (which happens with fictitious
           * planet Vulcan), we set
           * epoch = tjd, so that no motion will be added anymore
           * equinox = tjd */
          if (retc == 1) {
            tjd0.val = tjd;
          }
          mano.val *= SwissData.DEGTORAD;
        }
        /* semi-axis */
        if (sema != null) {
          retc = check_t_terms(tt, cpos[3], sema);
          if (sema.val <= 0 || retc == SweConst.ERR) {
            if (serr != null) {
              serr.append(serri).append(" semi-axis value invalid");
            }
//          goto return_err;
            fp.close(); return SweConst.ERR;
          }
        }
        /* eccentricity */
        if (ecce != null) {
          retc = check_t_terms(tt, cpos[4], ecce);
          if (ecce.val >= 1 || ecce.val < 0 || retc == SweConst.ERR) {
            if (serr != null) {
              serr.setLength(0);
              serr.append(serri).append(" eccentricity invalid (no parabolic or hyperbolic or bits allowed)");
            }
//          goto return_err;
            fp.close(); return SweConst.ERR;
          }
        }
        /* perihelion argument */
        if (parg != null) {
          retc = check_t_terms(tt, cpos[5], parg);
          parg.val = sl.swe_degnorm(parg.val);
          if (retc == SweConst.ERR) {
            if (serr != null) {
              serr.setLength(0);
              serr.append(serri).append(" perihelion argument value invalid");
            }
//          goto return_err;
            fp.close(); return SweConst.ERR;
          }
          parg.val *= SwissData.DEGTORAD;
        }
        /* node */
        if (node != null) {
          retc = check_t_terms(tt, cpos[6], node);
          node.val = sl.swe_degnorm(node.val);
          if (retc == SweConst.ERR) {
            if (serr != null) {
              serr.setLength(0);
              serr.append(serri).append(" node value invalid");
            }
//          goto return_err;
            fp.close(); return SweConst.ERR;
          }
          node.val *= SwissData.DEGTORAD;
        }
        /* inclination */
        if (incl != null) {
          retc = check_t_terms(tt, cpos[7], incl);
          incl.val = sl.swe_degnorm(incl.val);
          if (retc == SweConst.ERR) {
            if (serr != null) {
              serr.setLength(0);
              serr.append(serri).append(" inclination value invalid");
            }
//          goto return_err;
            fp.close(); return SweConst.ERR;
          }
          incl.val *= SwissData.DEGTORAD;
        }
        /* planet name */
        if (pname != null) {
          sp = cpos[8];
          spIdx=0;
          while(sp.charAt(spIdx) == ' ' || sp.charAt(spIdx) == '\t')
            spIdx++;
          sp=sp.substring(spIdx);
//      swi_right_trim(sp);
          sp=sp.trim();
          pname.setLength(0); pname.append(sp);
        }
        /* geocentric */
        if (fict_ifl != null && ncpos > 9) {
//          for (sp = cpos[9]; *sp != '\0'; sp++)
//            *sp = tolower(*sp);
          sp = sp.substring(0,Math.min(sp.length(),spIdx+9)) +
               sp.substring(Math.min(sp.length(),spIdx+9)).toLowerCase();
//          if (strstr(cpos[9], "geo") != NULL)
//            fict_ifl.val |= FICT_GEO;
          if (cpos[9].indexOf("geo") >= 0) {
            fict_ifl.val |= FICT_GEO;
          }
        }
        break;
      }
      if (!elem_found) {
        if (serr != null) {
          serr.append(serri).append(" elements for planet ").append(ipl).append(" not found");
        }
//      goto return_err;
        fp.close(); return SweConst.ERR;
      }
      fp.close();
      return SweConst.OK;
    } catch (java.io.IOException e) {
      if (fp!=null) { try { fp.close(); } catch (java.io.IOException ie) { } }
    }
    return SweConst.ERR;
  }

  private int check_t_terms(double t, String sinp, DblObj doutp) {
    int i, isgn = 1, z;
    int retc = 0;
    int spidx;
    double tt[]=new double[5], fac;
    tt[0] = t / 36525;
    tt[1] = tt[0];
    tt[2] = tt[1] * tt[1];
    tt[3] = tt[2] * tt[1];
    tt[4] = tt[3] * tt[1];
//    if (strpbrk(sinp, "+-") != null)
    if (sinp.indexOf('+') + sinp.indexOf('-') > -2) {
      retc = 1; /* with additional terms */
    }
    spidx=0;
    doutp.val = 0;
    fac = 1;
    z = 0;
    while (true) {
      while(spidx<sinp.length() &&
            (sinp.charAt(spidx)==' ' || sinp.charAt(spidx)=='\t')) {
        spidx++;
      }
      if (spidx==sinp.length() ||
          sinp.charAt(spidx)=='+' || sinp.charAt(spidx)=='-') {
        if (z > 0) {
          doutp.val += fac;
        }
        isgn = 1;
        if (spidx!=sinp.length() && sinp.charAt(spidx) == '-') {
          isgn = -1;
        }
        fac = 1 * isgn;
        if (spidx==sinp.length()) {
          return retc;
        }
        spidx++;
      } else {
        while(spidx<sinp.length() &&
              (sinp.charAt(spidx)=='*' || sinp.charAt(spidx)==' '
              || sinp.charAt(spidx)=='\t')) {
          spidx++;
        }
        if (spidx<sinp.length() &&
            (sinp.charAt(spidx)=='t' || sinp.charAt(spidx)=='T')) {
                /* a T */
          spidx++;
          if (spidx<sinp.length() &&
              (sinp.charAt(spidx)=='+' || sinp.charAt(spidx)=='-')) {
            fac *= tt[0];
          } else if ((i = SwissLib.atoi(sinp.substring(Math.min(sinp.length(),spidx)))) <= 4 && i >= 0) {
            fac *= tt[i];
          }
        } else {
          /* a number */
          double db=SwissLib.atof(sinp.substring(spidx));
          if (db!=0 || sinp.charAt(spidx)=='0') {
            fac *= db;
          }
        }
        while (spidx<sinp.length() &&
               (Character.isDigit(sinp.charAt(spidx)) ||
                sinp.charAt(spidx)=='.'))
          spidx++;
      }
      z++;
    }
  }

  private Plantbl planets[] = {
    SwemptabMer.mer404,
    SwemptabVen.ven404,
    SwemptabEar.ear404,
    SwemptabMar.mar404,
    SwemptabJup.jup404,
    SwemptabSat.sat404,
    SwemptabUra.ura404,
    SwemptabNep.nep404,
    SwemptabPlu.plu404,
  };
}


/*
  This is a port of the Swiss Ephemeris Free Edition, Version 1.64.01
  of Astrodienst AG, Switzerland from the original C Code to Java. For
  copyright see the original copyright notices below and additional
  copyright notes in the file named LICENSE, or - if this file is not
  available - the copyright notes at http://www.astro.ch/swisseph/ and
  following.
   
  For any questions or comments regarding this port to Java, you should
  ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
  in this port in any way.

  Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

   This file is part of Swiss Ephemeris Free Edition.

   Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
   or distributor accepts any responsibility for the consequences of using it,
   or for whether it serves any particular purpose or works at all, unless he
   or she says so in writing.  Refer to the Swiss Ephemeris Public License
   ("SEPL" or the "License") for full details.

   Every copy of Swiss Ephemeris must include a copy of the License,
   normally in a plain ASCII text file named LICENSE.  The License grants you
   the right to copy, modify and redistribute Swiss Ephemeris, but only
   under certain conditions described in the License.  Among other things, the
   License requires that the copyright notices and this notice be preserved on
   all copies.

   For uses of the Swiss Ephemeris which do not fall under the definitions
   laid down in the Public License, the Swiss Ephemeris Professional Edition
   must be purchased by the developer before he/she distributes any of his
   software or makes available any product or service built upon the use of
   the Swiss Ephemeris.

   Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

   The authors of Swiss Ephemeris have no control or influence over any of
   the derived works, i.e. over software or services created by other
   programmers which use Swiss Ephemeris functions.

   The names of the authors or of the copyright holder (Astrodienst) must not
   be used for promoting any software, product or service which uses or contains
   the Swiss Ephemeris. This copyright notice is the ONLY place where the
   names of the authors can legally appear, except in cases where they have
   given special permission in writing.

   The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
   for promoting such software, products or services.
*/

/**
 * A class to test (probably) all of the swiss ephemeris routines with
 * (probably) all possible options. See parameter -h for infos about
 * all the parameter switches.<P>
 */
class Swetest {

    public String globalResult = ""; // OH YEAH BABY
    
    static final String infocmd0 = "\n"+
        "  Swetest computes a complete set of geocentric planetary positions,\n"+
        "  for a given date or a sequence of dates.\n"+
        "  Input can either be a date or an absolute julian day number.\n"+
        "  0:00 (midnight).\n"+
        "  With the proper options, swetest can be used to output a printed\n"+
        "  ephemeris and transfer the data into other programs like spreadsheets\n"+
        "  for graphical display.\n"+
        "\n";
    static final String infocmd1 = "\n"+
        "  Command line options:\n"+
        "        -ay..   ayanamsa, with number of method, e.g. ay0 for Fagan/Bradley\n"+
        "        -pSEQ   planet sequence to be computed.\n"+
        "                See the letter coding below.\n"+
        "        -nN     output data for N consecutive days; if no -n option\n"+
        "                is given, the default is 1. If the option -n without a\n"+
        "                number is given, the default is 20.\n"+
        "        -sN     timestep N days, default 1. This option is only meaningful\n"+
        "                when combined with option -n.\n"+
        "        -edirPATH change the directory of the ephemeris files\n"+
        "        -dX     differential ephemeris: print differential ephemeris between\n"+
        "                body X and each body in list given by -p\n"+
        "                example: -p2 -d0 -fJl -n366 -b1.1.1992 prints the longitude\n"+
        "                distance between SUN (planet 0) and MERCURY (planet 2)\n"+
        "                for a full year starting at 1 Jan 1992.\n"+
        "        -DX     midpoint ephemeris, works the same way as the differential\n"+
        "                mode -d described above, but outputs the midpoint position.\n"+
        "        -hel    compute heliocentric positions\n"+
        "        -bary   compute barycentric positions (bar. earth instead of node)\n"+
        "        -sid..    sidereal, with number of method; 'sid0' for Fagan/Bradley\n"+
        "        -sidt0..  sidereal, projection on ecliptic of t0\n"+
        "        -sidsp..  sidereal, projection on solar system plane\n"+
        "        -topo[long,lat,elev]\n"+
        "                topocentric positions. The longitude, latitude (degrees with\n"+
        "                DECIMAL fraction) and elevation (meters) can be given, with\n"+
        "                commas separated, + for east and north. If none are given,\n"+
        "                Z\u00fcrich is used: 8.55,47.38,400\n"+
        "        -house[long,lat,hsys]\n"+
        "                include house cusps. The longitude, latitude (degrees with\n"+
        "                DECIMAL fraction) and house system letter can be given, with\n"+
        "                commas separated, + for east and north. If none are given,\n"+
        "                Greenwich UK and Placidus is used: 0.00,51.50,p.\n"+
        "                The output lists 12 house cusps, Asc, MC, ARMC and Vertex.\n"+
        "                Houses can only be computed if option -ut is given.\n";
    static final String infocmd2 = ""+
        "        -hsy[hsys]	\n"+
        "                house system to be used (for house positions of planets)\n"+
        "                for long, lat, hsys, see -house\n"+
        "        -geopos[long,lat,elev]\n"+
        "                Geographic position. Can be used for azimuth and altitude\n"+
        "                or topocentric or house cups calculations.\n"+
        "                The longitude, latitude (degrees with DECIMAL fraction)\n"+
        "                and elevation (meters) can be given, with\n"+
        "                commas separated, + for east and north. If none are given,\n"+
        "                Z?rich is used: 8.55,47.38,400\n"+
        "        -head   don\'t print the header before the planet data. This option\n"+
        "                is useful when you want to paste the output into a\n"+
        "                spreadsheet for displaying graphical ephemeris.\n"+
        "        -bDATE  begin date; e.g. -b1.1.1992 if\n"+
        "                Note: the date format is day month year (European style).\n"+
        "        -bj...  begin date as an absolute Julian day number; e.g. -bj2415020.5\n"+
        "        -j...   same as -bj\n"+
        "        -fSEQ   use SEQ as format sequence for the output columns;\n"+
        "                default is PLBRS.\n"+
        "        -tHH.MMSS  input time (ephemeris time)\n"+
        "        -ut     input date is universal time\n"+
        "        -utHH:MM:SS input time\n"+
        "        -utHH.MMSS input time\n";
    static final String infocmd3 = ""+
        "        -eswe   swiss ephemeris\n"+
        "        -ejpl   jpl ephemeris (DE406), or with ephemeris file name\n"+
        "                -ejplde200.eph\n"+
        "        -emos   moshier ephemeris\n"+
        "        -true   true positions\n"+
        "        -noaberr        no aberration\n"+
        "        -nodefl no gravitational light deflection\n"+
        "        -j2000  no precession (i.e. J2000 positions)\n"+
        "        -icrs   ICRS (positions in the Internat. Celestial Reference System)\n"+
        "        -nonut  no nutation\n"+
        "        -speed  high precision speed\n"+
        "        -speed3 'low' precision speed from 3 positions\n"+
        "                do not use this option. -speed parameter is faster and preciser\n"+
        "        -testaa96       test example in AA 96, B37,\n"+
        "                        i.e. venus, j2450442.5, DE200.\n"+
        "                        attention: use precession IAU1976\n"+
        "                        and nutation 1980 (s. swephlib.h)\n"+
        "        -testaa95\n"+
        "        -testaa97\n"+
        "        -roundsec       round to seconds\n"+
        "        -roundmin       round to minutes\n"+
        "\n"+
        "        -?, -h  display whole info\n"+
        "        -hcmd   display commands\n"+
        "        -hplan  display planet numbers\n"+
        "        -hform  display format characters\n"+
        "        -hdate  display input date format\n"+
        "        +head   header before every step (with -s..)\n"+
        "        -gPPP   use PPP as gap between output columns; default is a single\n"+
        "                blank.  -g followed by white space sets the\n"+
        "                gap to the TAB character; which is useful for data entry\n"+
        "                into spreadsheets.\n"+
        "        -iXX    force iflag to value XX\n"+
        "        -hexamp  display examples\n";
    static final String infocmd4 =
        "         -solecl solar eclipse\n"+
        "                 output 1st line:\n"+
        "                   eclipse date,\n"+
        "                   time of maximum,\n"+
        "                   core shadow width (negative with total eclipses),\n"+
        "                   fraction of solar diameter that is eclipsed\n"+
        "                 output 2nd line:\n"+
        "                   start and end times for partial and total phase\n"+
        "                 output 3rd line:\n"+
        "                   geographical longitude and latitude of maximum eclipse,\n"+
        "                   totality duration at that geographical position,\n"+
        "                 output with -local, see below.\n"+
        "         -occult occultation of planet or star by the moon. Use -p to\n"+
        "                 specify planet (-pf -xfAldebaran for stars)\n"+
        "                 output format same as with -solecl\n"+
        "         -lunecl lunar eclipse\n"+
        "                 output 1st line:\n"+
        "                   eclipse date,\n"+
        "                   time of maximum,\n"+
        "                 output 2nd line:\n"+
        "                   6 contacts for start and end of penumbral, partial, and\n"+
        "                   total phase\n"+
        "         -local  only with -solecl or -occult, if the next event of this\n"+
        "                 kind is wanted for a given geogr. position.\n"+
        "                 Use -geopos[long,lat,elev] to specify that position.\n"+
        "                 If -local is not set, the program\n"+
        "                 searches for the next event anywhere on earth.\n"+
        "                 output 1st line:\n"+
        "                   eclipse date,\n"+
        "                   time of maximum,\n"+
        "                   fraction of solar diameter that is eclipsed\n"+
        "                 output 2nd line:\n"+
        "                   local eclipse duration,\n"+
        "                   local four contacts,\n";
    static final String infocmd5 =
        "         -total  total eclipse (only with -solecl, -lunecl)\n"+
        "         -partial partial eclipse (only with -solecl, -lunecl)\n"+
        "         -annular annular eclipse (only with -solecl)\n"+
        "         -anntot annular-total eclipse (only with -solecl)\n"+
        "         -penumbral penumbral lunar eclipse (only with -lunecl)\n"+
        "         -central central eclipse (only with -solecl, nonlocal)\n"+
        "         -noncentral non-central eclipse (only with -solecl, nonlocal)\n"+
        "         -rise   rising and setting of a planet or star.\n"+
        "                 Use -geopos[long,lat,elev] to specify geographical position.\n"+
        "         -norefrac   neglect refraction (with option -rise)\n"+
        "         -disccenter find rise of disc center (with option -rise)\n"+
        "         -hindu      hindu version of sunrise (with option -rise)\n"+
        "         -metr   southern and northern meridian transit of a planet of star\n"+
        "                 Use -geopos[long,lat,elev] to specify geographical position.\n"+
        "         -bwd    search backward\n";
    /* characters still available:
       bcegijklruvxy
    */
    static final String infoplan = "\n"+
        "  Planet selection letters:\n"+
        "        d (default) main factors 0123456789mtABCcg\n"+
        "        p main factors as above, plus main asteroids DEFGHI\n"+
        "        h ficticious factors J..X\n"+
        "        a all factors\n"+
        "        (the letters above can only appear as a single letter)\n\n"+
        "        0 Sun (character zero)\n"+
        "        1 Moon (character 1)\n"+
        "        2 Mercury\n"+
        "        ....\n"+
        "        9 Pluto\n"+
        "        m mean lunar node\n"+
        "        t true lunar node\n"+
        "        n nutation\n"+
        "        q delta t\n"+
        "        o obliquity of ecliptic\n"+
        "        A mean lunar apogee (Lilith, Black Moon)\n"+
        "        B osculating lunar apogee\n"+  // True Lilith
        "        c intp. lunar apogee\n"+
        "        g intp. lunar perigee\n"+
        "        C Earth\n"+
        "        D Chiron\n"+
        "        E Pholus\n"+
        "        F Ceres\n"+
        "        G Pallas\n"+
        "        H Juno\n"+
        "        I Vesta\n"+
        "        J Cupido\n"+
        "        K Hades\n"+
        "        L Zeus\n"+
        "        M Kronos\n"+
        "        N Apollon\n"+
        "        O Admetos\n"+
        "        P Vulkanus\n"+
        "        Q Poseidon\n"+
        "        R Isis (Sevin)\n"+
        "        S Nibiru (Sitchin)\n"+
        "        T Harrington\n"+
        "        U Leverrier's Neptune\n"+
        "        V Adams' Neptune\n"+
        "        W Lowell's Pluto\n"+
        "        X Pickering's Pluto\n"+
        "        Y Vulcan\n"+
        "        Z White Moon\n"+
        "        w Waldemath's dark Moon\n"+
        "        f fixed star, with name or number given in -xf option\n"+
        "        z hypothetical body, with number given in -xz\n"+
        "        s minor planet, with MPC number given in -xs\n"+
        "        e print a line of labels\n"+
        "          \n";
    /* characters still available
       cgjv
    */
    static final String infoform = "\n"+
        "  Output format SEQ letters:\n"+
        "  In the standard setting five columns of coordinates are printed with\n"+
        "  the default format PLBRS. You can change the default by providing an\n"+
        "  option like -fCCCC where CCCC is your sequence of columns.\n"+
        "  The coding of the sequence is like this:\n"+
        "        y year\n"+
        "        Y year.fraction_of_year\n"+
        "        p planet index\n"+
        "        P planet name\n"+
        "        J absolute juldate\n"+
        "        T date formatted like 23.02.1992\n"+
        "        t date formatted like 920223 for 1992 february 23\n"+
        "        L longitude in degree ddd\u00b0mm'ss\"\n"+
        "        l longitude decimal\n"+
        "        Z longitude ddsignmm'ss\"\n"+
        "        S speed in longitude in degree ddd:mm:ss per day\n"+
        "        SS speed for all values specified in fmt\n"+
        "        s speed longitude decimal (degrees/day)\n"+
        "        ss speed for all values specified in fmt\n"+
        "        B latitude degree\n"+
        "        b latitude decimal\n"+
        "        R distance decimal in AU\n"+
        "        r distance decimal in AU, Moon in seconds parallax\n"+
        "          relative distance (1000=nearest, 0=furthest)\n"+
        "        A Rectascension in hh:mm:ss\n"+
        "        a rectascension hours decimal\n"+
        "        D Declination degree\n"+
        "        d declination decimal\n"+
        "        I Azimuth degree\n"+
        "        i Azimuth decimal\n"+
        "        H Height degree\n"+
        "        h Height decimal\n"+
        "        K Height (with refraction) degree\n"+
        "        k Height (with refraction) decimal\n"+
        "        G house position in degrees\n"+
        "        g house position in degrees decimal\n"+
        "        j house number 1.0 - 12.99999\n"+
        "        X x-, y-, and z-coordinates ecliptical\n"+
        "        x x-, y-, and z-coordinates equatorial\n"+
        "        U unit vector ecliptical\n"+
        "        u unit vector equatorial\n"+
        "        Q l, b, r, dl, db, dr, a, d, da, dd\n"+
        "        n mean values: ascending, descending node (Me - Ne) decimal degree\n"+
        "        N osculating values: ascending, descending node\n"+
        "        f mean values for longitude: perihel, aphel, second focal point\n"+
        "        F oscul. values for longitude: perihel, aphel, second focal point\n"+
        "        + phase angle\n"+
        "        - phase\n"+
        "        * elongation\n"+
        "        / apparent diameter of disc (without refraction)\n"+
        "        = magnitude\n";

    static final String infodate = "\n"+
        "  Date entry:\n"+
        "  In the interactive mode, when you are asked for a start date,\n"+
        "  you can enter data in one of the following formats:\n"+
        "\n"+
        "        1.2.1991        three integers separated by a nondigit character for\n"+
        "                        day month year. Dates are interpreted as Gregorian\n"+
        "                        after 4.10.1582 and as Julian Calender before.\n"+
        "                        Time is always set to midnight.\n"+
        "                        If the three letters jul are appended to the date,\n"+
        "                        the Julian calendar is used even after 1582.\n"+
        "                        If the four letters greg are appended to the date,\n"+
        "                        the Gregorian calendar is used even before 1582.\n"+
        "\n"+
        "        j2400123.67     the letter j followed by a real number, for\n"+
        "                        the absolute Julian daynumber of the start date.\n"+
        "                        Fraction .5 indicates midnight, fraction .0\n"+
        "                        indicates noon, other times of the day can be\n"+
        "                        chosen accordingly.\n"+
        "\n"+
        "        <RETURN>        repeat the last entry\n"+
        "        \n"+
        "        .               stop the program\n"+
        "\n"+
        "        +20             advance the date by 20 days\n"+
        "\n"+
        "        -10             go back in time 10 days\n";
    static final String infoexamp = "\n"+
        "\n"+
        "  Examples:\n"+
        "\n"+
        "    java Swetest -p2 -b1.12.1900 -n15 -s2\n"+
        "	ephemeris of Mercury (-p2) starting on 1 Dec 1900,\n"+
        "	15 positions (-n15) in two-day steps (-s2)\n"+
        "\n"+
        "    java Swetest -p2 -b1.12.1900 -n15 -s2 -fTZ -roundsec -g, -head\n"+
        "	same, but output format =  date and zodiacal position (-fTZ),\n"+
        "	separated by comma (-g,) and rounded to seconds (-roundsec),\n"+
        "	without header (-head).\n"+
        "\n"+
        "    java Swetest -ps -xs433 -b1.12.1900\n"+
        "	position of asteroid 433 Eros (-ps -xs433)\n"+
        "\n"+
        "    java Swetest -pf -xfAldebaran -b1.1.2000\n"+
        "     position of fixed star Aldebaran\n"+
        "\n"+
        "    java Swetest -p1 -d0 -b1.12.1900 -n10 -fPTl -head\n"+
        "	angular distance of moon (-p1) from sun (-d0) for 10\n"+
        "	consecutive days (-n10).\n"+
        "\n"+
        "    java Swetest -p6 -DD -b1.12.1900 -n100 -s5 -fPTZ -head -roundmin\n"+
        "     Midpoints between Saturn (-p6) and Chiron (-DD) for 100\n"+
        "     consecutive steps (-n100) with 5-day steps (-s5) with\n"+
        "     longitude in degree-sign format (-f..Z) rounded to minutes (-roundmin)\n"+
        "\n"+
        "    java Swetest -b5.1.2002 -p -house12.05,49.50,k -ut12:30\n"+
        "        Koch houses for a location in Germany at a given date and time\n";
    /**************************************************************/

    SwissData swed = new SwissData();
    SwissLib  sl   = new SwissLib();
    SwissEph  sw   = new SwissEph();
    SweDate   sd   = null;
    CFmt      f    = new CFmt();

    static final double J2000=2451545.0;  /* 2000 January 1.5 */
    public double square_sum(double x[]) { return x[0]*x[0]+x[1]*x[1]+x[2]*x[2]; }
    public static final int SEFLG_EPHMASK=SweConst.SEFLG_JPLEPH|
        SweConst.SEFLG_SWIEPH|
        SweConst.SEFLG_MOSEPH;

    static final int BIT_ROUND_SEC=1;
    static final int BIT_ROUND_MIN=2;
    static final int BIT_ZODIAC=4;
    static final String PLSEL_D="0123456789mtA";
    static final String PLSEL_P="0123456789mtA"+
        "BCcg"+
        "DEFGHI";
    static final String PLSEL_H="JKLMNOPQRSTUVWXYZw";
    static final String PLSEL_A="0123456789mtABCcgDEFGHIJKLMNOPQRSTUVWXYZw";

    static final char DIFF_DIFF='d';
    static final char DIFF_MIDP='D';
    static final int MODE_HOUSE=1;
    static final int MODE_LABEL=2;

    String se_pname;
    public static final String[] zod_nam = new String[]
        {"ar", "ta", "ge", "cn", "le", "vi",
         "li", "sc", "sa", "cp", "aq", "pi"};

    String star = "algol", star2;
    String sastno = "433";
    String shyp = "1";

    /* globals shared between main() and print_line() */
    String fmt = "PLBRS";
    String gap = " ";
    double t, te, tut, jut = 0;
    int jmon, jday, jyear;
    int ipl = SweConst.SE_SUN, ipldiff = SweConst.SE_SUN, nhouses = 12;
    String spnam, spnam2="";
    StringBuffer serr=new StringBuffer(swed.AS_MAXCH);
    StringBuffer serr_save=new StringBuffer(swed.AS_MAXCH);
    StringBuffer serr_warn=new StringBuffer(swed.AS_MAXCH);
    boolean gregflag = SweDate.SE_GREG_CAL;
    int diff_mode = 0;
    boolean universal_time = false;
    int round_flag = 0;
    double x[]=new double[6], x2[]=new double[6], xequ[]=new double[6],
        xcart[]=new double[6], xcartq[]=new double[6],
        xobl[]=new double[6], xaz[]=new double[6], xt[]=new double[6],
        geopos[]=new double[3], hpos, hpos2, armc, xsv[]=new double[6];
    DblObj hposj=new DblObj();
    int hpos_meth = 0;
    double attr[]=new double[20], tret[]=new double[20];
    int iflag = 0, iflag2;              /* external flag: helio, geo... */
    static final String hs_nam[] = {"undef",
                                    "Ascendant", "MC", "ARMC", "Vertex"};
    int smod = 0;
    int direction = 1;
    boolean direction_flag = false;
    double tjd = 2415020.5;
    int nstep = 1, istep;
    int search_flag = 0;
    String sout;
    int whicheph = SweConst.SEFLG_SWIEPH;
    String psp;
    int p=0; // Index for psp
    boolean norefrac = false;
    boolean disccenter = false;

    static final int SMOD_LUNAR    =1;
    static final int SMOD_HOW      =2;       /* an option for Lunar */
    static final int SMOD_SOLAR    =4;
    static final int SMOD_LOCAL    =8;       /* an option for Solar */
    static final int SMOD_TOTAL    =16;
    static final int SMOD_ANNULAR  =32;      /* count as penumbral for Lunar */
    static final int SMOD_ANNTOT   =64;
    static final int SMOD_PARTIAL  =128;
    static final int SMOD_PENUMBRAL=256;
    static final int SMOD_ALL      =(SMOD_TOTAL| SMOD_ANNULAR|SMOD_PARTIAL|SMOD_ANNTOT);
    static final int SMOD_OCCULT   =512;
    static final int SMOD_RISE     =1024;
    static final int SMOD_METR     =2048;
    static final int SMOD_HOCAL    =4096;


    static final int ECL_LUN_PENUMBRAL     =1;       /* eclipse types for hocal list */
    static final int ECL_LUN_PARTIAL       =2;
    static final int ECL_LUN_TOTAL         =3;
    static final int ECL_SOL_PARTIAL       =4;
    static final int ECL_SOL_ANNULAR       =5;
    static final int ECL_SOL_TOTAL         =6;

    String SE_EPHE_PATH="";

    /**
     * This class is not to be instantiated, it is to be run via the main method.
     */
    public Swetest() { }

    /**
     * Use the parameter -h to get infos about the available options.
     */
    public static void main(String argv[]) {
        Swetest swt=new Swetest();
        System.exit(swt.main_start(argv));
    }

    public int main_start(String[] argv) {
        String saves="";
        String s1, s2;
        String sp, spsave, sp2;
        String spno;
        String plsel = PLSEL_D;
        int i, j, n, iflag_f = -1, iflgt;
        int line_count, line_limit = 3200000;
        double daya;
        double top_long = 0; /* Greenwich, UK */
        double top_lat = 51.5;
        double top_elev = 0;
        boolean have_geopos = false;
        int ihsy = (int)'p';
        boolean do_houses = false;
        String ephepath;
        String fname;
        String sdate;
        String begindate = null;
        long iflgret;
        boolean with_header = true;
        boolean with_header_always = false;
        boolean do_ayanamsa = false;
        int sid_mode = SweConst.SE_SIDM_FAGAN_BRADLEY;
        double t2, tstep = 1, thour = 0;
        double delt;
        serr.setLength(0); serr_save.setLength(0); serr_warn.setLength(0);
        saves = "";

        sd=new SweDate(tjd,gregflag);

        ephepath="";
        fname=SweConst.SE_FNAME_DE406;
        for (i = 0; i < argv.length; i++) {
            if (argv[i].startsWith("-DSE_EPHE_PATH")) {
                if (++i<argv.length) {
                    SE_EPHE_PATH=argv[i];
                }
            } else if (argv[i].startsWith("-ut")) {
                universal_time = true;
                if (argv[i].length() > 3) {
                    s1=argv[i].substring(3);
                    if (s1.indexOf(':')>=0) {
                        s1=s1.substring(0,s1.indexOf(':'))+"."+s1.substring(s1.indexOf(':')+1);
                        if (s1.indexOf(':')>=0) {
                            s1=s1.substring(0,s1.indexOf(':'))+s1.substring(s1.indexOf(':')+1);
                        }
                    }
                    thour = Double.valueOf(s1).doubleValue();
                    /* h.mmss -> decimal */
                    // Allowing for negative times: this is different from the C code!
                    t = (thour%1.0) * 100 + (thour<0?-1e-10:1e-10);
                    j = (int) t;
                    t = (t%1.0) * 100 + 1e-10;
                    thour = (int) thour + j / 60.0 + t / 3600.0;
                }
            } else if (argv[i].startsWith("-head")) {
                with_header = false;
            } else if (argv[i].startsWith("+head")) {
                with_header_always = true;
            } else if (argv[i].equals("-j2000")) {
                iflag |= SweConst.SEFLG_J2000;
            } else if (argv[i].equals("-icrs")) {
                iflag |= SweConst.SEFLG_ICRS;
            } else if (argv[i].startsWith("-ay")) {
                do_ayanamsa = true;
                sid_mode=0;
                if (argv[i].length()>3) {
                    sid_mode=Integer.parseInt(argv[i].substring(3));
                }
                sw.swe_set_sid_mode(sid_mode, 0, 0);
            } else if (argv[i].startsWith("-sidt0")) {
                iflag |= SweConst.SEFLG_SIDEREAL;
                //      sid_mode = atol(argv[i]+6);
                sid_mode=0;
                if (argv[i].length()>6) {
                    sid_mode=Integer.parseInt(argv[i].substring(6));
                }
                if (sid_mode == 0)
                    sid_mode = SweConst.SE_SIDM_FAGAN_BRADLEY;
                sid_mode |= SweConst.SE_SIDBIT_ECL_T0;
                sw.swe_set_sid_mode(sid_mode, 0, 0);
            } else if (argv[i].startsWith("-sidsp")) {
                iflag |= SweConst.SEFLG_SIDEREAL;
                //      sid_mode = atol(argv[i]+6);
                sid_mode=0;
                if (argv[i].length()>6) {
                    sid_mode=Integer.parseInt(argv[i].substring(6));
                }
                if (sid_mode == 0)
                    sid_mode = SweConst.SE_SIDM_FAGAN_BRADLEY;
                sid_mode |= SweConst.SE_SIDBIT_SSY_PLANE;
                sw.swe_set_sid_mode(sid_mode, 0, 0);
            } else if (argv[i].startsWith("-sid")) {
                iflag |= SweConst.SEFLG_SIDEREAL;
                //      sid_mode = atol(argv[i]+4);
                sid_mode=0;
                if (argv[i].length()>4) {
                    try {
                        sid_mode=Integer.parseInt(argv[i].substring(4));
                    } catch (NumberFormatException nf) {
                        // Anything not being a number will be considered '0'
                    }
                }
                if (sid_mode > 0)
                    sw.swe_set_sid_mode(sid_mode, 0, 0);
            } else if (argv[i].startsWith("-j")) {
                begindate = argv[i].substring(1);
            } else if (argv[i].startsWith("-ejpl")) {
                whicheph = SweConst.SEFLG_JPLEPH;
                if (argv[i].length()>5)
                    fname=argv[i].substring(5);
            } else if (argv[i].startsWith("-edir")) {
                if (argv[i].length() > 5)
                    ephepath=argv[i].substring(5);
            } else if (argv[i].startsWith("-eswe")) {
                whicheph = SweConst.SEFLG_SWIEPH;
            } else if (argv[i].startsWith("-emos")) {
                whicheph = SweConst.SEFLG_MOSEPH;
            } else if (argv[i].equals("-hel")) {
                iflag |= SweConst.SEFLG_HELCTR;
            } else if (argv[i].equals("-bary")) {
                iflag |= SweConst.SEFLG_BARYCTR;
            } else if (argv[i].startsWith("-house")) {
                sout="";
                boolean hLonIsSet=false;
                boolean hLatIsSet=false;
                // sscanf(argv[i] + 6, "%lf,%lf,%s", &top_long, &top_lat, sout);
                try {
                    String h=argv[i].substring(6);
                    int idx=h.indexOf(',');
                    String hf=h.substring(0,idx);
                    top_long=Double.valueOf(hf).doubleValue();
                    hLonIsSet=true;
                    h=h.substring(idx+1);
                    idx=h.indexOf(',');
                    if (idx<0) { idx=h.length(); }
                    hf=h.substring(0,idx);
                    top_lat=Double.valueOf(hf).doubleValue();
                    hLatIsSet=true;
                    sout=h.substring(idx+1);
                } catch (NumberFormatException nfe) {
                    if (!hLonIsSet) { top_long=0; } else { top_lat=0; }
                } catch (StringIndexOutOfBoundsException aie) {
                    if (!hLonIsSet) { top_long=0; } else if (!hLatIsSet) { top_lat=0; }
                }
                top_elev = 0;
                if (sout.length()>0) { ihsy = sout.charAt(0); }
                do_houses = true;
                have_geopos = true;
            } else if (argv[i].startsWith("-hsy")) {
                if (argv[i].length()<5) {
                    ihsy = 'p';
                } else {
                    ihsy = argv[i].charAt(4);
                }
                if (argv[i].length()>5) {
                    hpos_meth = Integer.parseInt(argv[i].substring(5));
                }
                have_geopos = true;
            } else if (argv[i].startsWith("-topo") ||
                       argv[i].startsWith("-geopos")) {
                int plen=(argv[i].startsWith("-topo")?5:7);
                if (plen==5) { iflag |= SweConst.SEFLG_TOPOCTR; }
                //      sscanf(argv[i] + 5, "%lf,%lf,%lf", &top_long, &top_lat, &top_elev);
                if (argv[i].length()>plen) {
                    String fl=argv[i].substring(plen);
                    top_long=new Double(fl.substring(0,fl.indexOf(','))).doubleValue();
                    fl=fl.substring(fl.indexOf(',')+1);
                    top_lat=new Double(fl.substring(0,fl.indexOf(','))).doubleValue();
                    fl=fl.substring(fl.indexOf(',')+1);
                    top_elev=new Double(fl).doubleValue();
                }
                have_geopos = true;
            } else if (argv[i].equals("-true")) {
                iflag |= SweConst.SEFLG_TRUEPOS;
            } else if (argv[i].equals("-noaberr")) {
                iflag |= SweConst.SEFLG_NOABERR;
            } else if (argv[i].equals("-nodefl")) {
                iflag |= SweConst.SEFLG_NOGDEFL;
            } else if (argv[i].equals("-nonut")) {
                iflag |= SweConst.SEFLG_NONUT;
            } else if (argv[i].equals("-speed3")) {
                iflag |= SweConst.SEFLG_SPEED3;
            } else if (argv[i].equals("-speed")) {
                iflag |= SweConst.SEFLG_SPEED;
            } else if (argv[i].startsWith("-testaa")) {
                whicheph = SweConst.SEFLG_JPLEPH;
                fname=SweConst.SE_FNAME_DE200;
                if (argv[i].substring(7).equals("95"))
                    begindate = "j2449975.5";
                if (argv[i].substring(7).equals("96"))
                    begindate = "j2450442.5";
                if (argv[i].substring(7).equals("97"))
                    begindate = "j2450482.5";
                fmt = "PADRu";
                universal_time = false;
                plsel="3";
            } else if (argv[i].equals("-lunecl")) {
                smod |= SMOD_LUNAR;
                smod &= ~SMOD_SOLAR;
            } else if (argv[i].equals("-solecl")) {
                smod |= SMOD_SOLAR;
                search_flag |= SweConst.SE_ECL_CENTRAL;
                search_flag |= SweConst.SE_ECL_NONCENTRAL;
                have_geopos = true;
            } else if (argv[i].equals("-occult")) {
                smod |= SMOD_OCCULT;
                smod &= ~SMOD_SOLAR;
                smod &= ~SMOD_LUNAR;
                search_flag |= SweConst.SE_ECL_CENTRAL;
                search_flag |= SweConst.SE_ECL_NONCENTRAL;
                have_geopos = true;
            } else if (argv[i].equals("-hocal")) {
                /* used to create a listing for inclusion in hocal.c source code */
                smod |= SMOD_HOCAL;
            } else if (argv[i].equals("-how")) {
                smod |= SMOD_HOW;
            } else if (argv[i].equals("-total")) {
                smod |= SMOD_TOTAL;
            } else if (argv[i].equals("-annular")) {
                smod |= SMOD_ANNULAR;
            } else if (argv[i].equals("-anntot")) {
                smod |= SMOD_ANNTOT;
            } else if (argv[i].equals("-partial")) {
                smod |= SMOD_PARTIAL;
            } else if (argv[i].equals("-penumbral")) {
                smod |= SMOD_PENUMBRAL;
            } else if (argv[i].equals("-noncentral")) {
                search_flag &= ~SweConst.SE_ECL_CENTRAL;
                search_flag |= SweConst.SE_ECL_NONCENTRAL;
            } else if (argv[i].equals("-central")) {
                search_flag &= ~SweConst.SE_ECL_NONCENTRAL;
                search_flag |= SweConst.SE_ECL_CENTRAL;
            } else if (argv[i].equals("-local")) {
                smod |= SMOD_LOCAL;
            } else if (argv[i].equals("-rise")) {
                smod |= SMOD_RISE;
                smod &= ~SMOD_SOLAR;
                have_geopos = true;
            } else if (argv[i].equals("-norefrac")) {
                norefrac = true;
            } else if (argv[i].equals("-disccenter")) {
                disccenter = true;
            } else if (argv[i].equals("-hindu")) {
                norefrac = true;
                disccenter = true;
            } else if (argv[i].equals("-metr")) {
                smod |= SMOD_METR;
                smod &= ~SMOD_SOLAR;
                have_geopos = true;
            } else if (argv[i].equals("-bwd")) {
                direction = -1;
                direction_flag = true;
            } else if (argv[i].startsWith("-p")) {
                spno="";
                if (argv[i].length()>2) {
                    spno = argv[i].substring(2);
                    switch ((int)spno.charAt(0)) {
                        case (int)'d':
                            /*
                              case (int)'\0':
                              case (int)' ':
                            */
                            plsel = PLSEL_D; break;
                        case (int)'p':  plsel = PLSEL_P; break;
                        case (int)'h':  plsel = PLSEL_H; break;
                        case (int)'a':  plsel = PLSEL_A; break;
                        default:   plsel = spno;
                    }
                } else {
                    // We need at least one char in Java, to be able to use existing code
                    plsel = " ";
                }
            } else if (argv[i].startsWith("-xs")) {
                /* number of asteroid */
                sastno="0";
                if (argv[i].length()>3) {
                    sastno=argv[i].substring(3);
                }
            } else if (argv[i].startsWith("-xf")) {
                /* name or number of fixed star */
                star="";
                if (argv[i].length()>3) {
                    star=argv[i].substring(3);
                }
            } else if (argv[i].startsWith("-xz")) {
                /* number of hypothetical body */
                if (argv[i].length()>3) {
                    shyp=argv[i].substring(3);
                }
            } else if (argv[i].startsWith("-x")) {
                /* name or number of fixed star */
                star="";
                if (argv[i].length()>2) {
                    star=argv[i].substring(2);
                }
            } else if (argv[i].startsWith("-n")) {
                nstep=0;
                if (argv[i].length()>2) {
                    nstep = Integer.parseInt(argv[i].substring(2));
                }
                if (nstep==0) {
                    nstep=20;
                }
            } else if (argv[i].startsWith("-i")) {
                if (iflag_f<0) iflag_f = 0;
                if (argv[i].length()>2) {
                    iflag_f = Integer.parseInt(argv[i].substring(2));
                }
                if ((iflag_f & SweConst.SEFLG_XYZ)!=0)
                    fmt = "PX";
            } else if (argv[i].startsWith("-s")) {
                tstep=0;
                if (argv[i].length()>2) {
                    tstep = new Double(argv[i].substring(2)).doubleValue();
                }
            } else if (argv[i].startsWith("-b")) {
                begindate="";
                if (argv[i].length()>2) {
                    begindate = argv[i].substring(2);
                }
            } else if (argv[i].startsWith("-f")) {
                fmt="";
                if (argv[i].length()>2) {
                    fmt = argv[i].substring(2);
                }
            } else if (argv[i].startsWith("-g")) {
                gap = "\t";
                if (argv[i].length()>2) {
                    gap = argv[i].substring(2);
                }
            } else if (argv[i].startsWith("-d")
                       || argv[i].startsWith("-D")) {
                diff_mode = (int)argv[i].charAt(1); /* 'd' or 'D' */
                ipldiff=-1;
                if (argv[i].length()>2) {
                    sp = argv[i].substring(2);
                    ipldiff = letter_to_ipl((int) sp.charAt(0));
                }
                if (ipldiff <0) ipldiff = SweConst.SE_SUN;
                spnam2=sw.swe_get_planet_name(ipldiff);
            } else if (argv[i].equals("-roundsec")) {
                round_flag |= BIT_ROUND_SEC;
            } else if (argv[i].equals("-roundmin")) {
                round_flag |= BIT_ROUND_MIN;
            } else if (argv[i].startsWith("-t")) {
                if (argv[i].length() > 2) {
                    s1=argv[i].substring(2);
                    if (s1.indexOf(':')>=0) {
                        s1=s1.substring(0,s1.indexOf(':'))+"."+s1.substring(s1.indexOf(':')+1);
                        if (s1.indexOf(':')>=0) {
                            s1=s1.substring(0,s1.indexOf(':'))+s1.substring(s1.indexOf(':')+1);
                        }
                    }
                    thour = Double.valueOf(s1).doubleValue();
                    /* h.mmss -> decimal */
                    // Allowing for negative times: this is different from the C code!
                    t = (thour%1.) * 100 + (thour<0?-1e-10:1e-10);
                    j = (int) t;
                    t = (t%1.) * 100 + 1e-10;
                    thour = (int) thour + j / 60.0 + t / 3600.0;
                }
            } else if (argv[i].startsWith("-h")
                       || argv[i].startsWith("-?")) {
                sp=" ";
                if (argv[i].length()>2) {
                    sp = argv[i].substring(2);
                }
                if (sp.charAt(0) == 'c' || sp.charAt(0) == ' ') {
                    DevNull.print(infocmd0);
                    DevNull.print(infocmd1);
                    DevNull.print(infocmd2);
                    DevNull.print(infocmd3);
                    DevNull.print(infocmd4);
                    DevNull.print(infocmd5);
                }
                if (sp.charAt(0) == 'p' || sp.charAt(0) == ' ')
                    DevNull.print(infoplan);
                if (sp.charAt(0) == 'f' || sp.charAt(0) == ' ')
                    DevNull.print(infoform);
                if (sp.charAt(0) == 'd' || sp.charAt(0) == ' ')
                    DevNull.print(infodate);
                if (sp.charAt(0) == 'e' || sp.charAt(0) == ' ')
                    DevNull.print(infoexamp);
                //      goto end_main;
                /* close open files and free allocated space */
                sw.swe_close();
                return SweConst.OK;
            } else {
                sout="illegal option "+argv[i]+"\n";
                DevNull.print(sout);
                System.exit(1);
            }
        }
        if ((smod & (SMOD_OCCULT | SMOD_RISE | SMOD_METR)) != 0) {
            ipl = letter_to_ipl((int)plsel.charAt(0));
            if (plsel.charAt(0) == 'f')
                ipl = SweConst.SE_FIXSTAR;
            else
                star = "";
            if ((smod & SMOD_OCCULT)!=0 && ipl == 1)
                ipl = 2; /* no occultation of moon by moon */
        }
        geopos[0] = top_long;
        geopos[1] = top_lat;
        geopos[2] = top_elev;
        sw.swe_set_topo(top_long, top_lat, top_elev);
        if (with_header) {
            DevNull.print("swetest ");
            for (i = 0; i < argv.length; i++) {
                DevNull.print(argv[i]);
                DevNull.print(" ");
            }
        }
        iflag = (iflag & ~SweConst.SEFLG_EPHMASK) | whicheph;
        if (fmt.indexOf("S")>=0 || fmt.indexOf("s")>=0 || fmt.indexOf("Q")>=0)
            iflag |= SweConst.SEFLG_SPEED;
        String argv0=System.getProperties().getProperty("user.dir");
        if (ephepath.length()>0)
            sw.swe_set_ephe_path(ephepath);
        else if (make_ephemeris_path(iflag, argv0) == SweConst.ERR) {
            iflag = (iflag & ~SweConst.SEFLG_EPHMASK) | SweConst.SEFLG_MOSEPH;
            whicheph = SweConst.SEFLG_MOSEPH;
        }
        if ((whicheph & SweConst.SEFLG_JPLEPH)!=0)
            sw.swe_set_jpl_file(fname);
        while (true) {
            serr.setLength(0); serr_save.setLength(0); serr_warn.setLength(0);
            if (begindate == null) {
                DevNull.print("\nDate ?");
                sdate = "";
                try {
                    InputStreamReader in=new InputStreamReader(System.in);
                    BufferedReader bin=new BufferedReader(in);
                    sdate=bin.readLine();
                } catch (IOException ie) {
                    DevNull.println(ie.getMessage());
                }
            } else {
                sdate=begindate;
                begindate = ".";  /* to exit afterwards */
            }
            if (sdate.equals("-bary")) {
                iflag = iflag & ~SweConst.SEFLG_HELCTR;
                iflag |= SweConst.SEFLG_BARYCTR;
                sdate = "";
            } else if (sdate.equals("-hel")) {
                iflag = iflag & ~SweConst.SEFLG_BARYCTR;
                iflag |= SweConst.SEFLG_HELCTR;
                sdate = "";
            } else if (sdate.equals("-geo")) {
                iflag = iflag & ~SweConst.SEFLG_BARYCTR;
                iflag = iflag & ~SweConst.SEFLG_HELCTR;
                sdate = "";
            } else if (sdate.equals("-ejpl")) {
                iflag &= ~SweConst.SEFLG_EPHMASK;
                iflag |= SweConst.SEFLG_JPLEPH;
                sdate = "";
            } else if (sdate.equals("-eswe")) {
                iflag &= ~SweConst.SEFLG_EPHMASK;
                iflag |= SweConst.SEFLG_SWIEPH;
                sdate = "";
            } else if (sdate.equals("-emos")) {
                iflag &= ~SweConst.SEFLG_EPHMASK;
                iflag |= SweConst.SEFLG_MOSEPH;
                sdate = "";
            } else if (sdate.startsWith("-xs")) {
                sastno=sdate.substring(3);
                sdate = "";
            }
            sp = sdate;
            spsave = sp;
            if (sp.length()>0 && sp.charAt(0) == '.') {
                sw.swe_close();
                return SweConst.OK;
            } else if (sp.length() == 0) {
                sdate=saves;
                sp=sdate;
            } else {
                saves=sdate;
            }
            if (sp.length()>0 && sp.charAt(0) == 'j') {   /* it's a day number */
                if (sp.indexOf(',') >= 0)
                    sp=sp.substring(0,sp.indexOf(','))+'.'+sp.substring(sp.indexOf(',')+1);
                tjd = new Double(sp.substring(1)).doubleValue();
                if (tjd < 2299160.5)
                    gregflag = SweDate.SE_JUL_CAL;
                else
                    gregflag = SweDate.SE_GREG_CAL;
                if (sp.indexOf("jul") >= 0)
                    gregflag = SweDate.SE_JUL_CAL;
                else if (sp.indexOf("greg") >= 0)
                    gregflag = SweDate.SE_GREG_CAL;
                sd.setJulDay(tjd);
                sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                jyear=sd.getYear();
                jmon=sd.getMonth();
                jday=sd.getDay();
                jut=sd.getHour();
            } else if (sp.length()>0 && sp.charAt(0) == '+') {
                n=0;
                if (sp.length()>1) {
                    n = Integer.parseInt(sp.substring(1));
                }
                if (n == 0) n = 1;
                tjd += n;
                //      swe_revjul(tjd, gregflag, &jyear, &jmon, &jday, &jut);
                sd.setJulDay(tjd);
                jyear=sd.getYear();
                jmon=sd.getMonth();
                jday=sd.getDay();
                jut=sd.getHour();
            } else if (sp.length()>0 && sp.charAt(0) == '-') {
                n = Integer.parseInt(sp);
                if (n == 0) n = -1;
                tjd += n;
                //      swe_revjul(tjd, gregflag, &jyear, &jmon, &jday, &jut);
                sd.setJulDay(tjd);
                jyear=sd.getYear();
                jmon=sd.getMonth();
                jday=sd.getDay();
                jut=sd.getHour();
            } else {
                //      if (sscanf (sp, "%d%*c%d%*c%d", &jday,&jmon,&jyear) < 1) exit(1);
                jday=jmon=jyear=0;
                boolean neg=false;
                i=0;
                try {
                    neg=sp.charAt(0)=='-';
                    if (neg) { i++; }
                    while (Character.isDigit(sp.charAt(i))) {
                        jday=jday*10+Character.digit(sp.charAt(i++),10);
                    }
                    if (neg) { jday=-jday; neg=false; }

                    while (i<sp.length() &&
                           !Character.isDigit(sp.charAt(i)) && sp.charAt(i)!='-') { i++; }
                    neg=sp.charAt(i)=='-';
                    if (neg) { i++; }
                    while (i<sp.length() && Character.isDigit(sp.charAt(i))) {
                        jmon=jmon*10+Character.digit(sp.charAt(i++),10);
                    }
                    if (neg) { jmon=-jmon; neg=false; }

                    while (i<sp.length() &&
                           !Character.isDigit(sp.charAt(i)) && sp.charAt(i)!='-') { i++; }
                    neg=sp.charAt(i)=='-';
                    if (neg) { i++; }
                    while (i<sp.length() && Character.isDigit(sp.charAt(i))) {
                        jyear=jyear*10+Character.digit(sp.charAt(i++),10);
                    }
                    if (neg) { jyear=-jyear; }
                } catch (StringIndexOutOfBoundsException sob) {
                    System.exit(1);
                }
                if (jyear * 10000 + jmon * 100 + jday < 15821015)
                    gregflag = SweDate.SE_JUL_CAL;
                else
                    gregflag = SweDate.SE_GREG_CAL;
                if (sp.indexOf("jul") >= 0)
                    gregflag = SweDate.SE_JUL_CAL;
                else if (sp.indexOf("greg") >= 0)
                    gregflag = SweDate.SE_GREG_CAL;
                jut = 0;
                sd.setDate(jyear,jmon,jday,jut);
                sd.setCalendarType(gregflag,SweDate.SE_KEEP_DATE); // Keep Date!
                tjd = sd.getJulDay();
                tjd += thour / 24;
                sd.setJulDay(tjd);
            }
            line_count = 0;
            if (smod > 0) {
                do_eclipse_etc();
                sw.swe_close();
                return SweConst.OK;
            }
            for (t = tjd, istep = 1; istep <= nstep; t += tstep, istep++) {
                if (t < 2299160.5)
                    gregflag = SweDate.SE_JUL_CAL;
                else
                    gregflag = SweDate.SE_GREG_CAL;
                if (sp.indexOf("jul") >= 0)
                    gregflag = SweDate.SE_JUL_CAL;
                else if (spsave.indexOf("greg") >= 0)
                    gregflag = SweDate.SE_GREG_CAL;
                //      swe_revjul(t, gregflag, &jyear, &jmon, &jday, &jut);
                sd.setJulDay(t);
                sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                jyear=sd.getYear();
                jmon=sd.getMonth();
                jday=sd.getDay();
                jut=sd.getHour();
                if (with_header) {
                    sout="\ndate (dmy) "+jday+"."+jmon+"."+jyear;
                    DevNull.print(sout);
                    if (gregflag)
                        DevNull.print(" greg.");
                    else
                        DevNull.print(" jul.");
                    t2 = t + 0.5;
                    t2 += 0.5 / 86400; /* round to second */
                    t2 = (t2 - (int) t2) * 24;
                    sout="  "+f.fmt("% 2d",(int) t2)+":";
                    DevNull.print(sout);
                    t2 = (t2 - (int) t2) * 60;
                    sout=f.fmt("%02d",(int)t2)+":";
                    DevNull.print(sout);
                    t2 = (t2 - (int) t2) * 60;
                    sout=f.fmt("%02d",(int) t2);
                    DevNull.print(sout);
                    if (universal_time)
                        DevNull.print(" UT");
                    else
                        DevNull.print(" ET");
                }
                delt = sd.getDeltaT(t);
                if (universal_time) {
                    if (with_header) {
                        sout="\nUT: "+f.fmt("%f",t);
                        DevNull.print(sout);
                    }
                    if (with_header) {
                        sout="     delta t: "+f.fmt("%f",delt * 86400.0)+" sec";
                        DevNull.print(sout);
                    }
                    te = t + delt;
                    tut = t;
                } else {
                    te = t;
                    tut = t - delt;
                }
                iflgret = sw.swe_calc(te, SweConst.SE_ECL_NUT, iflag, xobl, serr);
                if (with_header) {
                    sout="\nET: "+f.fmt("%f",te);
                    DevNull.print(sout);
                    if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
                        daya = sw.swe_get_ayanamsa(te);
                        sout="   ayanamsa = "+dms(daya, round_flag);
                        DevNull.print(sout);
                    }
                    if (have_geopos) {
                        DevNull.print("\ngeo. long "+f.fmt("%f",geopos[0])+
                                         ", lat "+f.fmt("%f",geopos[1])+
                                         ", alt "+f.fmt("%f",geopos[2]));
                    }
                    if (iflag_f >=0)
                        iflag = iflag_f;
                    if (plsel.indexOf('o') < 0) {
                        sout="\n"+f.fmt("%-15s","Epsilon (true)")+" "+dms(xobl[0],round_flag);
                        DevNull.print(sout);
                    }
                    if (plsel.indexOf('n') < 0) {
                        s1=dms(xobl[2], round_flag);
                        s2=dms(xobl[3], round_flag);
                        //            sout="\nNutation        "+s1+gap+s2;
                        sout="\n"+f.fmt("%-15s","Nutation")+" "+s1+gap+s2;
                        DevNull.print(sout);
                    }
                    DevNull.print("\n");

                    if (do_houses) {
                        if (!universal_time) {
                            do_houses = false;
                            DevNull.print("option -house requires option -ut for "+
                                             "Universal Time\n");
                        } else {
                            s1 = dms(top_long, round_flag);
                            s2 = dms(top_lat, round_flag);
                            sout = "Houses system "+(char)ihsy+" for long="+s1+
                                ", lat="+s2+"\n";
                            DevNull.print(sout);
                        }     
                    }         
                }
                if (with_header && !with_header_always)
                    with_header = false;
                if (do_ayanamsa) {
                    daya = sw.swe_get_ayanamsa(te);
                    DevNull.print("Ayanamsa"+gap+dms(daya, round_flag)+"\n");
                    continue;
                }
                if (plsel.indexOf('e')>=0) {
                    print_line(MODE_LABEL);
                }
                for (psp = plsel, p=0; p<plsel.length(); p++) {
                    if (psp.charAt(p) == 'e') { continue; }
                    ipl = letter_to_ipl((int) psp.charAt(p));
                    if (psp.charAt(p) == 'f') {
                        ipl = SweConst.SE_FIXSTAR;
                    } else if (psp.charAt(p) == 's') {
                        try {
                            // Well, no: sastno may be appended a letter like '10s'!!!
                            //              ipl = Integer.parseInt(sastno) + 10000;
                            ipl = sl.atoi(sastno) + 10000;
                        } catch (NumberFormatException ne) {
                            ipl = SweConst.ERR;
                        }
                    } else if (psp.charAt(p) == 'z') {
                        try {
                            ipl = Integer.parseInt(shyp) + SweConst.SE_FICT_OFFSET_1;
                        } catch (NumberFormatException ne) {
                            ipl = SweConst.ERR;
                        }
                    }
                    if (ipl == -2) {
                        DevNull.print("illegal parameter -p"+plsel+"\n");
                        System.exit(1);
                    }
                    if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
                        if (ipl == SweConst.SE_SUN
                            || ipl == SweConst.SE_MEAN_NODE
                            || ipl == SweConst.SE_TRUE_NODE
                            || ipl == SweConst.SE_MEAN_APOG
                            || ipl == SweConst.SE_OSCU_APOG)
                            continue;
                    } else if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
                        if (ipl == SweConst.SE_MEAN_NODE || ipl == SweConst.SE_TRUE_NODE
                            || ipl == SweConst.SE_MEAN_APOG
                            || ipl == SweConst.SE_OSCU_APOG)
                            continue;
                    } else          /* geocentric */
                        if (ipl == SweConst.SE_EARTH)
                            continue;
                    /* ecliptic position */
                    if (iflag_f >=0)
                        iflag = iflag_f;
                    if (ipl == SweConst.SE_FIXSTAR) {
                        StringBuffer sstar=new StringBuffer(star);
                        iflgret = sw.swe_fixstar(sstar, te, iflag, x, serr);
                        star=sstar.toString();
                        se_pname=star;
                    } else {
                        iflgret = sw.swe_calc(te, ipl, iflag, x, serr);
                        /* phase, magnitude, etc. */
                        if (iflgret != SweConst.ERR && (fmt.indexOf("+")>=0 ||
                                                        fmt.indexOf("-")>=0 || fmt.indexOf("*")>=0 ||
                                                        fmt.indexOf("/")>=0 || fmt.indexOf("=")>=0)) {
                            iflgret = sw.swe_pheno(te, ipl, iflag, attr, serr);
                        }
                        se_pname=sw.swe_get_planet_name(ipl);
                    }
                    if (psp.charAt(p) == 'q') {/* delta t */
                        x[0] = sd.getDeltaT(te) * 86400;
                        x[1] = x[2] = x[3] = 0;
                        se_pname = "Delta T";
                    }
                    if (psp.charAt(p) == 'o') {/* ecliptic is wanted, remove nutation */
                        x[2] = x[3] = 0;
                        se_pname="Ecl. Obl.";
                    }
                    if (psp.charAt(p) == 'n') {/* nutation is wanted, remove ecliptic */
                        x[0] = x[2];
                        x[1] = x[3];
                        x[2] = x[3] = 0;
                        se_pname="Nutation";
                    }
                    if (iflgret < 0) {
                        if (!serr.toString().equals(serr_save.toString())
                            && (ipl == SweConst.SE_SUN || ipl == SweConst.SE_MOON
                                || ipl == SweConst.SE_MEAN_NODE
                                || ipl == SweConst.SE_TRUE_NODE || ipl == SweConst.SE_CHIRON
                                || ipl == SweConst.SE_PHOLUS || ipl == SweConst.SE_CUPIDO
                                || ipl >= SweConst.SE_AST_OFFSET
                                || ipl == SweConst.SE_FIXSTAR)) {
                            sout="error: "+serr.toString()+"\n";
                            DevNull.print(sout);
                        }
                        serr_save=new StringBuffer(serr.toString());
                    } else if (serr.length()>0 && serr_warn.length()==0) {
                        if (serr.toString().indexOf("'seorbel.txt' not found")<0) {
                            serr_warn=new StringBuffer(serr.toString());
                        }
                    }
                    if (diff_mode != 0) {
                        iflgret = sw.swe_calc(te, ipldiff, iflag, x2, serr);
                        if (iflgret < 0) {
                            sout="error: "+serr.toString()+"\n";
                            DevNull.print(sout);
                        }
                        if (diff_mode == DIFF_DIFF) {
                            for (i = 1; i < 6; i++)
                                x[i] -= x2[i];
                            if ((iflag & SweConst.SEFLG_RADIANS) == 0)
                                x[0] = sl.swe_difdeg2n(x[0], x2[0]);
                            else
                                x[0] = sl.swe_difrad2n(x[0], x2[0]);
                        } else {      /* DIFF_MIDP */
                            for (i = 1; i < 6; i++)
                                x[i] = (x[i] + x2[i]) / 2;
                            if ((iflag & SweConst.SEFLG_RADIANS) == 0)
                                x[0] = sl.swe_deg_midp(x[0], x2[0]);
                            else
                                x[0] = sl.swe_rad_midp(x[0], x2[0]);
                        }
                    }
                    /* equator position */
                    //        if (strpbrk(fmt, "aADdQ") != null) { ... }
                    if (fmt.indexOf("a")>=0 || fmt.indexOf("A")>=0 ||
                        fmt.indexOf("D")>=0 || fmt.indexOf("d")>=0 ||
                        fmt.indexOf("Q")>=0) {
                        iflag2 = iflag | SweConst.SEFLG_EQUATORIAL;
                        if (ipl == SweConst.SE_FIXSTAR) {
                            StringBuffer sstar=new StringBuffer(star);
                            iflgret = sw.swe_fixstar(sstar, te, iflag2, xequ, serr);
                            star=sstar.toString();
                        } else {
                            iflgret = sw.swe_calc(te, ipl, iflag2, xequ, serr);
                        }
                        if (diff_mode != 0) {
                            iflgret = sw.swe_calc(te, ipldiff, iflag2, x2, serr);
                            if (diff_mode == DIFF_DIFF) {
                                for (i = 1; i < 6; i++)
                                    xequ[i] -= x2[i];
                                if ((iflag & SweConst.SEFLG_RADIANS) == 0)
                                    xequ[0] = sl.swe_difdeg2n(xequ[0], x2[0]);
                                else
                                    xequ[0] = sl.swe_difrad2n(xequ[0], x2[0]);
                            } else {    /* DIFF_MIDP */
                                for (i = 1; i < 6; i++)
                                    xequ[i] = (xequ[i] + x2[i]) / 2;
                                if ((iflag & SweConst.SEFLG_RADIANS) == 0)
                                    xequ[0] = sl.swe_deg_midp(xequ[0], x2[0]);
                                else
                                    xequ[0] = sl.swe_rad_midp(xequ[0], x2[0]);
                            }
                        }
                    }
                    /* azimuth and height */
                    //        if (strpbrk(fmt, "IiHhKk") != NULL) { ... }
                    if (fmt.indexOf("I")>=0 || fmt.indexOf("i")>=0 ||
                        fmt.indexOf("H")>=0 || fmt.indexOf("h")>=0 ||
                        fmt.indexOf("K")>=0 || fmt.indexOf("k")>=0) {
                        /* first, get topocentric equatorial positions */
                        iflgt = whicheph | SweConst.SEFLG_EQUATORIAL | SweConst.SEFLG_TOPOCTR;
                        if (ipl == SweConst.SE_FIXSTAR) {
                            StringBuffer sstar=new StringBuffer(star);
                            iflgret = sw.swe_fixstar(sstar, te, iflgt, xt, serr);
                            star=sstar.toString();
                        } else {
                            iflgret = sw.swe_calc(te, ipl, iflgt, xt, serr);
                        }
                        /* to azimuth/height */
                        sw.swe_azalt(tut, SweConst.SE_EQU2HOR, geopos, 1013.25, 10, xt, xaz);
                        if (diff_mode!=0) {
                            iflgret = sw.swe_calc(te, ipldiff, iflgt, xt, serr);
                            sw.swe_azalt(tut, SweConst.SE_EQU2HOR, geopos, 1013.25, 10, xt, x2);
                            if (diff_mode == DIFF_DIFF) {
                                for (i = 1; i < 3; i++)
                                    xaz[i] -= x2[i];
                                if ((iflag & SweConst.SEFLG_RADIANS) == 0)
                                    xaz[0] = sl.swe_difdeg2n(xaz[0], x2[0]);
                                else
                                    xaz[0] = sl.swe_difrad2n(xaz[0], x2[0]);
                            } else {    /* DIFF_MIDP */
                                for (i = 1; i < 3; i++)
                                    xaz[i] = (xaz[i] + x2[i]) / 2;
                                if ((iflag & SweConst.SEFLG_RADIANS) == 0)
                                    xaz[0] = sl.swe_deg_midp(xaz[0], x2[0]);
                                else
                                    xaz[0] = sl.swe_rad_midp(xaz[0], x2[0]);
                            }
                        }
                    }
                    /* ecliptic cartesian position */
                    //        if (strpbrk(fmt, "XU") != null) { ... }
                    if (fmt.indexOf("X")>=0 || fmt.indexOf("U")>=0) {
                        iflag2 = iflag | SweConst.SEFLG_XYZ;
                        if (ipl == SweConst.SE_FIXSTAR) {
                            StringBuffer sstar=new StringBuffer(star);
                            iflgret = sw.swe_fixstar(sstar, te, iflag2, xcart, serr);
                            star=sstar.toString();
                        } else {
                            iflgret = sw.swe_calc(te, ipl, iflag2, xcart, serr);
                        }
                        if (diff_mode != 0) {
                            iflgret = sw.swe_calc(te, ipldiff, iflag2, x2, serr);
                            if (diff_mode == DIFF_DIFF) {
                                for (i = 0; i < 6; i++)
                                    xcart[i] -= x2[i];
                            } else {
                                xcart[i] = (xcart[i] + x2[i]) / 2;
                            }
                        }
                    }
                    /* equator cartesian position */
                    //        if (strpbrk(fmt, "xu") != null) { ... }
                    if (fmt.indexOf("x")>=0 || fmt.indexOf("u")>=0) {
                        iflag2 = iflag | SweConst.SEFLG_XYZ | SweConst.SEFLG_EQUATORIAL;
                        if (ipl == SweConst.SE_FIXSTAR) {
                            StringBuffer sstar=new StringBuffer(star);
                            iflgret = sw.swe_fixstar(sstar, te, iflag2, xcartq, serr);
                            star=sstar.toString();
                        } else {
                            iflgret = sw.swe_calc(te, ipl, iflag2, xcartq, serr);
                        }
                        if (diff_mode != 0) {
                            iflgret = sw.swe_calc(te, ipldiff, iflag2, x2, serr);
                            if (diff_mode == DIFF_DIFF) {
                                for (i = 0; i < 6; i++)
                                    xcartq[i] -= x2[i];
                            } else {
                                xcartq[i] = (xcart[i] + x2[i]) / 2;
                            }
                        }
                    }
                    /* house position */
                    //          if (strpbrk(fmt, "gGj") != NULL) { ... }
                    if (fmt.indexOf("g")>=0 || fmt.indexOf("G")>=0 || fmt.indexOf("j")>=0) {
                        armc = sl.swe_degnorm(sl.swe_sidtime(tut) * 15 + geopos[0]);
                        for (i = 0; i < 6; i++)
                            xsv[i] = x[i];
                        if (hpos_meth == 1)
                            xsv[1] = 0;
                        if (ipl == SweConst.SE_FIXSTAR)
                            star2=star;
                        else
                            star2 = "";
                        if (hpos_meth >= 2 && Character.toLowerCase((char)ihsy) == 'g') {
                            StringBuffer sstar2=new StringBuffer(star2);
                            sw.swe_gauquelin_sector(tut, ipl, sstar2, iflag, hpos_meth, geopos, 0, 0, hposj, serr);
                            star2=sstar2.toString();
                        } else {
                            hposj.val = sw.swe_house_pos(armc, geopos[1], xobl[0], ihsy, xsv, serr);
                        }
                        if (Character.toLowerCase((char)ihsy) == 'g')
                            hpos = (hposj.val - 1) * 10;
                        else
                            hpos = (hposj.val - 1) * 30;
                        if (diff_mode!=0) {
                            for (i = 0; i < 6; i++)
                                xsv[i] = x2[i];
                            if (hpos_meth == 1)
                                xsv[1] = 0;
                            hpos2 = sw.swe_house_pos(armc, geopos[1], xobl[0], ihsy, xsv, serr);
                            if (Character.toLowerCase((char)ihsy) == 'g')
                                hpos2 = (hpos2 - 1) * 10;
                            else
                                hpos2 = (hpos2 - 1) * 30;
                            if (diff_mode == DIFF_DIFF) {
                                if ((iflag & SweConst.SEFLG_RADIANS) == 0)
                                    hpos = sl.swe_difdeg2n(hpos, hpos2);
                                else
                                    hpos = sl.swe_difrad2n(hpos, hpos2);
                            } else {    /* DIFF_MIDP */
                                if ((iflag & SweConst.SEFLG_RADIANS) == 0)
                                    hpos = sl.swe_deg_midp(hpos, hpos2);
                                else
                                    hpos = sl.swe_rad_midp(hpos, hpos2);
                            }
                        }
                    }
                    spnam=se_pname;
                    print_line(0);
                    line_count++;
                    if (line_count >= line_limit) {
                        sout="****** line count "+line_limit+" was exceeded\n";
                        DevNull.print(sout);
                        break;
                    }
                }         /* for psp */
                if (do_houses) {
                    double cusp[]=new double[100];
                    int iofs;
                    if (Character.toLowerCase((char)ihsy) == 'g')
                        nhouses = 36;
                    iofs = nhouses + 1;
                    iflgret = sw.swe_houses(t,iflag, top_lat, top_long, ihsy, cusp, cusp, iofs);
                    if (iflgret < 0) {
                        if (!serr.toString().equals(serr_save.toString())) {
                            sout="error: "+serr.toString()+"\n";
                            DevNull.print(sout);
                        }
                        serr_save=new StringBuffer(serr.toString());
                    } else {
                        for (ipl = 1; ipl < iofs+4; ipl++) {
                            x[0] = cusp[ipl];
                            x[1] = 0;   /* latitude */
                            x[2] = 1.0; /* pseudo radius vector */
                            //              if (strpbrk(fmt, "aADdQ") != NULL)
                            if (fmt.indexOf('a')>=0 || fmt.indexOf('A')>=0 ||
                                fmt.indexOf('D')>=0 || fmt.indexOf('d')>=0 ||
                                fmt.indexOf('Q')>=0) {
                                sl.swe_cotrans(x, 0, xequ, 0, -xobl[0]);
                            }
                            print_line(MODE_HOUSE);
                            line_count++;
                        }
                    }
                }   
                if (line_count >= line_limit)
                    break;
            }           /* for tjd */
            if (serr_warn.length() != 0) {
                DevNull.print("\nwarning: ");
                DevNull.print(serr_warn.toString());
                DevNull.print("\n");
            }
        }             /* while 1 */
    }

    /*
     * The string fmt contains a sequence of format specifiers;
     * each character in fmt creates a column, the columns are
     * sparated by the gap string.
     */
    int print_line(int mode) {
        String sp, sp2, sout;
        double t2, ju2 = 0;
        double y_frac;
        double ar, sinp;
        boolean is_house = ((mode & MODE_HOUSE) != 0);
        boolean is_label = ((mode & MODE_LABEL) != 0);
        int iflgret;
        int c=0;
        for (sp = fmt; c<fmt.length(); c++) {
            if (is_house && "bBsSrRxXuUQnNfF+-*/=".indexOf(sp.charAt(c))>=0) {
                continue;
            }
            if (c != 0)
                DevNull.print(gap);
            switch((int)sp.charAt(c)) {
                case (int)'y':
                    if (is_label) { DevNull.println("year"); break; }
                    sout=""+jyear;
                    DevNull.print(sout);
                    break;
                case (int)'Y':
                    if (is_label) { DevNull.println("year"); break; }
                    t2 = sd.getJulDay(jyear,1,1,ju2,gregflag);
                    y_frac = (t - t2) / 365.0;
                    sout=f.fmt("%.2f",jyear + y_frac);
                    DevNull.print(sout);
                    break;
                case (int)'p':
                    if (is_label) { DevNull.println("obj.nr"); break; }
                    if (!is_house && diff_mode == DIFF_DIFF)
                        sout=""+ipl+"-"+ipldiff;
                    else if (!is_house && diff_mode == DIFF_MIDP)
                        sout=""+ipl+"/"+ipldiff;
                    else
                        sout=""+ipl;
                    DevNull.print(sout);
                    break;
                case (int)'P':
                    if (is_label) { DevNull.println("name           "); break; }
                    if (is_house) {
                        if (ipl <= nhouses)
                            sout="house "+f.fmt("%2d",ipl)+"       ";
                        else
                            sout=f.fmt("%-15s",hs_nam[ipl - nhouses]);
                    } else if (diff_mode == DIFF_DIFF)
                        sout=f.fmt("%.3s",spnam)+"-"+f.fmt("%.3s",spnam2);
                    else if (diff_mode == DIFF_MIDP)
                        sout=f.fmt("%.3s",spnam)+"/"+f.fmt("%.3s",spnam2);
                    else {
                        sout=f.fmt("%-15s",spnam);
                    }
                    DevNull.print(sout);
                    break;
                case (int)'J':
                    if (is_label) { DevNull.println("julday"); break; }
                    y_frac = (t - (int)(t)) * 100;
                    if ((int)(y_frac) != y_frac)
                        sout=f.fmt("%.5f", t);
                    else
                        sout=f.fmt("%.2f", t);
                    DevNull.print(sout);
                    break;
                case (int)'T':
                    if (is_label) { DevNull.println("date"); break; }
                    sout=f.fmt("%02d",jday)+"."+f.fmt("%02d",jmon)+"."+jyear;
                    if (jut != 0) {
                        int h, m, s;
                        s = (int) (jut * 3600 + 0.5);
                        h = (int) (s / 3600.0);
                        m = (int) ((s % 3600) / 60.0);
                        s %= 60;
                        sout+=" "+f.fmt("%d",h)+":"+f.fmt("%02d",m)+":"+
                            f.fmt("%02d",s);
                        if (universal_time)
                            sout+=" UT";
                        else
                            sout+=" ET";
                    }
                    DevNull.print(sout);
                    break;
                case (int)'t':
                    if (is_label) { DevNull.println("date"); break; }
                    sout=f.fmt("%02d",jyear % 100)+f.fmt("%02d",jmon)+
                        f.fmt("%02d",jday);
                    DevNull.print(sout);
                    break;
                case (int)'L':
                    if (is_label) { DevNull.println("long."); break; }
                    if (p >= psp.length() || (p < psp.length() && psp.charAt(p) != 'q')) { /* != delta t */
                        DevNull.print(dms(x[0], round_flag));
                        break;
                    }
                    // Fall through else...
                case (int)'l':
                    if (is_label && sp.charAt(c) != 'l') { DevNull.println("long"); break; }
                    sout=f.fmt("%# 11.7f", x[0]);
                    DevNull.print(sout);
                    break;
                case (int)'G':
                    if (is_label) { DevNull.println("housPos"); break; }
                    DevNull.print(dms(hpos, round_flag));
                    break;
                case (int)'g':
                    if (is_label) { DevNull.println("housPos"); break; }
                    sout=f.fmt("%# 11.7f", hpos);
                    DevNull.print(sout);
                    break;
                case (int)'j':
                    if (is_label) { DevNull.println("houseNr"); break; }
                    sout=f.fmt("%# 11.7f", hposj.val);
                    DevNull.print(sout);
                    break;
                case (int)'Z':
                    if (is_label) { DevNull.println("long"); break; }
                    DevNull.print(dms(x[0], round_flag|BIT_ZODIAC));
                    break;
                case (int)'S':
                case (int)'s':
                    if (fmt.indexOf("X")>=0 || fmt.indexOf("U")>=0 ||
                        fmt.indexOf("x")>=0 || fmt.indexOf("u")>=0 ||
                        (sp.length()>c+1 &&
                         (sp.charAt(c+1) == 'S' || sp.charAt(c+1) == 's'))) {
                        int c2=0;
                        for (sp2 = fmt; c2<fmt.length(); c2++) {
                            if (c2 != 0)
                                DevNull.print(gap);
                            switch((int)sp2.charAt(c2)) {
                                case (int)'L':   /* speed! */
                                case (int)'Z':   /* speed! */
                                    if (is_label) { DevNull.println("lon/day"); break; }
                                    DevNull.print(dms(x[3], round_flag));
                                    break;
                                case (int)'l':   /* speed! */
                                    if (is_label) { DevNull.println("lon/day"); break; }
                                    sout=f.fmt("%11.7f", x[3]);
                                    DevNull.print(sout);
                                    break;
                                case (int)'B':   /* speed! */
                                    if (is_label) { DevNull.println("lat/day"); break; }
                                    DevNull.print(dms(x[4], round_flag));
                                    break;
                                case (int)'b':   /* speed! */
                                    if (is_label) { DevNull.println("lat/day"); break; }
                                    sout=f.fmt("%11.7f", x[4]);
                                    DevNull.print(sout);
                                    break;
                                case (int)'A':   /* speed! */
                                    if (is_label) { DevNull.println("RA/day"); break; }
                                    DevNull.print(dms(xequ[3]/15,
                                                         round_flag|SweConst.SEFLG_EQUATORIAL));
                                    break;
                                case (int)'a':   /* speed! */
                                    if (is_label) { DevNull.println("RA/day"); break; }
                                    sout=f.fmt("%11.7f", xequ[3]);
                                    DevNull.print(sout);
                                    break;
                                case (int)'D':   /* speed! */
                                    if (is_label) { DevNull.println("dcl/day"); break; }
                                    DevNull.print(dms(xequ[4], round_flag));
                                    break;
                                case (int)'d':   /* speed! */
                                    if (is_label) { DevNull.println("dcl/day"); break; }
                                    sout=f.fmt("%11.7f", xequ[4]);
                                    DevNull.print(sout);
                                    break;
                                case (int)'R':   /* speed! */
                                case (int)'r':   /* speed! */
                                    if (is_label) { DevNull.println("AU/day"); break; }
                                    sout=f.fmt("%# 14.9f", x[5]);
                                    DevNull.print(sout);
                                    break;
                                case (int)'U':   /* speed! */
                                case (int)'X':   /* speed! */
                                    if (is_label) { DevNull.println("speed_0"+gap+"speed_1"+gap+"speed_2"); break; }
                                    if (sp.charAt(c) =='U')
                                        ar = Math.sqrt(square_sum(xcart));
                                    else
                                        ar = 1;
                                    sout=f.fmt("%# 14.9f", xcart[3]/ar)+gap;
                                    DevNull.print(sout);
                                    sout=f.fmt("%# 14.9f", xcart[4]/ar)+gap;
                                    DevNull.print(sout);
                                    sout=f.fmt("%# 14.9f", xcart[5]/ar);
                                    DevNull.print(sout);
                                    break;
                                case (int)'u':   /* speed! */
                                case (int)'x':   /* speed! */
                                    if (is_label) { DevNull.println("speed_0"+gap+"speed_1"+gap+"speed_2"); break; }
                                    if (sp.charAt(c) =='u')
                                        ar = Math.sqrt(square_sum(xcartq));
                                    else
                                        ar = 1;
                                    sout=f.fmt("%# 14.9f", xcartq[3]/ar)+gap;
                                    DevNull.print(sout);
                                    sout=f.fmt("%# 14.9f", xcartq[4]/ar)+gap;
                                    DevNull.print(sout);
                                    sout=f.fmt("%# 14.9f", xcartq[5]/ar);
                                    DevNull.print(sout);
                                    break;
                                default:
                                    break;
                            }
                        }
                        if (sp.charAt(c+1) == 'S' || sp.charAt(c+1) == 's')
                            c++;
                    } else if (sp.charAt(c) == 'S') {
                        if (is_label) { DevNull.println("deg/day"); break; }
                        DevNull.print(dms(x[3], round_flag));
                    } else {
                        if (is_label) { DevNull.println("deg/day"); break; }
                        DevNull.print(f.fmt("%# 11.7f", x[3]));
                    }
                    break;
                case (int)'B':
                    if (is_label) { DevNull.println("lat"); break; }
                    DevNull.print(dms(x[1], round_flag));
                    break;
                case (int)'b':
                    if (is_label) { DevNull.println("lat"); break; }
                    sout=f.fmt("%# 11.7f", x[1]);
                    DevNull.print(sout);
                    break;
                case (int)'A':     /* rectascensio */
                    if (is_label) { DevNull.println("RA"); break; }
                    DevNull.print(dms(xequ[0]/15,
                                         round_flag|SweConst.SEFLG_EQUATORIAL));
                    break;
                case (int)'a':     /* rectascensio */
                    if (is_label) { DevNull.println("RA"); break; }
                    sout=f.fmt("%# 11.7f", xequ[0]);
                    DevNull.print(sout);
                    break;
                case (int)'D':     /* declination */
                    if (is_label) { DevNull.println("decl"); break; }
                    DevNull.print(dms(xequ[1], round_flag));
                    break;
                case (int)'d':     /* declination */
                    if (is_label) { DevNull.println("decl"); break; }
                    sout=f.fmt("%# 11.7f", xequ[1]);
                    DevNull.print(sout);
                    break;
                case 'I':     /* azimuth */
                    if (is_label) { DevNull.println("azimuth"); break; }
                    DevNull.print(dms(xaz[0], round_flag));
                    break;
                case 'i':     /* azimuth */
                    if (is_label) { DevNull.println("azimuth"); break; }
                    sout=f.fmt("%# 11.7f", xaz[0]);
                    DevNull.print(sout);
                    break;
                case 'H':     /* height */
                    if (is_label) { DevNull.println("height"); break; }
                    DevNull.print(dms(xaz[1], round_flag));
                    break;
                case 'h':     /* height */
                    if (is_label) { DevNull.println("height"); break; }
                    sout=f.fmt("%# 11.7f", xaz[1]);
                    DevNull.print(sout);
                    break;
                case 'K':     /* height (apparent) */
                    if (is_label) { DevNull.println("hgtApp"); break; }
                    DevNull.print(dms(xaz[2], round_flag));
                    break;
                case 'k':     /* height (apparent) */
                    if (is_label) { DevNull.println("hgtApp"); break; }
                    sout=f.fmt("%# 11.7f", xaz[2]);
                    DevNull.print(sout);
                    break;
                case (int)'R':
                    if (is_label) { DevNull.println("distAU"); break; }
                    sout=f.fmt("%# 14.9f", x[2]);
                    DevNull.print(sout);
                    break;
                case (int)'r':
                    if (is_label) { DevNull.println("dist"); break; }
                    if ( ipl == SweConst.SE_MOON ) { /* for moon print parallax */
                        sinp = 8.794 / x[2];    /* in seconds of arc */
                        ar = sinp * (1 + sinp * sinp * 3.917402e-12);
                        /* the factor is 1 / (3600^2 * (180/pi)^2 * 6) */
                        sout=f.fmt("%# 13.5f",ar)+"\"";
                    } else {
                        sout=f.fmt("%# 14.9f", x[2]);
                    }
                    DevNull.print(sout);
                    break;
                case (int)'U':
                case (int)'X':
                    if (sp.charAt(c) =='U')
                        ar = Math.sqrt(square_sum(xcart));
                    else
                        ar = 1;
                    sout=f.fmt("%# 14.9f", xcart[0]/ar)+gap;
                    DevNull.print(sout);
                    sout=f.fmt("%# 14.9f", xcart[1]/ar)+gap;
                    DevNull.print(sout);
                    sout=f.fmt("%# 14.9f", xcart[2]/ar);
                    DevNull.print(sout);
                    break;
                case (int)'u':
                case (int)'x':
                    if (is_label) { DevNull.println("x0"+gap+"x1"+gap+"x2"); break; }
                    if (sp.charAt(c) =='u')
                        ar = Math.sqrt(square_sum(xcartq));
                    else
                        ar = 1;
                    sout=f.fmt("%# 14.9f", xcartq[0]/ar)+gap;
                    DevNull.print(sout);
                    sout=f.fmt("%# 14.9f", xcartq[1]/ar)+gap;
                    DevNull.print(sout);
                    sout=f.fmt("%# 14.9f", xcartq[2]/ar);
                    DevNull.print(sout);
                    break;
                case (int)'Q':
                    if (is_label) { DevNull.println("Q"); break; }
                    //                sout=f.fmt("%-15s", spnam);
                    sout=(spnam+"               ").substring(0,Math.max(15,spnam.length()));
                    DevNull.print(sout);
                    DevNull.print(dms(x[0], round_flag));
                    DevNull.print(dms(x[1], round_flag));
                    sout="  "+f.fmt("%# 14.9f", x[2]);
                    DevNull.print(sout);
                    DevNull.print(dms(x[3], round_flag));
                    DevNull.print(dms(x[4], round_flag));
                    sout="  "+f.fmt("%# 14.9f", x[5])+"\n";
                    DevNull.print(sout);
                    sout="               "+dms(xequ[0], round_flag);
                    DevNull.print(sout);
                    DevNull.print(dms(xequ[1], round_flag));
                    sout="                "+dms(xequ[3], round_flag);
                    DevNull.print(sout);
                    DevNull.print(dms(xequ[4], round_flag));
                    break;
                case 'N':
                case 'n': {
                    double xasc[]=new double[6], xdsc[]=new double[6];
                    int imeth = (Character.isLowerCase(sp.charAt(c)))?
                        SweConst.SE_NODBIT_MEAN:SweConst.SE_NODBIT_OSCU;
                    iflgret = sw.swe_nod_aps(te, ipl, iflag, imeth, xasc,
                                             xdsc, null, null, serr);
                    if (iflgret >= 0 &&
                        (ipl <= SweConst.SE_NEPTUNE || sp.charAt(c) == 'N') ) {
                        if (is_label) { DevNull.println("nodAsc"+gap+"nodDesc"); break; }
                        DevNull.print(f.fmt("%# 11.7f",xasc[0]));
                        DevNull.print(gap);
                        DevNull.print(f.fmt("%# 11.7f",xdsc[0]));
                    }
                };
                    break;
                case 'F':
                case 'f':
                    if (!is_house) {
                        double xfoc[]=new double[6], xaph[]=new double[6],
                            xper[]=new double[6];
                        int imeth = (Character.isLowerCase(sp.charAt(c)))?
                            SweConst.SE_NODBIT_MEAN:SweConst.SE_NODBIT_OSCU;
                        iflgret = sw.swe_nod_aps(te, ipl, iflag, imeth, null, null,
                                                 xper, xaph, serr);
                        if (iflgret >= 0 && (ipl <= SweConst.SE_NEPTUNE ||
                                             sp.charAt(c) == 'F') ) {
                            if (is_label) { DevNull.println("peri"+gap+"apo"); break; }
                            DevNull.print(f.fmt("%# 11.7f", xper[0]));
                            DevNull.print(gap);
                            DevNull.print(f.fmt("%# 11.7f", xaph[0]));
                        }
                        imeth |= SweConst.SE_NODBIT_FOPOINT;
                        iflgret = sw.swe_nod_aps(te, ipl, iflag, imeth, null, null,
                                                 xper, xfoc, serr);
                        if (iflgret >= 0 && (ipl <= SweConst.SE_NEPTUNE ||
                                             sp.charAt(c) == 'F') ) {
                            if (is_label) { DevNull.println(gap+"focus"); break; }
                            DevNull.print(gap);
                            DevNull.print(f.fmt("%# 11.7f", xfoc[0]));
                        }
                    };
                    break;
                case '+':
                    if (is_house) break;
                    if (is_label) { DevNull.println("phase"); break; }
                    DevNull.print(dms(attr[0], round_flag));
                    break;
                case '-':
                    if (is_label) { DevNull.println("phase"); break; }
                    if (is_house) break;
                    DevNull.print("  "+f.fmt("%# 14.9f", attr[1]));
                    break;
                case '*':
                    if (is_label) { DevNull.println("elong"); break; }
                    if (is_house) break;
                    DevNull.print(dms(attr[2], round_flag));
                    break;
                case '/':
                    if (is_label) { DevNull.println("diamet"); break; }
                    if (is_house) break;
                    DevNull.print(dms(attr[3], round_flag));
                    break;
                case '=':
                    if (is_label) { DevNull.println("magn"); break; }
                    if (is_house) break;
                    DevNull.print("  "+f.fmt("%# 6.1f", attr[4])+"m");
                    break;
            }     /* switch */
        }       /* for sp */
        DevNull.print("\n");
        return SweConst.OK;
    }

    private String dms(double xv, int iflag) {
        int izod;
        int k, kdeg, kmin, ksec;
        String c = swed.ODEGREE_CHAR;
        String s1;
        String s;
        int sgn;
        s = "";
        if ((iflag & SweConst.SEFLG_EQUATORIAL)!=0)
            c = "h";
        if (xv < 0) {
            xv = -xv;
            sgn = -1;
        } else
            sgn = 1;
        if ((iflag & BIT_ROUND_MIN)!=0)
            xv = sl.swe_degnorm(xv + 0.5/60);
        if ((iflag & BIT_ROUND_SEC)!=0)
            xv = sl.swe_degnorm(xv + 0.5/3600);
        if ((iflag & BIT_ZODIAC)!=0) {
            izod = (int) (xv / 30)%12;
            xv%=30.;
            kdeg = (int) xv;
            s=f.fmt("%2ld",kdeg)+" "+zod_nam[izod]+" ";
        } else {
            kdeg = (int) xv;
            s=" "+f.fmt("%3ld", kdeg)+c;
        }
        xv -= kdeg;
        xv *= 60;
        kmin = (int) xv;
        if ((iflag & BIT_ZODIAC)!=0 && (iflag & BIT_ROUND_MIN)!=0)
            s1=f.fmt("%2ld", kmin);
        else
            s1=f.fmt("%2ld", kmin)+"'";
        s+=s1;
        if ((iflag & BIT_ROUND_MIN)!=0)
            return return_dms(sgn,s);
        xv -= kmin;
        xv *= 60;
        ksec = (int) xv;
        if ((iflag & BIT_ROUND_SEC)!=0)
            s1=f.fmt("%2ld", ksec)+"\"";
        else
            s1=f.fmt("%2ld", ksec);
        s+=s1;
        if ((iflag & BIT_ROUND_SEC)!=0)
            return return_dms(sgn,s);
        xv -= ksec;
        k = (int) (xv * 10000);
        s1="."+f.fmt("%04ld", k);
        s+=s1;
        return return_dms(sgn,s);
    }

    private String return_dms(int sgn, String s) {
        if (sgn < 0) {
            for (int i=0; i<s.length();i++) {
                if (Character.isDigit(s.charAt(i))) {
                    s=s.substring(0,i-1)+"-"+s.substring(i);
                    break;
                }
            }
        }

        // such a hack that I am ashamed, but I say fuck it, I don't want to try
        // to figure out what this code does, the interface is very very
        // confusing, and I am no astrologist, astrologer, nor I want to become
        // one. Never spent such a long time to get one fucking number out of a
        // system, I swear to God.        
        globalResult = s;
        
        return(s);
    }

    private int letter_to_ipl(int letter) {
        if (letter >= (int)'0' && letter <= (int)'9')
            return letter - (int)'0' + SweConst.SE_SUN;
        if (letter >= (int)'A' && letter <= (int)'I')
            return letter - (int)'A' + SweConst.SE_MEAN_APOG;
        if (letter >= (int)'J' && letter <= (int)'Z')
            return letter - (int)'J' + SweConst.SE_CUPIDO;
        switch (letter) {
            case (int)'m': return SweConst.SE_MEAN_NODE;
            case (int)'c': return SweConst.SE_INTP_APOG;
            case (int)'g': return SweConst.SE_INTP_PERG;
            case (int)'n':
            case (int)'o': return SweConst.SE_ECL_NUT;
            case (int)'t': return SweConst.SE_TRUE_NODE;
            case (int)'f': return SweConst.SE_FIXSTAR;
            case (int)'w': return SweConst.SE_WALDEMATH;
            case 'e': /* swetest: a line of labels */
            case 'q': /* swetest: delta t */
            case 's': /* swetest: an asteroid, with number given in -xs[number] */
            case 'z': /* swetest: a fictitious body, number given in -xz[number] */
            case 'd': /* swetest: default (main) factors 0123456789mtABC */
            case 'p': /* swetest: main factors ('d') plus main asteroids DEFGHI */
            case 'h': /* swetest: fictitious factors JKLMNOPQRSTUVWXYZw */
            case 'a': /* swetest: all factors, like 'p'+'h' */
                return -1;
        }
        return -2;
    }


    private int do_eclipse_etc() {
        DblObj dtmp=new DblObj();
        StringBuffer sstar;
        int ii, i;
        boolean has_found = false;
        double t_ut, dt;
        int ecl_type = 0, eclflag;
        String s1, s2;
        int rsmi = 0;
        if ((smod & (SMOD_LUNAR | SMOD_SOLAR | SMOD_OCCULT))!=0)  {
            if ((smod & SMOD_ALL) == 0) /* no selective eclipse type set, set all */
                smod |= SMOD_ALL;
            if ((smod & SMOD_TOTAL)!=0) search_flag |= SweConst.SE_ECL_TOTAL;
            if ((smod & SMOD_ANNULAR)!=0) search_flag |= SweConst.SE_ECL_ANNULAR | SweConst.SE_ECL_PENUMBRAL;
            if ((smod & SMOD_PARTIAL)!=0) search_flag |= SweConst.SE_ECL_PARTIAL;
            if ((smod & SMOD_ANNTOT)!=0) search_flag |= SweConst.SE_ECL_ANNULAR_TOTAL;
        }
        /* 
         * for local eclipses: set geographic position of observer 
         */
        if ((smod & (SMOD_LOCAL|SMOD_RISE|SMOD_METR))!=0)
            sw.swe_set_topo(geopos[0], geopos[1], geopos[2]); 
        t_ut = tjd;
        do_printf("\n");
        for (ii = 0; ii < nstep; ii++) {
            sout = "";
            if ((smod & SMOD_LUNAR)!=0 && (smod & SMOD_HOW)!=0) {
                if ((eclflag = sw.swe_lun_eclipse_how(t_ut, whicheph, geopos, attr, serr)) == SweConst.ERR) {
                    do_printf(serr);
                    System.exit(0);
                } else {
                    ecl_type = 0;
                    if ((eclflag & SweConst.SE_ECL_TOTAL)!=0) {
                        sout="total lunar eclipse: "+f.fmt("%f",attr[0])+" o/o\n";
                        ecl_type = ECL_LUN_TOTAL;
                    } else if ((eclflag & SweConst.SE_ECL_PARTIAL)!=0)  {
                        sout="partial lunar eclipse: "+f.fmt("%f",attr[0])+" o/o\n";
                        ecl_type = ECL_LUN_PARTIAL;
                    } else if ((eclflag & SweConst.SE_ECL_PENUMBRAL)!=0)  {
                        sout="penumbral lunar eclipse: "+f.fmt("%f",attr[0])+" o/o\n";
                        ecl_type = ECL_LUN_PENUMBRAL;
                    } else {
                        sout="no lunar eclipse\n";
                    }
                    do_printf(sout);
                }
            }
            if ((smod & SMOD_LUNAR)!=0 && (smod & SMOD_HOW)==0) {
                if ((eclflag = sw.swe_lun_eclipse_when(t_ut, whicheph, search_flag, 
                                                       tret, direction_flag?-1:0, serr)) == SweConst.ERR) {
                    do_printf(serr);
                    System.exit(0);
                } 
                t_ut = tret[0];
                if ((eclflag & SweConst.SE_ECL_TOTAL)!=0) {
                    sout="total   ";
                    ecl_type = ECL_LUN_TOTAL;
                }
                if ((eclflag & SweConst.SE_ECL_PENUMBRAL)!=0) {
                    sout="penumb. ";
                    ecl_type = ECL_LUN_PENUMBRAL;
                }
                if ((eclflag & SweConst.SE_ECL_PARTIAL)!=0) {
                    sout="partial ";
                    ecl_type = ECL_LUN_PARTIAL;
                }
                sout+="lunar eclipse ";
                //        swe_revjul(t_ut, gregflag, &jyear, &jmon, &jday, &jut);
                sd.setJulDay(t_ut);
                sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                jyear=sd.getYear();
                jmon=sd.getMonth();
                jday=sd.getDay();
                jut=sd.getHour();
                if ((eclflag = sw.swe_lun_eclipse_how(t_ut, whicheph, geopos, attr, serr)) == SweConst.ERR) {
                    do_printf(serr);
                    System.exit(0);
                }
                /* eclipse times, penumbral, partial, total begin and end */
                sout += f.fmt("%2d",jday)+"."+f.fmt("%2d",jmon)+"."+
                    f.fmt("%4d",jyear)+"\t"+hms(jut,0)+"\t"+f.fmt("%f",attr[0])+
                    " o/o\n";
                sout += "  "+hms_from_tjd(tret[6])+" "; 
                if (tret[2] != 0)
                    sout += hms_from_tjd(tret[2])+" "; 
                else
                    sout+="   -         ";
                if (tret[4] != 0)
                    sout += hms_from_tjd(tret[4])+" "; 
                else
                    sout+="   -         ";
                if (tret[5] != 0)
                    sout += hms_from_tjd(tret[5]) + " "; 
                else
                    sout+="   -         ";
                if (tret[3] != 0)
                    sout += hms_from_tjd(tret[3]) + " "; 
                else
                    sout+="   -         ";
                sout += hms_from_tjd(tret[7]) + "\n"; 
                if ((smod & SMOD_HOCAL)!=0) {
                    IntObj ihou=new IntObj(), imin=new IntObj(), isec=new IntObj(), isgn=new IntObj();
                    DblObj dfrc=new DblObj();
                    sl.swe_split_deg(jut, SweConst.SE_SPLIT_DEG_ROUND_MIN, ihou, imin, isec, dfrc, isgn);
                    sout="\""+f.fmt("%04d",jyear)+" "+f.fmt("%02d",jmon)+" "+f.fmt("%02d",jday)+" "+f.fmt("%02d",ihou.val)+"."+f.fmt("%02d",imin.val)+" "+f.fmt("%d",ecl_type)+"\",\n";
                } 
                do_printf(sout);
            }
            if ((smod & SMOD_SOLAR)!=0 && (smod & SMOD_LOCAL)!=0) {
                if ((eclflag = sw.swe_sol_eclipse_when_loc(t_ut, whicheph, geopos, tret, attr, direction_flag?-1:0, serr)) == SweConst.ERR) {
                    do_printf(serr);
                    System.exit(0);
                } else { 
                    has_found = false;
                    t_ut = tret[0];
                    if ((smod & SMOD_TOTAL)!=0 && (eclflag & SweConst.SE_ECL_TOTAL)!=0) {
                        sout="total   ";
                        has_found = true;
                        ecl_type = ECL_SOL_TOTAL;
                    }
                    if ((smod & SMOD_ANNULAR)!=0 && (eclflag & SweConst.SE_ECL_ANNULAR)!=0) {
                        sout="annular ";
                        has_found = true;
                        ecl_type = ECL_SOL_ANNULAR;
                    }
                    if ((smod & SMOD_PARTIAL)!=0 && (eclflag & SweConst.SE_ECL_PARTIAL)!=0) {
                        sout="partial ";
                        has_found = true;
                        ecl_type = ECL_SOL_PARTIAL;
                    }
                    if (!has_found) {
                        ii--;
                    } else {
                        i = sw.swe_calc(t_ut + sd.getDeltaT(t_ut), SweConst.SE_ECL_NUT, 0, x, serr);
                        sd.setJulDay(t_ut);
                        sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                        jyear=sd.getYear();
                        jmon=sd.getMonth();
                        jday=sd.getDay();
                        jut=sd.getHour();
                        sout += f.fmt("%2d",jday)+"."+f.fmt("%2d",jmon)+"."+f.fmt("%4d",jyear)+"\t"+hms(jut,0)+"\t"+f.fmt("%f",attr[0])+"o/o\n";
                        dt = (tret[3] - tret[2]) * 24 * 60;
                        sout += "\t"+(int)dt+" min "+f.fmt("%4.2f",(dt%1.) * 60)+" sec\t";
                        if ((eclflag & SweConst.SE_ECL_1ST_VISIBLE)!=0)
                            sout += hms_from_tjd(tret[1]) + " "; 
                        else
                            sout+="   -         ";
                        if ((eclflag & SweConst.SE_ECL_2ND_VISIBLE)!=0)
                            sout += hms_from_tjd(tret[2]) + " "; 
                        else
                            sout+="   -         ";
                        if ((eclflag & SweConst.SE_ECL_3RD_VISIBLE)!=0)
                            sout += hms_from_tjd(tret[3]) + " "; 
                        else
                            sout+="   -         ";
                        if ((eclflag & SweConst.SE_ECL_4TH_VISIBLE)!=0)
                            sout += hms_from_tjd(tret[4]) + " "; 
                        else
                            sout+="   -         ";
                        sout+="\n";
                        do_printf(sout);
                    }
                }
            }   /* endif search_local */
            if ((smod & SMOD_OCCULT)!=0 && (smod & SMOD_LOCAL)!=0) {
                sstar=new StringBuffer(star);
                if ((eclflag = sw.swe_lun_occult_when_loc(t_ut, ipl, sstar, whicheph, geopos, tret, attr, direction_flag?-1:0, serr)) == SweConst.ERR) {
                    do_printf(serr);
                    System.exit(0);
                } else {
                    star=sstar.toString();
                    has_found = false;
                    t_ut = tret[0];
                    if ((smod & SMOD_TOTAL)!=0 && (eclflag & SweConst.SE_ECL_TOTAL)!=0) {
                        sout="total   ";
                        has_found = true;
                        ecl_type = ECL_SOL_TOTAL;
                    }
                    if ((smod & SMOD_ANNULAR)!=0 && (eclflag & SweConst.SE_ECL_ANNULAR)!=0) {
                        sout="annular ";
                        has_found = true;
                        ecl_type = ECL_SOL_ANNULAR;
                    }
                    if ((smod & SMOD_PARTIAL)!=0 && (eclflag & SweConst.SE_ECL_PARTIAL)!=0) {
                        sout="partial ";
                        has_found = true;
                        ecl_type = ECL_SOL_PARTIAL;
                    }
                    if (!has_found) {
                        ii--;
                    } else {
                        i = sw.swe_calc(t_ut + sd.getDeltaT(t_ut), SweConst.SE_ECL_NUT, 0, x, serr);
                        sd.setJulDay(t_ut);
                        sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                        jyear=sd.getYear();
                        jmon=sd.getMonth();
                        jday=sd.getDay();
                        jut=sd.getHour();
                        sout += f.fmt("%2d",jday)+"."+f.fmt("%2d",jmon)+"."+f.fmt("%4d",jyear)+"\t"+hms(jut,0)+"\t"+f.fmt("%f",attr[0])+"o/o\n";
                        dt = (tret[3] - tret[2]) * 24 * 60;
                        sout += "\t"+f.fmt("%d",(int) dt)+" min "+f.fmt("%4.2f",(dt%1.)*60)+" sec\t";
                        if ((eclflag & SweConst.SE_ECL_1ST_VISIBLE)!=0)
                            sout += hms_from_tjd(tret[1]) + " "; 
                        else
                            sout+="   -         ";
                        if ((eclflag & SweConst.SE_ECL_2ND_VISIBLE)!=0)
                            sout += hms_from_tjd(tret[2]) + " "; 
                        else
                            sout+="   -         ";
                        if ((eclflag & SweConst.SE_ECL_3RD_VISIBLE)!=0)
                            sout += hms_from_tjd(tret[3]) + " "; 
                        else
                            sout+="   -         ";
                        if ((eclflag & SweConst.SE_ECL_4TH_VISIBLE)!=0)
                            sout += hms_from_tjd(tret[4]) + " "; 
                        else
                            sout+="   -         ";
                        sout+="\n";
                        do_printf(sout);
                    }
                }
            }   /* endif search_local */
            if ((smod & SMOD_SOLAR)!=0 && (smod & SMOD_LOCAL)==0) {
                if ((eclflag = sw.swe_sol_eclipse_when_glob(t_ut, whicheph, search_flag,
                                                            tret, direction_flag?-1:0, serr)) == SweConst.ERR) {
                    do_printf(serr);
                    System.exit(0);
                } 
                t_ut = tret[0];
                if ((eclflag & SweConst.SE_ECL_TOTAL)!=0) {
                    sout="total   ";
                    ecl_type = ECL_SOL_TOTAL;
                }
                if ((eclflag & SweConst.SE_ECL_ANNULAR)!=0) {
                    sout="annular ";
                    ecl_type = ECL_SOL_ANNULAR;
                }
                if ((eclflag & SweConst.SE_ECL_ANNULAR_TOTAL)!=0) {
                    sout="ann-tot ";
                    ecl_type = ECL_SOL_ANNULAR;        /* by Alois: what is this ? */
                }
                if ((eclflag & SweConst.SE_ECL_PARTIAL)!=0) {
                    sout="partial ";
                    ecl_type = ECL_SOL_PARTIAL;
                }
                if ((eclflag & SweConst.SE_ECL_NONCENTRAL)!=0 && (eclflag & SweConst.SE_ECL_PARTIAL)==0)
                    sout+="non-central ";
                sw.swe_sol_eclipse_where(t_ut, whicheph, geopos, attr, serr);
                //      swe_revjul(t_ut, gregflag, &jyear, &jmon, &jday, &jut);
                sd.setJulDay(t_ut);
                sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                jyear=sd.getYear();
                jmon=sd.getMonth();
                jday=sd.getDay();
                jut=sd.getHour();
                sout += f.fmt("%2d",jday)+"."+f.fmt("%2d",jmon)+"."+f.fmt("%4d",jyear)+"\t"+hms(jut,0)+"\t"+f.fmt("%f",attr[3])+" km\t"+f.fmt("%f",attr[0])+" o/o\n";
                sout += "\t" + hms_from_tjd(tret[2]) + " "; 
                if (tret[4] != 0)
                    sout += hms_from_tjd(tret[4]) + " "; 
                else
                    sout+="   -         ";
                if (tret[5] != 0)
                    sout += hms_from_tjd(tret[5]) + " "; 
                else
                    sout+="   -         ";
                sout += hms_from_tjd(tret[3]) + "\n"; 
                s1=dms(geopos[0], BIT_ROUND_MIN);
                s2=dms(geopos[1], BIT_ROUND_MIN);
                sout += "\t"+s1+"\t"+s2;
                if ((eclflag & SweConst.SE_ECL_PARTIAL)==0 && (eclflag & SweConst.SE_ECL_NONCENTRAL)==0) {
                    if ((eclflag = sw.swe_sol_eclipse_when_loc(t_ut - 10, whicheph, geopos, tret, attr, 0, serr)) == SweConst.ERR) {
                        do_printf(serr);
                        System.exit(0);
                    }
                    if (Math.abs(tret[0] - t_ut) > 1) 
                        do_printf("when_loc returns wrong date\n");
                    dt = (tret[3] - tret[2]) * 24 * 60;
                    sout += "\t"+(int)dt+" min "+f.fmt("%4.2f",(dt%1.) * 60.)+" sec\t";
                }
                sout+="\n";
                if ((smod & SMOD_HOCAL)!=0) {
                    IntObj ihou=new IntObj(), imin=new IntObj(), isec=new IntObj(), isgn=new IntObj();
                    DblObj dfrc=new DblObj();
                    sl.swe_split_deg(jut, SweConst.SE_SPLIT_DEG_ROUND_MIN, ihou, imin, isec, dfrc, isgn);
                    sout="\""+f.fmt("%04d",jyear)+" "+f.fmt("%02d",jmon)+" "+f.fmt("%02d",jday)+" "+f.fmt("%02d",ihou.val)+"."+f.fmt("%02d",imin.val)+" "+f.fmt("%d",ecl_type)+"\",\n";
                } 
                do_printf(sout);
            }
            if ((smod & SMOD_OCCULT)!=0 && (smod & SMOD_LOCAL)==0) {
                /* * global search for eclipses */
                sstar=new StringBuffer(star);
                if ((eclflag = sw.swe_lun_occult_when_glob(t_ut, ipl, sstar, whicheph, search_flag, tret, direction_flag?-1:0, serr)) == SweConst.ERR) {
                    do_printf(serr);
                    System.exit(0);
                } 
                star=sstar.toString();
                t_ut = tret[0];
                if ((eclflag & SweConst.SE_ECL_TOTAL)!=0) {
                    sout="total   ";
                    ecl_type = ECL_SOL_TOTAL;
                }
                if ((eclflag & SweConst.SE_ECL_ANNULAR)!=0) {
                    sout="annular ";
                    ecl_type = ECL_SOL_ANNULAR;
                }
                if ((eclflag & SweConst.SE_ECL_ANNULAR_TOTAL)!=0) {
                    sout="ann-tot ";
                    ecl_type = ECL_SOL_ANNULAR;        /* by Alois: what is this ? */
                }
                if ((eclflag & SweConst.SE_ECL_PARTIAL)!=0) {
                    sout="partial ";
                    ecl_type = ECL_SOL_PARTIAL;
                }
                if ((eclflag & SweConst.SE_ECL_NONCENTRAL)!=0 && (eclflag & SweConst.SE_ECL_PARTIAL)==0)
                    sout+="non-central ";
                sstar=new StringBuffer(star);
                sw.swe_lun_occult_where(t_ut, ipl, sstar, whicheph, geopos, attr, serr);
                star=sstar.toString();
                sd.setJulDay(t_ut);
                sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                jyear=sd.getYear();
                jmon=sd.getMonth();
                jday=sd.getDay();
                jut=sd.getHour();
                sout += f.fmt("%2d",jday)+"."+f.fmt("%2d",jmon)+"."+f.fmt("%4d",jyear)+"\t"+hms(jut,0)+"\t"+f.fmt("%f",attr[3])+" km\t"+f.fmt("%f",attr[0])+" o/o\n";
                sout += "\t" + hms_from_tjd(tret[2]) + " "; 
                if (tret[4] != 0)
                    sout += hms_from_tjd(tret[4]) + " "; 
                else
                    sout+="   -         ";
                if (tret[5] != 0)
                    sout += hms_from_tjd(tret[5]) + " "; 
                else
                    sout+="   -         ";
                sout += hms_from_tjd(tret[3]) + "\n"; 
                s1=dms(geopos[0], BIT_ROUND_MIN);
                s2=dms(geopos[1], BIT_ROUND_MIN);
                sout += "\t"+s1+"\t"+s2;
                if ((eclflag & SweConst.SE_ECL_PARTIAL)==0 && (eclflag & SweConst.SE_ECL_NONCENTRAL)==0) {
                    sstar=new StringBuffer(star);
                    if ((eclflag = sw.swe_lun_occult_when_loc(t_ut - 10, ipl, sstar, whicheph, geopos, tret, attr, 0, serr)) == SweConst.ERR) {
                        do_printf(serr);
                        System.exit(0);
                    }
                    star=sstar.toString();
                    if (Math.abs(tret[0] - t_ut) > 1) 
                        do_printf("when_loc returns wrong date\n");
                    dt = (tret[3] - tret[2]) * 24 * 60;
                    sout += "\t"+(int)dt+" min "+f.fmt("%4.2f",(dt%1.)*60)+" sec\t";
                } 
                sout+="\n";
                if ((smod & SMOD_HOCAL)!=0) {
                    IntObj ihou=new IntObj(), imin=new IntObj(), isec=new IntObj(), isgn=new IntObj();
                    DblObj dfrc=new DblObj();
                    sl.swe_split_deg(jut, SweConst.SE_SPLIT_DEG_ROUND_MIN, ihou, imin, isec, dfrc, isgn);
                    sout="\""+f.fmt("%04d",jyear)+" "+f.fmt("%02d",jmon)+" "+f.fmt("%02d",jday)+" "+f.fmt("%02d",ihou.val)+"."+f.fmt("%02d",imin.val)+" "+f.fmt("%d",ecl_type)+"\",\n";
                } 
                do_printf(sout);
            }
            if ((smod & SMOD_RISE)!=0) {
                dtmp.val=tret[0];
                sstar=new StringBuffer(star);
                rsmi = SweConst.SE_CALC_RISE;
                if (norefrac) rsmi |= SweConst.SE_BIT_NO_REFRACTION;
                if (disccenter) rsmi |= SweConst.SE_BIT_DISC_CENTER;
                if (sw.swe_rise_trans(t_ut, ipl, sstar, whicheph, rsmi, geopos, 1013.25, 10, dtmp, serr) !=
                    SweConst.OK) {
                    do_printf(serr);
                    System.exit(0);
                } 
                star=sstar.toString();
                tret[0]=dtmp.val;
                dtmp.val=tret[1];
                sstar=new StringBuffer(star);
                rsmi = SweConst.SE_CALC_SET;
                if (norefrac) rsmi |= SweConst.SE_BIT_NO_REFRACTION;
                if (disccenter) rsmi |= SweConst.SE_BIT_DISC_CENTER;
                if (sw.swe_rise_trans(t_ut, ipl, sstar, whicheph, rsmi, geopos, 1013.25, 10, dtmp, serr) !=
                    SweConst.OK) {
                    do_printf(serr);
                    System.exit(0);
                } 
                star=sstar.toString();
                tret[1]=dtmp.val;
                sout="rise     ";
                if (tret[0] == 0 || tret[0] > tret[1]) {
                    sout+="         -                     ";
                } else {
                    sd.setJulDay(tret[0]);
                    sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                    jyear=sd.getYear();
                    jmon=sd.getMonth();
                    jday=sd.getDay();
                    jut=sd.getHour();
                    sout += f.fmt("%2d",jday)+"."+f.fmt("%2d",jmon)+"."+f.fmt("%4d",jyear)+"\t"+hms(jut,0)+"    ";
                }
                sout+="set      ";
                if (tret[1] == 0) {
                    sout+="         -                     \n";
                } else {
                    sd.setJulDay(tret[1]);
                    sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                    jyear=sd.getYear();
                    jmon=sd.getMonth();
                    jday=sd.getDay();
                    jut=sd.getHour();
                    sout += f.fmt("%2d",jday)+"."+f.fmt("%2d",jmon)+"."+f.fmt("%4d",jyear)+"\t"+hms(jut,0)+"\n"; 
                }
                do_printf(sout);
            }
            if ((smod & SMOD_METR)!=0) {
                dtmp.val=tret[0];
                sstar=new StringBuffer(star);
                if (sw.swe_rise_trans(t_ut, ipl, sstar, whicheph, SweConst.SE_CALC_MTRANSIT, geopos, 1013.25, 10, dtmp, serr) != SweConst.OK) {
                    do_printf(serr);
                    System.exit(0);
                } 
                star=sstar.toString();
                tret[0]=dtmp.val;
                dtmp.val=tret[1];
                sstar=new StringBuffer(star);
                if (sw.swe_rise_trans(t_ut, ipl, sstar, whicheph, SweConst.SE_CALC_ITRANSIT, geopos, 1013.25, 10, dtmp, serr) != SweConst.OK) {
                    do_printf(serr);
                    System.exit(0);
                }
                star=sstar.toString();
                tret[1]=dtmp.val;
                sout="mtransit ";
                if (tret[0] == 0) {
                    sout+="         -                     ";
                } else {
                    sd.setJulDay(tret[0]);
                    sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                    jyear=sd.getYear();
                    jmon=sd.getMonth();
                    jday=sd.getDay();
                    jut=sd.getHour();
                    sout += f.fmt("%2d",jday)+"."+f.fmt("%2d",jmon)+"."+f.fmt("%4d",jyear)+"\t"+hms(jut,0)+"    "; 
                }
                sout+="itransit ";
                if (tret[1] == 0) {
                    sout+="         -                     \n";
                } else {
                    sd.setJulDay(tret[1]);
                    sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                    jyear=sd.getYear();
                    jmon=sd.getMonth();
                    jday=sd.getDay();
                    jut=sd.getHour();
                    sout += f.fmt("%2d",jday)+"."+f.fmt("%2d",jmon)+"."+f.fmt("%4d",jyear)+"\t"+hms(jut,0)+"\n"; 
                }
                do_printf(sout);
            }
            if ((smod & (SMOD_RISE | SMOD_METR))!=0 && tret[1] > 0)
                t_ut = tret[1] + 0.1;
            else
                t_ut += direction;
        }
        if (serr_warn.length() > 0) {
            do_printf("\nwarning: ");
            do_printf(serr_warn);
            do_printf("\n");
        }
        return SweConst.OK;
    }
  
    private String hms_from_tjd(double x) {
        String s;
        s=hms(((x + 1000000.5)%1.) * 24, 0)+" ";
        return s;
    }
  
    private String hms(double x, int iflag) {
        String s;
        int sp;
        String c = swed.ODEGREE_CHAR;
        x += 0.5 / 36000.0; /* round to 0.1 sec */
        s=dms(x, iflag);
        sp = s.indexOf(c);
        if (sp >= 0) {
            s = s.substring(0,sp) + ":" + s.substring(sp+c.length());
            s = s.replace('\'',':');
            s = s.substring(0,s.lastIndexOf(':')+5);
        }
        return s;
    }
  
    static void do_printf(StringBuffer info) {
        DevNull.print(info.toString());
    }
    static void do_printf(String info) {
        DevNull.print(info);
    }

    /* make_ephemeris_path().
     * ephemeris path includes
     *   current working directory
     *   + program directory
     *   + default path from swephexp.h on current drive
     *   +                              on program drive
     *   +                              on drive C:
     */
    private int make_ephemeris_path(int iflg, String argv0) {
        String path="", s="";
        int sp;
        String dirglue = swed.DIR_GLUE;
        int pathlen = 0;
        /* moshier needs no ephemeris path */
        if ((iflg & SweConst.SEFLG_MOSEPH)!=0)
            return SweConst.OK;
        /* current working directory */
        path="."+swed.PATH_SEPARATOR.charAt(0);
        /* program directory */
        sp = argv0.lastIndexOf(dirglue);
        if (sp >= 0) {
            pathlen = sp;
            if (path.length() + pathlen < swed.AS_MAXCH-1) {
                s=argv0.substring(0,pathlen);
                path=path+s+swed.PATH_SEPARATOR.charAt(0);
            }
        }
        if (path.length() + pathlen < swed.AS_MAXCH-1)
            path+=SweConst.SE_EPHE_PATH;
        return SweConst.OK;
    }


} // End of class Swetest
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class SwissData {

  /**
  * The character to be used as the degree character. Only textmode
  * applications (and probably awt applications in Java 1.1 and below?)
  * will require to differentiate between different characters, awt&nbsp;/
  * swing components of Java 1.2 and above will use the unicode encoding
  * always!
  */
  public String ODEGREE_CHAR=""+'\u00b0'; // Unicode degree character 176
                                          // Identical in most ISO-8859 sets


  public static final String ayanamsa_name[] = {
     "Fagan/Bradley",
     "Lahiri",
     "De Luce",
     "Raman",
     "Ushashashi",
     "Krishnamurti",
     "Djwhal Khul",
     "Yukteshwar",
     "J.N. Bhasin",
     "Babylonian/Kugler 1",
     "Babylonian/Kugler 2",
     "Babylonian/Kugler 3",
     "Babylonian/Huber",
     "Babylonian/Eta Piscium",
     "Babylonian/Aldebaran = 15 Tau",
     "Hipparchos",
     "Sassanian",
     "Galact. Center = 0 Sag",
     "J2000",
     "J1900",
     "B1950",
  };

//////////////////////////////////////////////////////////////////////////////
// sweodef.h: ////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
  static final double M_PI=3.14159265358979323846;

  public static final int AS_MAXCH=256; // used for string declarations,
                                        // allowing 255 char+\0

  static final double DEGTORAD=0.0174532925199433;
  static final double RADTODEG=57.2957795130823;

  static final int DEG=360000;  // degree expressed in centiseconds
  static final int DEG7_30=2700000;	// 7.5 degrees
  static final int DEG15=15 * DEG;
  static final int DEG24=24 * DEG;
  static final int DEG30=30 * DEG;
  static final int DEG60=60 * DEG;
  static final int DEG90=90 * DEG;
  static final int DEG120=120 * DEG;
  static final int DEG150=150 * DEG;
  static final int DEG180=180 * DEG;
  static final int DEG270=270 * DEG;
  static final int DEG360=360 * DEG;

  static final double CSTORAD=4.84813681109536E-08; // centisec to rad:
                                                    // pi / 180 /3600/100
  static final double RADTOCS=2.06264806247096E+07; // rad to centisec
                                                    // 180*3600*100/pi

  static final double CS2DEG=1.0/360000.0;	     // centisec to degree

  static final String BFILE_R_ACCESS="r";  // open binary file for reading
  static final String BFILE_RW_ACCESS="r+";// open binary file for writing and reading
  static final String BFILE_W_CREATE="w";  // create/open binary file for write
  static final String BFILE_A_ACCESS="a+"; // create/open binary file for append
  static final String FILE_R_ACCESS="r";   // open text file for reading
  static final String FILE_RW_ACCESS="r+"; // open text file for writing and reading
  static final String FILE_W_CREATE="w";   // create/open text file for write
  static final String FILE_A_ACCESS="a+";  // create/open text file for append
  static final int O_BINARY=0;	           // for open(), not defined in Unix
  static final int OPEN_MODE=0666;         // default file creation mode
  public String DIR_GLUE;              // glue string for directory/file
  public static final String PATH_SEPARATOR=";:"; // semicolon or colon may be used


//////////////////////////////////////////////////////////////////////////////
// swephexp.h: ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
  public static final int SE_NSIDM_PREDEF         =21;

//  static final int SE_MAX_STNAME=20;    // maximum size of fixstar name;
//                                        // the parameter star in swe_fixstar
//					// must allow twice this space for
//				        // the returned star name.
//

  static final int pnoext2int[] = {SwephData.SEI_SUN, SwephData.SEI_MOON,
    SwephData.SEI_MERCURY, SwephData.SEI_VENUS, SwephData.SEI_MARS,
    SwephData.SEI_JUPITER, SwephData.SEI_SATURN, SwephData.SEI_URANUS,
    SwephData.SEI_NEPTUNE, SwephData.SEI_PLUTO, 0, 0, 0, 0, SwephData.SEI_EARTH,
    SwephData.SEI_CHIRON, SwephData.SEI_PHOLUS, SwephData.SEI_CERES,
    SwephData.SEI_PALLAS, SwephData.SEI_JUNO, SwephData.SEI_VESTA, };

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
  boolean ephe_path_is_set=false;
  boolean jpl_file_is_open=false;
  FilePtr fixfp=null;
  String ephepath;
  String jplfnam;
  int jpldenum;
  boolean geopos_is_set=false;
  boolean ayana_is_set=false;

  FileData fidat[] = new FileData[SwephData.SEI_NEPHFILES];
  GenConst gcdat;
  PlanData pldat[] = new PlanData[SwephData.SEI_NPLANETS];
  PlanData nddat[] = new PlanData[SwephData.SEI_NNODE_ETC];
  SavePositions savedat[] = new SavePositions[SweConst.SE_NPLANETS+1];
  Epsilon oec, oec2000;
  Nut nut, nut2000, nutv;
  TopoData topd;
  SidData sidd;
  String astelem;
  double ast_G, ast_H, ast_diam;
  int i_saved_planet_name;
  String saved_planet_name;

  /**
  * Constructs a new SwissData object.
  */
  public SwissData() {
    // File separator character:
    DIR_GLUE = System.getProperty("file.separator");

    try {
      // ODEGREE_CHAR:
      String cp=System.getProperties().getProperty("file.encoding");
      if (cp!=null) {
        if (cp.toUpperCase().startsWith("CP")) {
          try {
            int cpn=Integer.parseInt(cp.substring(2));
            if (cpn>=437 && cpn<870) {
              ODEGREE_CHAR=""+'\u00f8';
            }
          } catch (NumberFormatException nfe) {
          }
          ODEGREE_CHAR=""+'\u00f8'; // DOS degree character 248
        } else if (cp.toUpperCase().startsWith("ISO-8859-")) {
          ODEGREE_CHAR=""+'\u00b0'; // Latin1 degree character 176
        } else if (cp.toUpperCase().startsWith("UTF")) {
          ODEGREE_CHAR=""+'\u00b0'; // Default Unicode...
        }
      }
    } catch (SecurityException ase) {
      if (DIR_GLUE.equals("/")) {
        ODEGREE_CHAR=""+'\u00b0'; // Latin1 degree character 176
      } else if (DIR_GLUE.equals("\\")) {
        ODEGREE_CHAR=""+'\u00f8'; // DOS degree character 248
      } else {
        ODEGREE_CHAR=""+'\u00b0'; // Default Unicode...
      }
    }
    // Macintoshs (prior to MacOS X) should use '\u00a1', but how to
    // identify more reasonably? Has the Mac an appropriate text window anyway?
    if (DIR_GLUE.equals(":")) {
      ODEGREE_CHAR=""+'\u00a1';
    }


    int i;
    for(i=0;i<SwephData.SEI_NEPHFILES;i++){ fidat[i] = new FileData(); }
    gcdat = new GenConst();
    for(i=0;i<SwephData.SEI_NPLANETS;i++){ pldat[i] = new PlanData(); }
    for(i=0;i<SwephData.SEI_NNODE_ETC;i++){ nddat[i] = new PlanData(); }
    for(i=0;i<SweConst.SE_NPLANETS+1;i++){ savedat[i] = new SavePositions(); }
    oec = new Epsilon();
    oec2000 = new Epsilon();
    nut = new Nut();
    nut2000 = new Nut();
    nutv = new Nut();
    topd = new TopoData();
    sidd = new SidData();
  }

}


class SwissephException extends RuntimeException {
  private double jdet=0;
  private int type=0;
  private int rc=0;

  public static final int UNDEFINED                     = 0;

  // FILE errors:
  public static final int FILE_ERROR                    = 1;
  public static final int UNSPECIFIED_FILE_ERROR        = FILE_ERROR | 2;
  public static final int INVALID_FILE_NAME             = FILE_ERROR | 4;
  public static final int FILE_NOT_FOUND                = FILE_ERROR | 8;
  public static final int FILE_OPEN_FAILED              = FILE_ERROR | 16;
  public static final int FILE_READ_ERROR               = FILE_ERROR | 32;
  public static final int DATA_FILE_ERROR               = FILE_ERROR | 64;

  // Parameter errors:
  public static final int PARAM_ERROR                   = 128;
  public static final int OUT_OF_TIME_RANGE             = PARAM_ERROR | 256;
  public static final int UNSUPPORTED_OBJECT            = PARAM_ERROR | 512;
  public static final int INVALID_PARAMETER_COMBINATION = PARAM_ERROR | 1024;

  // User requested:
  public static final int USER_ERROR                    = 2048;
  public static final int BEYOND_USER_TIME_LIMIT        = USER_ERROR | 4096;



  public SwissephException(double jdet, int type, int rc, StringBuffer sb) {
    super(sb==null?null:sb.toString());
    this.jdet = jdet;
    this.type = type;
    this.rc = rc;
  }

  public SwissephException(double jdet, int type, int rc, String s) {
    super(s);
    this.jdet = jdet;
    this.type = type;
    this.rc = rc;
  }

  public SwissephException(double jdet, int type, String s) {
    super(s);
    this.jdet = jdet;
    this.type = type;
  }

  public SwissephException(double jdet, String s) {
    super(s);
    this.jdet = jdet;
    this.type = UNDEFINED;
  }

  /**
  * Returns the julian day number as ET of the current process.
  * May return <i>Infinity</i>, if no date is available.
  */
  public double getJD() {
    return jdet;
  }

  public int getType() {
    return type;
  }

  int getRC() {
    return rc;
  }
}
/*
  This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
  of Astrodienst AG, Switzerland from the original C Code to Java. For
  copyright see the original copyright notices below and additional
  copyright notes in the file named LICENSE, or - if this file is not
  available - the copyright notes at http://www.astro.ch/swisseph/ and
  following.

  For any questions or comments regarding this port to Java, you should
  ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
  in this port in any way.

  Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

   This file is part of Swiss Ephemeris Free Edition.

   Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
   or distributor accepts any responsibility for the consequences of using it,
   or for whether it serves any particular purpose or works at all, unless he
   or she says so in writing.  Refer to the Swiss Ephemeris Public License
   ("SEPL" or the "License") for full details.

   Every copy of Swiss Ephemeris must include a copy of the License,
   normally in a plain ASCII text file named LICENSE.  The License grants you
   the right to copy, modify and redistribute Swiss Ephemeris, but only
   under certain conditions described in the License.  Among other things, the
   License requires that the copyright notices and this notice be preserved on
   all copies.

   For uses of the Swiss Ephemeris which do not fall under the definitions
   laid down in the Public License, the Swiss Ephemeris Professional Edition
   must be purchased by the developer before he/she distributes any of his
   software or makes available any product or service built upon the use of
   the Swiss Ephemeris.

   Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

   The authors of Swiss Ephemeris have no control or influence over any of
   the derived works, i.e. over software or services created by other
   programmers which use Swiss Ephemeris functions.

   The names of the authors or of the copyright holder (Astrodienst) must not
   be used for promoting any software, product or service which uses or contains
   the Swiss Ephemeris. This copyright notice is the ONLY place where the
   names of the authors can legally appear, except in cases where they have
   given special permission in writing.

   The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
   for promoting such software, products or services.
*/



/**
 * This class is the basic class for planetary calculations.<p>
 * One important note: in all this package, negative longitudes are considered
 * to be <b>west</b> of Greenwich, positive longitudes are seen as <b>east</b>
 * of Greenwich. America seems to often use a different notation!<p>
 * <I><B>You will find the complete documentation for the original
 * SwissEphemeris package at <A HREF="http://www.astro.ch/swisseph/sweph_g.htm">
 * http://www.astro.ch/swisseph/sweph_g.htm</A>. By far most of the information 
 * there is directly valid for this port to Java as well.</B></I>
 */
class SwissEph {

    SwissData swed;
    SwephMosh smosh;
    SwephJPL sj;
    SwissLib sl;
    Swecl sc=null;
    Swemmoon sm;
    SweHouse sh=null;
    Extensions ext=null;

    double lastLat=0.;
    double lastLong=0.;
    int lastHSys=-1;

    
    //////////////////////////////////////////////////////////////////////////////
    // Constructors: /////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////
    /**
     * Constructs a new SwissEph object with the default search path for the
     * Swiss Ephemeris data files.
     * @see SweConst#SE_EPHE_PATH
     */
    public SwissEph() {
        this(null);
    }

    public String getTmp() {
        String tmp = "";
        if(System.getProperty("os.name").toLowerCase().indexOf("windows") > -1){
            tmp = "c:/temp";
        } else {
            tmp = "/tmp";
        }
        return tmp;
    }    

    /**
     * Constructs a new SwissEph object with the specified search path for
     * the Swiss Ephemeris data files. If you want to use this class in
     * applets, you would have to specify the path as a valid http URL on
     * the same www server from where your applet gets served.
     * @param path The search path for the Swiss Ephemeris
     * and JPL
     * data files. If null or empty, a default path will be used.
     * You will have to quote ':', ';' and '\' characters, so a
     * path like <code>&quot;C:\swiss\ephe&quot;</code> has to be written as
     * <code>&quot;C\\:\\\\swiss\\\\ephe&quot;</code>, as any '\' will be
     * evaluated twice: the first time by the Java compiler, and the second
     * time by the program itself. You can specify multiple path elements
     * separated by the (unquoted) ':' or ';' character. See swe_set_ephe_path()
     * for more information.
     * @see SweConst#SE_EPHE_PATH
     * @see SwissEph#swe_set_ephe_path(java.lang.String)
     */
    public SwissEph(String path) {
               
        swed     = new SwissData();
        sl       = new SwissLib(this.swed);
        sm       = new Swemmoon(this.swed, this.sl);
        smosh    = new SwephMosh(this.sl, this, this.swed);
        sj       = new SwephJPL(this, this.swed, this.sl);

        swed.ephe_path_is_set=false;
        swed.jpl_file_is_open=false;
        swed.fixfp=null;
        swed.ephepath=SweConst.SE_EPHE_PATH;
        swed.jplfnam=SweConst.SE_FNAME_DFT;
        swed.geopos_is_set=false;
        swed.ayana_is_set=false;
        swe_set_ephe_path(path);

    }
    //////////////////////////////////////////////////////////////////////////////
    // End of Constructors ///////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////


    //////////////////////////////////////////////////////////////////////////////
    // Public Methods: ///////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    private int httpBufSize=300;

    /**
     * This sets the buffer size for access to Swiss Ephemeris or JPL data
     * files, if you specify an http-URL in swe_set_ephe_path() or via the
     * SwissEph constructor. The buffer size determines, how many bytes will
     * get read on one single HTTP request. Increased buffer size will
     * result in a reduced number of HTTP-requests, but it will increase
     * the amount of data to be transferred. As the access to the data is
     * <I>somehow</I> random, it does not make so much sense to increase the
     * size arbitrarily.<P>
     * Some test numbers for the calculation of the sun:<BR>
     * <table border="1"><tr><th>buffer<br>size</th><th>HTTP Requests<br>for the sun</th><th>HTTP Requests<br>for 9 planets</th></tr>
     * <tr><td align="right">100</td><td align="right">57</td><td align="right">69</td></tr>
     * <tr><td align="right">200</td><td align="right">30</td><td align="right">40</td></tr>
     * <tr><td align="right">300</td><td align="right">23</td><td align="right">33</td></tr>
     * <tr><td align="right">400</td><td align="right">19</td><td align="right">29</td></tr>
     * <tr><td align="right">800</td><td align="right">14</td><td align="right">24</td></tr></table>
     * @param size The size of the buffer. It defaults to 300 bytes. Values less
     * than 100 bytes will be increased to 100 bytes, as you will only increase
     * the number of requests dramatically, but the amount of bytes transferred
     * will just be minimal less.
     */
    public void setHttpBufSize(int size) {
        httpBufSize=size;
        if (size<100) {
            httpBufSize=100;
        }
        swe_close();
    }

    /* The routine called by the user.
     * It checks whether a position for the same planet, the same t, and the
     * same flag bits has already been computed.
     * If yes, this position is returned. Otherwise it is computed.
     * -> If the SEFLG_SPEED flag has been specified, the speed will be returned
     * at offset 3 of position array x[]. Its precision is probably better
     * than 0.002"/day.
     * -> If the SEFLG_SPEED3 flag has been specified, the speed will be computed
     * from three positions. This speed is less accurate than SEFLG_SPEED,
     * i.e. better than 0.1"/day. And it is much slower. It is used for
     * program tests only.
     * -> If no speed flag has been specified, no speed will be returned.
     */
    private int swe_calc_epheflag_sv = 0;

    /**
     * This is the main calculation routine for all planets, asteroids, lunar
     * nodes and apogees.
     * See <A HREF="SwissEph.html#swe_calc(double, int, int, double[], java.lang.StringBuffer)">swe_calc(...)</A> for more information.
     * @param tjd_ut The Julian Day number in UT (Universal Time).
     * @param ipl The body to be calculated. See
     * <A HREF="SweConst.html">SweConst</A> for a list of bodies
     * @param iflag A flag that contains detailed specification on how the body
     * is to be computed. See <A HREF="SweConst.html">SweConst</A>
     * for a list of valid flags (SEFLG_*).
     * @param xx A double[6] in which the result is returned. See above for more
     * details.
     * @param serr A StringBuffer containing a warning or error message, if
     * something fails.
     * @return iflag or SweConst.ERR (-1); iflag MAY have changed from input
     * parameter!
     */
    public int swe_calc_ut(double tjd_ut, int ipl, int iflag, double xx[],
                           StringBuffer serr) {
        return swe_calc(tjd_ut + SweDate.getDeltaT(tjd_ut), ipl, iflag, xx, serr);
    }
    /**
     * This is the main calculation routine for all planets, asteroids, lunar
     * nodes and apogees. It is equal to swe_calc_ut() with the exception that
     * the time has to be given in ET (Ephemeris Time or Dynamical Time). You
     * would get ET by adding deltaT to the UT, e.g.,
     * <CODE>tjd_et&nbsp;+&nbsp;SweDate.getDeltaT(tjd_et)</CODE>.<P>
     * <P>The parameter xx is used as an output parameter containing the
     * following info:
     * <P><CODE><BLOCKQUOTE>xx[0]:&nbsp;&nbsp;&nbsp;longitude<BR>
     * xx[1]:&nbsp;&nbsp;&nbsp;latitude<BR>
     * xx[2]:&nbsp;&nbsp;&nbsp;distance in AU<BR>
     * xx[3]:&nbsp;&nbsp;&nbsp;speed in longitude (degree / day)<BR>
     * xx[4]:&nbsp;&nbsp;&nbsp;speed in latitude (degree / day)<BR>
     * xx[5]:&nbsp;&nbsp;&nbsp;speed in distance (AU / day)<BR>
     * </BLOCKQUOTE></CODE><P>
     * The speed infos will be calculated only, if the appropriate SEFLG_*
     * switch is set.
     * @param tjd The Julian Day number in ET (UT + deltaT).
     * @param ipl The body to be calculated. See
     * <A HREF="SweConst.html">SweConst</A> for a list of bodies
     * @param iflag A flag that contains detailed specification on how the body
     * is to be computed. See <A HREF="SweConst.html">SweConst</A>
     * for a list of valid flags (SEFLG_*).
     * @param xx A double[6] in which the result is returned. See above for more
     * details.
     * @param serr A StringBuffer containing a warning or error message, if
     * something fails.
     * @return iflag or SweConst.ERR (-1); iflag MAY have changed from input
     * parameter!
     * @see #swe_calc_ut(double, int, int, double[], java.lang.StringBuffer)
     * @see #swe_fixstar_ut(java.lang.StringBuffer, double, int, double[], java.lang.StringBuffer)
     * @see #swe_fixstar(java.lang.StringBuffer, double, int, double[], java.lang.StringBuffer)
     */
    public int swe_calc(double tjd, int ipl, int iflag, double xx[],
                        StringBuffer serr) {
        // It has been rewritten to be wrapper to the old interface without
        // exception handling like it was in C. The old routine can now be
        // found in the method _calc().
        int ret = 0;
        try {
            ret = _calc(tjd, ipl, iflag, xx, serr);
        } catch (SwissephException se) {
            ret = se.getRC();
            serr.setLength(0);
            serr.append(se.getMessage());
        }
        return ret;
    }

    // This is the new recommended interface for planetary calculations.
    // It should be rewritten to be used for fixstars as well.
    public int calc(double jdET, int ipl, int iflag, double xx[])
        throws SwissephException {
        return _calc(jdET, ipl, iflag, xx, new StringBuffer());
    }

    private int _calc(double tjd, int ipl, int iflag, double xx[],
                      StringBuffer serr) throws SwissephException {
        int i, j;
        int iflgcoor;
        int iflgsave = iflag;
        int epheflag;
        SavePositions sd;
        double x[]=new double[6], xs[];
        double x0[]=new double[24],
            x2[]=new double[24];
        double dt;

        /* if ephemeris flag != ephemeris flag of last call,
         * we clear the save area, to prevent swecalc() using
         * previously computed data for current calculation.
         * except with ipl = SE_ECL_NUT which is not dependent
         * on ephemeris, and except if change is from
         * ephemeris = 0 to ephemeris = SEFLG_DEFAULTEPH
         * or vice-versa.
         */
        epheflag = iflag & SweConst.SEFLG_EPHMASK;
        if ((epheflag & SweConst.SEFLG_DEFAULTEPH)!=0) {
            epheflag = 0;
        }
        if (swe_calc_epheflag_sv != epheflag && ipl != SweConst.SE_ECL_NUT) {
            swe_close();
            swe_calc_epheflag_sv = epheflag;
        }
        /* high precision speed prevails fast speed */
        if ((iflag & SweConst.SEFLG_SPEED3)!=0 && (iflag & SweConst.SEFLG_SPEED)!=0) {
            iflag = iflag & ~SweConst.SEFLG_SPEED3;
        }
        /* cartesian flag excludes radians flag */
        if (((iflag & SweConst.SEFLG_XYZ)!=0) &&
            ((iflag & SweConst.SEFLG_RADIANS)!=0)) {
            iflag = iflag & ~SweConst.SEFLG_RADIANS;
        }
        /*    if (iflag & SweConst.SEFLG_ICRS)
              iflag |= SweConst.SEFLG_J2000;*/
        /* pointer to save area */
        if (ipl < SweConst.SE_NPLANETS && ipl >= SweConst.SE_SUN) {
            sd = swed.savedat[ipl];
        } else {
            /* other bodies, e.g. asteroids called with ipl = SE_AST_OFFSET + MPC# */
            sd = swed.savedat[SweConst.SE_NPLANETS];
        }
        /*
         * if position is available in save area, it is returned.
         * this is the case, if tjd = tsave and iflag = iflgsave.
         * coordinate flags can be neglected, because save area
         * provides all coordinate types.
         * if ipl > SE_AST(EROID)_OFFSET, ipl must be checked,
         * because all asteroids called by MPC number share the same
         * save area.
         */
        iflgcoor = SweConst.SEFLG_EQUATORIAL | SweConst.SEFLG_XYZ |
            SweConst.SEFLG_RADIANS;

        try { // SwissephExceptions from swecalc
            if (sd.tsave != tjd || tjd == 0 || ipl != sd.ipl ||
                ((sd.iflgsave & ~iflgcoor) != (iflag & ~iflgcoor))) {
                /*
                 * otherwise, new position must be computed
                 */
                if ((iflag & SweConst.SEFLG_SPEED3) == 0) {
                    /*
                     * with high precision speed from one call of swecalc()
                     * (FAST speed)
                     */
                    sd.tsave = tjd;
                    sd.ipl = ipl;
                    if ((sd.iflgsave = swecalc(tjd, ipl, iflag, sd.xsaves, serr)) ==
                        SweConst.ERR) {
                        return swe_calc_error(xx);
                    }
                } else {
                    /*
                     * with speed from three calls of swecalc(), slower and less accurate.
                     * (SLOW speed, for test only)
                     */
                    sd.tsave = tjd;
                    sd.ipl = ipl;
                    switch(ipl) {
                        case SweConst.SE_MOON:
                            dt = SwephData.MOON_SPEED_INTV;
                            break;
                        case SweConst.SE_OSCU_APOG:
                        case SweConst.SE_TRUE_NODE:
                            /* this is the optimum dt with Moshier ephemeris, but not with
                             * JPL ephemeris or SWISSEPH. To avoid completely false speed
                             * in case that JPL is wanted but the program returns Moshier,
                             * we use Moshier optimum.
                             * For precise speed, use JPL and FAST speed computation,
                             */
                            dt = SwephData.NODE_CALC_INTV_MOSH;
                            break;
                        default:
                            dt = SwephData.PLAN_SPEED_INTV;
                            break;
                    }
                    sd.iflgsave = swecalc(tjd-dt, ipl, iflag, x0, serr);
                    if (sd.iflgsave == SweConst.ERR) {
                        return swe_calc_error(xx);
                    }
                    sd.iflgsave = swecalc(tjd+dt, ipl, iflag, x2, serr);
                    if (sd.iflgsave == SweConst.ERR) {
                        return swe_calc_error(xx);
                    }
                    sd.iflgsave = swecalc(tjd, ipl, iflag, sd.xsaves, serr);
                    if (sd.iflgsave == SweConst.ERR) {
                        return swe_calc_error(xx);
                    }
                    denormalize_positions(x0, sd.xsaves, x2);
                    calc_speed(x0, sd.xsaves, x2, dt);
                }
            }
        } catch (SwissephException se) {
            sd.iflgsave = SweConst.ERR;
            swe_calc_error(xx);
            throw se;
        }
        // end_swe_calc:
        int xsOffset=0;
        xs=sd.xsaves;
        if ((iflag & SweConst.SEFLG_EQUATORIAL) != 0) {
            xsOffset=12;        /* equatorial coordinates */
            //    } else {
            //      xsOffset=0;         /* ecliptic coordinates */
        }
        if ((iflag & SweConst.SEFLG_XYZ)!=0) {
            xsOffset+=6;         /* cartesian coordinates */
        }
        if (ipl == SweConst.SE_ECL_NUT) {
            i = 4;
        } else {
            i = 3;
        }
        for (j = 0; j < i; j++) { x[j] = xs[j+xsOffset]; }
        for (j = i; j < 6; j++) { x[j] = 0; }
        if ((iflag & (SweConst.SEFLG_SPEED3 | SweConst.SEFLG_SPEED))!=0) {
            for (j = 3; j < 6; j++) { x[j] = xs[j+xsOffset]; }
        }
        if ((iflag & SweConst.SEFLG_RADIANS)!=0) {
            if (ipl == SweConst.SE_ECL_NUT) {
                for (j = 0; j < 4; j++)
                    x[j] *= SwissData.DEGTORAD;
            } else {
                for (j = 0; j < 2; j++)
                    x[j] *= SwissData.DEGTORAD;
                if ((iflag & (SweConst.SEFLG_SPEED3 | SweConst.SEFLG_SPEED))!=0) {
                    for (j = 3; j < 5; j++)
                        x[j] *= SwissData.DEGTORAD;
                }
            }  
        } 
        for (i = 0; i <= 5; i++) {
            xx[i] = x[i];
        }
        iflag = sd.iflgsave;
        /* if no ephemeris has been specified, do not return chosen ephemeris */
        if ((iflgsave & SweConst.SEFLG_EPHMASK) == 0) {
            iflag = iflag & ~SweConst.SEFLG_DEFAULTEPH;
        }
        return iflag;
    }

    /* closes all open files, frees space of planetary data,
     * deletes memory of all computed positions
     */
    /**
     * This method closes all open data files and sets planetary data objects
     * to null for a hint to the garbage collector that those objects can be
     * freed.
     */
    public void swe_close() {
        int i;
        try {
            /* close SWISSEPH files */
            for(i=0;i<SwephData.SEI_NEPHFILES;i++) {
                swed.fidat[i].clearData();
            }
            /* free planets data space */
            for(i=0;i<SwephData.SEI_NPLANETS;i++) {
                swed.pldat[i].clearData();
            }
            for (i=0; i <= SweConst.SE_NPLANETS; i++) {/* "<=" is correct! see decl.*/
                swed.savedat[i].clearData();
            }
            /* clear node data space */
            for(i=0;i<SwephData.SEI_NNODE_ETC;i++) {
                swed.nddat[i].clearData();
            }
            swed.oec.clearData();
            swed.oec2000.clearData();
            swed.nut.clearData();
            swed.nut2000.clearData();
            swed.nutv.clearData();
            /* close JPL file */
            sj.swi_close_jpl_file();
            swed.jpl_file_is_open=false;
            /* close fixed stars */
            if (swed.fixfp!=null) {
                swed.fixfp.close();
                swed.fixfp=null;
            }
        } catch (java.io.IOException e) {
            // NBT
        }
    }

    /* sets ephemeris file path.
     * also calls swe_close(). this makes sure that swe_calc()
     * won't return planet positions previously computed from other
     * ephemerides
     */
    /**
     * This sets the search path for the ephemeris data files. Asteroid files
     * are searched in the subdirectories ast0 to ast9 first. Multiple path
     * elements are separated by a semikolon (;) or colon (:). Ephemeris
     * path elements can be normal file system paths or http-URLs. If your
     * elements contain colons or semikolons or spaces or backslashes, you
     * have to escape them with a backslash (\), e.g.
     * <CODE>&quot;./ephe:C\\:\\\\ephe:http\\://th-mack.de/datafiles&quot;</CODE>
     * for a search path of: a) local subdirectory ephe, or, if something is
     * not found here, b) in C:\ephe, or as a last resort c)
     * http://th-mack.de/datafiles.<P><B>Note: Opposed to the behaviour of
     * the C version, the Java version does not evaluate environment variables.
     * This is also true for the environment variable SE_EPHE_PATH!</B><BR>
     * @param path The search path for the Swiss Ephemeris. If null or empty,
     * a default path will be used.
     * and JPL
     * data files. You will have to quote ':', ';' and '\' characters, so a
     * path like <code>&quot;C:\swiss\ephe&quot;</code> has to be written as
     * <code>&quot;C\\:\\\\swiss\\\\ephe&quot;</code>, as any '\' will be
     * evaluated twice: the first time by the Java compiler, and the second
     * time by the program itself.
     */
    public void swe_set_ephe_path(String path) {
        String s="";
        swed.ephe_path_is_set=true;
        /* close all open files and delete all planetary data */
        swe_close();
        //  /* environment variable SE_EPHE_PATH has priority */
        //  if ((sp = getenv("SE_EPHE_PATH")) != NULL
        //    && strlen(sp) != 0
        //    && strlen(sp) <= AS_MAXCH-1-13) {
        //    strcpy(s, sp);
        //  } else
        if (path == null || path.length() == 0) {
            s=SweConst.SE_EPHE_PATH;
        } else if (path.length() <= SwissData.AS_MAXCH-1-13) {
            s=path;
        } else {
            s=SweConst.SE_EPHE_PATH;
        }
        // JAVA: Skipping this code in the Java version - it does not do anything
        // meaningful anyway...
        //    if (! s.endsWith(swed.DIR_GLUE)) {
        //      s+=swed.DIR_GLUE;
        //    }
        swed.ephepath=s;
    }

    /* sets jpl file name.
     * also calls swe_close(). this makes sure that swe_calc()
     * won't return planet positions previously computed from other
     * ephemerides
     */
    /**
     * This sets the name of the file that contains the ephemeris data
     * for the use with the JPL ephemeris. It defaults to the string
     * "de406.eph" defined in SweConst.SE_FNAME_DFT. If a path is given
     * in fname, the path will be cut off, as the path is given by
     * swe_set_ephe_path(...).
     * @param fname Name of the JPL data file
     * @see SweConst#SE_FNAME_DFT
     * @see SwissEph#swe_set_ephe_path(java.lang.String)
     */
    public void swe_set_jpl_file(String fname) {
        /* close all open files and delete all planetary data */
        swe_close();
        /* if path is contained in fnam, it is filled into the path variable */
        if (fname.indexOf(swed.DIR_GLUE)>=0) {
            fname=fname.substring(fname.lastIndexOf(swed.DIR_GLUE));
        }
        if (fname.length() >= SwissData.AS_MAXCH) {
            fname=fname.substring(0,SwissData.AS_MAXCH);
        }
        swed.jplfnam=fname;
    }

    /**
     * This sets the ayanamsha mode for sidereal planet calculations. If you
     * don't set the ayanamsha mode, it will default to Fagan/Bradley
     * (SE_SIDM_FAGAN_BRADLEY).
     * The predefined ayanamsha modes are as follows:<P><CODE>
     * <blockquote>
     * SE_SIDM_FAGAN_BRADLEY<BR>
     * SE_SIDM_LAHIRI<BR>
     * SE_SIDM_DELUCE<BR>
     * SE_SIDM_RAMAN<BR>
     * SE_SIDM_USHASHASHI<BR>
     * SE_SIDM_KRISHNAMURTI<BR>
     * SE_SIDM_DJWHAL_KHUL<BR>
     * SE_SIDM_YUKTESHWAR<BR>
     * SE_SIDM_JN_BHASIN<BR>
     * SE_SIDM_BABYL_KUGLER1<BR>
     * SE_SIDM_BABYL_KUGLER2<BR>
     * SE_SIDM_BABYL_KUGLER3<BR>
     * SE_SIDM_BABYL_HUBER<BR>
     * SE_SIDM_BABYL_ETPSC<BR>
     * SE_SIDM_ALDEBARAN_15TAU<BR>
     * SE_SIDM_HIPPARCHOS<BR>
     * SE_SIDM_SASSANIAN<BR>
     * SE_SIDM_GALCENT_0SAG<BR>
     * SE_SIDM_J2000<BR>
     * SE_SIDM_J1900<BR>
     * SE_SIDM_B1950<BR>
     * SE_SIDM_USER
     * </blockquote>
     * </CODE><P>
     * You do not consider the parameters ayan_t0 and t0 if you use a
     * predefined ayanamsha as above. If you specify SE_SIDM_USER, you
     * have to give the value of a reference date t0, and the value of
     * of the ayanamsha at that date in ayan_t0.
     * @param sid_mode One of the above ayanamsha modes plus (optionally)
     * one of the non-standard sidereal calculation modes of
     * <CODE>SE_SIDBIT_ECL_T0</CODE> or <CODE>SE_SIDBIT_SSY_PLANE</CODE>.
     * @param t0 Reference date (Julian day), if sid_mode is SE_SIDM_USER
     * @param ayan_t0 Initial ayanamsha at t0, if sid_mode is SE_SIDM_USER. This
     * is (tropical position - sidereal position) at date t0.
     * @see SweConst#SE_SIDM_FAGAN_BRADLEY
     * @see SweConst#SE_SIDM_LAHIRI
     * @see SweConst#SE_SIDM_DELUCE
     * @see SweConst#SE_SIDM_RAMAN
     * @see SweConst#SE_SIDM_USHASHASHI
     * @see SweConst#SE_SIDM_KRISHNAMURTI
     * @see SweConst#SE_SIDM_DJWHAL_KHUL
     * @see SweConst#SE_SIDM_YUKTESHWAR
     * @see SweConst#SE_SIDM_JN_BHASIN
     * @see SweConst#SE_SIDM_BABYL_KUGLER1
     * @see SweConst#SE_SIDM_BABYL_KUGLER2
     * @see SweConst#SE_SIDM_BABYL_KUGLER3
     * @see SweConst#SE_SIDM_BABYL_HUBER
     * @see SweConst#SE_SIDM_BABYL_ETPSC
     * @see SweConst#SE_SIDM_ALDEBARAN_15TAU
     * @see SweConst#SE_SIDM_HIPPARCHOS
     * @see SweConst#SE_SIDM_SASSANIAN
     * @see SweConst#SE_SIDM_GALCENT_0SAG
     * @see SweConst#SE_SIDM_J2000
     * @see SweConst#SE_SIDM_J1900
     * @see SweConst#SE_SIDM_B1950
     * @see SweConst#SE_SIDM_USER
     * @see SweConst#SE_SIDBIT_ECL_T0
     * @see SweConst#SE_SIDBIT_SSY_PLANE
     */
    public void swe_set_sid_mode(int sid_mode, double t0, double ayan_t0) {
        SidData sip = swed.sidd;
        sip.sid_mode = sid_mode;
        if (sid_mode >= SweConst.SE_SIDBITS) {
            sid_mode %= SweConst.SE_SIDBITS;
        }
        /* standard equinoxes: positions always referred to ecliptic of t0 */
        if (sid_mode == SweConst.SE_SIDM_J2000
            || sid_mode == SweConst.SE_SIDM_J1900
            || sid_mode == SweConst.SE_SIDM_B1950) {
            sip.sid_mode |= SweConst.SE_SIDBIT_ECL_T0;
        }
        if (sid_mode >= SwissData.SE_NSIDM_PREDEF && sid_mode != SweConst.SE_SIDM_USER) {
            sip.sid_mode = sid_mode = SweConst.SE_SIDM_FAGAN_BRADLEY;
        }
        swed.ayana_is_set = true;
        if (sid_mode == SweConst.SE_SIDM_USER) {
            sip.t0 = t0;
            sip.ayan_t0 = ayan_t0;
        } else {
            sip.t0 = SwephData.ayanamsa[sid_mode].t0;
            sip.ayan_t0 = SwephData.ayanamsa[sid_mode].ayan_t0;
        }
        swi_force_app_pos_etc();
    }

    /* the ayanamsa (precession in longitude)
     * according to Newcomb's definition: 360 -
     * longitude of the vernal point of t referred to the
     * ecliptic of t0.
     */
    /**
     * This calculates the ayanamsha for a given date. You should call
     * swe_set_sid_mode(...) before, where you will set the mode of ayanamsha,
     * as many different ayanamshas are used in the world today.
     * @param tjd_et The date as Julian Day in ET (Ephemeris Time or Dynamic Time)
     * @return The value of the ayanamsha
     * @see #swe_set_sid_mode(int, double, double)
     * @see #swe_get_ayanamsa_ut(double)
     */
    public double swe_get_ayanamsa(double tjd_et) {
        double x[]=new double[6], eps;
        SidData sip = swed.sidd;
        if (!swed.ayana_is_set) {
            swe_set_sid_mode(SweConst.SE_SIDM_FAGAN_BRADLEY, 0, 0);
        }
        /* vernal point (tjd), cartesian */
        x[0] = 1;
        x[1] = x[2] = 0;
        /* to J2000 */
        if (tjd_et != SwephData.J2000) {
            sl.swi_precess(x, tjd_et, SwephData.J_TO_J2000);
        }
        /* to t0 */
        sl.swi_precess(x, sip.t0, SwephData.J2000_TO_J);
        /* to ecliptic */
        eps = sl.swi_epsiln(sip.t0);
        sl.swi_coortrf(x, x, eps);
        /* to polar */
        sl.swi_cartpol(x, x);
        /* subtract initial value of ayanamsa */
        x[0] = x[0] * SwissData.RADTODEG - sip.ayan_t0;
        /* get ayanamsa */
        return sl.swe_degnorm(-x[0]);
    }

    /**
     * This calculates the ayanamsha for a given date. You should call
     * swe_set_sid_mode(...) before, where you will set the mode of ayanamsha,
     * as many different ayanamshas are used in the world today.
     * @param tjd_ut The date as Julian Day in UT (Universal Time)
     * @return The value of the ayanamsha
     * @see #swe_set_sid_mode(int, double, double)
     * @see #swe_get_ayanamsa(double)
     */
    public double swe_get_ayanamsa_ut(double tjd_ut) {
        return swe_get_ayanamsa(tjd_ut + SweDate.getDeltaT(tjd_ut));
    }

    /**********************************************************
     * get fixstar positions
     * parameters:
     * star         name of star or line number in star file
     *              (start from 1, don't count comment).
     *              If no error occurs, the name of the star is returned
     *              in the format trad_name, nomeclat_name
     *
     * tjd          absolute julian day
     * iflag        s. swecalc(); speed bit does not function
     * x            pointer for returning the ecliptic coordinates
     * serr         error return string
     **********************************************************/
    /**
     * Computes fixed stars. This method is identical to swe_fixstar_ut() with
     * the one exception that the time has to be given in ET (Ephemeris Time or
     * Dynamical Time instead of Universal Time UT). You would get ET by adding
     * deltaT to the UT, e.g.,
     * <CODE>tjd_et&nbsp;+&nbsp;SweDate.getDeltaT(tjd_et)</CODE>.<P>
     * See <A HREF="SwissEph.html#swe_fixstar_ut(java.lang.StringBuffer, double, int, double[], java.lang.StringBuffer)">
     * swe_fixstar_ut(...)</A> for missing information.
     */
    public int swe_fixstar(StringBuffer star, double tjd, int iflag, double xx[],
                           StringBuffer serr) {
        int i;
        int star_nr = 0;
        boolean isnomclat = false;
        int cmplen;
        // Missing parameters are in "int swe_fixstar_found(...)"!
        String sstar=null;
        String fstar=null;
        String s, sp;
        int line = 0;
        int fline = 0;
        int epheflag, iflgsave;
        iflag |= SweConst.SEFLG_SPEED; /* we need this in order to work correctly */
        iflgsave = iflag;

        if (serr != null) {
            serr.setLength(0);
        }
        iflag = plaus_iflag(iflag);
        if (((iflag & SweConst.SEFLG_SIDEREAL)!=0) && !swed.ayana_is_set) {
            swe_set_sid_mode(SweConst.SE_SIDM_FAGAN_BRADLEY, 0, 0);
        }
        epheflag = iflag & SweConst.SEFLG_EPHMASK;
        /******************************************
         * obliquity of ecliptic 2000 and of date *
         ******************************************/
        swi_check_ecliptic(tjd);
        /******************************************
         * nutation                               *
         ******************************************/
        swi_check_nutation(tjd, iflag);
        if (swed.fixfp == null) {
            try {
                swed.fixfp = swi_fopen(SwephData.SEI_FILE_FIXSTAR, SweConst.SE_STARFILE,
                                       swed.ephepath, serr);
            } catch (SwissephException se) {
                return swe_fixstar_error(xx,SweConst.ERR);
            }
        }
        /******************************************************
         * Star file
         * close to the beginning, a few stars selected by Astrodienst.
         * These can be accessed by giving their number instead of a name.
         * All other stars can be accessed by name.
         * Comment lines start with # and are ignored.
         ******************************************************/
        swed.fixfp.seek(0);
        sstar=star.toString().substring(0,
                                        Math.min(star.length(),SweConst.SE_MAX_STNAME));
        if (sstar.length()>0) {
            if (sstar.charAt(0) == ',') {
                isnomclat = true;
            } else if (Character.isDigit(sstar.charAt(0))) {
                // Use SwissLib.atoi(...)!!!
                star_nr = Integer.parseInt(sstar);
            } else {
                /* traditional name of star to lower case */
                sstar=sstar.toLowerCase();
                if (sstar.indexOf(',')>=0) {
                    sstar=sstar.substring(0,sstar.indexOf(','));
                }
            }
            sstar=sstar.trim();
        }
        cmplen = sstar.length();
        if (cmplen == 0) {
            if (serr != null) {
                serr.setLength(0);
                serr.append("star name empty");
            }
            return swe_fixstar_error(xx,SweConst.ERR);
        }
        try {
            while ((s=swed.fixfp.readLine())!=null) {
                fline++;
                if (s.startsWith("#")) { continue; }
                line++;
                if (star_nr == line) {
                    return swe_fixstar_found(serr,s,star,tjd,iflag,iflgsave,epheflag,xx);
                }
                else if (star_nr > 0) {
                    continue;
                }
                if(s.indexOf(',')<0) {
                    if (serr != null) {
                        serr.setLength(0);
                        serr.append("star file "+SweConst.SE_STARFILE+" damaged at line "+
                                    fline);
                    }
                    return swe_fixstar_error(xx,SweConst.ERR);
                }
                sp=s.substring(s.indexOf(','));
                if (isnomclat) {
                    if (sp.substring(0,Math.min(sp.length(),cmplen)).equals(
                                                                            sstar.substring(0,Math.min(sstar.length(),cmplen)))) {
                        return swe_fixstar_found(serr,s,star,tjd,iflag,iflgsave,epheflag,xx);
                    } else {
                        continue;
                    }
                }
                fstar=s.substring(0,
                                  Math.min(SweConst.SE_MAX_STNAME,s.indexOf(','))).trim();
                i = fstar.length();
                if (i < cmplen) {
                    continue;
                }
                fstar=fstar.toLowerCase();
                if (fstar.substring(0,Math.min(fstar.length(),cmplen)).equals(
                                                                              sstar.substring(0,Math.min(sstar.length(),cmplen)))) {
                    return swe_fixstar_found(serr,s,star,tjd,iflag,iflgsave,epheflag,xx);
                }
            }
        } catch (java.io.IOException ioe) {
        }
        if (serr != null && star.length() < SwissData.AS_MAXCH - 20) {
            serr.setLength(0);
            serr.append("star "+star+" not found");
        }
        return swe_fixstar_error(xx,SweConst.ERR);
    }

    /**
     * Computes fixed stars. This method is identical to swe_fixstar() with the
     * one exception that the time has to be given in UT (Universal Time instead
     * of Ephemeris Time or Dynamical Time ET).<P>
     * The fixed stars are defined in the file fixstars.cat and the star
     * parameter must refer to any entry in that file. The entries in that file
     * start with <I>traditional_name&nbsp;,nomenclature_name,...</I>, e.g.,
     * "<CODE>Alpheratz&nbsp;&nbsp;&nbsp;&nbsp;,alAnd,</CODE>"[...].
     * @param star Actually, it is an input and an output parameter at the same
     * time. So it is not possible to define it as a String, but rather as a
     * StringBuffer. On input it defines the star to be calculated and can be
     * in three forms:<BR>
     * - as a positive integer number meaning the star in the file fixstars.cat
     * that is given on the line number of the given number, without counting
     * any comment lines beginning with #.<BR>
     * - as a traditional name case insensitively compared to the first name
     * on every line in fixstars.cat.<BR>
     * - as a nomenclature prefixed by a comma. This name is compared in a case
     * preserving manner to the nomenclature name on every line in
     * fixstars.cat.<BR>
     * On Output it returns the complete name (traditional plus nomenclature
     * name), e.g. "<CODE>Alpheratz,alAnd</CODE>".
     * @param tjd_ut The Julian Day in UT
     * @param iflag Any of the SweConst.SEFLG_* flags
     * @param xx A double[6] used as output parameter only. This returns
     * longitude, latitude and the distance (in AU) of the fixed stars, but
     * it does <B>not</B> return any speed values in xx[3] to xx[5] as it does
     * in swe_calc() / swe_calc_ut(), even if you specify SweConst.SEFLG_SPEED
     * in the flags parameter!
     * @param serr A StringBuffer containing a warning or error message, if
     * something fails.
     * @return iflag or SweConst.ERR (-1); iflag MAY have changed from input
     * parameter!
     */
    public int swe_fixstar_ut(StringBuffer star, double tjd_ut, int iflag,
                              double[] xx, StringBuffer serr) {
        return swe_fixstar(star, tjd_ut + SweDate.getDeltaT(tjd_ut),
                           iflag, xx, serr);
    }


    /**
     * This will return the planet name for the given planet number. If you are
     * looking for names of asteroids, it may be possible that no name is
     * available so far. The names should be found in the asteroids data file,
     * but if nothing is found there, the name will be looked up in the file
     * seasnam.txt that should be more up to date and can be updated by the user.
     * You can get a list of names from
     * <A HREF="http://cfa-www.harvard.edu/iau/lists/MPNames.html">http://cfa-www.harvard.edu/iau/lists/MPNames.html</A>,
     * which you would like to rename to seasnam.txt and move to your ephemeris
     * directory.
     * @param ipl The planet number
     * @return The name of the planet
     */
    public String swe_get_planet_name(int ipl) {
        String s="";
        int i;
        int retc;
        double xp[]=new double[6];
        if (ipl != 0 && ipl == swed.i_saved_planet_name) {
            s=swed.saved_planet_name;
            return s;
        }
        switch(ipl) {
            case SweConst.SE_SUN:
                s = SwephData.SE_NAME_SUN;
                break;
            case SweConst.SE_MOON:
                s = SwephData.SE_NAME_MOON;
                break;
            case SweConst.SE_MERCURY:
                s = SwephData.SE_NAME_MERCURY;
                break;
            case SweConst.SE_VENUS:
                s = SwephData.SE_NAME_VENUS;
                break;
            case SweConst.SE_MARS:
                s = SwephData.SE_NAME_MARS;
                break;
            case SweConst.SE_JUPITER:
                s = SwephData.SE_NAME_JUPITER;
                break;
            case SweConst.SE_SATURN:
                s = SwephData.SE_NAME_SATURN;
                break;
            case SweConst.SE_URANUS:
                s = SwephData.SE_NAME_URANUS;
                break;
            case SweConst.SE_NEPTUNE:
                s = SwephData.SE_NAME_NEPTUNE;
                break;
            case SweConst.SE_PLUTO:
                s = SwephData.SE_NAME_PLUTO;
                break;
            case SweConst.SE_MEAN_NODE:
                s = SwephData.SE_NAME_MEAN_NODE;
                break;
            case SweConst.SE_TRUE_NODE:
                s = SwephData.SE_NAME_TRUE_NODE;
                break;
            case SweConst.SE_MEAN_APOG:
                s = SwephData.SE_NAME_MEAN_APOG;
                break;
            case SweConst.SE_OSCU_APOG:
                s = SwephData.SE_NAME_OSCU_APOG;
                break;
            case SweConst.SE_INTP_APOG: 
                s = SwephData.SE_NAME_INTP_APOG;
                break;  
            case SweConst.SE_INTP_PERG: 
                s = SwephData.SE_NAME_INTP_PERG;
                break;  
            case SweConst.SE_EARTH:
                s = SwephData.SE_NAME_EARTH;
                break;
            case SweConst.SE_CHIRON:
            case SweConst.SE_AST_OFFSET + SwephData.MPC_CHIRON:
                s = SwephData.SE_NAME_CHIRON;
                break;
            case SweConst.SE_PHOLUS:
            case SweConst.SE_AST_OFFSET + SwephData.MPC_PHOLUS:
                s = SwephData.SE_NAME_PHOLUS;
                break;
            case SweConst.SE_CERES:
            case SweConst.SE_AST_OFFSET + SwephData.MPC_CERES:
                s = SwephData.SE_NAME_CERES;
                break;
            case SweConst.SE_PALLAS:
            case SweConst.SE_AST_OFFSET + SwephData.MPC_PALLAS:
                s = SwephData.SE_NAME_PALLAS;
                break;
            case SweConst.SE_JUNO:
            case SweConst.SE_AST_OFFSET + SwephData.MPC_JUNO:
                s = SwephData.SE_NAME_JUNO;
                break;
            case SweConst.SE_VESTA:
            case SweConst.SE_AST_OFFSET + SwephData.MPC_VESTA:
                s = SwephData.SE_NAME_VESTA;
                break;
            default:
                /* fictitious planets */
                if (ipl >= SweConst.SE_FICT_OFFSET && ipl <= SweConst.SE_FICT_MAX) {
                    return smosh.swi_get_fict_name(ipl - SweConst.SE_FICT_OFFSET, s);
                }
                /* asteroids */
                if (ipl > SweConst.SE_AST_OFFSET) {
                    /* if name is already available */
                    if (ipl == swed.fidat[SwephData.SEI_FILE_ANY_AST].ipl[0]) {
                        s=swed.fidat[SwephData.SEI_FILE_ANY_AST].astnam;
                        /* else try to get it from ephemeris file */
                    } else {
                        retc = sweph(SwephData.J2000, ipl, SwephData.SEI_FILE_ANY_AST, 0,
                                     null, SwephData.NO_SAVE, xp, null);
                        if (retc != SweConst.ERR && retc != SwephData.NOT_AVAILABLE) {
                            s=swed.fidat[SwephData.SEI_FILE_ANY_AST].astnam;
                        } else {
                            s=(ipl - SweConst.SE_AST_OFFSET)+": not found";
                        }
                    }
                    /* If there is a provisional designation only in ephemeris file,
                     * we look for a name in seasnam.txt, which can be updated by
                     * the user.
                     * Some old ephemeris files return a '?' in the first position.
                     * There are still a couple of unnamed bodies that got their
                     * provisional designation before 1925, when the current method
                     * of provisional designations was introduced. They have an 'A'
                     * as the first character, e.g. A924 RC.
                     * The file seasnam.txt may contain comments starting with '#'.
                     * There must be at least two columns:
                     * 1. asteroid catalog number
                     * 2. asteroid name
                     * The asteroid number may or may not be in brackets
                     */
                    // Hopefully, I did understand the whole thing correctly...
                    if (s.charAt(0) == '?' || Character.isDigit(s.charAt(1))) {
                        int ipli = (int) (ipl - SweConst.SE_AST_OFFSET), iplf = 0;
                        FilePtr fp = null;
                        String si;
                        try {
                            fp = swi_fopen(-1, SweConst.SE_ASTNAMFILE, swed.ephepath, null);
                        } catch (SwissephException se) {
                        }
                        if (fp != null) {
                            while(ipli != iplf) {
                                try {
                                    si=fp.readLine();
                                    if (si==null) { break; }
                                    StringTokenizer tk=new StringTokenizer(si," \t([{"); // }
                                    String sk=tk.nextToken();
                                    if (sk.startsWith("#") ||
                                        Character.isWhitespace(sk.charAt(0))) {
                                        continue;
                                    }
                                    /* catalog number of body of current line */
                                    iplf = Double.valueOf(sk).intValue();
                                    if (ipli != iplf) {
                                        continue;
                                    }
                                    s=tk.nextToken("#\r\n").trim();
                                    fp.close();
                                } catch (java.io.IOException ioe) {
                                    // NBT
                                } catch (NoSuchElementException nse) {
                                    continue; /* there is no name */
                                }
                            }
                        }
                    }
                } else  {
                    i = ipl;
                    s=""+i;
                }
                break;
                // End of default
        } // End of switch()
        if (s.length() < 80) {
            swed.i_saved_planet_name = ipl;
            swed.saved_planet_name = s;
        }
        return s;
    }

    public String swe_get_ayanamsa_name(int isidmode) {
        if (isidmode < SwissData.SE_NSIDM_PREDEF)
            return SwissData.ayanamsa_name[isidmode];
        return null;
    }

    /* set geographic position and altitude of observer */
    /**
     * If you want to do calculations relative to the observer on some place
     * on the earth rather than relative to the center of the earth, you will
     * want to set the geographic location with this method.
     * @param geolon The Longitude in degrees
     * @param geolat The Latitude in degrees
     * @param geoalt The height above sea level in meters
     */
    public void swe_set_topo(double geolon, double geolat, double geoalt) {
        swed.topd.geolon = geolon;
        swed.topd.geolat = geolat;
        swed.topd.geoalt = geoalt;
        swed.geopos_is_set = true;
        /* to force new calculation of observer position vector */
        swed.topd.teval = 0;
        /* to force new calculation of light-time etc.
         */
        swi_force_app_pos_etc();
    }


    ////////////////////////////////////////////////////////////////////////////
    // Methods from SwephJPL.java: /////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    public double[] getJPLRange(String fname) {
        if (sj==null) {
            sj=new SwephJPL(this, swed, sl);
        }
        return sj.getJPLRange(fname);
    }

    ////////////////////////////////////////////////////////////////////////////
    // Methods from Swecl.java: ////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    /**
     * Computes the azimut and height from either ecliptic or equatorial
     * coordinates.
     * <P>xaz is an output parameter as follows:
     * <P><CODE>
     * xaz[0]:&nbsp;&nbsp;&nbsp;azimuth, i.e. position degree, measured from
     * the south point to west.<BR>
     * xaz[1]:&nbsp;&nbsp;&nbsp;true altitude above horizon in degrees.<BR>
     * xaz[2]:&nbsp;&nbsp;&nbsp;apparent (refracted) altitude above horizon
     * in degrees.
     * </CODE><P>
     * @param tjd_ut time and date in UT
     * @param calc_flag SweConst.SE_ECL2HOR (xin[0] contains ecliptic
     * longitude, xin[1] the ecliptic latitude) or SweConst.SE_EQU2HOR (xin[0] =
     * rectascension, xin[1] = declination)
     * @param geopos A double[3] containing the longitude, latitude and
     * height of the geographic position. Eastern longitude and northern
     * latitude is given by positive values, western longitude and southern
     * latitude by negative values.
     * @param atpress atmospheric pressure in mBar (hPa). If it is 0, the pressure
     * will be estimated from geopos[2] and attemp.
     * @param attemp atmospheric temperature in degrees Celsius.
     * @param xin double[3] with a content depending on parameter calc_flag.
     * See there. xin[3] does not need to be defined.
     * @param xaz Output parameter: a double[3] returning values as specified
     * above.
     */
    public void swe_azalt(double tjd_ut, int calc_flag, double[] geopos,
                          double atpress, double attemp, double[] xin,
                          double[] xaz) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        sc.swe_azalt(tjd_ut, calc_flag, geopos, atpress, attemp, xin, xaz);
    }

    /**
     * Computes either ecliptic or equatorial coordinates from azimuth and true
     * altitude. The true altitude might be gained from an apparent altitude by
     * calling swe_refrac.<P>xout is an output parameter containing the ecliptic
     * or equatorial coordinates, depending on the value of the parameter
     * calc_flag.
     * @param tjd_ut time and date in UT
     * @param calc_flag SweConst.SE_HOR2ECL or SweConst.SE_HOR2EQU
     * @param geopos A double[3] containing the longitude, latitude and
     * height of the geographic position. Eastern longitude and northern
     * latitude is given by positive values, western longitude and southern
     * latitude by negative values.
     * @param xin double[2] with azimuth and true altitude of planet
     * @param xout Output parameter: a double[2] returning either ecliptic or
     * equatorial coordinates
     */
    public void swe_azalt_rev(double tjd_ut, int calc_flag, double[] geopos,
                              double[] xin, double[] xout) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        sc.swe_azalt_rev(tjd_ut, calc_flag, geopos, xin, xout);
    }

    /**
     * Computes the attributes of a lunar eclipse for a given Julian Day,
     * geographic longitude, latitude, and height.
     * <BLOCKQUOTE><P><CODE>
     * attr[0]:&nbsp;&nbsp;&nbsp;umbral magnitude at tjd<BR>
     * attr[1]:&nbsp;&nbsp;&nbsp;penumbral magnitude<BR>
     * attr[4]:&nbsp;&nbsp;&nbsp;azimuth of moon at tjd. <I>Not yet
     * implemented.</I><BR>
     * attr[5]:&nbsp;&nbsp;&nbsp;true altitude of moon above horizon at tjd.
     * <I>Not yet implemented.</I><BR>
     * attr[6]:&nbsp;&nbsp;&nbsp;apparent altitude of moon above horizon at tjd.
     * <I>Not yet implemented.</I><BR>
     * attr[7]:&nbsp;&nbsp;&nbsp;distance of moon from opposition in degrees
     * </CODE></BLOCKQUOTE><P><B>Attention: attr must be a double[20]!</B>
     * @param tjd_ut The Julian Day number in UT
     * @param ifl To indicate, which ephemeris should be used (SEFLG_JPLEPH,
     * SEFLG_SWIEPH or SEFLG_MOSEPH)
     * @param geopos A double[3] containing geographic longitude, latitude and
     * height in meters above sea level in this order. Eastern longitude and
     * northern latitude is given by positive values, western longitude and
     * southern latitude by negative values.
     * @param attr A double[20], on return containing the attributes of the
     * eclipse as above
     * @param serr A StringBuffer containing a warning or error message, if
     * something fails
     * @return -1 (SweConst.ERR), if the calculation failed<BR>
     * 0, if there is no lunar eclipse at that time and location<BR>
     * otherwise:<BR>
     * SweConst.SE_ECL_TOTAL<BR>
     * SweConst.SE_ECL_PENUMBRAL<BR>
     * SweConst.SE_ECL_PARTIAL
     * @see SweConst#SE_ECL_TOTAL
     * @see SweConst#SE_ECL_PENUMBRAL
     * @see SweConst#SE_ECL_PARTIAL
     */
    public int swe_lun_eclipse_how(double tjd_ut, int ifl, double[] geopos,
                                   double[] attr, StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_lun_eclipse_how(tjd_ut, ifl, geopos, attr, serr);
    }

    /**
     * Computes the next lunar eclipse anywhere on earth.
     * <P>tret is an output parameter with the following meaning:
     * <P><CODE>
     * tret[0]:&nbsp;&nbsp;&nbsp;time of maximum eclipse.<BR>
     * tret[1]:&nbsp;&nbsp;&nbsp;<BR>
     * tret[2]:&nbsp;&nbsp;&nbsp;time of the begin of partial phase.<BR>
     * tret[3]:&nbsp;&nbsp;&nbsp;time of the end of partial phaseend.<BR>
     * tret[4]:&nbsp;&nbsp;&nbsp;time of the begin of totality.<BR>
     * tret[5]:&nbsp;&nbsp;&nbsp;time of the end of totality.<BR>
     * tret[6]:&nbsp;&nbsp;&nbsp;time of the begin of center line.<BR>
     * tret[7]:&nbsp;&nbsp;&nbsp;time of the end of center line<BR>
     * </CODE><P><B>Attention: tret must be a double[10]!</B>
     * @param tjd_start The Julian Day number in UT, from when to start searching
     * @param ifl To indicate, which ephemeris should be used (SEFLG_JPLEPH,
     * SEFLG_SWIEPH or SEFLG_MOSEPH)
     * @param ifltype SweConst.SE_ECL_TOTAL for total eclipse or 0 for any eclipse
     * @param tret A double[10], on return containing the times of different
     * occasions of the eclipse as above
     * @param backward !=0, if search should be done backwards
     * @param serr A StringBuffer containing a warning or error message, if
     * something fails.
     * @return -1 (SweConst.ERR), if the calculation failed<BR>
     * otherwise:<BR>
     * SweConst.SE_ECL_TOTAL<BR>
     * SweConst.SE_ECL_ANNULAR<BR>
     * SweConst.SE_ECL_PARTIAL<BR>
     * SweConst.SE_ECL_ANNULAR_TOTAL<BR>in combination with:<BR>
     * SweConst.SE_ECL_CENTRAL<BR>
     * SweConst.SE_ECL_NONCENTRAL
     * @see SweConst#SE_ECL_TOTAL
     * @see SweConst#SE_ECL_ANNULAR
     * @see SweConst#SE_ECL_PARTIAL
     * @see SweConst#SE_ECL_ANNULAR_TOTAL
     * @see SweConst#SE_ECL_CENTRAL
     * @see SweConst#SE_ECL_NONCENTRAL
     */
    public int swe_lun_eclipse_when(double tjd_start, int ifl, int ifltype,
                                    double[] tret, int backward,
                                    StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_lun_eclipse_when(tjd_start,ifl,ifltype,tret,backward,serr);
    }

    /**
     * Computes planetary nodes and apsides (perihelia, aphelia, second focal
     * points of the orbital ellipses). This method is identical to
     * swe_nod_aps_ut() with the one exception that the time has to be given
     * in ET (Ephemeris Time or Dynamical Time). You would get ET by adding
     * deltaT to the UT, e.g.,
     * <CODE>tjd_et&nbsp;+&nbsp;SweDate.getDeltaT(tjd_et)</CODE>.<P>
     * See <A HREF="SwissEph.html#swe_nod_aps_ut(double, int, int, int, double[], double[], double[], double[], java.lang.StringBuffer)">swe_nod_aps_ut(...)</A> for missing information.
     */
    public int swe_nod_aps(double tjd_et, int ipl, int iflag, int  method,
                           double[] xnasc, double[] xndsc,
                           double[] xperi, double[] xaphe,
                           StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_nod_aps(tjd_et, ipl, iflag, method, xnasc, xndsc,
                              xperi, xaphe, serr);
    }

    /**
     * Computes planetary nodes and apsides (perihelia, aphelia, second focal
     * points of the orbital ellipses). This method is identical to
     * swe_nod_aps_ut() with the one exception that the time has to be given
     * in UT (Universal Time) and not in ET (Ephemeris Time or Dynamical Time).
     * @param tjd_ut The time in UT
     * @param ipl Planet number
     * @param iflag Any of the SEFLG_* flags
     * @param method Defines, what kind of calculation is wanted (SE_NODBIT_MEAN,
     * SE_NODBIT_OSCU, SE_NODBIT_OSCU_BAR, SE_NODBIT_FOPOINT)
     * @param xnasc Output parameter of double[6]. On return it contains six
     * doubles for the ascending node
     * @param xndsc Output parameter of double[6]. On return it contains six
     * doubles for the descending node
     * @param xperi Output parameter of double[6]. On return it contains six
     * doubles for the perihelion
     * @param xaphe Output parameter of double[6]. On return it contains six
     * doubles for the aphelion
     * @param serr A StringBuffer containing a warning or error message, if
     * something fails.
     * @return SweConst.OK (0) or SweConst.ERR (-1)
     * @see SwissEph#swe_nod_aps(double, int, int, int, double[], double[], double[], double[], java.lang.StringBuffer)
     * @see SweConst#OK
     * @see SweConst#ERR
     * @see SweConst#SE_NODBIT_MEAN
     * @see SweConst#SE_NODBIT_OSCU
     * @see SweConst#SE_NODBIT_OSCU_BAR
     * @see SweConst#SE_NODBIT_FOPOINT
     */
    public int swe_nod_aps_ut(double tjd_ut, int ipl, int iflag, int  method,
                              double[] xnasc, double[] xndsc,
                              double[] xperi, double[] xaphe,
                              StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_nod_aps_ut(tjd_ut, ipl, iflag, method, xnasc, xndsc,
                                 xperi, xaphe, serr);
    }

    /**
     * Computes phase, phase angel, elongation, apparent diameter and apparent
     * magnitude for sun, moon, all planets and asteroids. This method is
     * identical to swe_pheno_ut() with the one exception that the time
     * has to be given in ET (Ephemeris Time or Dynamical Time). You
     * would get ET by adding deltaT to the UT, e.g.,
     * <CODE>tjd_et&nbsp;+&nbsp;SweDate.getDeltaT(tjd_et)</CODE>.<P>
     * See <A HREF="SwissEph.html#swe_pheno_ut(double, int, int, double[], java.lang.StringBuffer)">swe_pheno_ut(...)</A> for missing information.
     */
    public int swe_pheno(double tjd, int ipl, int iflag, double[] attr,
                         StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_pheno(tjd, ipl, iflag, attr, serr);
    }

    /**
     * Computes phase, phase angel, elongation, apparent diameter and apparent
     * magnitude for sun, moon, all planets and asteroids.
     * <P>attr is an output parameter with the following meaning:
     * <P><CODE><BLOCKQUOTE>
     * attr[0]:&nbsp;&nbsp;&nbsp;phase angle (earth-planet-sun).<BR>
     * attr[1]:&nbsp;&nbsp;&nbsp;phase (illumined fraction of disc).<BR>
     * attr[2]:&nbsp;&nbsp;&nbsp;elongation of planet.<BR>
     * attr[3]:&nbsp;&nbsp;&nbsp;apparent diameter of disc.<BR>
     * attr[4]:&nbsp;&nbsp;&nbsp;apparent magnitude.<BR>
     * </BLOCKQUOTE></CODE><P><B>Attention: attr must be a double[20]!</B>
     * @param tjd_ut The Julian Day number in UT (Universal Time).
     * @param ipl The body number to be calculated. See class
     * <A HREF="SweConst.html">SweConst</A> for a list of bodies (SE_*)
     * @param iflag Which ephemeris is to be used (SEFLG_JPLEPH, SEFLG_SWIEPH,
     * SEFLG_MOSEPH). Also allowable flags: SEFLG_TRUEPOS, SEFLG_HELCTR.
     * @param attr A double[20] in which the result is returned. See above for more
     * details.
     * @param serr A StringBuffer containing a warning or error message, if
     * something fails.
     * @return SweConst.OK (0) or SweConst.ERR (-1)
     * @see SweConst#OK
     * @see SweConst#ERR
     * @see SweConst#SEFLG_JPLEPH
     * @see SweConst#SEFLG_SWIEPH
     * @see SweConst#SEFLG_MOSEPH
     * @see SweConst#SEFLG_TRUEPOS
     * @see SweConst#SEFLG_HELCTR
     */
    public int swe_pheno_ut(double tjd_ut, int ipl, int iflag, double[] attr,
                            StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_pheno_ut(tjd_ut, ipl, iflag, attr, serr);
    }

    /**
     * Calculates the true altitude from the apparent altitude or vice versa.
     * @param inalt The true or apparent altitude to be converted
     * @param atpress Atmospheric pressure in mBar (hPa). If it is 0, the pressure
     * will be estimated from attemp on sea level.
     * @param attemp Atmospheric temperature in degrees Celsius.
     * @param calc_flag SweConst.SE_TRUE_TO_APP or SweConst.SE_APP_TO_TRUE
     * @return The converted altitude
     */
    public double swe_refrac(double inalt, double atpress, double attemp,
                             int calc_flag) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_refrac(inalt, atpress, attemp, calc_flag);
    }

    /**
     * Calculates the times of rising, setting and meridian transits for all
     * planets, asteroids, the moon, and the fixed stars.
     * @param tjd_ut The Julian Day number in UT, from when to start searching
     * @param ipl Planet number, if times for planet or moon are to be calculated.
     * @param starname The name of the star, if times for a star should be
     * calculated. It has to be null or the empty string otherwise!
     * @param epheflag To indicate, which ephemeris should be used (SEFLG_JPLEPH,
     * SEFLG_SWIEPH or SEFLG_MOSEPH)
     * @param rsmi Specification, what type of calculation is wanted
     * (SE_CALC_RISE, SE_CALC_SET, SE_CALC_MTRANSIT, SE_CALC_ITRANSIT,
     * SE_BIT_DISC_CENTER, SE_BIT_NO_REFRACTION). If it is 0, SE_CALC_RISE is
     * calculated
     * @param geopos A double[3] containing the longitude, latitude and
     * height of the observer. Eastern longitude and northern
     * latitude is given by positive values, western longitude and southern
     * latitude by negative values.
     * @param atpress atmospheric pressure in mBar (hPa). If it is 0, the pressure
     * will be estimated from geopos[2] and attemp (1013.25 mbar for sea level).
     * When calculating MTRANSIT or ITRANSIT, this parameter is not used.
     * @param attemp atmospheric temperature in degrees Celsius. When
     * calculating MTRANSIT or ITRANSIT, this parameter is not used.
     * @param tret Return value containing the time of rise or whatever was
     * requested. This is UT.
     * @param serr A StringBuffer containing a warning or error message, if
     * something fails
     * @return SweConst.OK (0) or SweConst.ERR (-1)
     * @see SweConst#OK
     * @see SweConst#ERR
     * @see SweConst#SEFLG_JPLEPH
     * @see SweConst#SEFLG_SWIEPH
     * @see SweConst#SEFLG_MOSEPH
     * @see SweConst#SE_CALC_RISE
     * @see SweConst#SE_CALC_SET
     * @see SweConst#SE_CALC_MTRANSIT
     * @see SweConst#SE_CALC_ITRANSIT
     * @see SweConst#SE_BIT_DISC_CENTER
     * @see SweConst#SE_BIT_NO_REFRACTION
     * @see DblObj
     */
    public int swe_rise_trans(double tjd_ut, int ipl, StringBuffer starname,
                              int epheflag, int rsmi, double[] geopos,
                              double atpress, double attemp, DblObj tret,
                              StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_rise_trans(tjd_ut, ipl, starname, epheflag, rsmi, geopos,
                                 atpress, attemp, tret, serr);
    }

    /**
     * Computes the attributes of a solar eclipse for a given Julian Day,
     * geographic longitude, latitude, and height.
     * <P><CODE><BLOCKQUOTE>
     * attr[0]:&nbsp;&nbsp;&nbsp;fraction of solar diameter covered by moon
     * (magnitude)<BR>
     * attr[1]:&nbsp;&nbsp;&nbsp;ratio of lunar diameter to solar one<BR>
     * attr[2]:&nbsp;&nbsp;&nbsp;fraction of solar disc covered by moon
     * (obscuration)<BR>
     * attr[3]:&nbsp;&nbsp;&nbsp;diameter of core shadow in km<BR>
     * attr[4]:&nbsp;&nbsp;&nbsp;azimuth of sun at tjd<BR>
     * attr[5]:&nbsp;&nbsp;&nbsp;true altitude of sun above horizon at tjd<BR>
     * attr[6]:&nbsp;&nbsp;&nbsp;apparent altitude of sun above horizon at tjd<BR>
     * attr[7]:&nbsp;&nbsp;&nbsp;angular distance of moon from sun in degrees
     * </BLOCKQUOTE></CODE><P><B>Attention: attr must be a double[20]!</B>
     * @param tjd_ut The Julian Day number in UT
     * @param ifl To indicate, which ephemeris should be used (SEFLG_JPLEPH,
     * SEFLG_SWIEPH or SEFLG_MOSEPH)
     * @param geopos A double[3] containing geographic longitude, latitude and
     * height in meters above sea level in this order. Eastern longitude and
     * northern latitude is given by positive values, western longitude and
     * southern latitude by negative values.
     * @param attr A double[20], on return containing the attributes of the
     * eclipse as above
     * @param serr A StringBuffer containing a warning or error message, if
     * something fails
     * @return -1 (SweConst.ERR), if the calculation failed<BR>
     * 0, if there is no solar eclipse at that time and location<BR>
     * SweConst.SE_ECL_TOTAL<BR>
     * SweConst.SE_ECL_ANNULAR<BR>
     * SweConst.SE_ECL_PARTIAL
     * @see SweConst#SE_ECL_TOTAL
     * @see SweConst#SE_ECL_ANNULAR
     * @see SweConst#SE_ECL_PARTIAL
     * @see SweConst#SEFLG_JPLEPH
     * @see SweConst#SEFLG_SWIEPH
     * @see SweConst#SEFLG_MOSEPH
     */
    public int swe_sol_eclipse_how(double tjd_ut, int ifl, double[] geopos,
                                   double[] attr, StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_sol_eclipse_how(tjd_ut, ifl, geopos, attr, serr);
    }

    /**
     * Computes the next solar eclipse anywhere on earth.
     * <P>tret is an output parameter with the following meaning:
     * <P><CODE>
     * tret[0]:&nbsp;&nbsp;&nbsp;time of maximum eclipse.<BR>
     * tret[1]:&nbsp;&nbsp;&nbsp;time, when the eclipse takes place at local
     * apparent noon.<BR><BLOCKQUOTE>
     * tret[2]:&nbsp;&nbsp;&nbsp;time of the begin of the eclipse.<BR>
     * tret[3]:&nbsp;&nbsp;&nbsp;time of the end of the eclipse.<BR>
     * tret[4]:&nbsp;&nbsp;&nbsp;time of the begin of totality.<BR>
     * tret[5]:&nbsp;&nbsp;&nbsp;time of the end of totality.<BR>
     * tret[6]:&nbsp;&nbsp;&nbsp;time of the begin of center line.<BR>
     * tret[7]:&nbsp;&nbsp;&nbsp;time of the end of center line<BR>
     * tret[8]:&nbsp;&nbsp;&nbsp;time, when annular-total eclipse becomes total --
     * <I>Not yet implemented.</I><BR>
     * tret[9]:&nbsp;&nbsp;&nbsp;time, when annular-total eclipse becomes annular
     * again -- <I>Not yet implemented.</I>
     * </BLOCKQUOTE></CODE><P><B>Attention: tret must be a double[10]!</B>
     * @param tjd_start The Julian Day number in UT, from when to start searching
     * @param ifl To indicate, which ephemeris should be used (SEFLG_JPLEPH,
     * SEFLG_SWIEPH or SEFLG_MOSEPH)
     * @param ifltype SweConst.SE_ECL_TOTAL for total eclipse or 0 for any eclipse
     * @param tret A double[10], on return containing the times of different
     * occasions of the eclipse as above
     * @param backward !=0, if search should be done backwards
     * @param serr A StringBuffer containing a warning or error message, if
     * something fails.
     * @return -1 (SweConst.ERR), if the calculation failed<BR>
     * SweConst.SE_ECL_TOTAL<BR>
     * SweConst.SE_ECL_ANNULAR<BR>
     * SweConst.SE_ECL_PARTIAL<BR>
     * SweConst.SE_ECL_ANNULAR_TOTAL<BR>in combination with:<BR>
     * SweConst.SE_ECL_CENTRAL<BR>
     * SweConst.SE_ECL_NONCENTRAL
     * @see SweConst#SE_ECL_TOTAL
     * @see SweConst#SE_ECL_ANNULAR
     * @see SweConst#SE_ECL_PARTIAL
     * @see SweConst#SE_ECL_ANNULAR_TOTAL
     * @see SweConst#SE_ECL_CENTRAL
     * @see SweConst#SE_ECL_NONCENTRAL
     * @see SweConst#SEFLG_JPLEPH
     * @see SweConst#SEFLG_SWIEPH
     * @see SweConst#SEFLG_MOSEPH
     */
    public int swe_sol_eclipse_when_glob(double tjd_start, int ifl, int ifltype,
                                         double tret[], int backward,
                                         StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_sol_eclipse_when_glob(tjd_start, ifl, ifltype, tret,
                                            backward, serr);
    }

    /**
     * Computes the next solar eclipse at a given geographical position. Note the
     * uncertainty of Delta T for the remote past and the future.<P>
     * tret is an output parameter with the following meaning:
     * <P><CODE>
     * tret[0]:&nbsp;&nbsp;&nbsp;time of maximum eclipse.<BR>
     * tret[1]:&nbsp;&nbsp;&nbsp;time of first contact.<BR>
     * tret[2]:&nbsp;&nbsp;&nbsp;time of second contact.<BR>
     * tret[3]:&nbsp;&nbsp;&nbsp;time of third contact.<BR>
     * tret[4]:&nbsp;&nbsp;&nbsp;time of forth contact.<BR>
     * tret[5]:&nbsp;&nbsp;&nbsp;time of sun rise between first and forth contact
     * -- <I>Not yet implemented.</I><BR>
     * tret[6]:&nbsp;&nbsp;&nbsp;time of sun set between first and forth contact
     * -- <I>Not yet implemented.</I><BR>
     * </CODE><P>
     * attr is an output parameter with the following meaning:
     * <P><CODE>
     * attr[0]:&nbsp;&nbsp;&nbsp;fraction of solar diameter covered by moon
     * (magnitude).<BR>
     * attr[1]:&nbsp;&nbsp;&nbsp;ratio of lunar diameter to solar one.<BR>
     * attr[2]:&nbsp;&nbsp;&nbsp;fraction of solar disc covered by moon
     * (obscuration).<BR>
     * attr[3]:&nbsp;&nbsp;&nbsp;diameter of core shadow in km.<BR>
     * attr[4]:&nbsp;&nbsp;&nbsp;azimuth of sun at tjd.<BR>
     * attr[5]:&nbsp;&nbsp;&nbsp;true altitude of sun above horizon at tjd.<BR>
     * attr[6]:&nbsp;&nbsp;&nbsp;apparent altitude of sun above horizon at tjd.<BR>
     * attr[7]:&nbsp;&nbsp;&nbsp;elongation of moon in degrees.<BR>
     * </CODE><P><B>Attention: attr must be a double[20]!</B>
     * @param tjd_start The Julian Day number in UT, from when to start searching
     * @param ifl To indicate, which ephemeris should be used (SEFLG_JPLEPH,
     * SEFLG_SWIEPH or SEFLG_MOSEPH)
     * @param geopos A double[3] containing the longitude, latitude and
     * height of the geographic position. Eastern longitude and northern
     * latitude is given by positive values, western longitude and southern
     * latitude by negative values.
     * @param tret A double[7], on return containing the times of different
     * occasions of the eclipse as specified above
     * @param attr A double[20], on return containing different attributes of
     * the eclipse. See above.
     * @param backward true, if search should be done backwards
     * @param serr A StringBuffer containing a warning or error message, if
     * something fails.
     * @return -1 (SweConst.ERR), if the calculation failed<BR>
     * SweConst.SE_ECL_TOTAL<BR>
     * SweConst.SE_ECL_ANNULAR<BR>
     * SweConst.SE_ECL_PARTIAL<BR>in combination with:<BR>
     * SweConst.SE_ECL_VISIBLE<BR>
     * SweConst.SE_ECL_MAX_VISIBLE<BR>
     * SweConst.SE_ECL_1ST_VISIBLE<BR>
     * SweConst.SE_ECL_2ND_VISIBLE<BR>
     * SweConst.SE_ECL_3RD_VISIBLE<BR>
     * SweConst.SE_ECL_4TH_VISIBLE
     * @see SweConst#SE_ECL_TOTAL
     * @see SweConst#SE_ECL_ANNULAR
     * @see SweConst#SE_ECL_PARTIAL
     * @see SweConst#SE_ECL_VISIBLE
     * @see SweConst#SE_ECL_MAX_VISIBLE
     * @see SweConst#SE_ECL_1ST_VISIBLE
     * @see SweConst#SE_ECL_2ND_VISIBLE
     * @see SweConst#SE_ECL_3RD_VISIBLE
     * @see SweConst#SE_ECL_4TH_VISIBLE
     * @see SweConst#SEFLG_JPLEPH
     * @see SweConst#SEFLG_SWIEPH
     * @see SweConst#SEFLG_MOSEPH
     */
    public int swe_sol_eclipse_when_loc(double tjd_start, int ifl,
                                        double[] geopos, double[] tret,
                                        double[] attr, int backward,
                                        StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_sol_eclipse_when_loc(tjd_start, ifl, geopos, tret, attr,
                                           backward, serr);
    }

    /**
     * Computes the geographic location for a given time, where a solar
     * eclipse is central (or maximum for a non-central eclipse).
     * <P>Output parameters:<P><CODE><BLOCKQUOTE>
     * geopos[0]:&nbsp;&nbsp;&nbsp;geographic longitude of central line, positive
     * values mean east of Greenwich, negative values west of Greenwich<BR>
     * geopos[1]:&nbsp;&nbsp;&nbsp;geographic latitude of central line,
     * positive values mean north of equator, negative values south<BR>
     * </CODE><P><CODE>
     * attr[0]:&nbsp;&nbsp;&nbsp;fraction of solar diameter covered by moon
     * (magnitude)<BR>
     * attr[1]:&nbsp;&nbsp;&nbsp;ratio of lunar diameter to solar one<BR>
     * attr[2]:&nbsp;&nbsp;&nbsp;fraction of solar disc covered by moon
     * (obscuration)<BR>
     * attr[3]:&nbsp;&nbsp;&nbsp;diameter of core shadow in km<BR>
     * attr[4]:&nbsp;&nbsp;&nbsp;azimuth of sun at tjd<BR>
     * attr[5]:&nbsp;&nbsp;&nbsp;true altitude of sun above horizon at tjd<BR>
     * attr[6]:&nbsp;&nbsp;&nbsp;apparent altitude of sun above horizon at tjd<BR>
     * attr[7]:&nbsp;&nbsp;&nbsp;angular distance of moon from sun in degrees
     * </BLOCKQUOTE></CODE><P><B>Attention: geopos must be a double[10], attr
     * a double[20]!</B>
     * @param tjd_ut The Julian Day number in UT
     * @param ifl To indicate, which ephemeris to be used (SEFLG_JPLEPH,
     * SEFLG_SWIEPH, SEFLG_MOSEPH)
     * @param geopos A double[10], on return containing the geographic positions.
     * @param attr A double[20], on return containing the attributes of the
     * eclipse as above.
     * @param serr A StringBuffer containing a warning or error message, if
     * something fails.
     * @return -1 (SweConst.ERR), if the calculation failed<BR>
     * 0, if there is no solar eclipse at that time<BR>
     * SweConst.SE_ECL_TOTAL<BR>
     * SweConst.SE_ECL_ANNULAR<BR>
     * SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_CENTRAL<BR>
     * SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_NONCENTRAL<BR>
     * SweConst.SE_ECL_ANNULAR | SweConst.SE_ECL_CENTRAL<BR>
     * SweConst.SE_ECL_ANNULAR | SweConst.SE_ECL_NONCENTRAL<BR>
     * SweConst.SE_ECL_PARTIAL<BR>
     * @see SweConst#SE_ECL_TOTAL
     * @see SweConst#SE_ECL_ANNULAR
     * @see SweConst#SE_ECL_CENTRAL
     * @see SweConst#SE_ECL_NONCENTRAL
     * @see SweConst#SE_ECL_PARTIAL
     * @see SweConst#SEFLG_JPLEPH
     * @see SweConst#SEFLG_SWIEPH
     * @see SweConst#SEFLG_MOSEPH
     */
    public int swe_sol_eclipse_where(double tjd_ut, int ifl, double[] geopos,
                                     double[] attr, StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_sol_eclipse_where(tjd_ut, ifl, geopos, attr, serr);
    }


    /* Same declaration as swe_sol_eclipse_when_loc().
     * In addition:
     * int32 ipl          planet number of occulted body
     * char* starname     name of occulted star. Must be NULL or "", if a planetary
     *                    occultation is to be calculated. For the use of this
     *                    field, also see swe_fixstar().
     * int32 ifl        ephemeris flag. If you want to have only one conjunction
     *                    of the moon with the body tested, add the following flag:
     *                    ifl |= SE_ECL_ONE_TRY. If this flag is not set,
     *                    the function will search for an occultation until it
     *                    finds one. For bodies with ecliptical latitudes > 5,
     *                    the function may search successlessly until it reaches
     *                    the end of the ephemeris.
     */
    /**
     * Computes the next eclipse of any planet or fixstar at a given geographical
     * position. Note the uncertainty of Delta T for the remote past and the
     * future.<P>
     * tret is an output parameter with the following meaning:
     * <P><CODE>
     * tret[0]:&nbsp;&nbsp;&nbsp;time of maximum eclipse.<BR>
     * tret[1]:&nbsp;&nbsp;&nbsp;time of first contact.<BR>
     * tret[2]:&nbsp;&nbsp;&nbsp;time of second contact.<BR>
     * tret[3]:&nbsp;&nbsp;&nbsp;time of third contact.<BR>
     * tret[4]:&nbsp;&nbsp;&nbsp;time of forth contact.<BR>
     * tret[5]:&nbsp;&nbsp;&nbsp;time of sun rise between first and forth contact
     * -- <I>Not yet implemented.</I><BR>
     * tret[6]:&nbsp;&nbsp;&nbsp;time of sun set between first and forth contact
     * -- <I>Not yet implemented.</I><BR>
     * </CODE><P>
     * attr is an output parameter with the following meaning:
     * <P><CODE>
     * attr[0]:&nbsp;&nbsp;&nbsp;fraction of solar diameter covered by moon
     * (magnitude).<BR>
     * attr[1]:&nbsp;&nbsp;&nbsp;ratio of lunar diameter to solar one.<BR>
     * attr[2]:&nbsp;&nbsp;&nbsp;fraction of solar disc covered by moon
     * (obscuration).<BR>
     * attr[3]:&nbsp;&nbsp;&nbsp;diameter of core shadow in km.<BR>
     * attr[4]:&nbsp;&nbsp;&nbsp;azimuth of sun at tjd.<BR>
     * attr[5]:&nbsp;&nbsp;&nbsp;true altitude of sun above horizon at tjd.<BR>
     * attr[6]:&nbsp;&nbsp;&nbsp;apparent altitude of sun above horizon at tjd.<BR>
     * attr[7]:&nbsp;&nbsp;&nbsp;elongation of moon in degrees.<BR>
     * </CODE><P><B>Attention: attr must be a double[20]!</B>
     * @param tjd_start The Julian Day number in UT, from when to start searching
     * @param ipl Planet number of the occulted planet. See SE_SUN etc. for the
     * planet numbers.
     * @param starname The name of the fixstar, if looking for an occulted
     * fixstar. This has to be null or an empty StringBuffer, if you are looking
     * for a planet specified in parameter ipl. See routine swe_fixstar() for this
     * parameter.
     * @param ifl To indicate, which ephemeris should be used (SEFLG_JPLEPH,
     * SEFLG_SWIEPH or SEFLG_MOSEPH). Additionally, you can specify SE_ECL_ONE_TRY,
     * to only search for one conjunction of the moon with the planetary body.
     * If this flag is not set, the function will search for an occultation until
     * it finds one. For bodies with ecliptical latitudes > 5, the function may
     * search successlessly until it reaches the end of the ephemeris.
     * @param geopos A double[3] containing the longitude, latitude and
     * height of the geographic position. Eastern longitude and northern
     * latitude is given by positive values, western longitude and southern
     * latitude by negative values.
     * @param tret A double[7], on return containing the times of different
     * occasions of the eclipse as specified above
     * @param attr A double[20], on return containing different attributes of
     * the eclipse. See above.
     * @param backward any value != 0 means, search should be done backwards
     * @param serr A StringBuffer containing a warning or error message, if
     * something fails.
     * @return -1 (SweConst.ERR), if the calculation failed<BR>
     * SweConst.SE_ECL_TOTAL<BR>
     * SweConst.SE_ECL_ANNULAR<BR>
     * SweConst.SE_ECL_PARTIAL<BR>in combination with:<BR>
     * SweConst.SE_ECL_VISIBLE<BR>
     * SweConst.SE_ECL_MAX_VISIBLE<BR>
     * SweConst.SE_ECL_1ST_VISIBLE<BR>
     * SweConst.SE_ECL_2ND_VISIBLE<BR>
     * SweConst.SE_ECL_3RD_VISIBLE<BR>
     * SweConst.SE_ECL_4TH_VISIBLE
     * @see #swe_fixstar_ut(StringBuffer, double, int, double[], StringBuffer)
     * @see SweConst#SE_ECL_ONE_TRY
     * @see SweConst#SE_ECL_TOTAL
     * @see SweConst#SE_ECL_ANNULAR
     * @see SweConst#SE_ECL_PARTIAL
     * @see SweConst#SE_ECL_VISIBLE
     * @see SweConst#SE_ECL_MAX_VISIBLE
     * @see SweConst#SE_ECL_1ST_VISIBLE
     * @see SweConst#SE_ECL_2ND_VISIBLE
     * @see SweConst#SE_ECL_3RD_VISIBLE
     * @see SweConst#SE_ECL_4TH_VISIBLE
     * @see SweConst#SE_ECL_ONE_TRY
     * @see SweConst#SEFLG_JPLEPH
     * @see SweConst#SEFLG_SWIEPH
     * @see SweConst#SEFLG_MOSEPH
     */
    public int swe_lun_occult_when_loc(double tjd_start, int ipl, StringBuffer starname, int ifl,
                                       double[] geopos, double[] tret, double[] attr, int backward, StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_lun_occult_when_loc(tjd_start, ipl, starname, ifl, geopos, tret, attr, backward, serr);
    }

    /**
     * Computes the geographic location for a given time, where a planet
     * occultation by the moon is central or maximum for a non-central
     * occultation.
     * @param tjd_ut The Julian Day number in UT
     * @param ipl The planet, whose occultation by the moon should be searched.
     * @param starname The fixstar, whose occultation by the moon should be
     * searched. See swe_fixstar() for details. It has to be null or the empty
     * string, if a planet (see parameter ipl) is to be searched.
     * @param ifl To indicate, which ephemeris to be used (SEFLG_JPLEPH,
     * SEFLG_SWIEPH, SEFLG_MOSEPH)
     * @param geopos A double[10], on return containing the geographic positions.
     * @param attr A double[20], on return containing the attributes of the
     * eclipse as above.
     * @param serr A StringBuffer containing a warning or error message, if
     * something fails.
     * @return -1 (SweConst.ERR), if the calculation failed<BR>
     * 0, if there is no solar eclipse at that time<BR>
     * @see #swe_sol_eclipse_where(double, int, double[], double[], java.lang.StringBuffer)
     * @see #swe_fixstar_ut(StringBuffer, double, int, double[], StringBuffer)
     */
    public int swe_lun_occult_where(double tjd_ut,
                                    int ipl,
                                    StringBuffer starname,
                                    int ifl,
                                    double[] geopos,
                                    double[] attr,
                                    StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_lun_occult_where(tjd_ut, ipl, starname, ifl, geopos, attr, serr);
    }


    /* When is the next lunar occultation anywhere on earth?
     * This function also finds solar eclipses, but is less efficient
     * than swe_sol_eclipse_when_glob().
     *
     * input parameters:
     *
     * tjd_start          start time for search (UT)
     * ipl                planet number of occulted body
     * starname           name of occulted star. Must be NULL or "", if a planetary
     *                    occultation is to be calculated. For the use of this
     *                    field, also see swe_fixstar().
     * ifl                      ephemeris to be used (SEFLG_SWIEPH, etc.)
     *                  ephemeris flag. If you want to have only one conjunction
     *                    of the moon with the body tested, add the following flag:
     *                    ifl |= SE_ECL_ONE_TRY. If this flag is not set,
     *                    the function will search for an occultation until it
     *                    finds one. For bodies with ecliptical latitudes > 5,
     *                    the function may search successlessly until it reaches
     *                    the end of the ephemeris.
     *
     * ifltype          eclipse type to be searched (SE_ECL_TOTAL, etc.)
     *                    0, if any type of eclipse is wanted
     *                    this functionality also works with occultations
     *
     * return values:
     *
     * retflag    SE_ECL_TOTAL or SE_ECL_ANNULAR or SE_ECL_PARTIAL
     *              or SE_ECL_ANNULAR_TOTAL
     *              SE_ECL_CENTRAL
     *              SE_ECL_NONCENTRAL
     *
     * tret[0]    time of maximum eclipse
     * tret[1]    time, when eclipse takes place at local apparent noon
     * tret[2]    time of eclipse begin
     * tret[3]    time of eclipse end
     * tret[4]    time of totality begin
     * tret[5]    time of totality end
     * tret[6]    time of center line begin
     * tret[7]    time of center line end
     * tret[8]    time when annular-total eclipse becomes total
     *               not implemented so far
     * tret[9]    time when annular-total eclipse becomes annular again
     *               not implemented so far
     *         declare as tret[10] at least!
     *
     */
    /**
     * Computes the next lunar occultation anywhere on earth.
     * This method also finds solar eclipses, but is less efficient
     * than swe_sol_eclipse_when_glob().
     * <P>tret is an output parameter with the following meaning:
     * <P><CODE>
     * tret[0]:&nbsp;&nbsp;&nbsp;time of maximum eclipse.<BR>
     * tret[1]:&nbsp;&nbsp;&nbsp;time, when the eclipse takes place at local
     * apparent noon.<BR><BLOCKQUOTE>
     * tret[2]:&nbsp;&nbsp;&nbsp;time of the begin of the eclipse.<BR>
     * tret[3]:&nbsp;&nbsp;&nbsp;time of the end of the eclipse.<BR>
     * tret[4]:&nbsp;&nbsp;&nbsp;time of the begin of totality.<BR>
     * tret[5]:&nbsp;&nbsp;&nbsp;time of the end of totality.<BR>
     * tret[6]:&nbsp;&nbsp;&nbsp;time of the begin of center line.<BR>
     * tret[7]:&nbsp;&nbsp;&nbsp;time of the end of center line<BR>
     * tret[8]:&nbsp;&nbsp;&nbsp;time, when annular-total eclipse becomes total --
     * <I>Not yet implemented.</I><BR>
     * tret[9]:&nbsp;&nbsp;&nbsp;time, when annular-total eclipse becomes annular
     * again -- <I>Not yet implemented.</I>
     * </BLOCKQUOTE></CODE><P><B>Attention: tret must be a double[10]!</B>
     * @param tjd_start The Julian Day number in UT, from when to start searching
     * @param ipl planet number of occulted body
     * @param starname name of occulted star. Must be null or &quot;&quot;, if
     * a planetary occultation is to be calculated. For the use of this
     * field, also see swe_fixstar().
     * @param ifl To indicate, which ephemeris should be used (SEFLG_JPLEPH,
     * SEFLG_SWIEPH or SEFLG_MOSEPH). If you want to have only one conjunction
     * of the moon with the body tested, add flag SE_ECL_ONE_TRY. If this flag
     * is not set, the function will search for an occultation until it
     * finds one. For bodies with ecliptical latitudes > 5, the function may
     * search successlessly until it reaches the end of the ephemeris.
     * @param ifltype eclipse type to be searched (SE_ECL_TOTAL, etc.).
     * 0, if any type of eclipse is wanted. This functionality also works
     * with occultations.
     * @param tret A double[10], on return containing the times of different
     * occasions of the eclipse as above
     * @param backward if != 0, search is done backwards
     * @param serr A StringBuffer containing a warning or error message, if
     * something fails.
     * @return -1 (SweConst.ERR), if the calculation failed<BR>
     * SweConst.SE_ECL_TOTAL<BR>
     * SweConst.SE_ECL_ANNULAR<BR>
     * SweConst.SE_ECL_PARTIAL<BR>
     * SweConst.SE_ECL_ANNULAR_TOTAL<BR>in combination with:<BR>
     * SweConst.SE_ECL_CENTRAL<BR>
     * SweConst.SE_ECL_NONCENTRAL
     * @see #swe_sol_eclipse_when_glob(double, int, int, double[], int, java.lang.StringBuffer)
     * @see #swe_fixstar_ut(StringBuffer, double, int, double[], StringBuffer)
     * @see SweConst#SE_ECL_ONE_TRY
     * @see SweConst#SE_ECL_TOTAL
     * @see SweConst#SE_ECL_ANNULAR
     * @see SweConst#SE_ECL_PARTIAL
     * @see SweConst#SE_ECL_ANNULAR_TOTAL
     * @see SweConst#SE_ECL_CENTRAL
     * @see SweConst#SE_ECL_NONCENTRAL
     * @see SweConst#SEFLG_JPLEPH
     * @see SweConst#SEFLG_SWIEPH
     * @see SweConst#SEFLG_MOSEPH
     */
    public int swe_lun_occult_when_glob(
                                        double tjd_start, int ipl, StringBuffer starname, int ifl, int ifltype,
                                        double[] tret, int backward, StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_lun_occult_when_glob(tjd_start, ipl, starname, ifl, ifltype, tret, backward, serr);
    }

    /* function finds the gauquelin sector position of a planet or fixed star
     * 
     * if starname != NULL then a star is computed.
     * iflag: use the flags SE_SWIEPH, SE_JPLEPH, SE_MOSEPH, SEFLG_TOPOCTR.
     *
     * imeth defines method:
     *           imeth = 0                  sector from longitude and latitude
     *           imeth = 1                  sector from longitude, with lat = 0
     *           imeth = 2                  sector from rise and set
     *           imeth = 3                  sector from rise and set with refraction
     * rise and set are defined as appearance and disappearance of disc center.
     *
     * geopos is an array of 3 doubles for geo. longitude, geo. latitude, elevation.
     * atpress and attemp are only needed for imeth = 3. If imeth = 3,
     * If imeth=3 and atpress not given (= 0), the programm assumes 1013.25 mbar;
     * if a non-zero height above sea is given in geopos, atpress is estimated.
     * dgsect is return area (pointer to a double)
     * serr is pointer to error string, may be NULL
     */
    /**
     * Finds the gauquelin sector position of a planet or fixed star.
     * @param t_ut Time in UT.
     * @param ipl Planet number.
     * @param starname If starname != null and not an empty string, then a
     * fixstar is computed and not a planet specified in ipl. See swe_fixstar()
     * method on this.
     * @param iflag Use the flags SE_SWIEPH, SE_JPLEPH, SE_MOSEPH, SEFLG_TOPOCTR.
     * @param imeth defines the method.<br>
     * <blockquote>
     * imeth = 0: sector from longitude and latitude<br>
     * imeth = 1: sector from longitude, with lat = 0<br>
     * imeth = 2: sector from rise and set<br>
     * imeth = 3: sector from rise and set with refraction<br>
     * </blockquote>
     * Rise and set are defined as appearance and disappearance of disc center.
     * @param geopos An array of 3 doubles for geo. longitude, geo. latitude, elevation in meter.
     * @param atpress Only needed for imeth = 3.
     * If imeth=3 and atpress not given (= 0), the programm assumes 1013.25 mbar;
     * if a non-zero height above sea is given in geopos, atpress is estimated.
     * @param attemp Temperature. Only needed for imeth = 3.
     * @param dgsect Return value.
     * @param serr Pointer to error string, may be null.
     * @return SweConst.OK (0) or SweConst.ERR (-1) on error.
     * @see #swe_fixstar_ut(StringBuffer, double, int, double[], StringBuffer)
     * @see SweConst#SEFLG_TOPOCTR
     * @see SweConst#SEFLG_JPLEPH
     * @see SweConst#SEFLG_SWIEPH
     * @see SweConst#SEFLG_MOSEPH
     */
    public int swe_gauquelin_sector(double t_ut, int ipl, StringBuffer starname, int iflag, int imeth, double[] geopos, double atpress, double attemp, DblObj dgsect, StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_gauquelin_sector(t_ut, ipl, starname, iflag, imeth, geopos, atpress, attemp, dgsect, serr);
    }
    ////////////////////////////////////////////////////////////////////////////
    // Methods from SweHouse.java: /////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    /**
     * The function returns a value between 1.0 and 12.999999, indicating in
     * which house a planet is and how far from its cusp it is. With Koch houses,
     * the function sometimes returns 0, if the computation was not possible.
     * @param armc The ARMC (= sidereal time)
     * @param geolat The latitude
     * @param eps The ecliptic obliquity (e.g. xx[0] of swe_calc(...))
     * @param hsys The house system. See swe_houses(...) for a list of all
     * houses.
     * @param xpin A double[2] containing the ecliptic longitude and latitude of
     * the planet in degrees. It is an input parameter, describing tropical positions.
     * @param serr StringBuffer to contain any error messages or warnings
     * @return A value between 1.0 and 12.999999, indicating in which house a
     * planet is and how far from its cusp it is. Koch may return 0, if the
     * calculation was not possible.
     * @see #swe_houses(double, int, double, double, int, double[], double[])
     */
    public double swe_house_pos(double armc, double geolat, double eps,
                                int hsys, double xpin[], StringBuffer serr) {
        if (sh==null) {
            sh=new SweHouse(sl, this, swed);
        }
        return sh.swe_house_pos(armc, geolat, eps, hsys, xpin, serr);
    }


    /**
     * Calculates the house positions and other vital points. You would use
     * this method instead of swe_houses, if you do not have a date available,
     * but just the ARMC (sidereal time).
     * @param armc The ARMC (= sidereal time)
     * @param geolat The latitude on earth, for which the calculation has to be
     * done.
     * @param eps The ecliptic obliquity (e.g. xx[0] of swe_calc(...))
     * @param hsys The house system as a character given as an integer. See
     * swe_houses(...) for a list of all houses.
     * @param cusp The house cusps are returned here in cusp[1...12] for
     * the house 1 to 12.
     * @param ascmc The special points like ascendent etc. are returned here.
     * See swe_houses(...) for further info on this parameter.
     * @see SwissEph#swe_houses(double, int, double, double, int, double[], double[])
     * @see SwissEph#swe_calc
     * @return SweConst.OK (==0) or SweConst.ERR (==-1), if calculation was not
     * possible due to nearness to the polar circle in Koch or Placidus house system
     * or when requesting Gauquelin sectors. Calculation automatically switched to
     * Porphyry house calculation method in this case, so that valid houses will be
     * returned anyway, just in a different house system than requested.
     */
    public int swe_houses_armc(double armc, double geolat, double eps,
                               int hsys, double[] cusp, double[] ascmc) {
        if (sh==null) {
            sh=new SweHouse(sl, this, swed);
        }
        return sh.swe_houses_armc(armc, geolat, eps, hsys, cusp, ascmc, 0);
    }


    /**
     * Calculates the house positions and other vital points. The possible
     * house systems are:<P><CODE><BLOCKQUOTE>
     * (int)'P'&nbsp;&nbsp;Placidus<BR>
     * (int)'K'&nbsp;&nbsp;Koch<BR>
     * (int)'O'&nbsp;&nbsp;Porphyrius<BR>
     * (int)'R'&nbsp;&nbsp;Regiomontanus<BR>
     * (int)'C'&nbsp;&nbsp;Campanus<BR>
     * (int)'A'&nbsp;&nbsp;equal (cusp 1 is ascendent)<BR>
     * (int)'E'&nbsp;&nbsp;equal (cusp 1 is ascendent)<BR>
     * (int)'V'&nbsp;&nbsp;Vehlow equal (asc. in middle of house 1)<BR>
     * (int)'X'&nbsp;&nbsp;axial rotation system/ Meridian houses<BR>
     * (int)'H'&nbsp;&nbsp;azimuthal or horizontal system<BR>
     * (int)'T'&nbsp;&nbsp;Polich/Page ('topocentric' system)<BR>
     * (int)'B'&nbsp;&nbsp;Alcabitius
     * </BLOCKQUOTE></CODE><P>
     *
     * As Koch and Placidus don't work in the polar circle, the
     * calculation is done in that case by swapping MC/IC so that MC is
     * always before AC in the zodiac. Then the quadrants are divided into
     * 3 equal parts.<P>
     * The parameter ascmc is defined as double[10] and will return the
     * following points:<P><CODE><BLOCKQUOTE>
     * ascmc[0] = ascendant<BR>
     * ascmc[1] = mc<BR>
     * ascmc[2] = armc (= sidereal time)<BR>
     * ascmc[3] = vertex<BR>
     * ascmc[4] = equatorial ascendant<BR>
     * ascmc[5] = co-ascendant (Walter Koch)<BR>
     * ascmc[6] = co-ascendant (Michael Munkasey)<BR>
     * ascmc[7] = polar ascendant (Michael Munkasey)<BR>
     * ascmc[8] = reserved for future use<BR>
     * ascmc[9] = reserved for future use
     *  </BLOCKQUOTE></CODE>
     * You can use the SE_ constants below from SweConst.java to access
     * these values in ascmc[].<p>
     * @param tjd_ut The Julian Day number in UT
     * @param iflag An additional flag for calculation. It must be 0 or
     * SEFLG_SIDEREAL and / or SEFLG_RADIANS.
     * @param geolat The latitude on earth, for which the calculation has to be
     * done.
     * @param geolon The longitude on earth, for which the calculation has to be
     * done. Eastern longitude and northern latitude is given by positive values,
     * western longitude and southern latitude by negative values.
     * @param hsys The house system as a character given as an integer.
     * @param cusp (double[13]) The house cusps are returned here in
     * cusp[1...12] for the houses 1 to 12.
     * @param ascmc (double[10]) The special points like ascendent etc. are
     * returned here. See the list above.
     * @return SweConst.OK (==0) or SweConst.ERR (==-1), if calculation was not
     * possible due to nearness to the polar circle in Koch or Placidus house system
     * or when requesting Gauquelin sectors. Calculation automatically switched to
     * Porphyry house calculation method in this case, so that valid houses will be
     * returned anyway, just in a different house system than requested.
     * @see SwissEph#swe_set_sid_mode(int, double, double)
     * @see SweConst#SEFLG_RADIANS
     * @see SweConst#SEFLG_SIDEREAL
     */  
    public int swe_houses(double tjd_ut, int iflag, double geolat,
                          double geolon, int hsys, double[] cusp,
                          double[] ascmc) {
        return swe_houses(tjd_ut, iflag, geolat, geolon, hsys, cusp, ascmc, 0);
    }
    public int swe_houses(double tjd_ut, int iflag, double geolat,
                          double geolon, int hsys, double[] cusp,
                          double[] ascmc, int aOffs) {
        if (sh==null) {
            sh=new SweHouse(sl, this, swed);
        }
        return sh.swe_houses(tjd_ut, iflag, geolat, geolon, hsys, cusp, ascmc, aOffs);
    }


    /**
     * Searches for the next or previous transit of a planet over a specified
     * longitude, latitude, distance or speed value with geocentric or topocentric
     * positions in a tropical or sidereal zodiac. Dates are interpreted as ET
     * (=UT&nbsp;+&nbsp;deltaT).<p>
     *
     * @param tc The TransitCalculator that should be used here.
     * @param jdET The date (and time) in ET, from where to start searching.
     * @param backwards If backward search should be performed.
     * @return return A double containing the julian day number for the next /
     * previous transit as ET.
     * @see swisseph.TCPlanet#TCPlanet(SwissEph, int, int, double)
     * @see swisseph.TCPlanetPlanet#TCPlanetPlanet(SwissEph, int, int, int, double)
     */
    public double getTransitET(TransitCalculator tc, double jdET, boolean backwards)
        throws IllegalArgumentException, SwissephException {
        return getTransitET(tc,
                            jdET,
                            backwards,
                            (backwards?-Double.MAX_VALUE:Double.MAX_VALUE));
    }
    /**
     * Searches for the next or previous transit of a planet over a specified
     * longitude, latitude, distance or speed value with geocentric or topocentric
     * positions in a tropical or sidereal zodiac. Dates are interpreted as ET
     * (=UT&nbsp;+&nbsp;deltaT).<p>
     *
     * @param tc The TransitCalculator that should be used here.
     * @param jdET The date (and time) in ET, from where to start searching.
     * @param backwards If backward search should be performed.
     * @param jdLimit This is the date, when the search for transits should be
     * stopped, even if no transit point had been found up to then.
     * @return return A double containing the julian day number for the next /
     * previous transit as ET.
     * @see swisseph.TCPlanet#TCPlanet(SwissEph, int, int, double)
     * @see swisseph.TCPlanetPlanet#TCPlanetPlanet(SwissEph, int, int, int, double)
     */
    public double getTransitET(TransitCalculator tc, double jdET, boolean backwards, double jdLimit)
        throws IllegalArgumentException, SwissephException {
        if (ext==null) { ext=new Extensions(this); }
        return ext.getTransit(tc, jdET, backwards, jdLimit);
    }
    /**
     * Searches for the next or previous transit of a planet over a specified
     * longitude, latitude, distance or speed value with geocentric or topocentric
     * positions in a tropical or sidereal zodiac. Dates are interpreted as UT
     * (=ET&nbsp;-&nbsp;deltaT).<p>
     *
     * @param tc The TransitCalculator that should be used here.
     * @param jdUT The date (and time) in UT, from where to start searching.
     * @param backwards If backward search should be performed.
     * @return return A double containing the julian day number for the next /
     * previous transit as UT.
     * @see swisseph.TCPlanet#TCPlanet(SwissEph, int, int, double)
     * @see swisseph.TCPlanetPlanet#TCPlanetPlanet(SwissEph, int, int, int, double)
     */
    public double getTransitUT(
                               TransitCalculator tc,
                               double jdUT,
                               boolean backwards)
        throws IllegalArgumentException, SwissephException {
        if (ext==null) { ext=new Extensions(this); }
        double jdET = ext.getTransit(
                                     tc,
                                     jdUT + SweDate.getDeltaT(jdUT),
                                     backwards,
                                     (backwards?-Double.MAX_VALUE:Double.MAX_VALUE));
        return jdET - SweDate.getDeltaT(jdET);
    }
    /**
     * Searches for the next or previous transit of a planet over a specified
     * longitude, latitude, distance or speed value with geocentric or topocentric
     * positions in a tropical or sidereal zodiac. Dates are interpreted as UT
     * (=ET&nbsp;-&nbsp;deltaT).<p>
     *
     * @param tc The TransitCalculator that should be used here.
     * @param jdUT The date (and time) in UT, from where to start searching.
     * @param backwards If backward search should be performed.
     * @param jdLimit This is the date, when the search for transits should be
     * stopped, even if no transit point had been found up to then. It is
     * interpreted as UT time as well.
     * @return return A double containing the julian day number for the next /
     * previous transit as UT.
     * @see swisseph.TCPlanet#TCPlanet(SwissEph, int, int, double)
     * @see swisseph.TCPlanetPlanet#TCPlanetPlanet(SwissEph, int, int, int, double)
     */
    public double getTransitUT(
                               TransitCalculator tc,
                               double jdUT,
                               boolean backwards,
                               double jdLimit)
        throws IllegalArgumentException, SwissephException {
        if (ext==null) { ext=new Extensions(this); }
        double jdET = ext.getTransit(
                                     tc,
                                     jdUT + SweDate.getDeltaT(jdUT),
                                     backwards,
                                     jdLimit + SweDate.getDeltaT(jdLimit));
        return jdET - SweDate.getDeltaT(jdET);
    }
    //////////////////////////////////////////////////////////////////////////////
    // End of public methods /////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////
    private int swe_calc_error(double[] xx) {
        for (int i = 0; i < xx.length; i++) {
            xx[i] = 0;
        }
        return SweConst.ERR;
    }


    int swecalc(double tjd, int ipl, int iflag, double[] x, StringBuffer serr) 
        throws SwissephException {
        int i;
        int ipli, ipli_ast, ifno;
        int retc;
        int epheflag = SweConst.SEFLG_DEFAULTEPH;
        PlanData pdp;
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        PlanData ndp;
        double xp[], xp2[];
        double ss[]=new double[3];
        String serr2="";

        if (serr!=null) { serr.setLength(0); }
        /******************************************
         * iflag plausible?                       *
         ******************************************/
        iflag = plaus_iflag(iflag);
        /******************************************
         * which ephemeris is wanted, which is used?
         * Three ephemerides are possible: MOSEPH, SWIEPH, JPLEPH.
         * JPLEPH is best, SWIEPH is nearly as good, MOSEPH is least precise.
         * The availability of the various ephemerides depends on the installed
         * ephemeris files in the users ephemeris directory. This can change at
         * any time.
         * Swisseph should try to fulfil the wish of the user for a specific
         * ephemeris, but use a less precise one if the desired ephemeris is not
         * available for the given date and body.
         * If internal ephemeris errors are detected (data error, file length error)
         * an error is returned.
         * If the time range is bad but another ephemeris can deliver this range,
         * the other ephemeris is used.
         * If no ephemeris is specified, DEFAULTEPH is assumed as desired.
         * DEFAULTEPH is defined at compile time, usually as JPLEPH.
         * The caller learns from the return flag which ephemeris was used.
         * ephe_flag is extracted from iflag, but can change later if the
         * desired ephe is not available.
         ******************************************/
        if ((iflag & SweConst.SEFLG_MOSEPH)!=0) {
            epheflag = SweConst.SEFLG_MOSEPH;
        }
        if ((iflag & SweConst.SEFLG_SWIEPH)!=0) {
            epheflag = SweConst.SEFLG_SWIEPH;
        }
        if ((iflag & SweConst.SEFLG_JPLEPH)!=0) {
            epheflag = SweConst.SEFLG_JPLEPH;
        }
        /* no barycentric calculations with Moshier ephemeris */
        if (((iflag & SweConst.SEFLG_BARYCTR)!=0) &&
            ((iflag & SweConst.SEFLG_MOSEPH)!=0)) {
            if (serr != null) {
                serr.append("barycentric Moshier positions are not supported.");
            }
            throw new SwissephException(tjd, SwissephException.INVALID_PARAMETER_COMBINATION,
                                        SweConst.ERR, serr);
        }
        if (epheflag != SweConst.SEFLG_MOSEPH && !swed.ephe_path_is_set) {
            swe_set_ephe_path(null);
        }
        if ((iflag & SweConst.SEFLG_SIDEREAL)!=0 && !swed.ayana_is_set) {
            swe_set_sid_mode(SweConst.SE_SIDM_FAGAN_BRADLEY, 0, 0);
        }
        /******************************************
         * obliquity of ecliptic 2000 and of date *
         ******************************************/
        swi_check_ecliptic(tjd);
        /******************************************
         * nutation                               *
         ******************************************/
        swi_check_nutation(tjd, iflag);
        /******************************************
         * select planet and ephemeris            *
         *                                        *
         * ecliptic and nutation                  *
         ******************************************/
        if (ipl == SweConst.SE_ECL_NUT) {
            x[0] = swed.oec.eps + swed.nut.nutlo[1];	/* true ecliptic */
            x[1] = swed.oec.eps;			/* mean ecliptic */
            x[2] = swed.nut.nutlo[0];		/* nutation in longitude */
            x[3] = swed.nut.nutlo[1];		/* nutation in obliquity */
            /*if ((iflag & SweConst.SEFLG_RADIANS) == 0)*/
            for (i = 0; i <= 3; i++)
                x[i] *= SwissData.RADTODEG;
            return(iflag);
            /******************************************
             * moon                                   *
             ******************************************/
        } else if (ipl == SweConst.SE_MOON) {
            /* internal planet number */
            ipli = SwephData.SEI_MOON;
            pdp = swed.pldat[ipli];
            xp = pdp.xreturn;
            switch(epheflag) {
                case SweConst.SEFLG_JPLEPH:
                    retc = jplplan(tjd, ipli, iflag, SwephData.DO_SAVE, null,null,null, serr);
                    /* read error or corrupt file */
                    if (retc == SweConst.ERR) {
                        swecalc_error(x);
                        throw new SwissephException(tjd, SwissephException.DATA_FILE_ERROR,
                                                    SweConst.ERR, serr);
                    }
                    /* jpl ephemeris not on disk or date beyond ephemeris range
                     *     or file corrupt */
                    if (retc == SwephData.NOT_AVAILABLE) {
                        iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_SWIEPH;
                        if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                            serr.append(" \ntrying Swiss Eph; ");
                        }
                        retc =  sweph_moon(tjd, ipli, iflag, serr);
                        if (retc == SweConst.ERR) {
                            return swecalc_error(x);
                        }
                    } else if (retc == SwephData.BEYOND_EPH_LIMITS) {
                        if (tjd > SwephData.MOSHLUEPH_START &&
                            tjd < SwephData.MOSHLUEPH_END) {
                            iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_MOSEPH;
                            if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                                serr.append(" \nusing Moshier Eph; ");
                            }
                            //              goto moshier_moon;
                            retc = moshier_moon(tjd, SwephData.DO_SAVE, null, serr);
                            if (retc == SweConst.ERR) {
                                return swecalc_error(x);
                            }
                        } else
                            return swecalc_error(x);
                    }
                    break;
                case SweConst.SEFLG_SWIEPH:
                    retc =  sweph_moon(tjd, ipli,iflag, serr);
                    if (retc == SweConst.ERR) {
                        return swecalc_error(x);
                    }
                    break;
                case SweConst.SEFLG_MOSEPH:
                    //          moshier_moon:
                    retc = moshier_moon(tjd, SwephData.DO_SAVE, null, serr);
                    if (retc == SweConst.ERR) {
                        return swecalc_error(x);
                    }
                    break;
                default:
                    break;
            }
            /* heliocentric, lighttime etc. */
            if ((retc = app_pos_etc_moon(iflag, serr))!=SweConst.OK) {
                return swecalc_error(x); // retc may be wrong with sidereal calculation
            }
            /**********************************************
             * barycentric sun                            *
             * (only JPL and SWISSEPH ephemerises)        *
             **********************************************/
        } else if (ipl == SweConst.SE_SUN &&
                   ((iflag & SweConst.SEFLG_BARYCTR)!=0)) {
            /* barycentric sun must be handled separately because of
             * the following reasons:
             * ordinary planetary computations use the function
             * main_planet() and its subfunction jplplan(),
             * see further below.
             * now, these functions need the swisseph internal
             * planetary indices, where SEI_EARTH = SEI_SUN = 0.
             * therefore they don't know the difference between
             * a barycentric sun and a barycentric earth and
             * always return barycentric earth.
             * to avoid this problem, many functions would have to
             * be changed. as an alternative, we choose a more
             * separate handling. */
            ipli = SwephData.SEI_SUN;	/* = SEI_EARTH ! */
            xp = pedp.xreturn;

            switch (epheflag) {
                case SweConst.SEFLG_JPLEPH:
                    /* open ephemeris, if still closed */
                    if (!swed.jpl_file_is_open) {
                        retc = sj.swi_open_jpl_file(ss, swed.jplfnam, swed.ephepath, serr);
                        swed.jpldenum = sj.swi_get_jpl_denum();
                        if (retc != SweConst.OK) {
                            retc = sweph_sbar(tjd, iflag, psdp, pedp, serr);
                        }
                        if (retc == SweConst.ERR) {
                            return swecalc_error(x);
                        }
                        swed.jpl_file_is_open = true;
                    }
                    retc = sj.swi_pleph(tjd, SwephJPL.J_SUN, SwephJPL.J_SBARY, psdp.x, serr);
                    if (retc == SweConst.ERR || retc == SwephData.BEYOND_EPH_LIMITS) {
                        sj.swi_close_jpl_file();
                        swed.jpl_file_is_open = false;
                        return swecalc_error(x);
                    }
                    /* jpl ephemeris not on disk or date beyond ephemeris range
                     *     or file corrupt */
                    if (retc == SwephData.NOT_AVAILABLE) {
                        iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_SWIEPH;
                        if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                            serr.append(" \ntrying Swiss Eph; ");
                        }
                        retc = sweph_sbar(tjd, iflag, psdp, pedp, serr);
                        if (retc == SweConst.ERR) {
                            return swecalc_error(x);
                        }
                    }
                    psdp.teval = tjd;
                    break;
                case SweConst.SEFLG_SWIEPH:
                    retc = sweph_sbar(tjd, iflag, psdp, pedp, serr);
                    if (retc == SweConst.ERR) {
                        return swecalc_error(x);
                    }
                    break;
                default:
                    return SweConst.ERR;
            }
            /* flags */
            if ((retc = app_pos_etc_sbar(iflag, serr)) != SweConst.OK) {
                return swecalc_error(x);
            }
            /* iflag has possibly changed */
            iflag = pedp.xflgs;
            /* barycentric sun is now in save area of barycentric earth.
             * (pedp->xreturn = swed.pldat[SEI_EARTH].xreturn).
             * in case a barycentric earth computation follows for the same
             * date, the planetary functions will return the barycentric
             * SUN unless we force a new computation of pedp->xreturn.
             * this can be done by initializing the save of iflag.
             */
            pedp.xflgs = -1;
            /******************************************
             * mercury - pluto                        *
             ******************************************/
        } else if (ipl == SweConst.SE_SUN 	/* main planet */
                   || ipl == SweConst.SE_MERCURY
                   || ipl == SweConst.SE_VENUS
                   || ipl == SweConst.SE_MARS
                   || ipl == SweConst.SE_JUPITER
                   || ipl == SweConst.SE_SATURN
                   || ipl == SweConst.SE_URANUS
                   || ipl == SweConst.SE_NEPTUNE
                   || ipl == SweConst.SE_PLUTO
                   || ipl == SweConst.SE_EARTH) {
            if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
                if (ipl == SweConst.SE_SUN) {
                    /* heliocentric position of Sun does not exist */
                    for (i = 0; i < 24; i++) {
                        x[i] = 0;
                    }
                    return iflag;
                }
            } else if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
                // NOOP
            } else {		/* geocentric */
                if (ipl == SweConst.SE_EARTH) {
                    /* geocentric position of Earth does not exist */
                    for (i = 0; i < 24; i++) {
                        x[i] = 0;
                    }
                    return iflag;
                }
            }
            /* internal planet number */
            ipli = SwissData.pnoext2int[ipl];
            pdp = swed.pldat[ipli];
            xp = pdp.xreturn;
            retc = main_planet(tjd, ipli, epheflag, iflag, serr);
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            /* iflag has possibly changed in main_planet() */
            iflag = pdp.xflgs;
            /**********************************************
             * mean lunar node                            *
             * for comment s. moshmoon.c, swi_mean_node() *
             **********************************************/
        } else if (ipl == SweConst.SE_MEAN_NODE) {
            if (((iflag & SweConst.SEFLG_HELCTR)!=0) ||
                ((iflag & SweConst.SEFLG_BARYCTR)!=0)) {
                /* heliocentric/barycentric lunar node not allowed */
                for (i = 0; i < 24; i++) {
                    x[i] = 0;
                }
                return iflag;
            }
            ndp = swed.nddat[SwephData.SEI_MEAN_NODE];
            xp = ndp.xreturn;
            xp2 = ndp.x;
            retc = sm.swi_mean_node(tjd, xp2, serr);
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            /* speed (is almost constant; variation < 0.001 arcsec) */
            retc = sm.swi_mean_node(tjd - SwephData.MEAN_NODE_SPEED_INTV, xp2, 3, serr);
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            xp2[3] = sl.swe_difrad2n(xp2[0], xp2[3]) / SwephData.MEAN_NODE_SPEED_INTV;
            xp2[4] = xp2[5] = 0;
            ndp.teval = tjd;
            ndp.xflgs = -1;
            /* lighttime etc. */
            retc = app_pos_etc_mean(SwephData.SEI_MEAN_NODE, iflag, serr);
            if (retc != SweConst.OK) {
                return swecalc_error(x);
            }
            /* to avoid infinitesimal deviations from latitude = 0
             * that result from conversions */
            if ((iflag & SweConst.SEFLG_SIDEREAL)==0 &&
                (iflag & SweConst.SEFLG_J2000)==0) {
                ndp.xreturn[1] = 0.0;	/* ecl. latitude       */
                ndp.xreturn[4] = 0.0;	/*               speed */
                ndp.xreturn[5] = 0.0;	/*      radial   speed */
                ndp.xreturn[8] = 0.0;	/* z coordinate        */
                ndp.xreturn[11] = 0.0;	/*               speed */
            }
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            /**********************************************
             * mean lunar apogee ('dark moon', 'lilith')  *
             * for comment s. moshmoon.c, swi_mean_apog() *
             **********************************************/
        } else if (ipl == SweConst.SE_MEAN_APOG) {
            if (((iflag & SweConst.SEFLG_HELCTR)!=0) ||
                ((iflag & SweConst.SEFLG_BARYCTR)!=0)) {
                /* heliocentric/barycentric lunar apogee not allowed */
                for (i = 0; i < 24; i++) {
                    x[i] = 0;
                }
                return iflag;
            }
            ndp = swed.nddat[SwephData.SEI_MEAN_APOG];
            xp = ndp.xreturn;
            xp2 = ndp.x;
            retc = sm.swi_mean_apog(tjd, xp2, serr);
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            /* speed (is not constant! variation ~= several arcsec) */
            retc = sm.swi_mean_apog(tjd - SwephData.MEAN_NODE_SPEED_INTV, xp2, 3, serr);
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            for(i = 0; i <= 1; i++) {
                xp2[3+i] = sl.swe_difrad2n(xp2[i], xp2[3+i]) / SwephData.MEAN_NODE_SPEED_INTV;
            }
            xp2[5] = 0;
            ndp.teval = tjd;
            ndp.xflgs = -1;
            /* lighttime etc. */
            if ((retc = app_pos_etc_mean(SwephData.SEI_MEAN_APOG, iflag, serr)) !=
                SweConst.OK) {
                return swecalc_error(x);
            }
            /* to avoid infinitesimal deviations from r-speed = 0
             * that result from conversions */
            ndp.xreturn[5] = 0.0;	/*               speed */
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            /***********************************************
             * osculating lunar node ('true node')         *
             ***********************************************/
        } else if (ipl == SweConst.SE_TRUE_NODE) {
            if (((iflag & SweConst.SEFLG_HELCTR)!=0) ||
                ((iflag & SweConst.SEFLG_BARYCTR)!=0)) {
                /* heliocentric/barycentric lunar node not allowed */
                for (i = 0; i < 24; i++) {
                    x[i] = 0;
                }
                return iflag;
            }
            ndp = swed.nddat[SwephData.SEI_TRUE_NODE];
            xp = ndp.xreturn;
            retc = lunar_osc_elem(tjd, SwephData.SEI_TRUE_NODE, iflag, serr);
            iflag = ndp.xflgs;
            /* to avoid infinitesimal deviations from latitude = 0
             * that result from conversions */
            if ((iflag & SweConst.SEFLG_SIDEREAL)==0 &&
                (iflag & SweConst.SEFLG_J2000)==0) {
                ndp.xreturn[1] = 0.0;	/* ecl. latitude       */
                ndp.xreturn[4] = 0.0;	/*               speed */
                ndp.xreturn[8] = 0.0;	/* z coordinate        */
                ndp.xreturn[11] = 0.0;	/*               speed */
            }
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            /***********************************************
             * osculating lunar apogee                     *
             ***********************************************/
        } else if (ipl == SweConst.SE_OSCU_APOG) {
            if (((iflag & SweConst.SEFLG_HELCTR)!=0) ||
                ((iflag & SweConst.SEFLG_BARYCTR)!=0)) {
                /* heliocentric/barycentric lunar apogee not allowed */
                for (i = 0; i < 24; i++) {
                    x[i] = 0;
                }
                return iflag;
            }
            ndp = swed.nddat[SwephData.SEI_OSCU_APOG];
            xp = ndp.xreturn;
            retc = lunar_osc_elem(tjd, SwephData.SEI_OSCU_APOG, iflag, serr);
            iflag = ndp.xflgs;
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            /***********************************************
             * interpolated lunar apogee                   *    
             ***********************************************/
        } else if (ipl == SweConst.SE_INTP_APOG) {
            if ((iflag & SweConst.SEFLG_HELCTR)!=0 ||
                (iflag & SweConst.SEFLG_BARYCTR)!=0) {
                /* heliocentric/barycentric lunar apogee not allowed */
                for (i = 0; i < 24; i++) {
                    x[i] = 0;
                }
                return iflag;
            }
            ndp = swed.nddat[SwephData.SEI_INTP_APOG];
            xp = ndp.xreturn;
            retc = intp_apsides(tjd, SwephData.SEI_INTP_APOG, iflag, serr); 
            iflag = ndp.xflgs;
            if (retc == SweConst.ERR)
                return swecalc_error(x);
            /*********************************************** 
             * interpolated lunar perigee                  *    
             ***********************************************/
        } else if (ipl == SweConst.SE_INTP_PERG) {
            if ((iflag & SweConst.SEFLG_HELCTR)!=0 ||
                (iflag & SweConst.SEFLG_BARYCTR)!=0) {
                /* heliocentric/barycentric lunar apogee not allowed */
                for (i = 0; i < 24; i++) {
                    x[i] = 0;
                }
                return iflag;
            }
            ndp = swed.nddat[SwephData.SEI_INTP_PERG];
            xp = ndp.xreturn;
            retc = intp_apsides(tjd, SwephData.SEI_INTP_PERG, iflag, serr); 
            iflag = ndp.xflgs;
            if (retc == SweConst.ERR)
                return swecalc_error(x);
            /*********************************************** 
             * minor planets                               *
             ***********************************************/
        } else if (ipl == SweConst.SE_CHIRON
                   || ipl == SweConst.SE_PHOLUS
                   || ipl == SweConst.SE_CERES		/* Ceres - Vesta */
                   || ipl == SweConst.SE_PALLAS
                   || ipl == SweConst.SE_JUNO
                   || ipl == SweConst.SE_VESTA
                   || ipl > SweConst.SE_AST_OFFSET) {
            /* internal planet number */
            if (ipl < SweConst.SE_NPLANETS) {
                ipli = SwissData.pnoext2int[ipl];
            } else if (ipl <= SweConst.SE_AST_OFFSET + SwephData.MPC_VESTA) {
                ipli = SwephData.SEI_CERES + ipl - SweConst.SE_AST_OFFSET - 1;
                ipl = SweConst.SE_CERES + ipl - SweConst.SE_AST_OFFSET - 1;
            } else {		/* any asteroid except*/
                ipli = SwephData.SEI_ANYBODY;
            }
            if (ipli == SwephData.SEI_ANYBODY) {
                ipli_ast = ipl;
            } else {
                ipli_ast = ipli;
            }
            pdp = swed.pldat[ipli];
            xp = pdp.xreturn;
            if (ipli_ast > SweConst.SE_AST_OFFSET) {
                ifno = SwephData.SEI_FILE_ANY_AST;
            } else {
                ifno = SwephData.SEI_FILE_MAIN_AST;
            }
            if (ipli == SwephData.SEI_CHIRON &&
                (tjd < SwephData.CHIRON_START || tjd > SwephData.CHIRON_END)) {
                if (serr != null) {
                    serr.setLength(0);
                    serr.append("Chiron's ephemeris is restricted to JD "+
                                SwephData.CHIRON_START+" - JD "+
                                SwephData.CHIRON_END);
                }
                return SweConst.ERR;
            }
            if (ipli == SwephData.SEI_PHOLUS && tjd < SwephData.PHOLUS_START) {
                if (serr != null) {
                    serr.setLength(0);
                    serr.append("Pholus's ephemeris is restricted to the time after JD "+
                                SwephData.PHOLUS_START);
                }
                return SweConst.ERR;
            }
            //  do_asteroid:
            while (true) {
                /* earth and sun are also needed */
                retc = main_planet(tjd, SwephData.SEI_EARTH, epheflag, iflag, serr);
                if (retc == SweConst.ERR) {
                    return swecalc_error(x);
                }
                /* iflag (ephemeris bit) has possibly changed in main_planet() */
                iflag = swed.pldat[SwephData.SEI_EARTH].xflgs;
                /* asteroid */
                if (serr != null) {
                    serr2=serr.toString();
                    serr.setLength(0);
                }
                /* asteroid */
                retc = sweph(tjd, ipli_ast, ifno, iflag, psdp.x, SwephData.DO_SAVE,
                             null, serr);
                if (retc == SweConst.ERR || retc == SwephData.NOT_AVAILABLE) {
                    return swecalc_error(x);
                }
                retc = app_pos_etc_plan(ipli_ast, iflag, serr);
                if (retc == SweConst.ERR) {
                    return swecalc_error(x);
                }
                /* app_pos_etc_plan() might have failed, if t(light-time)
                 * is beyond ephemeris range. in this case redo with Moshier
                 */
                if (retc == SwephData.NOT_AVAILABLE ||
                    retc == SwephData.BEYOND_EPH_LIMITS) {
                    if (epheflag != SweConst.SEFLG_MOSEPH) {
                        iflag = (iflag & ~SweConst.SEFLG_EPHMASK) | SweConst.SEFLG_MOSEPH;
                        epheflag = SweConst.SEFLG_MOSEPH;
                        if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                            serr.append("\nusing Moshier eph.; ");
                        }
                        //          goto do_asteroid;
                        continue;
                    } else
                        return swecalc_error(x);
                }
                break;
            }
            /* add warnings from earth/sun computation */
            if (serr != null && serr.length()==0 && serr2.length()!=0) {
                serr.setLength(0);
                serr2=serr2.substring(0,Math.min(serr2.length(),SwissData.AS_MAXCH-5));
                serr.append("sun: "+serr2);
            }
            /***********************************************
             * fictitious planets                          *
             * (Isis-Transpluto and Uranian planets)       *
             ***********************************************/
            // JAVA: Geht nur mit Moshier Routinen???
        } else if (ipl >= SweConst.SE_FICT_OFFSET && ipl <= SweConst.SE_FICT_MAX) {
            /* internal planet number */
            ipli = SwephData.SEI_ANYBODY;
            pdp = swed.pldat[ipli];
            xp = pdp.xreturn;
            //  do_fict_plan:
            while (true) {
                /* the earth for geocentric position */
                retc = main_planet(tjd, SwephData.SEI_EARTH, epheflag, iflag, serr);
                /* iflag (ephemeris bit) has possibly changed in main_planet() */
                iflag = swed.pldat[SwephData.SEI_EARTH].xflgs;
                /* planet from osculating elements */
                if (smosh.swi_osc_el_plan(tjd, pdp.x, ipl-SweConst.SE_FICT_OFFSET,
                                          ipli, pedp.x, psdp.x, serr) != SweConst.OK) {
                    return swecalc_error(x);
                }
                if (retc == SweConst.ERR) {
                    return swecalc_error(x);
                }
                retc = app_pos_etc_plan_osc(ipl, ipli, iflag, serr);
                if (retc == SweConst.ERR) {
                    return swecalc_error(x);
                }
                /* app_pos_etc_plan_osc() might have failed, if t(light-time)
                 * is beyond ephemeris range. in this case redo with Moshier
                 */
                if (retc == SwephData.NOT_AVAILABLE ||
                    retc == SwephData.BEYOND_EPH_LIMITS) {
                    if (epheflag != SweConst.SEFLG_MOSEPH) {
                        iflag = (iflag & ~SweConst.SEFLG_EPHMASK) | SweConst.SEFLG_MOSEPH;
                        epheflag = SweConst.SEFLG_MOSEPH;
                        if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                            serr.append("\nusing Moshier eph.; ");
                        }
                        //        goto do_fict_plan;
                        continue;
                    } else
                        return swecalc_error(x);
                }
                break;
            }
            /***********************************************
             * invalid body number                         *
             ***********************************************/
        } else {
            if (serr != null) {
                serr.setLength(0);
                serr.append("illegal planet number "+ipl+".");
            }
            return swecalc_error(x);
        }
        for (i = 0; i < 24; i++) {
            x[i] = xp[i];
        }
        return(iflag);
    }

    int moshier_moon(double tjd, boolean do_save, double[] xpmret,
                     StringBuffer serr) {
        int retc = sm.swi_moshmoon(tjd, do_save, null, serr);/**/
        if (retc == SweConst.ERR) {
            return SweConst.ERR;
        }
        /* for hel. position, we need earth as well */
        retc = smosh.swi_moshplan(tjd, SwephData.SEI_EARTH, do_save, null, null, serr);/**/
        if (retc == SweConst.ERR) {
            return SweConst.ERR;
        }
        return SweConst.OK;
    }

    int swecalc_error(double x[]) {
        /***********************************************
         * return error                                *
         ***********************************************/
        //  return_error:;
        for (int i = 0; i < 24; i++) {
            x[i] = 0.;
        }
        return SweConst.ERR;
    }

    int sweph_sbar(double tjd, int iflag, PlanData psdp, PlanData pedp,
                   StringBuffer serr) {
        int retc;
        /* sweplan() provides barycentric sun as a by-product in save area;
         * it is saved in swed.pldat[SEI_SUNBARY].x */
        retc = sweplan(tjd, SwephData.SEI_EARTH, SwephData.SEI_FILE_PLANET, iflag,
                       SwephData.DO_SAVE, null, null, null, null, serr);
        if (retc == SweConst.ERR || retc == SwephData.NOT_AVAILABLE) {
            return SweConst.ERR;
        }
        psdp.teval = tjd;
        /* pedp.teval = tjd; */
        return SweConst.OK;
    }

    int sweph_moon(double tjd, int ipli, int iflag, StringBuffer serr) {
        int retc;
        retc = sweplan(tjd, ipli, SwephData.SEI_FILE_MOON, iflag, SwephData.DO_SAVE,
                       null, null, null, null, serr);
        if (retc == SweConst.ERR) {
            return SweConst.ERR;
        }
        /* if sweph file not found, switch to moshier */
        if (retc == SwephData.NOT_AVAILABLE) {
            if (tjd > SwephData.MOSHLUEPH_START && tjd < SwephData.MOSHLUEPH_END) {
                iflag = (iflag & ~SweConst.SEFLG_SWIEPH) | SweConst.SEFLG_MOSEPH;
                if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                    serr.append(" \nusing Moshier eph.; ");
                }
                //        goto moshier_moon;
                retc = moshier_moon(tjd, SwephData.DO_SAVE, null, serr);
                if (retc == SweConst.ERR) {
                    return SweConst.ERR;
                }
            } else
                return SweConst.ERR;
        }
        return SweConst.OK;
    }

    /* calculates obliquity of ecliptic and stores it together
     * with its date, sine, and cosine
     */
    void calc_epsilon(double tjd, Epsilon e) {
        e.teps = tjd;
        e.eps = sl.swi_epsiln(tjd);
        e.seps = Math.sin(e.eps);
        e.ceps = Math.cos(e.eps);
    }

    /* computes a main planet from any ephemeris, if it
     * has not yet been computed for this date.
     * since a geocentric position requires the earth, the
     * earth's position will be computed as well. With SWISSEPH
     * files the barycentric sun will be done as well.
     * With Moshier, the moon will be done as well.
     *
     * tjd          = julian day
     * ipli         = body number
     * epheflag     = which ephemeris? JPL, SWISSEPH, Moshier?
     * iflag        = other flags
     *
     * the geocentric apparent position of ipli (or whatever has
     * been specified in iflag) will be saved in
     * &swed.pldat[ipli].xreturn[];
     *
     * the barycentric (heliocentric with Moshier) position J2000
     * will be kept in
     * &swed.pldat[ipli].x[];
     */
    int main_planet(double tjd, int ipli, int epheflag, int iflag,
                    StringBuffer serr) {
        int retc;
        boolean calc_swieph=false;
        boolean calc_moshier=false;
        if (epheflag == SweConst.SEFLG_JPLEPH) {
            retc = jplplan(tjd, ipli, iflag, SwephData.DO_SAVE,
                           null, null, null,serr);
            /* read error or corrupt file */
            if (retc == SweConst.ERR) {
                return SweConst.ERR;
            }
            /* jpl ephemeris not on disk or date beyond ephemeris range */
            if (retc == SwephData.NOT_AVAILABLE) {
                iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_SWIEPH;
                if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                    serr.append(" \ntrying Swiss Eph; ");
                }
                calc_swieph=true;
                //        goto sweph_planet;
            } else if (retc == SwephData.BEYOND_EPH_LIMITS) {
                if (tjd > SwephData.MOSHPLEPH_START && tjd < SwephData.MOSHPLEPH_END) {
                    iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_MOSEPH;
                    if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                        serr.append(" \nusing Moshier Eph; ");
                    }
                    calc_moshier=true;
                    //          goto moshier_planet;
                } else {
                    return SweConst.ERR;
                }
            }
            if (!calc_swieph && !calc_moshier) {
                /* geocentric, lighttime etc. */
                if (ipli == SwephData.SEI_SUN) {
                    retc = app_pos_etc_sun(iflag, serr)/**/;
                } else {
                    retc = app_pos_etc_plan(ipli, iflag, serr);
                }
                if (retc == SweConst.ERR) {
                    return SweConst.ERR;
                }
                /* t for light-time beyond ephemeris range */
                if (retc == SwephData.NOT_AVAILABLE) {
                    iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_SWIEPH;
                    if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                        serr.append(" \ntrying Swiss Eph; ");
                    }
                    calc_swieph=true;
                    //          goto sweph_planet;
                } else if (retc == SwephData.BEYOND_EPH_LIMITS) {
                    if (tjd > SwephData.MOSHPLEPH_START &&
                        tjd < SwephData.MOSHPLEPH_END) {
                        iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_MOSEPH;
                        if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                            serr.append(" \nusing Moshier Eph; ");
                        }
                        calc_moshier=true;
                        //            goto moshier_planet;
                    } else {
                        return SweConst.ERR;
                    }
                }
            }
        } // SweConst.SEFLG_JPLEPH
        if (epheflag == SweConst.SEFLG_SWIEPH || calc_swieph) {
            //      sweph_planet:
            /* compute barycentric planet (+ earth, sun, moon) */
            retc = sweplan(tjd, ipli, SwephData.SEI_FILE_PLANET, iflag, SwephData.DO_SAVE,
                           null, null, null, null, serr);
            if (retc == SweConst.ERR) {
                return SweConst.ERR;
            }
            /* if sweph file not found, switch to moshier */
            if (retc == SwephData.NOT_AVAILABLE) {
                if (tjd > SwephData.MOSHPLEPH_START && tjd < SwephData.MOSHPLEPH_END) {
                    iflag = (iflag & ~SweConst.SEFLG_SWIEPH) | SweConst.SEFLG_MOSEPH;
                    if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                        serr.append(" \nusing Moshier eph.; ");
                    }
                    calc_moshier=true;
                    //          goto moshier_planet;
                } else {
                    return SweConst.ERR;
                }
            }
            if (!calc_moshier) {
                /* geocentric, lighttime etc. */
                if (ipli == SwephData.SEI_SUN) {
                    retc = app_pos_etc_sun(iflag, serr)/**/;
                } else {
                    retc = app_pos_etc_plan(ipli, iflag, serr);
                }
                if (retc == SweConst.ERR) {
                    return SweConst.ERR;
                }
                /* if sweph file for t(lighttime) not found, switch to moshier */
                if (retc == SwephData.NOT_AVAILABLE) {
                    if (tjd > SwephData.MOSHPLEPH_START &&
                        tjd < SwephData.MOSHPLEPH_END) {
                        iflag = (iflag & ~SweConst.SEFLG_SWIEPH) | SweConst.SEFLG_MOSEPH;
                        if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                            serr.append(" \nusing Moshier eph.; ");
                        }
                        calc_moshier=true;
                        //          goto moshier_planet;
                    } else {
                        return SweConst.ERR;
                    }
                }
            } // SweConst.SEFLG_SWIEPH
        } // !calc_moshier
        if (epheflag == SweConst.SEFLG_MOSEPH || calc_moshier) {
            //      moshier_planet:
            retc = smosh.swi_moshplan(tjd, ipli, SwephData.DO_SAVE, null, null, serr);/**/
            if (retc == SweConst.ERR) {
                return SweConst.ERR;
            }
            /* geocentric, lighttime etc. */
            if (ipli == SwephData.SEI_SUN) {
                retc = app_pos_etc_sun(iflag, serr)/**/;
            } else {
                retc = app_pos_etc_plan(ipli, iflag, serr);
            }
            if (retc == SweConst.ERR) {
                return SweConst.ERR;
            }
        }
        return SweConst.OK;
    }

    /* Computes a main planet from any ephemeris or returns
     * it again, if it has been computed before.
     * In barycentric equatorial position of the J2000 equinox.
     * The earth's position is computed as well. With SWISSEPH
     * and JPL ephemeris the barycentric sun is computed, too.
     * With Moshier, the moon is returned, as well.
     *
     * tjd          = julian day
     * ipli         = body number
     * epheflag     = which ephemeris? JPL, SWISSEPH, Moshier?
     * iflag        = other flags
     * xp, xe, xs, and xm are the pointers, where the program
     * either finds or stores (if not found) the barycentric
     * (heliocentric with Moshier) positions of the following
     * bodies:
     * xp           planet
     * xe           earth
     * xs           sun
     * xm           moon
     *
     * xm is used with Moshier only
     */
    int main_planet_bary(double tjd, int ipli, int epheflag, int iflag,
                         boolean do_save,
                         double xp[], double xe[], double xs[], double xm[],
                         StringBuffer serr) {
        int i;
        int retc;
        boolean calc_moshier=false;
        boolean calc_swieph=false;
        if (epheflag == SweConst.SEFLG_JPLEPH) {
            retc = jplplan(tjd, ipli, iflag, do_save, xp, xe, xs, serr);
            /* read error or corrupt file */
            if (retc == SweConst.ERR || retc == SwephData.BEYOND_EPH_LIMITS) {
                return retc;
            }
            /* jpl ephemeris not on disk or date beyond ephemeris range */
            if (retc == SwephData.NOT_AVAILABLE) {
                iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_SWIEPH;
                if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                    serr.append(" \ntrying Swiss Eph; ");
                }
                calc_swieph=true;
                //        goto sweph_planet;
            }
        }
        if (epheflag == SweConst.SEFLG_SWIEPH || calc_swieph) {
            //      sweph_planet:
            /* compute barycentric planet (+ earth, sun, moon) */
            retc = sweplan(tjd, ipli, SwephData.SEI_FILE_PLANET, iflag, do_save,
                           xp, xe, xs, xm, serr);
            if (retc == SweConst.ERR || retc == SwephData.NOT_AVAILABLE) {
                return retc;
            }
        }
        if (epheflag == SweConst.SEFLG_MOSEPH || calc_moshier) {
            retc = smosh.swi_moshplan(tjd, ipli, do_save, xp, xe, serr);/**/
            if (retc == SweConst.ERR) {
                return SweConst.ERR;
            }
            for (i = 0; i <= 5; i++) {
                xs[i] = 0;
            }
        }
        return SweConst.OK;
    }

    /* SWISSEPH
     * this routine computes heliocentric cartesian equatorial coordinates
     * of equinox 2000 of
     * geocentric moon
     *
     * tjd          julian date
     * iflag        flag
     * do_save      save J2000 position in save area pdp->x ?
     * xp           array of 6 doubles for lunar position and speed
     * serr         error string
     */
    int swemoon(double tjd, int iflag, boolean do_save, double xpret[],
                StringBuffer serr) {
        int i, retc;
        PlanData pdp = swed.pldat[SwephData.SEI_MOON];
        int speedf1, speedf2;
        double xx[]=new double[6], xp[];
        if (do_save) {
            xp = pdp.x;
        }
        else
            xp = xx;
        /* if planet has already been computed for this date, return
         * if speed flag has been turned on, recompute planet */
        speedf1 = pdp.xflgs & SweConst.SEFLG_SPEED;
        speedf2 = iflag & SweConst.SEFLG_SPEED;
        if (tjd == pdp.teval
            && pdp.iephe == SweConst.SEFLG_SWIEPH
            && ((speedf2==0) || (speedf1!=0))) {
            xp = pdp.x;
        } else {
            /* call sweph for moon */
            retc = sweph(tjd, SwephData.SEI_MOON, SwephData.SEI_FILE_MOON, iflag,
                         null, do_save, xp, serr);
            if (retc != SweConst.OK) {
                return(retc);
            }
            if (do_save) {
                pdp.teval = tjd;
                pdp.xflgs = -1;
                pdp.iephe = SweConst.SEFLG_SWIEPH;
            }
        }
        if (xpret != null) {
            for (i = 0; i <= 5; i++) {
                xpret[i] = xp[i];
            }
        }
        return SweConst.OK;
    }

    /* SWISSEPH
     * this function computes
     * 1. a barycentric planet
     * plus, under certain conditions,
     * 2. the barycentric sun,
     * 3. the barycentric earth, and
     * 4. the geocentric moon,
     * in barycentric cartesian equatorial coordinates J2000.
     *
     * these are the data needed for calculation of light-time etc.
     *
     * tjd          julian date
     * ipli         SEI_ planet number
     * ifno         ephemeris file number
     * do_save      write new positions in save area
     * xp           array of 6 doubles for planet's position and velocity
     * xpe                                 earth's
     * xps                                 sun's
     * xpm                                 moon's
     * serr         error string
     *
     * xp - xpm can be NULL. if do_save is TRUE, all of them can be NULL.
     * the positions will be written into the save area (swed.pldat[ipli].x)
     */
    int sweplan(double tjd, int ipli, int ifno, int iflag, boolean do_save,
                double xpret[], double xperet[], double xpsret[],
                double xpmret[], StringBuffer serr) {
        int i, retc;
        boolean do_earth = false, do_moon = false, do_sunbary = false;
        PlanData pdp = swed.pldat[ipli];
        PlanData pebdp = swed.pldat[SwephData.SEI_EMB];
        PlanData psbdp = swed.pldat[SwephData.SEI_SUNBARY];
        PlanData pmdp = swed.pldat[SwephData.SEI_MOON];
        double xxp[]=new double[6], xxm[]=new double[6],
            xxs[]=new double[6], xxe[]=new double[6];
        double xp[], xpe[], xpm[], xps[];
        int speedf1, speedf2;
        /* xps (barycentric sun) may be necessary because some planets on sweph
         * file are heliocentric, other ones are barycentric. without xps,
         * the heliocentric ones cannot be returned barycentrically.
         */
        if (do_save || ipli == SwephData.SEI_SUNBARY
            || (pdp.iflg & SwephData.SEI_FLG_HELIO)!=0
            || xpsret != null || (iflag & SweConst.SEFLG_HELCTR)!=0) {
            do_sunbary = true;
        }
        if (do_save || ipli == SwephData.SEI_EARTH || xperet != null) {
            do_earth = true;
        }
        if (ipli == SwephData.SEI_MOON) {
            do_earth = true;
            do_sunbary = true;
        }
        if (do_save || ipli == SwephData.SEI_MOON || ipli == SwephData.SEI_EARTH ||
            xperet != null || xpmret != null) {
            do_moon = true;
        }
        if (do_save) {
            xp = pdp.x;
            xpe = pebdp.x;
            xps = psbdp.x;
            xpm = pmdp.x;
        } else {
            xp = xxp;
            xpe = xxe;
            xps = xxs;
            xpm = xxm;
        }
        speedf2 = iflag & SweConst.SEFLG_SPEED;
        /* barycentric sun */
        if (do_sunbary) {
            speedf1 = psbdp.xflgs & SweConst.SEFLG_SPEED;
            /* if planet has already been computed for this date, return
             * if speed flag has been turned on, recompute planet */
            if (tjd == psbdp.teval
                && psbdp.iephe == SweConst.SEFLG_SWIEPH
                && ((speedf2==0) || (speedf1!=0))) {
                for (i = 0; i <= 5; i++) {
                    xps[i] = psbdp.x[i];
                }
            } else {
                retc = sweph(tjd, SwephData.SEI_SUNBARY, SwephData.SEI_FILE_PLANET, iflag,
                             null, do_save, xps, serr);/**/
                if (retc != SweConst.OK) {
                    return(retc);
                }
            }
            if (xpsret != null) {
                for (i = 0; i <= 5; i++) {
                    xpsret[i] = xps[i];
                }
            }
        }
        /* moon */
        if (do_moon) {
            speedf1 = pmdp.xflgs & SweConst.SEFLG_SPEED;
            if (tjd == pmdp.teval
                && pmdp.iephe == SweConst.SEFLG_SWIEPH
                && ((speedf2==0) || (speedf1!=0))) {
                for (i = 0; i <= 5; i++) {
                    xpm[i] = pmdp.x[i];
                }
            } else {
                retc = sweph(tjd, SwephData.SEI_MOON, SwephData.SEI_FILE_MOON, iflag, null,
                             do_save, xpm, serr);
                if (retc == SweConst.ERR) {
                    return(retc);
                }
                /* if moon file doesn't exist, take moshier moon */
                if (swed.fidat[SwephData.SEI_FILE_MOON].fptr == null) {
                    if (serr != null && serr.length() + 35 < SwissData.AS_MAXCH) {
                        serr.append(" \nusing Moshier eph. for moon; ");
                    }
                    retc = sm.swi_moshmoon(tjd, do_save, xpm, serr);
                    if (retc != SweConst.OK) {
                        return(retc);
                    }
                }
            }
            if (xpmret != null) {
                for (i = 0; i <= 5; i++) {
                    xpmret[i] = xpm[i];
                }
            }
        }
        /* barycentric earth */
        if (do_earth) {
            speedf1 = pebdp.xflgs & SweConst.SEFLG_SPEED;
            if (tjd == pebdp.teval
                && pebdp.iephe == SweConst.SEFLG_SWIEPH
                && ((speedf2==0) || (speedf1!=0))) {
                for (i = 0; i <= 5; i++) {
                    xpe[i] = pebdp.x[i];
                }
            } else {
                retc = sweph(tjd, SwephData.SEI_EMB, SwephData.SEI_FILE_PLANET, iflag, null,
                             do_save, xpe, serr);
                if (retc != SweConst.OK) {
                    return(retc);
                }
                /* earth from emb and moon */
                embofs(xpe, 0, xpm, 0);
                /* speed is needed, if
                 * 1. true position is being computed before applying light-time etc.
                 *    this is the position saved in pdp->x.
                 *    in this case, speed is needed for light-time correction.
                 * 2. the speed flag has been specified.
                 */
                if (xpe == pebdp.x || ((iflag & SweConst.SEFLG_SPEED)!=0)) {
                    embofs(xpe, 3, xpm, 3);
                }
            }
            if (xperet != null) {
                for (i = 0; i <= 5; i++) {
                    xperet[i] = xpe[i];
                }
            }
        }
        if (ipli == SwephData.SEI_MOON) {
            for (i = 0; i <= 5; i++) {
                xp[i] = xpm[i];
            }
        } else if (ipli == SwephData.SEI_EARTH) {
            for (i = 0; i <= 5; i++) {
                xp[i] = xpe[i];
            }
        } else if (ipli == SwephData.SEI_SUN) {
            for (i = 0; i <= 5; i++) {
                xp[i] = xps[i];
            }
        } else {
            /* planet */
            speedf1 = pdp.xflgs & SweConst.SEFLG_SPEED;
            if (tjd == pdp.teval
                && pdp.iephe == SweConst.SEFLG_SWIEPH
                && ((speedf2==0) || (speedf1!=0))) {
                for (i = 0; i <= 5; i++) {
                    xp[i] = pdp.x[i];
                }
                return(SweConst.OK);
            } else {
                retc = sweph(tjd, ipli, ifno, iflag, null, do_save, xp, serr);
                if (retc != SweConst.OK) {
                    return(retc);
                }
                /* if planet is heliocentric, it must be transformed to barycentric */
                if ((pdp.iflg & SwephData.SEI_FLG_HELIO)!=0) {
                    /* now barycentric planet */
                    for (i = 0; i <= 2; i++) {
                        xp[i] += xps[i];
                    }
                    if (do_save || ((iflag & SweConst.SEFLG_SPEED)!=0)) {
                        for (i = 3; i <= 5; i++) {
                            xp[i] += xps[i];
                        }
                    }
                }
            }
        }
        if (xpret != null) {
            for (i = 0; i <= 5; i++) {
                xpret[i] = xp[i];
            }
        }
        return SweConst.OK;
    }

    /* jpl ephemeris.
     * this function computes
     * 1. a barycentric planet position
     * plus, under certain conditions,
     * 2. the barycentric sun,
     * 3. the barycentric earth,
     * in barycentric cartesian equatorial coordinates J2000.
  
     * tjd          julian day
     * ipli         sweph internal planet number
     * do_save      write new positions in save area
     * xp           array of 6 doubles for planet's position and speed vectors
     * xpe                                 earth's
     * xps                                 sun's
     * serr         pointer to error string
     *
     * xp - xps can be NULL. if do_save is TRUE, all of them can be NULL.
     * the positions will be written into the save area (swed.pldat[ipli].x)
     */
    int jplplan(double tjd, int ipli, int iflag, boolean do_save,
                double xpret[], double xperet[], double xpsret[],
                StringBuffer serr) throws SwissephException {
        int i, retc;
        boolean do_earth = false, do_sunbary = false;
        double ss[]=new double[3];
        double xxp[]=new double[6], xxe[]=new double[6], xxs[]=new double[6];
        double xp[], xpe[], xps[];
        int ictr = SwephJPL.J_SBARY;
        PlanData pdp = swed.pldat[ipli];
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        /* we assume Teph ~= TDB ~= TT. The maximum error is < 0.002 sec, 
         * corresponding to an ephemeris error < 0.001 arcsec for the moon */
        /* double tjd_tdb, T;
           T = (tjd - 2451545.0)/36525.0;
           tjd_tdb = tjd + (0.001657 * sin(628.3076 * T + 6.2401)
           + 0.000022 * sin(575.3385 * T + 4.2970)
           + 0.000014 * sin(1256.6152 * T + 6.1969)) / 8640.0;*/
        if (do_save) {
            xp = pdp.x;
            xpe = pedp.x;
            xps = psdp.x;
        } else {
            xp = xxp;
            xpe = xxe;
            xps = xxs;
        }
        if (do_save || ipli == SwephData.SEI_EARTH || xperet != null
            || (ipli == SwephData.SEI_MOON)) {
            /* && (iflag & (SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR |
               SweConst.SEFLG_NOABERR))!=0)) */
            do_earth = true;
        }
        if (do_save || ipli == SwephData.SEI_SUNBARY || xpsret != null
            || (ipli == SwephData.SEI_MOON)) {
            /* && (iflag & (SEFLG_HELCTR | SEFLG_NOABERR)))) */
            do_sunbary = true;
        }
        if (ipli == SwephData.SEI_MOON) {
            ictr = SwephJPL.J_EARTH;
        }
        /* open ephemeris, if still closed */
        if (!swed.jpl_file_is_open) {
            retc = sj.swi_open_jpl_file(ss, swed.jplfnam, swed.ephepath, serr);
            swed.jpldenum = sj.swi_get_jpl_denum();
            if (retc != SweConst.OK) {
                throw new SwissephException(tjd, SwissephException.FILE_OPEN_FAILED,
                                            retc, serr);
            }
            swed.jpl_file_is_open = true;
        }
        if (do_earth) {
            /* barycentric earth */
            if (tjd != pedp.teval || tjd == 0) {
                retc = sj.swi_pleph(tjd, SwephJPL.J_EARTH, SwephJPL.J_SBARY, xpe, serr);
                if (retc != SweConst.OK) {
                    sj.swi_close_jpl_file();
                    swed.jpl_file_is_open = false;
                    return retc;
                }
                if (do_save) {
                    pedp.teval = tjd;
                    pedp.xflgs = -1;       /* new light-time etc. required */
                    pedp.iephe = SweConst.SEFLG_JPLEPH;
                }
            } else {
                xpe = pedp.x;
            }
            if (xperet != null) {
                for (i = 0; i <= 5; i++) {
                    xperet[i] = xpe[i];
                }
            }
  
        }
        if (do_sunbary) {
            /* barycentric sun */
            if (tjd != psdp.teval || tjd == 0) {
                retc = sj.swi_pleph(tjd, SwephJPL.J_SUN, SwephJPL.J_SBARY, xps, serr);
                if (retc != SweConst.OK) {
                    sj.swi_close_jpl_file();
                    swed.jpl_file_is_open = false;
                    return retc;
                }
                if (do_save) {
                    psdp.teval = tjd;
                    psdp.xflgs = -1;
                    psdp.iephe = SweConst.SEFLG_JPLEPH;
                }
            } else {
                xps = psdp.x;
            }
            if (xpsret != null) {
                for (i = 0; i <= 5; i++) {
                    xpsret[i] = xps[i];
                }
            }
        }
        /* earth is wanted */
        if (ipli == SwephData.SEI_EARTH) {
            for (i = 0; i <= 5; i++) {
                xp[i] = xpe[i];
            }
            /* sunbary is wanted */
        } if (ipli == SwephData.SEI_SUNBARY) {
            for (i = 0; i <= 5; i++) {
                xp[i] = xps[i];
            }
            /* other planet */
        } else {
            /* if planet already computed */
            if (tjd == pdp.teval && pdp.iephe == SweConst.SEFLG_JPLEPH) {
                xp = pdp.x;
            } else {
                retc = sj.swi_pleph(tjd, SwephData.pnoint2jpl[ipli], ictr, xp, serr);
                if (retc != SweConst.OK) {
                    sj.swi_close_jpl_file();
                    swed.jpl_file_is_open = false;
                    return retc;
                }
                if (do_save) {
                    pdp.teval = tjd;
                    pdp.xflgs = -1;
                    pdp.iephe = SweConst.SEFLG_JPLEPH;
                }
            }
        }
        if (xpret != null) {
            for (i = 0; i <= 5; i++) {
                xpret[i] = xp[i];
            }
        }
        return (SweConst.OK);
    }

    /*
     * this function looks for an ephemeris file,
     * opens it, if not yet open,
     * reads constants, if not yet read,
     * computes a planet, if not yet computed
     * attention: asteroids are heliocentric
     *            other planets barycentric
     *
     * tjd          julian date
     * ipli         SEI_ planet number
     * ifno         ephemeris file number
     * xsunb        INPUT (!) array of 6 doubles containing barycentric sun
     *              (must be given with asteroids)
     * do_save      boolean: save result in save area
     * xp           return array of 6 doubles for planet's position
     * serr         error string
     */
    int sweph(double tjd, int ipli, int ifno, int iflag, double xsunb[],
              boolean do_save, double xpret[], StringBuffer serr) {
        int i, ipl, retc, subdirlen;
        String s="", subdirnam, fname;
        double t, tsv;
        double xemb[]=new double[6], xx[]=new double[6], xp[];
        PlanData pdp;
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        FileData fdp = swed.fidat[ifno];
        int speedf1, speedf2;
        boolean need_speed;
        ipl = ipli;
        if (ipli > SweConst.SE_AST_OFFSET) {
            ipl = SwephData.SEI_ANYBODY;
        }
        pdp = swed.pldat[ipl];
        if (do_save) {
            xp = pdp.x;
        } else {
            xp = xx;
        }
        /* if planet has already been computed for this date, return.
         * if speed flag has been turned on, recompute planet */
        speedf1 = pdp.xflgs & SweConst.SEFLG_SPEED;
        speedf2 = iflag & SweConst.SEFLG_SPEED;
        if (tjd == pdp.teval
            && pdp.iephe == SweConst.SEFLG_SWIEPH
            && ((speedf2==0) || (speedf1!=0))
            && ipl < SwephData.SEI_ANYBODY) {
            if (xpret != null) {
                for (i = 0; i <= 5; i++) {
                    xpret[i] = pdp.x[i];
                }
            }
            return SweConst.OK;
        }
        /******************************
         * get correct ephemeris file *
         ******************************/
        if (fdp.fptr != null) {
            /* if tjd is beyond file range, close old file.
             * if new asteroid, close old file. */
            if (tjd < fdp.tfstart || tjd > fdp.tfend
                || (ipl == SwephData.SEI_ANYBODY && ipli != pdp.ibdy)) {
                try {
                    fdp.fptr.close();
                } catch (java.io.IOException e) {
                    // NBT
                }
                fdp.fptr = null;
                if (pdp.refep != null) {
                    pdp.refep = null;
                }
                if (pdp.segp != null) {
                    pdp.segp = null;
                }
            }
        }
        /* if sweph file not open, find and open it */
        if (fdp.fptr == null) {
            fname=sl.swi_gen_filename(new SweDate(tjd), ipli);
            subdirnam=fname;
            if (subdirnam.lastIndexOf(swed.DIR_GLUE)>0) {
                subdirnam=subdirnam.substring(0,subdirnam.indexOf(swed.DIR_GLUE));
                subdirlen=subdirnam.length();
            } else {
                subdirlen=0;
            }
            s=fname;

            while (fdp.fptr==null) {
                try {
                    fdp.fptr=swi_fopen(ifno,s,swed.ephepath, serr);
                } catch (SwissephException se) {
                }
                if (fdp.fptr == null ||
                    (fdp.fptr!=null && fdp.fptr.fp==null && fdp.fptr.sk==null)) {
                    /*
                     * if it is a numbered asteroid file, try also for short files (..s.se1)
                     * On the second try, the inserted 's' will be seen and not tried again.
                     */
                    if (ipli > SweConst.SE_AST_OFFSET) {
                        if (s.indexOf("s.")<=0) {
                            s=s.substring(0,s.indexOf("."))+"s."+SwephData.SE_FILE_SUFFIX;
                            continue;
                        } else {
                            /*
                             * if we still have 'ast0' etc. in front of the filename,
                             * we remove it now, remove the 's' also,
                             * and try in the main ephemeris directory instead of the
                             * asteroid subdirectory.
                             */
                            s=s.substring(0,s.indexOf("s."))+s.substring(s.indexOf("s.")+1);
                            if (subdirlen>0 &&
                                s.startsWith(subdirnam.substring(
                                                                 0,Math.min(subdirnam.length(),subdirlen)))) {
                                s=s.substring(subdirlen+1);
                                continue;
                            }
                        }
                    }
                    return(SwephData.NOT_AVAILABLE);
                }
                if (fdp.fptr!=null) { break; }
            }

            /* during the search error messages may have been built, delete them */
            if (serr != null) {
                serr.setLength(0);
            }
            retc = swed.fidat[ifno].read_const(ifno, serr, swed);
            if (retc != SweConst.OK) {
                return(retc);
            }
        }
        /* if first ephemeris file (J-3000), it might start a mars period
         * after -3000. if last ephemeris file (J3000), it might end a
         * 4000-day-period before 3000. */
        if (tjd < fdp.tfstart || tjd > fdp.tfend) {
            if (serr != null) {
                if (tjd < fdp.tfstart) {
                    s="jd "+tjd+" < Swiss Eph. lower limit "+fdp.tfstart+";";
                } else {
                    s="jd "+tjd+" > Swiss Eph. upper limit "+fdp.tfend+";";
                }
                if (serr.length()+s.length() < SwissData.AS_MAXCH) {
                    serr.append(s);
                }
            }
            return(SwephData.NOT_AVAILABLE);
        }
        /******************************
         * get planet's position
         ******************************/
        /* get new segment, if necessary */
        if (pdp.segp == null || tjd < pdp.tseg0 || tjd > pdp.tseg1) {
            retc = swed.fidat[ifno].get_new_segment(swed, tjd, ipl, ifno, serr);
            if (retc != SweConst.OK) {
                return(retc);
            }
            /* rotate cheby coeffs back to equatorial system.
             * if necessary, add reference orbit. */
            if ((pdp.iflg & SwephData.SEI_FLG_ROTATE)!=0) {
                rot_back(ipl); /**/
            } else {
                pdp.neval = pdp.ncoe;
            }
        }
        /* evaluate chebyshew polynomial for tjd */
        t = (tjd - pdp.tseg0) / pdp.dseg;
        t = t * 2 - 1;
        /* speed is needed, if
         * 1. true position is being computed before applying light-time etc.
         *    this is the position saved in pdp->x.
         *    in this case, speed is needed for light-time correction.
         * 2. the speed flag has been specified.
         */
        need_speed = (do_save || ((iflag & SweConst.SEFLG_SPEED)!=0));
        for (i = 0; i <= 2; i++) {
            xp[i]  = sl.swi_echeb (t, pdp.segp, i*pdp.ncoe, pdp.neval);
            if (need_speed) {
                xp[i+3] = sl.swi_edcheb(t, pdp.segp, i*pdp.ncoe, pdp.neval) / pdp.dseg * 2;
            } else
                xp[i+3] = 0;      /* von Alois als billiger fix, evtl. illegal */
        }
        /* if planet wanted is barycentric sun and must be computed
         * from heliocentric earth and barycentric earth: the
         * computation above gives heliocentric earth, therefore we
         * have to compute barycentric earth and subtract heliocentric
         * earth from it. this may be necessary with calls from
         * sweplan() and from app_pos_etc_sun() (light-time). */
        if (ipl == SwephData.SEI_SUNBARY &&
            (pdp.iflg & SwephData.SEI_FLG_EMBHEL)!=0) {
            /* sweph() calls sweph() !!! for EMB.
             * Attention: a new calculation must be forced in any case.
             * Otherwise EARTH (instead of EMB) will possibly taken from
             * save area.
             * to force new computation, set pedp->teval = 0 and restore it
             * after call of sweph(EMB).
             */
            tsv = pedp.teval;
            pedp.teval = 0;
            retc = sweph(tjd, SwephData.SEI_EMB, ifno, iflag | SweConst.SEFLG_SPEED,
                         null, SwephData.NO_SAVE, xemb, serr);
            if (retc != SweConst.OK) {
                return(retc);
            }
            pedp.teval = tsv;
            for (i = 0; i <= 2; i++) {
                xp[i] = xemb[i] - xp[i];
            }
            if (need_speed) {
                for (i = 3; i <= 5; i++) {
                    xp[i] = xemb[i] - xp[i];
                }
            }
        }
        /* asteroids are heliocentric.
         * if JPL or SWISSEPH, convert to barycentric */
        if ((iflag & SweConst.SEFLG_JPLEPH)!=0 ||
            (iflag & SweConst.SEFLG_SWIEPH)!=0) {
            if (ipl >= SwephData.SEI_ANYBODY) {
                for (i = 0; i <= 2; i++) {
                    xp[i] += xsunb[i];
                }
                if (need_speed) {
                    for (i = 3; i <= 5; i++) {
                        xp[i] += xsunb[i];
                    }
                }
            }
        }
        if (do_save) {
            pdp.teval = tjd;
            pdp.xflgs = -1;    /* do new computation of light-time etc. */
            if (ifno == SwephData.SEI_FILE_PLANET ||
                ifno == SwephData.SEI_FILE_MOON) {
                pdp.iephe = SweConst.SEFLG_SWIEPH;/**/
            } else {
                pdp.iephe = psdp.iephe;
            }
        }
        if (xpret != null) {
            for (i = 0; i <= 5; i++) {
                xpret[i] = xp[i];
            }
        }
        return SweConst.OK;
    }

    /*
     * Alois 2.12.98: inserted error message generation for file not found
     */
    FilePtr swi_fopen(int ifno, String fname, String ephepath,
                      StringBuffer serr) throws SwissephException {
        int np, i;
        java.io.RandomAccessFile fp = null;
        String fnamp;
        String[] cpos=new String[20];
        String path, s, s1;
        //s1=ephepath;
        s1=getTmp();
        
        np = sl.swi_cutstr(s1, SwissData.PATH_SEPARATOR, cpos, 20);
        for (i = 0; i < np; i++) {
            path=cpos[i];
            if ("".equals(path)) { path="."; }
            fnamp=path+swed.DIR_GLUE;

            if (fnamp.length() + fname.length() < SwissData.AS_MAXCH) {
                fnamp+=fname;
            } else {
                if (serr != null) {
                    serr.setLength(0);
                    serr.append("error: file path and name must be shorter than "+
                                SwissData.AS_MAXCH+".");
                }
                throw new SwissephException(1./0., SwissephException.INVALID_FILE_NAME,
                                            SweConst.ERR, serr);
            }
            try {          
                fp = new java.io.RandomAccessFile(fnamp, SwissData.BFILE_R_ACCESS);
                if (ifno >= 0) {
                    swed.fidat[ifno].fnam=fnamp;
                }
                FilePtr sfp = new FilePtr(fp,null,null,null,fnamp,-1,httpBufSize);
                return sfp;
            } catch (java.io.IOException ex) {
                // Maybe it is an URL...
                FilePtr f=tryFileAsURL(path+"/"+fname, ifno);
                if (f!=null) {
                    return f;
                }
            } catch (SecurityException ex) {
                // Probably an applet, we try fnamp as an URL:
                FilePtr f=tryFileAsURL(path+"/"+fname, ifno);
                if (f!=null) {
                    return f;
                }
            }
        }
//         //    s="SwissEph file '"+fname+"' not found in PATH '"+ephepath+"'";
//         s="SwissEph file '"+fname+"' not found in the paths of: ";
//         for (int n=0;n<cpos.length;n++) {
//             if (cpos[n]!=null && !"".equals(cpos[n])) { s+="'"+cpos[n]+"', "; }
//         }
//         /* s may be longer then AS_MAXCH */
//         // Who cares...
//         //    s=s.substring(0,Math.min(s.length(),SwissData.AS_MAXCH));
//         if (serr != null) {
//             serr.setLength(0);
//             serr.append(s);
//         }
//         ////#ifdef TRACE0
//         //    Trace.level--;
//         ////#endif /* TRACE0 */
//         throw new SwissephException(1./0., SwissephException.FILE_NOT_FOUND,
//                                     SwephData.NOT_AVAILABLE, serr);
        return null;
    }

    private FilePtr tryFileAsURL(String fnamp, int ifno) {
        ////#ifdef TRACE0
        //    Trace.level++;
        //    Trace.trace(Trace.level, "SwissEph.tryFileAsURL(String, int)");
        ////#ifdef TRACE1
        //    DevNull.println("    fnamp: " + fnamp + "\n    ifno: " + ifno);
        ////#endif /* TRACE1 */
        ////#endif /* TRACE0 */
        Socket sk=null;
        try {
            URL u=new URL(fnamp);
            sk=new Socket(u.getHost(),(u.getPort()<0?80:u.getPort()));
            String sht="HEAD "+fnamp+" HTTP/1.1\r\n"+
                "User-Agent: "+FilePtr.useragent+"\r\n"+
                "Host: "+u.getHost()+":"+(u.getPort()<0?80:u.getPort())+
                "\r\n\r\n";
            sk.setSoTimeout(5000);
            InputStream is=sk.getInputStream();
            BufferedOutputStream os=new BufferedOutputStream(sk.getOutputStream());
            for(int n=0; n<sht.length(); n++) {
                os.write((byte)sht.charAt(n));
            }
            os.flush();
            String sret=""+(char)is.read();
            while (is.available()>0) {
                sret+=(char)is.read();
            }
            int idx=sret.indexOf("Content-Length:");
            if (idx < 0) {
                sk.close();
                ////#ifdef TRACE0
                //        Trace.level--;
                ////#endif /* TRACE0 */
                return null;
            }
            // We need to query ranges, otherwise it will not make much sense...
            if (sret.indexOf("Accept-Ranges: none")>=0) {
                System.err.println("Server does not accept HTTP range requests. "+
                                   "Aborting!");
                sk.close();
                ////#ifdef TRACE0
                //        Trace.level--;
                ////#endif /* TRACE0 */
                return null;
            }
            sret=sret.substring(idx+"Content-Length:".length());
            sret=sret.substring(0,sret.indexOf("\n")).trim();
            // We might want to check for a minimum length?
            long len=Long.parseLong(sret);
            if (ifno >= 0) {
                swed.fidat[ifno].fnam=fnamp;
            }
            ////#ifdef TRACE0
            //      Trace.level--;
            ////#endif /* TRACE0 */
            return new FilePtr(null,sk,is,os,fnamp,len,httpBufSize);
        } catch (MalformedURLException m) {
        } catch (IOException ie) {
        } catch (NumberFormatException nf) {
            // Why this? Should not be able to happen...
        } catch (SecurityException se) {
        }
        try { sk.close(); }
        catch (IOException e) { }
        catch (NullPointerException np) { }
        ////#ifdef TRACE0
        //    Trace.level--;
        ////#endif /* TRACE0 */
        return null;
    }

    /* converts planets from barycentric to geocentric,
     * apparent positions
     * precession and nutation
     * according to flags
     * ipli         planet number
     * iflag        flags
     * serr         error string
     */
    int app_pos_etc_plan(int ipli, int iflag, StringBuffer serr) {
        int i, j, niter, retc = SweConst.OK;
        int ipl;
        int ifno, ibody;
        int flg1, flg2;
        double xx[]=new double[6], dx[]=new double[3], dt, t, dtsave_for_defl;
        double xobs[]=new double[6], xobs2[]=new double[6];
        double xearth[]=new double[6], xsun[]=new double[6];
        double xxsp[]=new double[6], xxsv[]=new double[6];
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData pdp;
        Epsilon oe = swed.oec2000;
        int epheflag = iflag & SweConst.SEFLG_EPHMASK;
        t = dtsave_for_defl = 0;      /* dummy assignment to silence gcc */
        /* ephemeris file */
        if (ipli > SweConst.SE_AST_OFFSET) {
            ifno = SwephData.SEI_FILE_ANY_AST;
            ibody = SwephData.IS_ANY_BODY;
            pdp = swed.pldat[SwephData.SEI_ANYBODY];
        } else if (ipli == SwephData.SEI_CHIRON
                   || ipli == SwephData.SEI_PHOLUS
                   || ipli == SwephData.SEI_CERES
                   || ipli == SwephData.SEI_PALLAS
                   || ipli == SwephData.SEI_JUNO
                   || ipli == SwephData.SEI_VESTA) {
            ifno = SwephData.SEI_FILE_MAIN_AST;
            ibody = SwephData.IS_MAIN_ASTEROID;
            pdp = swed.pldat[ipli];
        } else {
            ifno = SwephData.SEI_FILE_PLANET;
            ibody = SwephData.IS_PLANET;
            pdp = swed.pldat[ipli];
        }
        /* if the same conversions have already been done for the same
         * date, then return */
        flg1 = iflag & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        flg2 = pdp.xflgs & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        if (flg1 == flg2) {
            pdp.xflgs = iflag;
            pdp.iephe = iflag & SweConst.SEFLG_EPHMASK;
            return SweConst.OK;
        }
        /* the conversions will be done with xx[]. */
        for (i = 0; i <= 5; i++) {
            xx[i] = pdp.x[i];
        }
        /* if heliocentric position is wanted */
        if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
            if (pdp.iephe == SweConst.SEFLG_JPLEPH ||
                pdp.iephe == SweConst.SEFLG_SWIEPH) {
                for (i = 0; i <= 5; i++) {
                    xx[i] -= swed.pldat[SwephData.SEI_SUNBARY].x[i];
                }
            }
        }
        /************************************
         * observer: geocenter or topocenter
         ************************************/
        /* if topocentric position is wanted  */
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            if (swed.topd.teval != pedp.teval
                || pedp.teval == 0) {
                if (swi_get_observer(pedp.teval, iflag, SwephData.DO_SAVE, xobs, serr)
                    != SweConst.OK) {
                    return SweConst.ERR;
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = swed.topd.xobs[i];
                }
            }
            /* barycentric position of observer */
            for (i = 0; i <= 5; i++) {
                xobs[i] = xobs[i] + pedp.x[i];
            }
        } else {
            /* barycentric position of geocenter */
            for (i = 0; i <= 5; i++) {
                xobs[i] = pedp.x[i];
            }
        }
        /*******************************
         * light-time geocentric       *
         *******************************/
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0) {
            /* number of iterations - 1 */
            if (pdp.iephe == SweConst.SEFLG_JPLEPH ||
                pdp.iephe == SweConst.SEFLG_SWIEPH) {
                niter = 1;
            } else {      /* SEFLG_MOSEPH or planet from osculating elements */
                niter = 0;
            }
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                /*
                 * Apparent speed is influenced by the fact that dt changes with
                 * motion. This makes a difference of several hundredths of an
                 * arc second. To take this into account, we compute
                 * 1. true position - apparent position at time t - 1.
                 * 2. true position - apparent position at time t.
                 * 3. the difference between the two is the part of the daily motion
                 * that results from the change of dt.
                 */
                for (i = 0; i <= 2; i++) {
                    xxsv[i] = xxsp[i] = xx[i] - xx[i+3];
                }
                for (j = 0; j <= niter; j++) {
                    for (i = 0; i <= 2; i++) {
                        dx[i] = xxsp[i];
                        if (((iflag & SweConst.SEFLG_HELCTR)==0) &&
                            (iflag & SweConst.SEFLG_BARYCTR)==0) {
                            dx[i] -= (xobs[i] - xobs[i+3]);
                        }
                    }
                    /* new dt */
                    dt = Math.sqrt(sl.square_sum(dx)) * SweConst.AUNIT / SwephData.CLIGHT /
                        86400.0;
                    for (i = 0; i <= 2; i++) {      /* rough apparent position at t-1 */
                        xxsp[i] = xxsv[i] - dt * pdp.x[i+3];
                    }
                }
                /* true position - apparent position at time t-1 */
                for (i = 0; i <= 2; i++) {
                    xxsp[i] = xxsv[i] - xxsp[i];
                }
            }
            /* dt and t(apparent) */
            for (j = 0; j <= niter; j++) {
                for (i = 0; i <= 2; i++) {
                    dx[i] = xx[i];
                    if ((iflag & SweConst.SEFLG_HELCTR)==0 &&
                        (iflag & SweConst.SEFLG_BARYCTR)==0) {
                        dx[i] -= xobs[i];
                    }
                }
                dt = Math.sqrt(sl.square_sum(dx)) *SweConst.AUNIT / SwephData.CLIGHT / 86400.0;
                /* new t */
                t = pdp.teval - dt;
                dtsave_for_defl = dt;
                for (i = 0; i <= 2; i++) {        /* rough apparent position at t*/
                    xx[i] = pdp.x[i] - dt * pdp.x[i+3];
                }
            }
            /* part of daily motion resulting from change of dt */
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                for (i = 0; i <= 2; i++) {
                    xxsp[i] = pdp.x[i] - xx[i] - xxsp[i];
                }
            }
            /* new position, accounting for light-time (accurate) */
            switch(epheflag) {
                case SweConst.SEFLG_JPLEPH:
                    if (ibody == SwephData.IS_PLANET) {
                        ipl = SwephData.pnoint2jpl[ipli];
                        retc = sj.swi_pleph(t, ipl, SwephJPL.J_SBARY, xx, serr);
                        if (retc != SweConst.OK) {
                            sj.swi_close_jpl_file();
                            swed.jpl_file_is_open = false;
                        }
                    } else {        /* asteroid */
                        /* first sun */
                        retc = sj.swi_pleph(t, SwephJPL.J_SUN, SwephJPL.J_SBARY, xsun, serr);
                        if (retc != SweConst.OK) {
                            sj.swi_close_jpl_file();
                            swed.jpl_file_is_open = false;
                        }
                        /* asteroid */
                        retc = sweph(t, ipli, ifno, iflag, xsun, SwephData.NO_SAVE, xx, serr);
                    }
                    if (retc != SweConst.OK) {
                        return(retc);
                    }
                    /* for accuracy in speed, we need earth as well */
                    if ((iflag & SweConst.SEFLG_SPEED)!=0
                        && (iflag & SweConst.SEFLG_HELCTR)==0
                        && (iflag & SweConst.SEFLG_BARYCTR)==0) {
                        retc = sj.swi_pleph(t, SwephJPL.J_EARTH, SwephJPL.J_SBARY, xearth, serr);
                        if (retc != SweConst.OK) {
                            sj.swi_close_jpl_file();
                            swed.jpl_file_is_open = false;
                            return(retc);
                        }
                    }
                    break;
                case SweConst.SEFLG_SWIEPH:
                    if (ibody == SwephData.IS_PLANET) {
                        retc = sweplan(t, ipli, ifno, iflag, SwephData.NO_SAVE, xx, xearth,
                                       xsun, null, serr);
                    } else {          /*asteroid*/
                        retc = sweplan(t, SwephData.SEI_EARTH, SwephData.SEI_FILE_PLANET,
                                       iflag, SwephData.NO_SAVE, xearth, null, xsun, null,
                                       serr);
                        if (retc == SweConst.OK) {
                            retc = sweph(t, ipli, ifno, iflag, xsun, SwephData.NO_SAVE, xx,
                                         serr);
                        }
                    }
                    if (retc != SweConst.OK) {
                        return(retc);
                    }
                    break;
                case SweConst.SEFLG_MOSEPH:
                default:
                    /*
                     * with moshier or other ephemerides, subtraction of dt * speed
                     * is sufficient (has been done in light-time iteration above)
                     */
                    /* if speed flag is true, we call swi_moshplan() for new t.
                     * this does not increase position precision,
                     * but speed precision, which becomes better than 0.01"/day.
                     * for precise speed, we need earth as well.
                     */
                    if ((iflag & SweConst.SEFLG_SPEED)!=0
                        && (iflag & (SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR))==0) {
                        if (ibody == SwephData.IS_PLANET) {
                            retc = smosh.swi_moshplan(t, ipli, SwephData.NO_SAVE, xxsv,
                                                      xearth, serr);
                        } else {                /* if asteroid */
                            retc = sweph(t, ipli, ifno, iflag, null, SwephData.NO_SAVE, xxsv,
                                         serr);
                            if (retc == SweConst.OK) {
                                retc = smosh.swi_moshplan(t, SwephData.SEI_EARTH,
                                                          SwephData.NO_SAVE, xearth, xearth,
                                                          serr);
                            }
                        }
                        if (retc != SweConst.OK) {
                            return(retc);
                        }
                        /* only speed is taken from this computation, otherwise position
                         * calculations with and without speed would not agree. The difference
                         * would be about 0.01", which is far below the intrinsic error of the
                         * moshier ephemeris.
                         */
                        for (i = 3; i <= 5; i++) {
                            xx[i] = xxsv[i];
                        }
                    }
                    break;
            }
            if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
                if (pdp.iephe == SweConst.SEFLG_JPLEPH ||
                    pdp.iephe == SweConst.SEFLG_SWIEPH) {
                    for (i = 0; i <= 5; i++) {
                        xx[i] -= swed.pldat[SwephData.SEI_SUNBARY].x[i];
                    }
                }
            }
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                /* observer position for t(light-time) */
                if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
                    if (swi_get_observer(t, iflag, SwephData.NO_SAVE, xobs2, serr) !=
                        SweConst.OK) {
                        return SweConst.ERR;
                    }
                    for (i = 0; i <= 5; i++) {
                        xobs2[i] += xearth[i];
                    }
                } else {
                    for (i = 0; i <= 5; i++) {
                        xobs2[i] = xearth[i];
                    }
                }
            }
        }
        /*******************************
         * conversion to geocenter     *
         *******************************/
        if ((iflag & SweConst.SEFLG_HELCTR)==0 &&
            (iflag & SweConst.SEFLG_BARYCTR)==0) {
            /* subtract earth */
            for (i = 0; i <= 5; i++) {
                xx[i] -= xobs[i];
            }
            if ((iflag & SweConst.SEFLG_TRUEPOS) == 0 ) {
                /*
                 * Apparent speed is also influenced by
                 * the change of dt during motion.
                 * Neglect of this would result in an error of several 0.01"
                 */
                if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                    for (i = 3; i <= 5; i++) {
                        xx[i] -= xxsp[i-3];
                    }
                }
            }
        }
        if ((iflag & SweConst.SEFLG_SPEED)==0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        /************************************
         * relativistic deflection of light *
         ************************************/
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0 &&
            (iflag & SweConst.SEFLG_NOGDEFL)==0) {
            /* SEFLG_NOGDEFL is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
            swi_deflect_light(xx, 0, dtsave_for_defl, iflag);
        }
        /**********************************
         * 'annual' aberration of light   *
         **********************************/
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0 &&
            (iflag & SweConst.SEFLG_NOABERR)==0) {
            /* SEFLG_NOABERR is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
            swi_aberr_light(xx, xobs, iflag);
            /*
             * Apparent speed is also influenced by
             * the difference of speed of the earth between t and t-dt.
             * Neglecting this would involve an error of several 0.1"
             */
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                for (i = 3; i <= 5; i++) {
                    xx[i] += xobs[i] - xobs2[i];
                }
            }
        }
        if ((iflag & SweConst.SEFLG_SPEED) == 0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        /* ICRS to J2000 */
        if ((iflag & SweConst.SEFLG_ICRS) == 0 && swed.jpldenum >= 403) {
            sl.swi_bias(xx, iflag, false);
        }/**/
        /* save J2000 coordinates; required for sidereal positions */
        for (i = 0; i <= 5; i++) {
            xxsv[i] = xx[i];
        }
        /************************************************
         * precession, equator 2000 -> equator of date *
         ************************************************/
        if ((iflag & SweConst.SEFLG_J2000)==0) {
            sl.swi_precess(xx, pdp.teval, SwephData.J2000_TO_J);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(xx, pdp.teval, SwephData.J2000_TO_J);
            }
            oe = swed.oec;
        } else {
            oe = swed.oec2000;
        }
        return app_pos_rest(pdp, iflag, xx, xxsv, oe, serr);
    }

    int app_pos_rest(PlanData pdp, int iflag,
                     double[] xx, double[] x2000,
                     Epsilon oe, StringBuffer serr) {
        int i;
        /************************************************
         * nutation                                     *
         ************************************************/
        if ((iflag & SweConst.SEFLG_NONUT)==0) {
            swi_nutate(xx, 0, iflag, false);
        }
        /* now we have equatorial cartesian coordinates; save them */
        for (i = 0; i <= 5; i++) {
            pdp.xreturn[18+i] = xx[i];
        }
        /************************************************
         * transformation to ecliptic.                  *
         * with sidereal calc. this will be overwritten *
         * afterwards.                                  *
         ************************************************/
        sl.swi_coortrf2(xx, xx, oe.seps, oe.ceps);
        if ((iflag & SweConst.SEFLG_SPEED) !=0) {
            sl.swi_coortrf2(xx, 3, xx, 3, oe.seps, oe.ceps);
        }
        if ((iflag & SweConst.SEFLG_NONUT)==0) {
            sl.swi_coortrf2(xx, xx, swed.nut.snut, swed.nut.cnut);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                sl.swi_coortrf2(xx, 3, xx, 3, swed.nut.snut, swed.nut.cnut);
            }
        }
        /* now we have ecliptic cartesian coordinates */
        for (i = 0; i <= 5; i++) {
            pdp.xreturn[6+i] = xx[i];
        }
        /************************************
         * sidereal positions               *
         ************************************/
        if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
            /* project onto ecliptic t0 */
            if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0) {
                if (swi_trop_ra2sid_lon(x2000, pdp.xreturn, 6, pdp.xreturn, 18, iflag,
                                        serr) != SweConst.OK) {
                    return SweConst.ERR;
                }
                /* project onto solar system equator */
            } else if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
                if (swi_trop_ra2sid_lon_sosy(x2000, pdp.xreturn, 6, pdp.xreturn, 18,
                                             iflag, serr) != SweConst.OK) {
                    return SweConst.ERR;
                }
            } else {
                /* traditional algorithm */
                sl.swi_cartpol_sp(pdp.xreturn, 6, pdp.xreturn, 0);
                pdp.xreturn[0] -= swe_get_ayanamsa(pdp.teval) * SwissData.DEGTORAD;
                sl.swi_polcart_sp(pdp.xreturn, 0, pdp.xreturn, 6);
            }
        }
        /************************************************
         * transformation to polar coordinates          *
         ************************************************/
        sl.swi_cartpol_sp(pdp.xreturn, 18, pdp.xreturn, 12);
        sl.swi_cartpol_sp(pdp.xreturn, 6, pdp.xreturn, 0);
        /**********************
         * radians to degrees *
         **********************/
        /*if ((iflag & SEFLG_RADIANS) == 0) {*/
        for (i = 0; i < 2; i++) {
            pdp.xreturn[i] *= SwissData.RADTODEG;                /* ecliptic */
            pdp.xreturn[i+3] *= SwissData.RADTODEG;
            pdp.xreturn[i+12] *= SwissData.RADTODEG;     /* equator */
            pdp.xreturn[i+15] *= SwissData.RADTODEG;
        }
        /*}*/
        /* save, what has been done */
        pdp.xflgs = iflag;
        pdp.iephe = iflag & SweConst.SEFLG_EPHMASK;
        return SweConst.OK;
    }

    /*
     * input coordinates are J2000, cartesian.
     * xout         ecliptical sidereal position
     * xoutr        equatorial sidereal position
     */
    int swi_trop_ra2sid_lon(double[] xin, double[] xout, double[] xoutr,
                            int iflag, StringBuffer serr) {
        return swi_trop_ra2sid_lon(xin, xout, 0, xoutr, 0, iflag, serr);
    }
    int swi_trop_ra2sid_lon(double[] xin, double[] xout, int xoOffs,
                            double[] xoutr, int xrOffs, int iflag,
                            StringBuffer serr) {
        double x[]=new double[6];
        int i;
        SidData sip = swed.sidd;
        Epsilon oectmp=new Epsilon();
        for (i = 0; i <= 5; i++) {
            x[i] = xin[i];
        }
        if (sip.t0 != SwephData.J2000) {
            sl.swi_precess(x, sip.t0, SwephData.J2000_TO_J);
            sl.swi_precess(x, 3, sip.t0, SwephData.J2000_TO_J);      /* speed */
        }
        for (i = 0; i <= 5; i++) {
            xoutr[i+xrOffs] = x[i];
        }
        calc_epsilon(swed.sidd.t0, oectmp);
        sl.swi_coortrf2(x, x, oectmp.seps, oectmp.ceps);
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            sl.swi_coortrf2(x, 3, x, 3, oectmp.seps, oectmp.ceps);
        }
        /* to polar coordinates */
        sl.swi_cartpol_sp(x, x);
        /* subtract ayan_t0 */
        x[0] -= sip.ayan_t0 * SwissData.DEGTORAD;
        /* back to cartesian */
        sl.swi_polcart_sp(x, 0, xout, xoOffs);
        return SweConst.OK;
    }

    /*
     * input coordinates are J2000, cartesian.
     * xout         ecliptical sidereal position
     * xoutr        equatorial sidereal position
     */
    int swi_trop_ra2sid_lon_sosy(double[] xin, double[] xout, double[] xoutr,
                                 int iflag, StringBuffer serr) {
        return swi_trop_ra2sid_lon_sosy(xin, xout, 0, xoutr, 0, iflag, serr);
    }
    int swi_trop_ra2sid_lon_sosy(double[] xin, double[] xout, int xoOffs,
                                 double[] xoutr, int xrOffs, int iflag,
                                 StringBuffer serr) {
        double x[]=new double[6], x0[]=new double[6];
        int i;
        SidData sip = swed.sidd;
        Epsilon oe = swed.oec2000;
        double plane_node = SwephData.SSY_PLANE_NODE_E2000;
        double plane_incl = SwephData.SSY_PLANE_INCL;
        for (i = 0; i <= 5; i++) {
            x[i] = xin[i];
        }
        /* planet to ecliptic 2000 */
        sl.swi_coortrf2(x, x, oe.seps, oe.ceps);
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            sl.swi_coortrf2(x, 3, x, 3, oe.seps, oe.ceps);
        }
        /* to polar coordinates */
        sl.swi_cartpol_sp(x, x);
        /* to solar system equator */
        x[0] -= plane_node;
        sl.swi_polcart_sp(x, x);
        sl.swi_coortrf(x, x, plane_incl);
        sl.swi_coortrf(x, 3, x, 3, plane_incl);
        sl.swi_cartpol_sp(x, x);
        /* zero point of t0 in J2000 system */
        x0[0] = 1;
        x0[1] = x0[2] = 0;
        if (sip.t0 != SwephData.J2000) {
            sl.swi_precess(x0, sip.t0, SwephData.J_TO_J2000);
        }
        /* zero point to ecliptic 2000 */
        sl.swi_coortrf2(x0, x0, oe.seps, oe.ceps);
        /* to polar coordinates */
        sl.swi_cartpol(x0, x0);
        /* to solar system equator */
        x0[0] -= plane_node;
        sl.swi_polcart(x0, x0);
        sl.swi_coortrf(x0, x0, plane_incl);
        sl.swi_cartpol(x0, x0);
        /* measure planet from zero point */
        x[0] -= x0[0];
        x[0] *= SwissData.RADTODEG;
        /* subtract ayan_t0 */
        x[0] -= sip.ayan_t0;
        x[0] = sl.swe_degnorm(x[0]) * SwissData.DEGTORAD;
        /* back to cartesian */
        sl.swi_polcart_sp(x, 0, xout, xoOffs);
        return SweConst.OK;
    }

    /* converts planets from barycentric to geocentric,
     * apparent positions
     * precession and nutation
     * according to flags
     * ipli         planet number
     * iflag        flags
     */
    int app_pos_etc_plan_osc(int ipl, int ipli, int iflag, StringBuffer serr) {
        int i, j, niter, retc;
        double xx[]=new double[6], dx[]=new double[3], dt, dtsave_for_defl;
        double xearth[]=new double[6], xsun[]=new double[6], xmoon[]=new double[6];
        double xxsv[]=new double[6], xxsp[]=new double[6],
            xobs[]=new double[6], xobs2[]=new double[6];
        double t;
        PlanData pdp = swed.pldat[ipli];
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        Epsilon oe = swed.oec2000;
        int epheflag = SweConst.SEFLG_DEFAULTEPH;
        dt = dtsave_for_defl = 0;     /* dummy assign to silence gcc */
        if ((iflag & SweConst.SEFLG_MOSEPH)!=0) {
            epheflag = SweConst.SEFLG_MOSEPH;
        } else if ((iflag & SweConst.SEFLG_SWIEPH)!=0) {
            epheflag = SweConst.SEFLG_SWIEPH;
        } else if ((iflag & SweConst.SEFLG_JPLEPH)!=0) {
            epheflag = SweConst.SEFLG_JPLEPH;
        }
        /* the conversions will be done with xx[]. */
        for (i = 0; i <= 5; i++) {
            xx[i] = pdp.x[i];
        }
        /************************************
         * barycentric position is required *
         ************************************/
        /* = heliocentric position with Moshier ephemeris */
        /************************************
         * observer: geocenter or topocenter
         ************************************/
        /* if topocentric position is wanted  */
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            if (swed.topd.teval != pedp.teval
                || swed.topd.teval != 0) {
                if (swi_get_observer(pedp.teval, iflag, SwephData.DO_SAVE, xobs, serr)
                    != SweConst.OK) {
                    return SweConst.ERR;
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = swed.topd.xobs[i];
                }
            }
            /* barycentric position of observer */
            for (i = 0; i <= 5; i++) {
                xobs[i] = xobs[i] + pedp.x[i];
            }
        } else if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
            for (i = 0; i <= 5; i++) {
                xobs[i] = 0;
            }
        } else if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
            if ((iflag & SweConst.SEFLG_MOSEPH)!=0) {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = 0;
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = psdp.x[i];
                }
            }
        } else {
            for (i = 0; i <= 5; i++) {
                xobs[i] = pedp.x[i];
            }
        }
        /*******************************
         * light-time                  *
         *******************************/
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0) {
            niter = 1;
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                /*
                 * Apparent speed is influenced by the fact that dt changes with
                 * motion. This makes a difference of several hundredths of an
                 * arc second. To take this into account, we compute
                 * 1. true position - apparent position at time t - 1.
                 * 2. true position - apparent position at time t.
                 * 3. the difference between the two is the daily motion resulting from
                 * the change of dt.
                 */
                for (i = 0; i <= 2; i++) {
                    xxsv[i] = xxsp[i] = xx[i] - xx[i+3];
                }
                for (j = 0; j <= niter; j++) {
                    for (i = 0; i <= 2; i++) {
                        dx[i] = xxsp[i];
                        if ((iflag & SweConst.SEFLG_HELCTR)==0 &&
                            (iflag & SweConst.SEFLG_BARYCTR)==0) {
                            dx[i] -= (xobs[i] - xobs[i+3]);
                        }
                    }
                    /* new dt */
                    dt = Math.sqrt(sl.square_sum(dx)) * SweConst.AUNIT / SwephData.CLIGHT /
                        86400.0;
                    for (i = 0; i <= 2; i++) {
                        xxsp[i] = xxsv[i] - dt * pdp.x[i+3];/* rough apparent position */
                    }
                }
                /* true position - apparent position at time t-1 */
                for (i = 0; i <= 2; i++) {
                    xxsp[i] = xxsv[i] - xxsp[i];
                }
            }
            /* dt and t(apparent) */
            for (j = 0; j <= niter; j++) {
                for (i = 0; i <= 2; i++) {
                    dx[i] = xx[i];
                    if ((iflag & SweConst.SEFLG_HELCTR)==0 &&
                        (iflag & SweConst.SEFLG_BARYCTR)==0) {
                        dx[i] -= xobs[i];
                    }
                }
                /* new dt */
                dt = Math.sqrt(sl.square_sum(dx)) *SweConst.AUNIT / SwephData.CLIGHT / 86400.0;
                dtsave_for_defl = dt;
                /* new position: subtract t * speed
                 */
                for (i = 0; i <= 2; i++) {
                    xx[i] = pdp.x[i] - dt * pdp.x[i+3];/**/
                    xx[i+3] = pdp.x[i+3];
                }
            }
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                /* part of daily motion resulting from change of dt */
                for (i = 0; i <= 2; i++) {
                    xxsp[i] = pdp.x[i] - xx[i] - xxsp[i];
                }
                t = pdp.teval - dt;
                /* for accuracy in speed, we will need earth as well */
                retc = main_planet_bary(t, SwephData.SEI_EARTH, epheflag, iflag,
                                        SwephData.NO_SAVE, xearth, xearth, xsun,
                                        xmoon, serr);
                if (smosh.swi_osc_el_plan(t, xx, ipl-SweConst.SE_FICT_OFFSET, ipli,
                                          xearth, xsun, serr) != SweConst.OK) {
                    return(SweConst.ERR);
                }
                if (retc != SweConst.OK) {
                    return(retc);
                }
                if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
                    if (swi_get_observer(t, iflag, SwephData.NO_SAVE, xobs2, serr) !=
                        SweConst.OK) {
                        return SweConst.ERR;
                    }
                    for (i = 0; i <= 5; i++) {
                        xobs2[i] += xearth[i];
                    }
                } else {
                    for (i = 0; i <= 5; i++) {
                        xobs2[i] = xearth[i];
                    }
                }
            }
        }
        /*******************************
         * conversion to geocenter     *
         *******************************/
        for (i = 0; i <= 5; i++) {
            xx[i] -= xobs[i];
        }
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0) {
            /*
             * Apparent speed is also influenced by
             * the change of dt during motion.
             * Neglect of this would result in an error of several 0.01"
             */
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                for (i = 3; i <= 5; i++) {
                    xx[i] -= xxsp[i-3];
                }
            }
        }
        if ((iflag & SweConst.SEFLG_SPEED)==0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        /************************************
         * relativistic deflection of light *
         ************************************/
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0 &&
            (iflag & SweConst.SEFLG_NOGDEFL)==0) {
            /* SEFLG_NOGDEFL is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
            swi_deflect_light(xx, 0, dtsave_for_defl, iflag);
        }
        /**********************************
         * 'annual' aberration of light   *
         **********************************/
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0 &&
            (iflag & SweConst.SEFLG_NOABERR)==0) {
            /* SEFLG_NOABERR is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
            swi_aberr_light(xx, xobs, iflag);
            /*
             * Apparent speed is also influenced by
             * the difference of speed of the earth between t and t-dt.
             * Neglecting this would involve an error of several 0.1"
             */
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                for (i = 3; i <= 5; i++) {
                    xx[i] += xobs[i] - xobs2[i];
                }
            }
        }
        /* save J2000 coordinates; required for sidereal positions */
        for (i = 0; i <= 5; i++) {
            xxsv[i] = xx[i];
        }
        /************************************************
         * precession, equator 2000 -> equator of date *
         ************************************************/
        if ((iflag & SweConst.SEFLG_J2000)==0) {
            sl.swi_precess(xx, pdp.teval, SwephData.J2000_TO_J);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(xx, pdp.teval, SwephData.J2000_TO_J);
            }
            oe = swed.oec;
        } else
            oe = swed.oec2000;
        return app_pos_rest(pdp, iflag, xx, xxsv, oe, serr);
    }

    /* influence of precession on speed
     * xx           position and speed of planet in equatorial cartesian
     *              coordinates */
    void swi_precess_speed(double xx[], double t, int direction) {
        swi_precess_speed(xx, 0, t, direction);
    }
    void swi_precess_speed(double xx[], int xOffs, double t, int direction) {
        Epsilon oe;
        double fac;
        double tprec = (t - SwephData.J2000) / 36525.0;
        if (direction == SwephData.J2000_TO_J) {
            fac = 1;
            oe = swed.oec;
        } else {
            fac = -1;
            oe = swed.oec2000;
        }
        /* first correct rotation.
         * this costs some sines and cosines, but neglect might
         * involve an error > 1"/day */
        sl.swi_precess(xx, 3+xOffs, t, direction);
        /* then add 0.137"/day */
        sl.swi_coortrf2(xx, xOffs, xx, xOffs, oe.seps, oe.ceps);
        sl.swi_coortrf2(xx, 3+xOffs, xx, 3+xOffs, oe.seps, oe.ceps);
        sl.swi_cartpol_sp(xx, xOffs, xx, xOffs);
        xx[3+xOffs] += (50.290966 + 0.0222226 * tprec) /
            3600 / 365.25 * SwissData.DEGTORAD * fac;
        /* formula from Montenbruck, German 1994, p. 18 */
        sl.swi_polcart_sp(xx, xOffs, xx, xOffs);
        sl.swi_coortrf2(xx, xOffs, xx, xOffs, -oe.seps, oe.ceps);
        sl.swi_coortrf2(xx, 3+xOffs, xx, 3+xOffs, -oe.seps, oe.ceps);
    }

    /* multiplies cartesian equatorial coordinates with previously
     * calculated nutation matrix. also corrects speed.
     */
    void swi_nutate(double xx[], int offs, int iflag, boolean backward) {
        int i;
        double x[]=new double[6], xv[]=new double[6];
        for (i = 0; i <= 2; i++) {
            if (backward) {
                x[i] = xx[0+offs] * swed.nut.matrix[i][0] +
                    xx[1+offs] * swed.nut.matrix[i][1] +
                    xx[2+offs] * swed.nut.matrix[i][2];
            } else {
                x[i] = xx[0+offs] * swed.nut.matrix[0][i] +
                    xx[1+offs] * swed.nut.matrix[1][i] +
                    xx[2+offs] * swed.nut.matrix[2][i];
            }
        }
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            /* correct speed:
             * first correct rotation */
            for (i = 0; i <= 2; i++) {
                if (backward) {
                    x[i+3] = xx[3+offs] * swed.nut.matrix[i][0] +
                        xx[4+offs] * swed.nut.matrix[i][1] +
                        xx[5+offs] * swed.nut.matrix[i][2];
                } else {
                    x[i+3] = xx[3+offs] * swed.nut.matrix[0][i] +
                        xx[4+offs] * swed.nut.matrix[1][i] +
                        xx[5+offs] * swed.nut.matrix[2][i];
                }
            }
            /* then apparent motion due to change of nutation during day.
             * this makes a difference of 0.01" */
            for (i = 0; i <= 2; i++) {
                if (backward) {
                    xv[i] = xx[0+offs] * swed.nutv.matrix[i][0] +
                        xx[1+offs] * swed.nutv.matrix[i][1] +
                        xx[2+offs] * swed.nutv.matrix[i][2];
                } else {
                    xv[i] = xx[0+offs] * swed.nutv.matrix[0][i] +
                        xx[1+offs] * swed.nutv.matrix[1][i] +
                        xx[2+offs] * swed.nutv.matrix[2][i];
                }
                /* new speed */
                xx[3+i+offs] = x[3+i] + (x[i] - xv[i]) / SwephData.NUT_SPEED_INTV;
            }
        }
        /* new position */
        for (i = 0; i <= 2; i++) {
            xx[i+offs] = x[i];
        }
    }

    /* computes 'annual' aberration
     * xx           planet's position accounted for light-time
     *              and gravitational light deflection
     * xe           earth's position and speed
     */
    void swi_aberr_light(double xx[], double xe[], int iflag) {
        swi_aberr_light(xx, 0, xe, iflag);
    }
    void swi_aberr_light(double xx[], int xxOffs, double xe[], int iflag) {
        int i;
        double xxs[]=new double[6], v[]=new double[6], u[]=new double[6], ru;
        double xx2[]=new double[6], dx1, dx2;
        double b_1, f1, f2;
        double v2;
        double intv = SwephData.PLAN_SPEED_INTV;
        for (i = 0; i <= 5; i++) {
            u[i] = xxs[i] = xx[i+xxOffs];
        }
        ru = Math.sqrt(sl.square_sum(u));
        for (i = 0; i <= 2; i++) {
            v[i] = xe[i+3] / 24.0 / 3600.0 / SwephData.CLIGHT * SweConst.AUNIT;
        }
        v2 = sl.square_sum(v);
        b_1 = Math.sqrt(1 - v2);
        f1 = dot_prod(u, v) / ru;
        f2 = 1.0 + f1 / (1.0 + b_1);
        for (i = 0; i <= 2; i++) {
            xx[i+xxOffs] = (b_1*xx[i+xxOffs] + f2*ru*v[i]) / (1.0 + f1);
        }
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            /* correction of speed
             * the influence of aberration on apparent velocity can
             * reach 0.4"/day
             */
            for (i = 0; i <= 2; i++) {
                u[i] = xxs[i] - intv * xxs[i+3];
            }
            ru = Math.sqrt(sl.square_sum(u));
            f1 = dot_prod(u, v) / ru;
            f2 = 1.0 + f1 / (1.0 + b_1);
            for (i = 0; i <= 2; i++) {
                xx2[i] = (b_1*u[i] + f2*ru*v[i]) / (1.0 + f1);
            }
            for (i = 0; i <= 2; i++) {
                dx1 = xx[i+xxOffs] - xxs[i];
                dx2 = xx2[i] - u[i];
                dx1 -= dx2;
                xx[i+3+xxOffs] += dx1 / intv;
            }
        }
    }

    /* computes relativistic light deflection by the sun
     * ipli         sweph internal planet number
     * xx           planet's position accounted for light-time
     * dt           dt of light-time
     */
    void swi_deflect_light(double xx[], int offs, double dt, int iflag) {
        int i;
        double xx2[]=new double[6];
        double u[]=new double[6], e[]=new double[6], q[]=new double[6];
        double ru, re, rq, uq, ue, qe, g1, g2;
        double xx3[]=new double[6], dx1, dx2, dtsp;
        double xsun[]=new double[6], xearth[]=new double[6];
        double sina, sin_sunr, meff_fact;
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        int iephe = pedp.iephe;
        for (i = 0; i <= 5; i++) {
            xearth[i] = pedp.x[i];
        }
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            for (i = 0; i <= 5; i++) {
                xearth[i] += swed.topd.xobs[i];
            }
        }
        /* U = planetbary(t-tau) - earthbary(t) = planetgeo */
        for (i = 0; i <= 2; i++) {
            u[i] = xx[i+offs];
        }
        /* Eh = earthbary(t) - sunbary(t) = earthhel */
        if (iephe == SweConst.SEFLG_JPLEPH || iephe == SweConst.SEFLG_SWIEPH) {
            for (i = 0; i <= 2; i++) {
                e[i] = xearth[i] - psdp.x[i];
            }
        } else {
            for (i = 0; i <= 2; i++) {
                e[i] = xearth[i];
            }
        }
        /* Q = planetbary(t-tau) - sunbary(t-tau) = 'planethel' */
        /* first compute sunbary(t-tau) for */
        if (iephe == SweConst.SEFLG_JPLEPH || iephe == SweConst.SEFLG_SWIEPH) {
            for (i = 0; i <= 2; i++) {
                /* this is sufficient precision */
                xsun[i] = psdp.x[i] - dt * psdp.x[i+3];
            }
            for (i = 3; i <= 5; i++) {
                xsun[i] = psdp.x[i];
            }
        } else {
            for (i = 0; i <= 5; i++) {
                xsun[i] = psdp.x[i];
            }
        }
        for (i = 0; i <= 2; i++) {
            q[i] = xx[i+offs] + xearth[i] - xsun[i];
        }
        ru = Math.sqrt(sl.square_sum(u));
        rq = Math.sqrt(sl.square_sum(q));
        re = Math.sqrt(sl.square_sum(e));
        for (i = 0; i <= 2; i++) {
            u[i] /= ru;
            q[i] /= rq;
            e[i] /= re;
        }
        uq = dot_prod(u,q);
        ue = dot_prod(u,e);
        qe = dot_prod(q,e);
        /* When a planet approaches the center of the sun in superior
         * conjunction, the formula for the deflection angle as given
         * in Expl. Suppl. p. 136 cannot be used. The deflection seems
         * to increase rapidly towards infinity. The reason is that the
         * formula considers the sun as a point mass. AA recommends to
         * set deflection = 0 in such a case.
         * However, to get a continous motion, we modify the formula
         * for a non-point-mass, taking into account the mass distribution
         * within the sun. For more info, s. meff().
         */
        sina = Math.sqrt(1 - ue * ue);      /* sin(angle) between sun and planet */
        sin_sunr = SwephData.SUN_RADIUS / re;   /* sine of sun radius (= sun radius) */
        if (sina < sin_sunr) {
            meff_fact = meff(sina / sin_sunr);
        } else {
            meff_fact = 1;
        }
        g1 = 2.0 * SwephData.HELGRAVCONST * meff_fact / SwephData.CLIGHT / SwephData.CLIGHT / SweConst.AUNIT / re;
        g2 = 1.0 + qe;
        /* compute deflected position */
        for (i = 0; i <= 2; i++) {
            xx2[i] = ru * (u[i] + g1/g2 * (uq * e[i] - ue * q[i]));
        }
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            /* correction of speed
             * influence of light deflection on a planet's apparent speed:
             * for an outer planet at the solar limb with
             * |v(planet) - v(sun)| = 1 degree, this makes a difference of 7"/day.
             * if the planet is within the solar disc, the difference may increase
             * to 30" or more.
             * e.g. mercury at j2434871.45:
             *  distance from sun               45"
             *  1. speed without deflection     2\xb310'10".4034
             *    2. speed with deflection        2\xb310'42".8460 (-speed flag)
             *    3. speed with deflection        2\xb310'43".4824 (< 3 positions/
             *                                                     -speed3 flag)
             * 3. is not very precise. Smaller dt would give result closer to 2.,
             * but will probably never be as good as 2, unless long doubles are
             * used. (try also j2434871.46!!)
             * however, in such a case speed changes rapidly. before being
             * passed by the sun, the planet accelerates, and after the sun
             * has passed it slows down. some time later it regains 'normal'
             * speed.
             * to compute speed, we do the same calculation as above with
             * slightly different u, e, q, and find out the difference in
             * deflection.
             */
            dtsp = -SwephData.DEFL_SPEED_INTV;
            /* U = planetbary(t-tau) - earthbary(t) = planetgeo */
            for (i = 0; i <= 2; i++) {
                u[i] = xx[i+offs] - dtsp * xx[i+3+offs];
            }
            /* Eh = earthbary(t) - sunbary(t) = earthhel */
            if (iephe == SweConst.SEFLG_JPLEPH || iephe == SweConst.SEFLG_SWIEPH) {
                for (i = 0; i <= 2; i++) {
                    e[i] = xearth[i] - psdp.x[i] - dtsp * (xearth[i+3] - psdp.x[i+3]);
                }
            } else {
                for (i = 0; i <= 2; i++) {
                    e[i] = xearth[i] - dtsp * xearth[i+3];
                }
            }
            /* Q = planetbary(t-tau) - sunbary(t-tau) = 'planethel' */
            for (i = 0; i <= 2; i++) {
                q[i] = u[i] + xearth[i] - xsun[i] - dtsp * (xearth[i+3] - xsun[i+3]);
            }
            ru = Math.sqrt(sl.square_sum(u));
            rq = Math.sqrt(sl.square_sum(q));
            re = Math.sqrt(sl.square_sum(e));
            for (i = 0; i <= 2; i++) {
                u[i] /= ru;
                q[i] /= rq;
                e[i] /= re;
            }
            uq = dot_prod(u,q);
            ue = dot_prod(u,e);
            qe = dot_prod(q,e);
            sina = Math.sqrt(1 - ue * ue);    /* sin(angle) between sun and planet */
            sin_sunr = SwephData.SUN_RADIUS / re; /* sine of sun radius (= sun radius) */
            if (sina < sin_sunr) {
                meff_fact = meff(sina / sin_sunr);
            } else {
                meff_fact = 1;
            }
            g1 = 2.0 * SwephData.HELGRAVCONST * meff_fact / SwephData.CLIGHT /
                SwephData.CLIGHT / SweConst.AUNIT / re;
            g2 = 1.0 + qe;
            for (i = 0; i <= 2; i++) {
                xx3[i] = ru * (u[i] + g1/g2 * (uq * e[i] - ue * q[i]));
            }
            for (i = 0; i <= 2; i++) {
                dx1 = xx2[i] - xx[i+offs];
                dx2 = xx3[i] - u[i] * ru;
                dx1 -= dx2;
                xx[i+3+offs] += dx1 / dtsp;
            }
        } /* endif speed */
        /* deflected position */
        for (i = 0; i <= 2; i++) {
            xx[i+offs] = xx2[i];
        }
    }

    /* converts the sun from barycentric to geocentric,
     *          the earth from barycentric to heliocentric
     * computes
     * apparent position,
     * precession, and nutation
     * according to flags
     * iflag        flags
     * serr         error string
     */
    int app_pos_etc_sun(int iflag, StringBuffer serr) {
        int i, j, niter, retc = SweConst.OK;
        int flg1, flg2;
        double xx[]=new double[6], xxsv[]=new double[6], dx[]=new double[3], dt, t;
        double xearth[]=new double[6], xsun[]=new double[6], xobs[]=new double[6];
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        Epsilon oe = swed.oec2000;
        /* if the same conversions have already been done for the same
         * date, then return */
        flg1 = iflag & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        flg2 = pedp.xflgs & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        if (flg1 == flg2) {
            pedp.xflgs = iflag;
            pedp.iephe = iflag & SweConst.SEFLG_EPHMASK;
            return SweConst.OK;
        }
        /************************************
         * observer: geocenter or topocenter
         ************************************/
        /* if topocentric position is wanted  */
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            if (swed.topd.teval != pedp.teval
                || swed.topd.teval == 0) {
                if (swi_get_observer(pedp.teval, iflag, SwephData.DO_SAVE, xobs, serr)
                    != SweConst.OK) {
                    return SweConst.ERR;
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = swed.topd.xobs[i];
                }
            }
            /* barycentric position of observer */
            for (i = 0; i <= 5; i++) {
                xobs[i] = xobs[i] + pedp.x[i];
            }
        } else {
            /* barycentric position of geocenter */
            for (i = 0; i <= 5; i++) {
                xobs[i] = pedp.x[i];
            }
        }
        /***************************************
         * true heliocentric position of earth *
         ***************************************/
        if (pedp.iephe == SweConst.SEFLG_MOSEPH ||
            (iflag & SweConst.SEFLG_BARYCTR)!=0) {
            for (i = 0; i <= 5; i++) {
                xx[i] = xobs[i];
            }
        } else {
            for (i = 0; i <= 5; i++) {
                xx[i] = xobs[i] - psdp.x[i];
            }
        }
        /*******************************
         * light-time                  *
         *******************************/
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0) {
            /* number of iterations - 1
             * the following if() does the following:
             * with jpl and swiss ephemeris:
             *   with geocentric computation of sun:
             *     light-time correction of barycentric sun position.
             *   with heliocentric or barycentric computation of earth:
             *     light-time correction of barycentric earth position.
             * with moshier ephemeris (heliocentric!!!):
             *   with geocentric computation of sun:
             *     nothing! (aberration will be done later)
             *   with heliocentric or barycentric computation of earth:
             *     light-time correction of heliocentric earth position.
             */
            if (pedp.iephe == SweConst.SEFLG_JPLEPH ||
                pedp.iephe == SweConst.SEFLG_SWIEPH ||
                (iflag & SweConst.SEFLG_HELCTR)!=0 ||
                (iflag & SweConst.SEFLG_BARYCTR)!=0) {
                for (i = 0; i <= 5; i++) {
                    xearth[i] = xobs[i];
                    if (pedp.iephe == SweConst.SEFLG_MOSEPH) {
                        xsun[i] = 0;
                    } else {
                        xsun[i] = psdp.x[i];
                    }
                }
                niter = 1;        /* # of iterations */
                for (j = 0; j <= niter; j++) {
                    /* distance earth-sun */
                    for (i = 0; i <= 2; i++) {
                        dx[i] = xearth[i];
                        if ((iflag & SweConst.SEFLG_BARYCTR)==0) {
                            dx[i] -= xsun[i];
                        }
                    }
                    /* new t */
                    dt = Math.sqrt(sl.square_sum(dx)) * SweConst.AUNIT / SwephData.CLIGHT /
                        86400.0;
                    t = pedp.teval - dt;
                    /* new position */
                    switch(pedp.iephe) {
                        /* if geocentric sun, new sun at t'
                         * if heliocentric or barycentric earth, new earth at t' */
                        case SweConst.SEFLG_JPLEPH:
                            if ((iflag & SweConst.SEFLG_HELCTR)!=0 ||
                                (iflag & SweConst.SEFLG_BARYCTR)!=0) {
                                retc = sj.swi_pleph(t, SwephJPL.J_EARTH, SwephJPL.J_SBARY, xearth, serr);
                            } else {
                                retc = sj.swi_pleph(t, SwephJPL.J_SUN, SwephJPL.J_SBARY, xsun, serr);
                            }
                            if (retc != SweConst.OK) {
                                sj.swi_close_jpl_file();
                                swed.jpl_file_is_open = false;
                                return(retc);
                            }
                            break;
                        case SweConst.SEFLG_SWIEPH:
                            /*
                              retc = sweph(t, SEI_SUN, SEI_FILE_PLANET, iflag, NULL, NO_SAVE, xearth, serr);
                            */
                            if ((iflag & SweConst.SEFLG_HELCTR)!=0 ||
                                (iflag & SweConst.SEFLG_BARYCTR)!=0) {
                                retc = sweplan(t, SwephData.SEI_EARTH,
                                               SwephData.SEI_FILE_PLANET, iflag,
                                               SwephData.NO_SAVE, xearth, null, xsun, null,
                                               serr);
                            } else {
                                retc = sweph(t, SwephData.SEI_SUNBARY,
                                             SwephData.SEI_FILE_PLANET, iflag, null,
                                             SwephData.NO_SAVE, xsun, serr);
                            }
                            break;
                        case SweConst.SEFLG_MOSEPH:
                            if ((iflag & SweConst.SEFLG_HELCTR)!=0 ||
                                (iflag & SweConst.SEFLG_BARYCTR)!=0) {
                                retc = smosh.swi_moshplan(t, SwephData.SEI_EARTH,
                                                          SwephData.NO_SAVE, xearth, xearth,
                                                          serr);
                            }
                            /* with moshier there is no barycentric sun */
                            break;
                        default:
                            retc = SweConst.ERR;
                            break;
                    }
                    if (retc != SweConst.OK) {
                        return(retc);
                    }
                }
                /* apparent heliocentric earth */
                for (i = 0; i <= 5; i++) {
                    xx[i] = xearth[i];
                    if ((iflag & SweConst.SEFLG_BARYCTR)==0) {
                        xx[i] -= xsun[i];
                    }
                }
            }
        }
        if ((iflag & SweConst.SEFLG_SPEED)==0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        /*******************************
         * conversion to geocenter     *
         *******************************/
        if ((iflag & SweConst.SEFLG_HELCTR)==0 &&
            (iflag & SweConst.SEFLG_BARYCTR)==0) {
            for (i = 0; i <= 5; i++) {
                xx[i] = -xx[i];
            }
        }
        /**********************************
         * 'annual' aberration of light   *
         **********************************/
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0 &&
            (iflag & SweConst.SEFLG_NOABERR)==0) {
            /* SEFLG_NOABERR is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
            swi_aberr_light(xx, xobs, iflag);
        }
        if ((iflag & SweConst.SEFLG_SPEED) == 0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        /* ICRS to J2000 */
        if ((iflag & SweConst.SEFLG_ICRS) == 0 && swed.jpldenum >= 403) {
            sl.swi_bias(xx, iflag, false);
        }/**/
        /* save J2000 coordinates; required for sidereal positions */
        for (i = 0; i <= 5; i++) {
            xxsv[i] = xx[i];
        }
        /************************************************
         * precession, equator 2000 -> equator of date *
         ************************************************/
        if ((iflag & SweConst.SEFLG_J2000)==0) {
            sl.swi_precess(xx, pedp.teval, SwephData.J2000_TO_J);/**/
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(xx, pedp.teval, SwephData.J2000_TO_J);/**/
            }
            oe = swed.oec;
        } else
            oe = swed.oec2000;
        return app_pos_rest(pedp, iflag, xx, xxsv, oe, serr);
    }

    /* transforms the position of the moon:
     * heliocentric position
     * barycentric position
     * astrometric position
     * apparent position
     * precession and nutation
     *
     * note:
     * for apparent positions, we consider the earth-moon
     * system as independant.
     * for astrometric positions (SEFLG_NOABERR), we
     * consider the motions of the earth and the moon
     * related to the solar system barycenter.
     */
    int app_pos_etc_moon(int iflag, StringBuffer serr) {
        int i;
        int flg1, flg2;
        double xx[]=new double[6], xxsv[]=new double[6], xobs[]=new double[6],
            xxm[]=new double[6], xs[]=new double[6], xe[]=new double[6],
            xobs2[]=new double[6], dt;
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        PlanData pdp = swed.pldat[SwephData.SEI_MOON];
        Epsilon oe = swed.oec;
        double t;
        int retc;
        /* if the same conversions have already been done for the same
         * date, then return */
        flg1 = iflag & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        flg2 = pdp.xflgs & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        if (flg1 == flg2) {
            pdp.xflgs = iflag;
            pdp.iephe = (iflag & SweConst.SEFLG_EPHMASK);
            return SweConst.OK;
        }
        /* the conversions will be done with xx[]. */
        for (i = 0; i <= 5; i++) {
            xx[i] = pdp.x[i];
            xxm[i] = xx[i];
        }
        /***********************************
         * to solar system barycentric
         ***********************************/
        for (i = 0; i <= 5; i++) {
            xx[i] += pedp.x[i];
        }
        /*******************************
         * observer
         *******************************/
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            if (swed.topd.teval != pdp.teval
                || swed.topd.teval == 0) {
                if (swi_get_observer(pdp.teval, iflag, SwephData.DO_SAVE, xobs, null) !=
                    SweConst.OK) {
                    return SweConst.ERR;
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = swed.topd.xobs[i];
                }
            }
            for (i = 0; i <= 5; i++) {
                xxm[i] -= xobs[i];
            }
            for (i = 0; i <= 5; i++) {
                xobs[i] += pedp.x[i];
            }
        } else if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
            for (i = 0; i <= 5; i++) {
                xobs[i] = 0;
            }
            for (i = 0; i <= 5; i++) {
                xxm[i] += pedp.x[i];
            }
        } else if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
            for (i = 0; i <= 5; i++) {
                xobs[i] = psdp.x[i];
            }
            for (i = 0; i <= 5; i++) {
                xxm[i] += pedp.x[i] - psdp.x[i];
            }
        } else {
            for (i = 0; i <= 5; i++) {
                xobs[i] = pedp.x[i];
            }
        }
        /*******************************
         * light-time                  *
         *******************************/
        if ((iflag & SweConst.SEFLG_TRUEPOS) == 0) {
            dt = Math.sqrt(sl.square_sum(xxm)) * SweConst.AUNIT /
                SwephData.CLIGHT / 86400.0;
            t = pdp.teval - dt;
            switch(pdp.iephe) {
                case SweConst.SEFLG_JPLEPH:
                    retc = sj.swi_pleph(t, SwephJPL.J_MOON, SwephJPL.J_EARTH, xx, serr);
                    if (retc == SweConst.OK) {
                        retc = sj.swi_pleph(t, SwephJPL.J_EARTH, SwephJPL.J_SBARY, xe, serr);
                    }
                    if (retc == SweConst.OK && (iflag & SweConst.SEFLG_HELCTR)!=0) {
                        retc = sj.swi_pleph(t, SwephJPL.J_SUN, SwephJPL.J_SBARY, xs, serr);
                    }
                    if (retc != SweConst.OK) {
                        sj.swi_close_jpl_file();
                        swed.jpl_file_is_open = false;
                    }
                    for (i = 0; i <= 5; i++) {
                        xx[i] += xe[i];
                    }
                    break;
                case SweConst.SEFLG_SWIEPH:
                    retc = sweplan(t, SwephData.SEI_MOON, SwephData.SEI_FILE_MOON, iflag, SwephData.NO_SAVE, xx, xe, xs, null, serr);
                    if (retc != SweConst.OK) {
                        return(retc);
                    }
                    for (i = 0; i <= 5; i++) {
                        xx[i] += xe[i];
                    }
                    break;
                case SweConst.SEFLG_MOSEPH:
                    /* this method results in an error of a milliarcsec in speed */
                    for (i = 0; i <= 2; i++) {
                        xx[i] -= dt * xx[i+3];
                        xe[i] = pedp.x[i] - dt * pedp.x[i+3];
                        xe[i+3] = pedp.x[i+3];
                        xs[i] = 0;
                        xs[i+3] = 0;
                    }
                    break;
            }
            if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
                if (swi_get_observer(t, iflag, SwephData.NO_SAVE, xobs2, null) !=
                    SweConst.OK) {
                    return SweConst.ERR;
                }
                for (i = 0; i <= 5; i++) {
                    xobs2[i] += xe[i];
                }
            } else if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
                for (i = 0; i <= 5; i++) {
                    xobs2[i] = 0;
                }
            } else if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
                for (i = 0; i <= 5; i++) {
                    xobs2[i] = xs[i];
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs2[i] = xe[i];
                }
            }
        }
        /*************************
         * to correct center
         *************************/
        for (i = 0; i <= 5; i++) {
            xx[i] -= xobs[i];
        }
        /**********************************
         * 'annual' aberration of light   *
         **********************************/
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0 &&
            (iflag & SweConst.SEFLG_NOABERR)==0) {
            /* SEFLG_NOABERR is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
            swi_aberr_light(xx, xobs, iflag);
            /*
             * Apparent speed is also influenced by
             * the difference of speed of the earth between t and t-dt.
             * Neglecting this would lead to an error of several 0.1"
             */
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                for (i = 3; i <= 5; i++) {
                    xx[i] += xobs[i] - xobs2[i];
                }
            }
        }
        /* if !speedflag, speed = 0 */
        if ((iflag & SweConst.SEFLG_SPEED)==0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        /* ICRS to J2000 */
        if ((iflag & SweConst.SEFLG_ICRS) == 0 && swed.jpldenum >= 403) {
            sl.swi_bias(xx, iflag, false);
        }/**/
        /* save J2000 coordinates; required for sidereal positions */
        for (i = 0; i <= 5; i++) {
            xxsv[i] = xx[i];
        }
        /************************************************
         * precession, equator 2000 -> equator of date *
         ************************************************/
        if ((iflag & SweConst.SEFLG_J2000) == 0) {
            sl.swi_precess(xx, pdp.teval, SwephData.J2000_TO_J);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(xx, pdp.teval, SwephData.J2000_TO_J);
            }
            oe = swed.oec;
        } else {
            oe = swed.oec2000;
        }
        return app_pos_rest(pdp, iflag, xx, xxsv, oe, serr);
    }

    /* transforms the position of the barycentric sun:
     * precession and nutation
     * according to flags
     * iflag        flags
     * serr         error string
     */
    int app_pos_etc_sbar(int iflag, StringBuffer serr) {
        int i;
        double xx[]=new double[6], xxsv[]=new double[6], dt;
        PlanData psdp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psbdp = swed.pldat[SwephData.SEI_SUNBARY];
        Epsilon oe = swed.oec;
        /* the conversions will be done with xx[]. */
        for (i = 0; i <= 5; i++) {
            xx[i] = psbdp.x[i];
        }
        /**************
         * light-time *
         **************/
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0) {
            dt = Math.sqrt(sl.square_sum(xx)) * SweConst.AUNIT / SwephData.CLIGHT / 86400.0;
            for (i = 0; i <= 2; i++) {
                xx[i] -= dt * xx[i+3];    /* apparent position */
            }
        }
        if ((iflag & SweConst.SEFLG_SPEED)==0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        /* ICRS to J2000 */
        if ((iflag & SweConst.SEFLG_ICRS) == 0 && swed.jpldenum >= 403) {
            sl.swi_bias(xx, iflag, false);
        }/**/
        /* save J2000 coordinates; required for sidereal positions */
        for (i = 0; i <= 5; i++) {
            xxsv[i] = xx[i];
        }
        /************************************************
         * precession, equator 2000 -> equator of date *
         ************************************************/
        if ((iflag & SweConst.SEFLG_J2000)==0) {
            sl.swi_precess(xx, psbdp.teval, SwephData.J2000_TO_J);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(xx, psbdp.teval, SwephData.J2000_TO_J);
            }
            oe = swed.oec;
        } else {
            oe = swed.oec2000;
        }
        return app_pos_rest(psdp, iflag, xx, xxsv, oe, serr);
    }

    /* transforms position of mean lunar node or apogee:
     * input is polar coordinates in mean ecliptic of date.
     * output is, according to iflag:
     * position accounted for light-time
     * position referred to J2000 (i.e. precession subtracted)
     * position with nutation
     * equatorial coordinates
     * cartesian coordinates
     * heliocentric position is not allowed ??????????????
     *         DAS WAERE ZIEMLICH AUFWENDIG. SONNE UND ERDE MUESSTEN
     *         SCHON VORHANDEN SEIN!
     * ipl          bodynumber (SE_MEAN_NODE or SE_MEAN_APOG)
     * iflag        flags
     * serr         error string
     */
    int app_pos_etc_mean(int ipl, int iflag, StringBuffer serr) {
        int i;
        int flg1, flg2;
        double xx[]=new double[6], xxsv[]=new double[6];
        PlanData pdp = swed.nddat[ipl];
        Epsilon oe;
        /* if the same conversions have already been done for the same
         * date, then return */
        flg1 = iflag & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        flg2 = pdp.xflgs & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        if (flg1 == flg2) {
            pdp.xflgs = iflag;
            pdp.iephe = iflag & SweConst.SEFLG_EPHMASK;
            return SweConst.OK;
        }
        for (i = 0; i <= 5; i++) {
            xx[i] = pdp.x[i];
        }
        /* cartesian equatorial coordinates */
        sl.swi_polcart_sp(xx, xx);
        sl.swi_coortrf2(xx, xx, -swed.oec.seps, swed.oec.ceps);
        sl.swi_coortrf2(xx, 3, xx, 3, -swed.oec.seps, swed.oec.ceps);
        if ((iflag & SweConst.SEFLG_SPEED)==0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        /* J2000 coordinates; required for sidereal positions */
        if (((iflag & SweConst.SEFLG_SIDEREAL)!=0
             && (swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0)
            || (swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
            for (i = 0; i <= 5; i++) {
                xxsv[i] = xx[i];
            }
            /* xxsv is not J2000 yet! */
            if (pdp.teval != SwephData.J2000) {
                sl.swi_precess(xxsv, pdp.teval, SwephData.J_TO_J2000);
                if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                    swi_precess_speed(xxsv, pdp.teval, SwephData.J_TO_J2000);
                }
            }
        }
        /*****************************************************
         * if no precession, equator of date -> equator 2000 *
         *****************************************************/
        if ((iflag & SweConst.SEFLG_J2000)!=0) {
            sl.swi_precess(xx, pdp.teval, SwephData.J_TO_J2000);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(xx, pdp.teval, SwephData.J_TO_J2000);
            }
            oe = swed.oec2000;
        } else {
            oe = swed.oec;
        }
        return app_pos_rest(pdp, iflag, xx, xxsv, oe, serr);
    }

    /* SWISSEPH
     * adds reference orbit to chebyshew series (if SEI_FLG_ELLIPSE),
     * rotates series to mean equinox of J2000
     *
     * ipli         planet number
     */
    void rot_back(int ipli) {
        int i;
        double t, tdiff;
        double qav, pav, dn;
        double omtild, com, som, cosih2;
        double x[][]=new double[SwephData.MAXORD+1][3];
        double uix[]=new double[3], uiy[]=new double[3], uiz[]=new double[3];
        double xrot, yrot, zrot;
        double chcfx[];
        double refepx[];
        double seps2000 = swed.oec2000.seps;
        double ceps2000 = swed.oec2000.ceps;
        PlanData pdp = swed.pldat[ipli];
        int nco = pdp.ncoe;
        int chcfyOffs;
        int chcfzOffs;
        int refepyOffs;
        t = pdp.tseg0 + pdp.dseg / 2;
        chcfx = pdp.segp;
        chcfyOffs = nco;
        chcfzOffs = 2 * nco;
        refepx = pdp.refep;
        refepyOffs = nco;
        tdiff= (t - pdp.telem) / 365250.0;
        if (ipli == SwephData.SEI_MOON) {
            dn = pdp.prot + tdiff * pdp.dprot;
            i = (int) (dn / SwephData.TWOPI);
            dn -= i * SwephData.TWOPI;
            qav = (pdp.qrot + tdiff * pdp.dqrot) * Math.cos(dn);
            pav = (pdp.qrot + tdiff * pdp.dqrot) * Math.sin(dn);
        } else {
            qav = pdp.qrot + tdiff * pdp.dqrot;
            pav = pdp.prot + tdiff * pdp.dprot;
        }
        /*calculate cosine and sine of average perihelion longitude. */
        for (i = 0; i < nco; i++) {
            x[i][0] = chcfx[i];
            x[i][1] = chcfx[i+chcfyOffs];
            x[i][2] = chcfx[i+chcfzOffs];
        }
        if ((pdp.iflg & SwephData.SEI_FLG_ELLIPSE)!=0) {
            omtild = pdp.peri + tdiff * pdp.dperi;
            i = (int) (omtild / SwephData.TWOPI);
            omtild -= i * SwephData.TWOPI;
            com = Math.cos(omtild);
            som = Math.sin(omtild);
            /*add reference orbit.  */
            for (i = 0; i < nco; i++) {
                x[i][0] = chcfx[i] + com * refepx[i] - som * refepx[i+refepyOffs];
                x[i][1] = chcfx[i+chcfyOffs] + com * refepx[i+refepyOffs] + som * refepx[i];
            }
        }
        /* construct right handed orthonormal system with first axis along
           origin of longitudes and third axis along angular momentum
           this uses the standard formulas for equinoctal variables
           (see papers by broucke and by cefola).      */
        cosih2 = 1.0 / (1.0 + qav * qav + pav * pav);
        /*     calculate orbit pole. */
        uiz[0] = 2.0 * pav * cosih2;
        uiz[1] = -2.0 * qav * cosih2;
        uiz[2] = (1.0 - qav * qav - pav * pav) * cosih2;
        /*     calculate origin of longitudes vector. */
        uix[0] = (1.0 + qav * qav - pav * pav) * cosih2;
        uix[1] = 2.0 * qav * pav * cosih2;
        uix[2] = -2.0 * pav * cosih2;
        /*     calculate vector in orbital plane orthogonal to origin of
               longitudes.                                               */
        uiy[0] =2.0 * qav * pav * cosih2;
        uiy[1] =(1.0 - qav * qav + pav * pav) * cosih2;
        uiy[2] =2.0 * qav * cosih2;
        /*     rotate to actual orientation in space.         */
        for (i = 0; i < nco; i++) {
            xrot = x[i][0] * uix[0] + x[i][1] * uiy[0] + x[i][2] * uiz[0];
            yrot = x[i][0] * uix[1] + x[i][1] * uiy[1] + x[i][2] * uiz[1];
            zrot = x[i][0] * uix[2] + x[i][1] * uiy[2] + x[i][2] * uiz[2];
            if (Math.abs(xrot) + Math.abs(yrot) + Math.abs(zrot) >= 1e-14) {
                pdp.neval = i;
            }
            x[i][0] = xrot;
            x[i][1] = yrot;
            x[i][2] = zrot;
            if (ipli == SwephData.SEI_MOON) {
                /* rotate to j2000 equator */
                x[i][1] = ceps2000 * yrot - seps2000 * zrot;
                x[i][2] = seps2000 * yrot + ceps2000 * zrot;
            }
        }
        for (i = 0; i < nco; i++) {
            chcfx[i] = x[i][0];
            chcfx[i+chcfyOffs] = x[i][1];
            chcfx[i+chcfzOffs] = x[i][2];
        }
    }

    /* Adjust position from Earth-Moon barycenter to Earth
     *
     * xemb = hel./bar. position or velocity vectors of emb (input)
     *                                                  earth (output)
     * xmoon= geocentric position or velocity vector of moon
     */
    void embofs(double xemb[], int eOffs, double xmoon[], int mOffs) {
        int i;
        for (i = 0; i <= 2; i++) {
            xemb[i+eOffs] -= xmoon[i+mOffs] / (SwephData.EARTH_MOON_MRAT + 1.0);
        }
    }

    /* calculates the nutation matrix
     * nu           pointer to nutation data structure
     * oe           pointer to epsilon data structure
     */
    void nut_matrix(Nut nu, Epsilon oe) {
        double psi, eps;
        double sinpsi, cospsi, sineps, coseps, sineps0, coseps0;
        psi = nu.nutlo[0];
        eps = oe.eps + nu.nutlo[1];
        sinpsi = Math.sin(psi);
        cospsi = Math.cos(psi);
        sineps0 = oe.seps;
        coseps0 = oe.ceps;
        sineps = Math.sin(eps);
        coseps = Math.cos(eps);
        nu.matrix[0][0] = cospsi;
        nu.matrix[0][1] = sinpsi * coseps;
        nu.matrix[0][2] = sinpsi * sineps;
        nu.matrix[1][0] = -sinpsi * coseps0;
        nu.matrix[1][1] = cospsi * coseps * coseps0 + sineps * sineps0;
        nu.matrix[1][2] = cospsi * sineps * coseps0 - coseps * sineps0;
        nu.matrix[2][0] = -sinpsi * sineps0;
        nu.matrix[2][1] = cospsi * coseps * sineps0 - sineps * coseps0;
        nu.matrix[2][2] = cospsi * sineps * sineps0 + coseps * coseps0;
    }

    /* lunar osculating elements, i.e.
     * osculating node ('true' node) and
     * osculating apogee ('black moon', 'lilith').
     * tjd          julian day
     * ipl          body number, i.e. SEI_TRUE_NODE or SEI_OSCU_APOG
     * iflag        flags (which ephemeris, nutation, etc.)
     * serr         error string
     *
     * definitions and remarks:
     * the osculating node and the osculating apogee are defined
     * as the orbital elements of the momentary lunar orbit.
     * their advantage is that when the moon crosses the ecliptic,
     * it is really at the osculating node, and when it passes
     * its greatest distance from earth it is really at the
     * osculating apogee. with the mean elements this is not
     * the case. (some define the apogee as the second focus of
     * the lunar ellipse. but, as seen from the geocenter, both
     * points are in the same direction.)
     * problems:
     * the osculating apogee is given in the 'New International
     * Ephemerides' (Editions St. Michel) as the 'True Lilith'.
     * however, this name is misleading. this point is based on
     * the idea that the lunar orbit can be approximated by an
     * ellipse.
     * arguments against this:
     * 1. this procedure considers celestial motions as two body
     *    problems. this is quite good for planets, but not for
     *    the moon. the strong gravitational attraction of the sun
     *    destroys the idea of an ellipse.
     * 2. the NIE 'True Lilith' has strong oscillations around the
     *    mean one with an amplitude of about 30 degrees. however,
     *    when the moon is in apogee, its distance from the mean
     *    apogee never exceeds 5 degrees.
     * besides, the computation of NIE is INACCURATE. the mistake
     * reaches 20 arc minutes.
     * According to Santoni, the point was calculated using 'les 58
     * premiers termes correctifs au Perigee moyen' published by
     * Chapront and Chapront-Touze. And he adds: "Nous constatons
     * que meme en utilisant ces 58 termes CORRECTIFS, l'erreur peut
     * atteindre 0,5d!" (p. 13) We avoid this error, computing the
     * orbital elements directly from the position and the speed vector.
     *
     * how about the node? it is less problematic, because we
     * we needn't derive it from an orbital ellipse. we can say:
     * the axis of the osculating nodes is the intersection line of
     * the actual orbital plane of the moon and the plane of the
     * ecliptic. or: the osculating nodes are the intersections of
     * the two great circles representing the momentary apparent
     * orbit of the moon and the ecliptic. in this way they make
     * some sense. then, the nodes are really an axis, and they
     * have no geocentric distance. however, in this routine
     * we give a distance derived from the osculating ellipse.
     * the node could also be defined as the intersection axis
     * of the lunar orbital plane and the solar orbital plane,
     * which is not precisely identical to the ecliptic. this
     * would make a difference of several arcseconds.
     *
     * is it possible to keep the idea of a continuously moving
     * apogee that is exact at the moment when the moon passes
     * its greatest distance from earth?
     * to achieve this, we would probably have to interpolate between
     * the actual apogees.
     * the nodes could also be computed by interpolation. the resulting
     * nodes would deviate from the so-called 'true node' by less than
     * 30 arc minutes.
     *
     * sidereal and j2000 true node are first computed for the ecliptic
     * of epoch and then precessed to ecliptic of t0(ayanamsa) or J2000.
     * there is another procedure that computes the node for the ecliptic
     * of t0(ayanamsa) or J2000. it is excluded by
     * #ifdef SID_TNODE_FROM_ECL_T0
     */
    private int lunar_osc_elem(double tjd, int ipl, int iflag, StringBuffer serr) {
        int i, j, istart;
        int ipli = SwephData.SEI_MOON;
        int epheflag = SweConst.SEFLG_DEFAULTEPH;
        int retc = SweConst.ERR;
        int flg1, flg2;
        PlanData ndp, ndnp, ndap;
        Epsilon oe;
        double speed_intv = SwephData.NODE_CALC_INTV;   /* to silence gcc warning */
        double a, b;
        double xpos[][]=new double[3][6], xx[][]=new double[3][6],
            xxa[][]=new double[3][6];
        double xp[];
        double xnorm[]=new double[6], r[]=new double[6];
        double rxy, rxyz, t, dt, fac, sgn;
        double sinnode, cosnode, sinincl, cosincl, sinu, cosu, sinE, cosE;
        double uu, ny, sema, ecce, Gmsm, c2, v2, pp;
        int speedf1, speedf2;
        oe = swed.oec;
        ndp = swed.nddat[ipl];
        /* if elements have already been computed for this date, return
         * if speed flag has been turned on, recompute */
        flg1 = iflag & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        flg2 = ndp.xflgs & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        speedf1 = ndp.xflgs & SweConst.SEFLG_SPEED;
        speedf2 = iflag & SweConst.SEFLG_SPEED;
        if (tjd == ndp.teval
            && tjd != 0
            && flg1 == flg2
            && ((speedf2==0) || (speedf1!=0))) {
            ndp.xflgs = iflag;
            ndp.iephe = iflag & SweConst.SEFLG_EPHMASK;
            return SweConst.OK;
        }
        /* the geocentric position vector and the speed vector of the
         * moon make up the lunar orbital plane. the position vector
         * of the node is along the intersection line of the orbital
         * plane and the plane of the ecliptic.
         * to calculate the osculating node, we need one lunar position
         * with speed.
         * to calculate the speed of the osculating node, we need
         * three lunar positions and the speed of each of them.
         * this is relatively cheap, if the jpl-moon or the swisseph
         * moon is used. with the moshier moon this is much more
         * expensive, because then we need 9 lunar positions for
         * three speeds. but one position and speed can normally
         * be taken from swed.pldat[moon], which corresponds to
         * three moshier moon calculations.
         * the same is also true for the osculating apogee: we need
         * three lunar positions and speeds.
         */
        /*********************************************
         * now three lunar positions with speeds     *
         *********************************************/
        if ((iflag & SweConst.SEFLG_MOSEPH)!=0) {
            epheflag = SweConst.SEFLG_MOSEPH;
        } else if ((iflag & SweConst.SEFLG_SWIEPH)!=0) {
            epheflag = SweConst.SEFLG_SWIEPH;
        } else if ((iflag & SweConst.SEFLG_JPLEPH)!=0) {
            epheflag = SweConst.SEFLG_JPLEPH;
        }
        /* there may be a moon of wrong ephemeris in save area
         * force new computation: */
        swed.pldat[SwephData.SEI_MOON].teval = 0;
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            istart = 0;
        } else {
            istart = 2;
        }
        if (serr != null) {
            serr.setLength(0);
        }
        //  three_positions:
        do {
            switch(epheflag) {
                case SweConst.SEFLG_JPLEPH:
                    speed_intv = SwephData.NODE_CALC_INTV;
                    for (i = istart; i <= 2; i++) {
                        if (i == 0) {
                            t = tjd - speed_intv;
                        } else if (i == 1) {
                            t = tjd + speed_intv;
                        } else {
                            t = tjd;
                        }
                        xp = xpos[i];
                        retc = jplplan(t, ipli, iflag, SwephData.NO_SAVE, xp, null, null,
                                       serr);
                        /* read error or corrupt file */
                        if (retc == SweConst.ERR) {
                            return(SweConst.ERR);
                        }
                        /* light-time-corrected moon for apparent node
                         * this makes a difference of several milliarcseconds with
                         * the node and 0.1" with the apogee.
                         * the simple formual 'x[j] -= dt * speed' should not be
                         * used here. the error would be greater than the advantage
                         * of computation speed. */
                        if ((iflag & SweConst.SEFLG_TRUEPOS) == 0 && retc >= SweConst.OK) {
                            dt = Math.sqrt(sl.square_sum(xpos[i])) * SweConst.AUNIT /
                                SwephData.CLIGHT / 86400.0;
                            retc = jplplan(t-dt, ipli, iflag, SwephData.NO_SAVE, xpos[i],
                                           null, null, serr); /**/
                            /* read error or corrupt file */
                            if (retc == SweConst.ERR) {
                                return(SweConst.ERR);
                            }
                        }
                        /* jpl ephemeris not on disk, or date beyond ephemeris range */
                        if (retc == SwephData.NOT_AVAILABLE) {
                            iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_SWIEPH;
                            epheflag = SweConst.SEFLG_SWIEPH;
                            if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                                serr.append(" \ntrying Swiss Eph; ");
                            }
                            break;
                        } else if (retc == SwephData.BEYOND_EPH_LIMITS) {
                            if (tjd > SwephData.MOSHLUEPH_START &&
                                tjd < SwephData.MOSHLUEPH_END) {
                                iflag = (iflag & ~SweConst.SEFLG_JPLEPH) |
                                    SweConst.SEFLG_MOSEPH;
                                epheflag = SweConst.SEFLG_MOSEPH;
                                if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                                    serr.append(" \nusing Moshier Eph; ");
                                }
                                break;
                            } else
                                return SweConst.ERR;
                        }
                        /* precession and nutation etc. */
                        retc = swi_plan_for_osc_elem(iflag|SweConst.SEFLG_SPEED, t, xpos[i]); /* retc is always ok */

                    }
                    break;
                case SweConst.SEFLG_SWIEPH:
                    speed_intv = SwephData.NODE_CALC_INTV;
                    for (i = istart; i <= 2; i++) {
                        if (i == 0) {
                            t = tjd - speed_intv;
                        } else if (i == 1) {
                            t = tjd + speed_intv;
                        } else {
                            t = tjd;
                        }
                        retc = swemoon(t, iflag | SweConst.SEFLG_SPEED, SwephData.NO_SAVE,
                                       xpos[i], serr);/**/
                        if (retc == SweConst.ERR) {
                            return(SweConst.ERR);
                        }
                        /* light-time-corrected moon for apparent node (~ 0.006") */
                        if ((iflag & SweConst.SEFLG_TRUEPOS) == 0 && retc >= SweConst.OK) {
                            dt = Math.sqrt(sl.square_sum(xpos[i])) * SweConst.AUNIT /
                                SwephData.CLIGHT / 86400.0;
                            retc = swemoon(t-dt, iflag | SweConst.SEFLG_SPEED,
                                           SwephData.NO_SAVE, xpos[i], serr);/**/
                            if (retc == SweConst.ERR) {
                                return(SweConst.ERR);
                            }
                        }
                        if (retc == SwephData.NOT_AVAILABLE) {
                            if (tjd > SwephData.MOSHPLEPH_START &&
                                tjd < SwephData.MOSHPLEPH_END) {
                                iflag = (iflag & ~SweConst.SEFLG_SWIEPH) | SweConst.SEFLG_MOSEPH;
                                epheflag = SweConst.SEFLG_MOSEPH;
                                if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                                    serr.append(" \nusing Moshier eph.; ");
                                }
                                break;
                            } else
                                return SweConst.ERR;
                        }
                        /* precession and nutation etc. */
                        retc = swi_plan_for_osc_elem(iflag|SweConst.SEFLG_SPEED, t, xpos[i]); /* retc is always ok */
                    }
                    break;
                case SweConst.SEFLG_MOSEPH:
                    /* with moshier moon, we need a greater speed_intv, because here the
                     * node and apogee oscillate wildly within small intervals */
                    speed_intv = SwephData.NODE_CALC_INTV_MOSH;
                    for (i = istart; i <= 2; i++) {
                        if (i == 0) {
                            t = tjd - speed_intv;
                        } else if (i == 1) {
                            t = tjd + speed_intv;
                        } else {
                            t = tjd;
                        }
                        retc = sm.swi_moshmoon(t, SwephData.NO_SAVE, xpos[i], serr);/**/
                        if (retc == SweConst.ERR) {
                            return(retc);
                        }
                        /* precession and nutation etc. */
                        retc = swi_plan_for_osc_elem(iflag|SweConst.SEFLG_SPEED, t, xpos[i]); /* retc is always ok */

                    }
                    break;
                default:
                    break;
            }
        } while (retc == SwephData.NOT_AVAILABLE || retc == SwephData.BEYOND_EPH_LIMITS);
        //    goto three_positions;
        /*********************************************
         * node with speed                           *
         *********************************************/
        /* node is always needed, even if apogee is wanted */
        ndnp = swed.nddat[SwephData.SEI_TRUE_NODE];
        /* three nodes */
        for (i = istart; i <= 2; i++) {
            if (Math.abs(xpos[i][5]) < 1e-15) {
                xpos[i][5] = 1e-15;
            }
            fac = xpos[i][2] / xpos[i][5];
            sgn = xpos[i][5] / Math.abs(xpos[i][5]);
            for (j = 0; j <= 2; j++) {
                xx[i][j] = (xpos[i][j] - fac * xpos[i][j+3]) * sgn;
            }
        }
        /* now we have the correct direction of the node, the
         * intersection of the lunar plane and the ecliptic plane.
         * the distance is the distance of the point where the tangent
         * of the lunar motion penetrates the ecliptic plane.
         * this can be very large, e.g. j2415080.37372.
         * below, a new distance will be derived from the osculating
         * ellipse.
         */
        /* save position and speed */
        for (i = 0; i <= 2; i++) {
            ndnp.x[i] = xx[2][i];
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                b = (xx[1][i] - xx[0][i]) / 2;
                a = (xx[1][i] + xx[0][i]) / 2 - xx[2][i];
                ndnp.x[i+3] = (2 * a + b) / speed_intv;
            } else
                ndnp.x[i+3] = 0;
            ndnp.teval = tjd;
            ndnp.iephe = epheflag;
        }
        /************************************************************
         * apogee with speed                                        *
         * must be computed anyway to get the node's distance       *
         ************************************************************/
        ndap = swed.nddat[SwephData.SEI_OSCU_APOG];
        Gmsm = SwephData.GEOGCONST * (1 + 1 / SwephData.EARTH_MOON_MRAT) /
            SweConst.AUNIT/SweConst.AUNIT/SweConst.AUNIT*86400.0*86400.0;
        /* three apogees */
        for (i = istart; i <= 2; i++) {
            /* node */
            rxy =  Math.sqrt(xx[i][0] * xx[i][0] + xx[i][1] * xx[i][1]);
            cosnode = xx[i][0] / rxy;
            sinnode = xx[i][1] / rxy;
            /* inclination */
            sl.swi_cross_prod(xpos[i], 0, xpos[i], 3, xnorm, 0);
            rxy =  xnorm[0] * xnorm[0] + xnorm[1] * xnorm[1];
            c2 = (rxy + xnorm[2] * xnorm[2]);
            rxyz = Math.sqrt(c2);
            rxy = Math.sqrt(rxy);
            sinincl = rxy / rxyz;
            cosincl = Math.sqrt(1 - sinincl * sinincl);
            /* argument of latitude */
            cosu = xpos[i][0] * cosnode + xpos[i][1] * sinnode;
            sinu = xpos[i][2] / sinincl;
            uu = Math.atan2(sinu, cosu);
            /* semi-axis */
            rxyz = Math.sqrt(sl.square_sum(xpos[i]));
            v2 = sl.square_sum(xpos[i], 3);
            sema = 1 / (2 / rxyz - v2 / Gmsm);
            /* eccentricity */
            pp = c2 / Gmsm;
            ecce = Math.sqrt(1 - pp / sema);
            /* eccentric anomaly */
            cosE = 1 / ecce * (1 - rxyz / sema);
            sinE = 1 / ecce / Math.sqrt(sema * Gmsm) * dot_prod(xpos[i], xpos[i], 3);
            /* true anomaly */
            ny = 2 * Math.atan(Math.sqrt((1+ecce)/(1-ecce)) * sinE / (1 + cosE));
            /* distance of apogee from ascending node */
            xxa[i][0] = sl.swi_mod2PI(uu - ny + SwephData.PI);
            xxa[i][1] = 0;                      /* latitude */
            xxa[i][2] = sema * (1 + ecce);      /* distance */
            /* transformation to ecliptic coordinates */
            sl.swi_polcart(xxa[i], xxa[i]);
            sl.swi_coortrf2(xxa[i], xxa[i], -sinincl, cosincl);
            sl.swi_cartpol(xxa[i], xxa[i]);
            /* adding node, we get apogee in ecl. coord. */
            xxa[i][0] += Math.atan2(sinnode, cosnode);
            sl.swi_polcart(xxa[i], xxa[i]);
            /* new distance of node from orbital ellipse:
             * true anomaly of node: */
            ny = sl.swi_mod2PI(ny - uu);
            /* eccentric anomaly */
            cosE = Math.cos(2 * Math.atan(Math.tan(ny / 2) / Math.sqrt((1+ecce) / (1-ecce))));
            /* new distance */
            r[0] = sema * (1 - ecce * cosE);
            /* old node distance */
            r[1] = Math.sqrt(sl.square_sum(xx[i]));
            /* correct length of position vector */
            for (j = 0; j <= 2; j++) {
                xx[i][j] *= r[0] / r[1];
            }
        }
        /* save position and speed */
        for (i = 0; i <= 2; i++) {
            /* apogee */
            ndap.x[i] = xxa[2][i];
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                ndap.x[i+3] = (xxa[1][i] - xxa[0][i]) / speed_intv / 2;
            } else {
                ndap.x[i+3] = 0;
            }
            ndap.teval = tjd;
            ndap.iephe = epheflag;
            /* node */
            ndnp.x[i] = xx[2][i];
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                ndnp.x[i+3] = (xx[1][i] - xx[0][i]) / speed_intv / 2;/**/
            } else {
                ndnp.x[i+3] = 0;
            }
        }
        /**********************************************************************
         * precession and nutation have already been taken into account
         * because the computation is on the basis of lunar positions
         * that have gone through swi_plan_for_osc_elem.
         * light-time is already contained in lunar positions.
         * now compute polar and equatorial coordinates:
         **********************************************************************/
        double[] x=new double[6];
        for (j = 0; j <= 1; j++) {
            if (j == 0) {
                ndp = swed.nddat[SwephData.SEI_TRUE_NODE];
            } else {
                ndp = swed.nddat[SwephData.SEI_OSCU_APOG];
            }
            //  memset((void *) ndp.xreturn, 0, 24 * sizeof(double));
            for (int z=0; z<ndp.xreturn.length; z++) { ndp.xreturn[z]=0.0; }
            /* cartesian ecliptic */
            for (i = 0; i <= 5; i++) {
                ndp.xreturn[6+i] = ndp.x[i];
            }
            /* polar ecliptic */
            sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
            /* cartesian equatorial */
            sl.swi_coortrf2(ndp.xreturn, 6, ndp.xreturn, 18, -oe.seps, oe.ceps);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                sl.swi_coortrf2(ndp.xreturn, 9, ndp.xreturn, 21, -oe.seps, oe.ceps);
            }
            if ((iflag & SweConst.SEFLG_NONUT) == 0) {
                sl.swi_coortrf2(ndp.xreturn, 18, ndp.xreturn, 18, -swed.nut.snut,
                                swed.nut.cnut);
                if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                    sl.swi_coortrf2(ndp.xreturn, 21, ndp.xreturn, 21, -swed.nut.snut,
                                    swed.nut.cnut);
                }
            }
            /* polar equatorial */
            sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
            ndp.xflgs = iflag;
            ndp.iephe = iflag & SweConst.SEFLG_EPHMASK;
            if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
                /* node and apogee are referred to t;
                 * the ecliptic position must be transformed to t0 */
                /* rigorous algorithm */
                if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0
                    || (swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
                    for (i = 0; i <= 5; i++) {
                        x[i] = ndp.xreturn[18+i];
                    }
                    /* remove nutation */
                    if ((iflag & SweConst.SEFLG_NONUT)==0) {
                        swi_nutate(x, 0, iflag, true);
                    }
                    /* precess to J2000 */
                    sl.swi_precess(x, tjd, SwephData.J_TO_J2000);
                    if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                        swi_precess_speed(x, tjd, SwephData.J_TO_J2000);
                    }
                    if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0) {
                        swi_trop_ra2sid_lon(x, ndp.xreturn, 6, ndp.xreturn, 18, iflag,
                                            null);
                        /* project onto solar system equator */
                    } else if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
                        swi_trop_ra2sid_lon_sosy(x, ndp.xreturn, 6, ndp.xreturn, 18, iflag,
                                                 null);
                    }
                    /* to polar */
                    sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
                    sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
                    /* traditional algorithm;
                     * this is a bit clumsy, but allows us to keep the
                     * sidereal code together */
                } else {
                    sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
                    ndp.xreturn[0] -= swe_get_ayanamsa(ndp.teval) * SwissData.DEGTORAD;
                    sl.swi_polcart_sp(ndp.xreturn, 0, ndp.xreturn, 6);
                }
            } else if ((iflag & SweConst.SEFLG_J2000)!=0) {
                /* node and apogee are referred to t;
                 * the ecliptic position must be transformed to J2000 */
                for (i = 0; i <= 5; i++) {
                    x[i] = ndp.xreturn[18+i];
                }
                /* precess to J2000 */
                sl.swi_precess(x, tjd, SwephData.J_TO_J2000);
                if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                    swi_precess_speed(x, tjd, SwephData.J_TO_J2000);
                }
                for (i = 0; i <= 5; i++) {
                    ndp.xreturn[18+i] = x[i];
                }
                sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
                sl.swi_coortrf2(ndp.xreturn, 18, ndp.xreturn, 6, swed.oec2000.seps,
                                swed.oec2000.ceps);
                if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                    sl.swi_coortrf2(ndp.xreturn, 21, ndp.xreturn, 9, swed.oec2000.seps,
                                    swed.oec2000.ceps);
                }
                sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
            }
            /**********************
             * radians to degrees *
             **********************/
            /*if (!(iflag & SEFLG_RADIANS)) {*/
            for (i = 0; i < 2; i++) {
                ndp.xreturn[i] *= SwissData.RADTODEG;              /* ecliptic */
                ndp.xreturn[i+3] *= SwissData.RADTODEG;
                ndp.xreturn[i+12] *= SwissData.RADTODEG;   /* equator */
                ndp.xreturn[i+15] *= SwissData.RADTODEG;
            }
            ndp.xreturn[0] = sl.swe_degnorm(ndp.xreturn[0]);
            ndp.xreturn[12] = sl.swe_degnorm(ndp.xreturn[12]);
            /*}*/
        }
        return SweConst.OK;
    }

    /* lunar osculating elements, i.e.
     */ 
    private int intp_apsides(double tjd, int ipl, int iflag, StringBuffer serr) {
        int i;
        int flg1, flg2;
        PlanData ndp;
        Epsilon oe;
        Nut nut;
        double speed_intv = 0.1;
        double t, dt;
        double xpos[][] = new double[3][6], xx[] = new double[6], x[] = new double[6];
        int speedf1, speedf2;
        oe = swed.oec;
        nut = swed.nut;
        ndp = swed.nddat[ipl];
        /* if same calculation was done before, return
         * if speed flag has been turned on, recompute */
        flg1 = iflag & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        flg2 = ndp.xflgs & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        speedf1 = ndp.xflgs & SweConst.SEFLG_SPEED;
        speedf2 = iflag & SweConst.SEFLG_SPEED;
        if (tjd == ndp.teval 
            && tjd != 0 
            && flg1 == flg2
            && ((speedf2==0) || (speedf1!=0))) {
            ndp.xflgs = iflag;
            ndp.iephe = iflag & SweConst.SEFLG_MOSEPH;
            return SweConst.OK;
        }
        /*********************************************
         * now three apsides * 
         *********************************************/
        for (t = tjd - speed_intv, i = 0; i < 3; t += speed_intv, i++) {
            if ( ((iflag & SweConst.SEFLG_SPEED)==0) && i != 1) continue;
            sm.swi_intp_apsides(t, xpos[i], ipl);
        }
        /************************************************************
         * apsis with speed                                         * 
         ************************************************************/
        for (i = 0; i < 3; i++) {
            xx[i] = xpos[1][i];
            xx[i+3] = 0;
        }
        if ((iflag & SweConst.SEFLG_SPEED) != 0) {
            xx[3] = sl.swe_difrad2n(xpos[2][0], xpos[0][0]) / speed_intv / 2.0;
            xx[4] = (xpos[2][1] - xpos[0][1]) / speed_intv / 2.0;
            xx[5] = (xpos[2][2] - xpos[0][2]) / speed_intv / 2.0;
        }
        // memset((void *) ndp.xreturn, 0, 24 * sizeof(double));
        for(int p=0;p<24;p++) { ndp.xreturn[p]=0.; }
        /* ecliptic polar to cartesian */
        sl.swi_polcart_sp(xx, xx);
        /* light-time */
        if ((iflag & SweConst.SEFLG_TRUEPOS) == 0) {
            dt = Math.sqrt(sl.square_sum(xx)) * SweConst.AUNIT / SwephData.CLIGHT / 86400.0;     
            for (i = 1; i < 3; i++)
                xx[i] -= dt * xx[i+3];
        }
        for (i = 0; i <= 5; i++) {
            ndp.xreturn[i+6] = xx[i];
        }
        /*printf("%.10f, %.10f, %.10f, %.10f\n", xx[0] /DEGTORAD, xx[1] / DEGTORAD, xx [2], xx[3] /DEGTORAD);*/
        /* equatorial cartesian */
        sl.swi_coortrf2(ndp.xreturn, 6, ndp.xreturn, 18, -oe.seps, oe.ceps);
        if ((iflag & SweConst.SEFLG_SPEED) != 0)
            sl.swi_coortrf2(ndp.xreturn, 9, ndp.xreturn, 21, -oe.seps, oe.ceps);
        ndp.teval = tjd;
        ndp.xflgs = iflag;
        ndp.iephe = iflag & SweConst.SEFLG_EPHMASK;
        if ((iflag & SweConst.SEFLG_SIDEREAL) != 0) {
            /* apogee is referred to t; 
             * the ecliptic position must be transformed to t0 */
            /* rigorous algorithm */
            if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0) != 0
                || (swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE) != 0) {
                for (i = 0; i <= 5; i++)
                    x[i] = ndp.xreturn[18+i];
                /* precess to J2000 */
                sl.swi_precess(x, tjd, SwephData.J_TO_J2000);
                if ((iflag & SweConst.SEFLG_SPEED) != 0)
                    swi_precess_speed(x, tjd, SwephData.J_TO_J2000);
                if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0) != 0) 
                    swi_trop_ra2sid_lon(x, ndp.xreturn, 6, ndp.xreturn, 18, iflag, null);
                /* project onto solar system equator */
                else if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE) != 0)
                    swi_trop_ra2sid_lon_sosy(x, ndp.xreturn, 6, ndp.xreturn, 18, iflag, null);
                /* to polar */
                sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
                sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
            } else {
                /* traditional algorithm */
                sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0); 
                ndp.xreturn[0] -= swe_get_ayanamsa(ndp.teval) * SwissData.DEGTORAD;
                sl.swi_polcart_sp(ndp.xreturn, 0, ndp.xreturn, 6); 
                sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
            }
        } else if ((iflag & SweConst.SEFLG_J2000) != 0) {
            /* node and apogee are referred to t; 
             * the ecliptic position must be transformed to J2000 */
            for (i = 0; i <= 5; i++)
                x[i] = ndp.xreturn[18+i];
            /* precess to J2000 */
            sl.swi_precess(x, tjd, SwephData.J_TO_J2000);
            if ((iflag & SweConst.SEFLG_SPEED) != 0)
                swi_precess_speed(x, tjd, SwephData.J_TO_J2000);
            for (i = 0; i <= 5; i++)
                ndp.xreturn[18+i] = x[i];
            sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
            sl.swi_coortrf2(ndp.xreturn, 18, ndp.xreturn, 6, swed.oec2000.seps, swed.oec2000.ceps);
            if ((iflag & SweConst.SEFLG_SPEED) != 0)
                sl.swi_coortrf2(ndp.xreturn, 21, ndp.xreturn, 9, swed.oec2000.seps, swed.oec2000.ceps);
            sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
        } else {
            /* tropical ecliptic positions */
            /* precession has already been taken into account, but not nutation */
            if ((iflag & SweConst.SEFLG_NONUT) == 0) {
                swi_nutate(ndp.xreturn, 18, iflag, false);
            }
            /* equatorial polar */
            sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
            /* ecliptic cartesian */
            sl.swi_coortrf2(ndp.xreturn, 18, ndp.xreturn, 6, oe.seps, oe.ceps);
            if ((iflag & SweConst.SEFLG_SPEED) != 0)
                sl.swi_coortrf2(ndp.xreturn, 21, ndp.xreturn, 9, oe.seps, oe.ceps);
            if ((iflag & SweConst.SEFLG_NONUT) == 0) {
                sl.swi_coortrf2(ndp.xreturn, 6, ndp.xreturn, 6, nut.snut, nut.cnut);
                if ((iflag & SweConst.SEFLG_SPEED) != 0)
                    sl.swi_coortrf2(ndp.xreturn, 9, ndp.xreturn, 9, nut.snut, nut.cnut);
            }
            /* ecliptic polar */
            sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
        }
        /********************** 
         * radians to degrees *
         **********************/
        /*if ((iflag & SweConst.SEFLG_RADIANS)==0) {*/
        for (i = 0; i < 2; i++) {
            ndp.xreturn[i] *= SwissData.RADTODEG;		/* ecliptic */
            ndp.xreturn[i+3] *= SwissData.RADTODEG;
            ndp.xreturn[i+12] *= SwissData.RADTODEG;	/* equator */
            ndp.xreturn[i+15] *= SwissData.RADTODEG;
        }
        ndp.xreturn[0] = sl.swe_degnorm(ndp.xreturn[0]);
        ndp.xreturn[12] = sl.swe_degnorm(ndp.xreturn[12]);
        /*}*/
        return SweConst.OK;
    }
  
    /* transforms the position of the moon in a way we can use it
     * for calculation of osculating node and apogee:
     * precession and nutation (attention to speed vector!)
     * according to flags
     * iflag        flags
     * tjd          time for which the element is computed
     *              i.e. date of ecliptic
     * xx           array equatorial cartesian position and speed
     * serr         error string
     */
    int swi_plan_for_osc_elem(int iflag, double tjd, double xx[]) {
        int i;
        double x[]=new double[6];
        Nut nuttmp=new Nut();
        Nut nutp = nuttmp;   /* dummy assign, to silence gcc warning */
        Epsilon oe = swed.oec;
        Epsilon oectmp=new Epsilon();
        /* ICRS to J2000 */
        if ((iflag & SweConst.SEFLG_ICRS)==0 && swed.jpldenum >= 403) {
            sl.swi_bias(xx, iflag, false);
        }/**/
        /************************************************
         * precession, equator 2000 -> equator of date  *
         * attention: speed vector has to be rotated,   *
         * but daily precession 0.137" may not be added!*/
        sl.swi_precess(xx, tjd, SwephData.J2000_TO_J);
        sl.swi_precess(xx, 3, tjd, SwephData.J2000_TO_J);
        /* epsilon */
        if (tjd == swed.oec.teps) {
            oe = swed.oec;
        } else if (tjd == SwephData.J2000) {
            oe = swed.oec2000;
        } else {
            calc_epsilon(tjd, oectmp);
            oe = oectmp;
        }
        /************************************************
         * nutation                                     *
         * again: speed vector must be rotated, but not *
         * added 'speed' of nutation                    *
         ************************************************/
        if ((iflag & SweConst.SEFLG_NONUT) == 0) {
            if (tjd == swed.nut.tnut) {
                nutp = swed.nut;
            } else if (tjd == SwephData.J2000) {
                nutp = swed.nut2000;
            } else if (tjd == swed.nutv.tnut) {
                nutp = swed.nutv;
            } else {
                nutp = nuttmp;
                sl.swi_nutation(tjd, nutp.nutlo);
                nutp.tnut = tjd;
                nutp.snut = Math.sin(nutp.nutlo[1]);
                nutp.cnut = Math.cos(nutp.nutlo[1]);
                nut_matrix(nutp, oe);
            }
            for (i = 0; i <= 2; i++) {
                x[i] = xx[0] * nutp.matrix[0][i] +
                    xx[1] * nutp.matrix[1][i] +
                    xx[2] * nutp.matrix[2][i];
            }
            /* speed:
             * rotation only */
            for (i = 0; i <= 2; i++) {
                x[i+3] = xx[3] * nutp.matrix[0][i] +
                    xx[4] * nutp.matrix[1][i] +
                    xx[5] * nutp.matrix[2][i];
            }
            for (i = 0; i <= 5; i++) {
                xx[i] = x[i];
            }
        }
        /************************************************
         * transformation to ecliptic                   *
         ************************************************/
        sl.swi_coortrf2(xx, xx, oe.seps, oe.ceps);
        sl.swi_coortrf2(xx, 3, xx, 3, oe.seps, oe.ceps);
        if ((iflag & SweConst.SEFLG_NONUT) == 0) {
            sl.swi_coortrf2(xx, xx, nutp.snut, nutp.cnut);
            sl.swi_coortrf2(xx, 3, xx, 3, nutp.snut, nutp.cnut);
        }
        return SweConst.OK;
    }

    static final MeffEle eff_arr[] = {
        /*
         * r , m_eff for photon passing the sun at min distance r (fraction of Rsun)
         * the values where computed with sun_model.c, which is a classic
         * treatment of a photon passing a gravity field, multiplied by 2.
         * The sun mass distribution m(r) is from Michael Stix, The Sun, p. 47.
         */
        new MeffEle(1.000, 1.000000),
        new MeffEle(0.990, 0.999979),
        new MeffEle(0.980, 0.999940),
        new MeffEle(0.970, 0.999881),
        new MeffEle(0.960, 0.999811),
        new MeffEle(0.950, 0.999724),
        new MeffEle(0.940, 0.999622),
        new MeffEle(0.930, 0.999497),
        new MeffEle(0.920, 0.999354),
        new MeffEle(0.910, 0.999192),
        new MeffEle(0.900, 0.999000),
        new MeffEle(0.890, 0.998786),
        new MeffEle(0.880, 0.998535),
        new MeffEle(0.870, 0.998242),
        new MeffEle(0.860, 0.997919),
        new MeffEle(0.850, 0.997571),
        new MeffEle(0.840, 0.997198),
        new MeffEle(0.830, 0.996792),
        new MeffEle(0.820, 0.996316),
        new MeffEle(0.810, 0.995791),
        new MeffEle(0.800, 0.995226),
        new MeffEle(0.790, 0.994625),
        new MeffEle(0.780, 0.993991),
        new MeffEle(0.770, 0.993326),
        new MeffEle(0.760, 0.992598),
        new MeffEle(0.750, 0.991770),
        new MeffEle(0.740, 0.990873),
        new MeffEle(0.730, 0.989919),
        new MeffEle(0.720, 0.988912),
        new MeffEle(0.710, 0.987856),
        new MeffEle(0.700, 0.986755),
        new MeffEle(0.690, 0.985610),
        new MeffEle(0.680, 0.984398),
        new MeffEle(0.670, 0.982986),
        new MeffEle(0.660, 0.981437),
        new MeffEle(0.650, 0.979779),
        new MeffEle(0.640, 0.978024),
        new MeffEle(0.630, 0.976182),
        new MeffEle(0.620, 0.974256),
        new MeffEle(0.610, 0.972253),
        new MeffEle(0.600, 0.970174),
        new MeffEle(0.590, 0.968024),
        new MeffEle(0.580, 0.965594),
        new MeffEle(0.570, 0.962797),
        new MeffEle(0.560, 0.959758),
        new MeffEle(0.550, 0.956515),
        new MeffEle(0.540, 0.953088),
        new MeffEle(0.530, 0.949495),
        new MeffEle(0.520, 0.945741),
        new MeffEle(0.510, 0.941838),
        new MeffEle(0.500, 0.937790),
        new MeffEle(0.490, 0.933563),
        new MeffEle(0.480, 0.928668),
        new MeffEle(0.470, 0.923288),
        new MeffEle(0.460, 0.917527),
        new MeffEle(0.450, 0.911432),
        new MeffEle(0.440, 0.905035),
        new MeffEle(0.430, 0.898353),
        new MeffEle(0.420, 0.891022),
        new MeffEle(0.410, 0.882940),
        new MeffEle(0.400, 0.874312),
        new MeffEle(0.390, 0.865206),
        new MeffEle(0.380, 0.855423),
        new MeffEle(0.370, 0.844619),
        new MeffEle(0.360, 0.833074),
        new MeffEle(0.350, 0.820876),
        new MeffEle(0.340, 0.808031),
        new MeffEle(0.330, 0.793962),
        new MeffEle(0.320, 0.778931),
        new MeffEle(0.310, 0.763021),
        new MeffEle(0.300, 0.745815),
        new MeffEle(0.290, 0.727557),
        new MeffEle(0.280, 0.708234),
        new MeffEle(0.270, 0.687583),
        new MeffEle(0.260, 0.665741),
        new MeffEle(0.250, 0.642597),
        new MeffEle(0.240, 0.618252),
        new MeffEle(0.230, 0.592586),
        new MeffEle(0.220, 0.565747),
        new MeffEle(0.210, 0.537697),
        new MeffEle(0.200, 0.508554),
        new MeffEle(0.190, 0.478420),
        new MeffEle(0.180, 0.447322),
        new MeffEle(0.170, 0.415454),
        new MeffEle(0.160, 0.382892),
        new MeffEle(0.150, 0.349955),
        new MeffEle(0.140, 0.316691),
        new MeffEle(0.130, 0.283565),
        new MeffEle(0.120, 0.250431),
        new MeffEle(0.110, 0.218327),
        new MeffEle(0.100, 0.186794),
        new MeffEle(0.090, 0.156287),
        new MeffEle(0.080, 0.128421),
        new MeffEle(0.070, 0.102237),
        new MeffEle(0.060, 0.077393),
        new MeffEle(0.050, 0.054833),
        new MeffEle(0.040, 0.036361),
        new MeffEle(0.030, 0.020953),
        new MeffEle(0.020, 0.009645),
        new MeffEle(0.010, 0.002767),
        new MeffEle(0.000, 0.000000)
    };
    double meff(double r) {
        double f, m;
        int i;
        if (r <= 0) {
            return 0.0;
        } else if (r >= 1) {
            return 1.0;
        }
        for (i = 0; eff_arr[i].r > r; i++) {
            ; /* empty body */
        }
        f = (r - eff_arr[i-1].r) / (eff_arr[i].r - eff_arr[i-1].r);
        m = eff_arr[i-1].m + f * (eff_arr[i].m - eff_arr[i-1].m);
        return m;
    }

    // Only used with SEFLG_SPEED3
    void denormalize_positions(double[] x0, double[] x1, double[] x2) {
        int i;
        /* x*[0] = ecliptic longitude, x*[12] = rectascension */
        for (i = 0; i <= 12; i += 12) {
            if (x1[i] - x0[i] < -180) {
                x0[i] -= 360;
            }
            if (x1[i] - x0[i] > 180) {
                x0[i] += 360;
            }
            if (x1[i] - x2[i] < -180) {
                x2[i] -= 360;
            }
            if (x1[i] - x2[i] > 180) {
                x2[i] += 360;
            }
        }
    }

    // Only used with SEFLG_SPEED3
    void calc_speed(double[] x0, double[] x1, double[] x2, double dt) {
        int i, j, k;
        double a, b;
        for (j = 0; j <= 18; j += 6) {
            for (i = 0; i < 3; i++) {
                k = j + i;
                b = (x2[k] - x0[k]) / 2;
                a = (x2[k] + x0[k]) / 2 - x1[k];
                x1[k+3] = (2 * a + b) / dt;
            }
        }
    }

    void swi_check_ecliptic(double tjd) {
        if (swed.oec2000.teps != SwephData.J2000) {
            calc_epsilon(SwephData.J2000, swed.oec2000);
        }
        if (tjd == SwephData.J2000) {
            swed.oec.teps = swed.oec2000.teps;
            swed.oec.eps = swed.oec2000.eps;
            swed.oec.seps = swed.oec2000.seps;
            swed.oec.ceps = swed.oec2000.ceps;
            return;
        }
        if (swed.oec.teps != tjd || tjd == 0) {
            calc_epsilon(tjd, swed.oec);
        }
    }

    /* computes nutation, if it is wanted and has not yet been computed.
     * if speed flag has been turned on since last computation,
     * nutation is recomputed */
    int chck_nut_nutflag = 0;
    void swi_check_nutation(double tjd, int iflag) {
        int speedf1, speedf2;
        double t;
        speedf1 = chck_nut_nutflag & SweConst.SEFLG_SPEED;
        speedf2 = iflag & SweConst.SEFLG_SPEED;
        if ((iflag & SweConst.SEFLG_NONUT) == 0
            && (tjd != swed.nut.tnut || tjd == 0
                || ((speedf1==0) && (speedf2!=0)))) {
            sl.swi_nutation(tjd, swed.nut.nutlo);
            swed.nut.tnut = tjd;
            swed.nut.snut = Math.sin(swed.nut.nutlo[1]);
            swed.nut.cnut = Math.cos(swed.nut.nutlo[1]);
            chck_nut_nutflag = iflag;
            nut_matrix(swed.nut, swed.oec);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                /* once more for 'speed' of nutation, which is needed for
                 * planetary speeds */
                t = tjd - SwephData.NUT_SPEED_INTV;
                sl.swi_nutation(t, swed.nutv.nutlo);
                swed.nutv.tnut = t;
                swed.nutv.snut = Math.sin(swed.nutv.nutlo[1]);
                swed.nutv.cnut = Math.cos(swed.nutv.nutlo[1]);
                nut_matrix(swed.nutv, swed.oec);
            }
        }
    }

    int plaus_iflag(int iflag) {
        int epheflag = 0;
        /* if topocentric bit, turn helio- and barycentric bits off */
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            iflag = iflag & ~(SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR);
        }
        /* if heliocentric bit, turn aberration and deflection off */
        if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
            iflag |= SweConst.SEFLG_NOABERR | SweConst.SEFLG_NOGDEFL;
            /*iflag |= SEFLG_TRUEPOS;*/
        }
        /* same, if barycentric bit */
        if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
            iflag |= SweConst.SEFLG_NOABERR | SweConst.SEFLG_NOGDEFL;
            /*iflag |= SEFLG_TRUEPOS;*/
        }
        /* if no_precession bit is set, set also no_nutation bit */
        if ((iflag & SweConst.SEFLG_J2000)!=0) {
            iflag |= SweConst.SEFLG_NONUT;
        }
        /* if truepos is set, turn off grav. defl. and aberration */
        if ((iflag & SweConst.SEFLG_TRUEPOS)!=0) {
            iflag |= (SweConst.SEFLG_NOGDEFL | SweConst.SEFLG_NOABERR);
        }
        /* if sidereal bit is set, set also no_nutation bit */
        if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
            iflag |= SweConst.SEFLG_NONUT;
        }
        if ((iflag & SweConst.SEFLG_MOSEPH)!=0) {
            epheflag = SweConst.SEFLG_MOSEPH;
        }
        if ((iflag & SweConst.SEFLG_SWIEPH)!=0) {
            epheflag = SweConst.SEFLG_SWIEPH;
        }
        if ((iflag & SweConst.SEFLG_JPLEPH)!=0) {
            epheflag = SweConst.SEFLG_JPLEPH;
        }
        if (epheflag == 0) {
            epheflag = SweConst.SEFLG_DEFAULTEPH;
        }
        /* delete wrong ephe bits from flag */
        iflag = (iflag & ~SweConst.SEFLG_EPHMASK) | epheflag;

        return iflag;
    }

    int swe_fixstar_found(StringBuffer serr, String s, StringBuffer star,
                          double tjd, int iflag, int iflgsave, int epheflag,
                          double[] xx) {
        double xpo[] = null;
        double ra_s, ra_pm, de_pm, ra, de, t, cosra, cosde, sinra, sinde;
        double ra_h, ra_m, de_d, de_m, de_s;
        String sde_d;
        double epoch, radv, parall, u;
        double x[]=new double[6];
        double xxsv[]=new double[6];
        double xobs[]=new double[6];
        int retc;
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        Epsilon oe = swed.oec2000;

        String[] cpos=new String[20];
        StringTokenizer tk=new StringTokenizer(s,",");
        int i=tk.countTokens();
        int n=0;
        while(tk.hasMoreTokens() && n<20) {
            cpos[n++]=tk.nextToken();
        }
        cpos[0]=cpos[0].trim();
        cpos[1]=cpos[1].trim();
        if (i < 13) {
            if (serr!=null) {
                serr.setLength(0);
                serr.append("data of star '"+cpos[0]+","+cpos[1]+"' incomplete");
            }
            return swe_fixstar_error(xx,SweConst.ERR);
        }
        // JAVA: Grrr: zumindest cpos[2] muss keine Zahl sein, aber es FAENGT
        // moeglicherweise mit einer Zahl AN!!!
        int idx=cpos[2].length();
        while(true) {
            try {
                epoch = Double.valueOf(cpos[2].substring(0,idx)).doubleValue();
                break;
            } catch (NumberFormatException nf) {
                idx--;
                if (idx==0) { epoch=0.; break; }
            }
        }
        ra_h = new Double(cpos[3]).doubleValue();
        ra_m = new Double(cpos[4]).doubleValue();
        ra_s = new Double(cpos[5]).doubleValue();
        de_d = new Double(cpos[6]).doubleValue();
        sde_d = cpos[6];
        de_m = new Double(cpos[7]).doubleValue();
        de_s = new Double(cpos[8]).doubleValue();
        ra_pm = new Double(cpos[9]).doubleValue();
        de_pm = new Double(cpos[10]).doubleValue();
        radv = new Double(cpos[11]).doubleValue();
        parall = new Double(cpos[12]).doubleValue();
        /* return trad. name, nomeclature name */
        if (cpos[0].length() > SweConst.SE_MAX_STNAME) {
            cpos[0]=cpos[0].substring(0,SweConst.SE_MAX_STNAME);
        }
        if (cpos[1].length() > SweConst.SE_MAX_STNAME-1) {
            cpos[1]=cpos[1].substring(0,SweConst.SE_MAX_STNAME-1);
        }
        star.setLength(0);
        star.append(cpos[0]+","+cpos[1]);
        /****************************************
         * position and speed (equinox)
         ****************************************/
        /* ra and de in degrees */
        ra = (ra_s / 3600.0 + ra_m / 60.0 + ra_h) * 15.0;
        if (sde_d.indexOf('-') < 0) {
            de = de_s / 3600.0 + de_m / 60.0 + de_d;
        } else {
            de = -de_s / 3600.0 - de_m / 60.0 + de_d;
        }
        /* speed in ra and de, degrees per century */
        ra_pm = ra_pm * 15 / 3600.0;
        de_pm /= 3600.0;
        /* parallax, degrees */
        if (parall > 1) {
            parall = (1 / parall / 3600);
        } else {
            parall /= 3600;
        }
        /* radial velocity in AU per century */
        radv *= SwephData.KM_S_TO_AU_CTY;
        /* radians */
        ra *= SwissData.DEGTORAD;
        de *= SwissData.DEGTORAD;
        ra_pm *= SwissData.DEGTORAD;
        de_pm *= SwissData.DEGTORAD;
        parall *= SwissData.DEGTORAD;
        x[0] = ra;
        x[1] = de;
        x[2] = 1;     /* -> unit vector */
        /* cartesian */
        sl.swi_polcart(x, x);
        /*space motion vector */
        cosra = Math.cos(ra);
        cosde = Math.cos(de);
        sinra = Math.sin(ra);
        sinde = Math.sin(de);
        x[3] = -ra_pm * cosde * sinra - de_pm * sinde * cosra
            + radv * parall * cosde * cosra;
        x[4] = ra_pm * cosde * cosra - de_pm * sinde * sinra
            + radv * parall * cosde * sinra;
        x[5] = de_pm * cosde + radv * parall * sinde;
        x[3] /= 36525;
        x[4] /= 36525;
        x[5] /= 36525;
        /******************************************
         * FK5
         ******************************************/
        if (epoch == 1950) {
            sl.swi_FK4_FK5(x, SwephData.B1950);
            sl.swi_precess(x, SwephData.B1950, SwephData.J_TO_J2000);
            sl.swi_precess(x, 3, SwephData.B1950, SwephData.J_TO_J2000);
        }
        /* FK5 to ICRS, if jpl ephemeris is referred to ICRS 
         * With data that are already ICRS, epoch = 0 */
        if (epoch != 0) {
            sl.swi_icrs2fk5(x, iflag, true);
            /* with ephemerides < DE403, we now convert to J2000 */
            if (swed.jpldenum < 403)
                sl.swi_bias(x, iflag, false);
        }
        /****************************************************
         * earth/sun
         * for parallax, light deflection, and aberration,
         ****************************************************/
        retc = main_planet(tjd, SwephData.SEI_EARTH, epheflag, iflag, serr);
        if (retc != SweConst.OK) {
            return swe_fixstar_error(xx,SweConst.ERR);
        }
        /* iflag (ephemeris bit) may have changed in main_planet() */
        iflag = swed.pldat[SwephData.SEI_EARTH].xflgs;
        /************************************
         * observer: geocenter or topocenter
         ************************************/
        /* if topocentric position is wanted  */
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            if (swed.topd.teval != pedp.teval
                || swed.topd.teval == 0) {
                if (swi_get_observer(pedp.teval, iflag, SwephData.DO_SAVE, xobs, serr)!=
                    SweConst.OK) {
                    return SweConst.ERR;
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = swed.topd.xobs[i];
                }
            }
            /* barycentric position of observer */
            for (i = 0; i <= 5; i++) {
                xobs[i] = xobs[i] + pedp.x[i];
            }
        } else {
            /* barycentric position of geocenter */
            for (i = 0; i <= 5; i++) {
                xobs[i] = pedp.x[i];
            }
        }
        /************************************
         * position and speed at tjd        *
         ************************************/
        if (epoch == 1950) {
            t= (tjd - SwephData.B1950);   /* days since 1950.0 */
        } else { /* epoch == 2000 */
            t= (tjd - SwephData.J2000);   /* days since 2000.0 */
        }
        /* for parallax */
        if ((iflag & SweConst.SEFLG_HELCTR)!=0 &&
            (iflag & SweConst.SEFLG_MOSEPH)!=0) {
            xpo = null;         /* no parallax, if moshier and heliocentric */
        } else if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
            xpo = psdp.x;
        } else if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
            xpo = null;         /* no parallax, if barycentric */
        } else {
            xpo = xobs;
        }
        if (xpo == null) {
            for (i = 0; i <= 2; i++) {
                x[i] += t * x[i+3];
            }
        } else {
            for (i = 0; i <= 2; i++) {
                x[i] += t * x[i+3] - parall * xpo[i];
                x[i+3] -= parall * xpo[i+3];
            }
        }
        /************************************
         * relativistic deflection of light *
         ************************************/
        for (i = 0; i <= 5; i++) {
            x[i] *= 10000;      /* great distance, to allow
                                 * algorithm used with planets */
        }
        if ((iflag & SweConst.SEFLG_TRUEPOS) == 0 &&
            (iflag & SweConst.SEFLG_NOGDEFL) == 0) {
            swi_deflect_light(x, 0, 0, iflag & SweConst.SEFLG_SPEED);
        }
        /**********************************
         * 'annual' aberration of light   *
         * speed is incorrect !!!         *
         **********************************/
        if ((iflag & SweConst.SEFLG_TRUEPOS) == 0 &&
            (iflag & SweConst.SEFLG_NOABERR) == 0) {
            swi_aberr_light(x, xpo, iflag & SweConst.SEFLG_SPEED);
        }
        /* ICRS to J2000 */
        if ((iflag & SweConst.SEFLG_ICRS) == 0 && swed.jpldenum >= 403) {
            sl.swi_bias(x, iflag, false);
        }/**/
        /* save J2000 coordinates; required for sidereal positions */
        for (i = 0; i <= 5; i++) {
            xxsv[i] = x[i];
        }
        /************************************************
         * precession, equator 2000 -> equator of date *
         ************************************************/
        /*x[0] = -0.374018403; x[1] = -0.312548592; x[2] = -0.873168719;*/
        if ((iflag & SweConst.SEFLG_J2000) == 0) {
            sl.swi_precess(x, tjd, SwephData.J2000_TO_J);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(x, tjd, SwephData.J2000_TO_J);
            }
            oe = swed.oec;
        } else {
            oe = swed.oec2000;
        }
        /************************************************
         * nutation                                     *
         ************************************************/
        if ((iflag & SweConst.SEFLG_NONUT) == 0) {
            swi_nutate(x, 0, 0, false);
        }
        /************************************************
         * unit vector (distance = 1)                   *
         ************************************************/
        u = Math.sqrt(sl.square_sum(x));
        for (i = 0; i <= 5; i++) {
            x[i] /= u;
        }
        u = Math.sqrt(sl.square_sum(xxsv));
        for (i = 0; i <= 5; i++) {
            xxsv[i] /= u;
        }
        /************************************************
         * set speed = 0, because not correct (aberration)
         ************************************************/
        for (i = 3; i <= 5; i++) {
            x[i] = xxsv[i] = 0;
        }
        /************************************************
         * transformation to ecliptic.                  *
         * with sidereal calc. this will be overwritten *
         * afterwards.                                  *
         ************************************************/
        if ((iflag & SweConst.SEFLG_EQUATORIAL) == 0) {
            sl.swi_coortrf2(x, x, oe.seps, oe.ceps);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                sl.swi_coortrf2(x, 3, x, 3, oe.seps, oe.ceps);
            }
            if ((iflag & SweConst.SEFLG_NONUT) == 0) {
                sl.swi_coortrf2(x, x, swed.nut.snut, swed.nut.cnut);
                if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                    sl.swi_coortrf2(x, 3, x, 3, swed.nut.snut, swed.nut.cnut);
                }
            }
        }
        /************************************
         * sidereal positions               *
         ************************************/
        if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
            /* rigorous algorithm */
            if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0) {
                if (swi_trop_ra2sid_lon(xxsv, x, xxsv, iflag, serr) != SweConst.OK) {
                    return SweConst.ERR;
                }
                if ((iflag & SweConst.SEFLG_EQUATORIAL)!=0) {
                    for (i = 0; i <= 5; i++) {
                        x[i] = xxsv[i];
                    }
                }
                /* project onto solar system equator */
            } else if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
                if (swi_trop_ra2sid_lon_sosy(xxsv, x, xxsv, iflag, serr) !=
                    SweConst.OK) {
                    return SweConst.ERR;
                }
                if ((iflag & SweConst.SEFLG_EQUATORIAL)!=0) {
                    for (i = 0; i <= 5; i++) {
                        x[i] = xxsv[i];
                    }
                }
                /* traditional algorithm */
            } else {
                sl.swi_cartpol_sp(x, x);
                x[0] -= swe_get_ayanamsa(tjd) * SwissData.DEGTORAD;
                sl.swi_polcart_sp(x, x);
            }
        }
        /************************************************
         * transformation to polar coordinates          *
         ************************************************/
        if ((iflag & SweConst.SEFLG_XYZ) == 0) {
            sl.swi_cartpol_sp(x, x);
        }
        /**********************
         * radians to degrees *
         **********************/
        if ((iflag & SweConst.SEFLG_RADIANS) == 0 &&
            (iflag & SweConst.SEFLG_XYZ) == 0) {
            for (i = 0; i < 2; i++) {
                x[i] *= SwissData.RADTODEG;
                x[i+3] *= SwissData.RADTODEG;
            }
        }
        for (i = 0; i <= 5; i++) {
            xx[i] = x[i];
        }
        /* if no ephemeris has been specified, do not return chosen ephemeris */
        if ((iflgsave & SweConst.SEFLG_EPHMASK) == 0) {
            iflag = iflag & ~SweConst.SEFLG_DEFAULTEPH;
        }
        iflag = iflag & ~SweConst.SEFLG_SPEED;
        return iflag;
    }

    int swe_fixstar_error(double[] xx, int retc) {
        for (int i = 0; i <= 5; i++) {
            xx[i] = 0;
        }
        return retc;
    }



    void swi_force_app_pos_etc() {
        int i;
        for (i = 0; i < SwephData.SEI_NPLANETS; i++) {
            swed.pldat[i].xflgs = -1;
        }
        for (i = 0; i < SwephData.SEI_NNODE_ETC; i++) {
            swed.nddat[i].xflgs = -1;
        }
        for (i = 0; i < SweConst.SE_NPLANETS; i++) {
            swed.savedat[i].tsave = 0;
            swed.savedat[i].iflgsave = -1;
        }
    }

    int swi_get_observer(double tjd, int iflag, boolean do_save, double xobs[],
                         StringBuffer serr) {
        int i;
        double sidt, delt, tjd_ut, eps, nut, nutlo[]=new double[2];
        double f = SwephData.EARTH_OBLATENESS;
        double re = SwephData.EARTH_RADIUS;
        double cosfi, sinfi, cc, ss, cosl, sinl, h;
        if (!swed.geopos_is_set) {
            if (serr != null) {
                serr.setLength(0);
                serr.append("geographic position has not been set");
            }
            return SweConst.ERR;
        }
        /* geocentric position of observer depends on sidereal time,
         * which depends on UT.
         * compute UT from ET. this UT will be slightly different
         * from the user's UT, but this difference is extremely small.
         */
        delt = SweDate.getDeltaT(tjd);
        tjd_ut = tjd - delt;
        if (swed.oec.teps == tjd && swed.nut.tnut == tjd) {
            eps = swed.oec.eps;
            nutlo[1] = swed.nut.nutlo[1];
            nutlo[0] = swed.nut.nutlo[0];
        } else {
            eps = sl.swi_epsiln(tjd);
            if ((iflag & SweConst.SEFLG_NONUT)==0) {
                sl.swi_nutation(tjd, nutlo);
            }
        }
        if ((iflag & SweConst.SEFLG_NONUT)!=0) {
            nut = 0;
        } else {
            eps += nutlo[1];
            nut = nutlo[0];
        }
        /* mean or apparent sidereal time, depending on whether or
         * not SEFLG_NONUT is set */
        sidt = sl.swe_sidtime0(tjd_ut, eps, nut);
        sidt *= 15;   /* in degrees */
        /* length of position and speed vectors;
         * the height above sea level must be taken into account.
         * with the moon, an altitude of 3000 m makes a difference
         * of about 2 arc seconds.
         * height is referred to the average sea level. however,
         * the spheroid (geoid), which is defined by the average
         * sea level (or rather by all points of same gravitational
         * potential), is of irregular shape and cannot easily
         * be taken into account. therefore, we refer height to
         * the surface of the ellipsoid. the resulting error
         * is below 500 m, i.e. 0.2 - 0.3 arc seconds with the moon.
         */
        cosfi = Math.cos(swed.topd.geolat * SwissData.DEGTORAD);
        sinfi = Math.sin(swed.topd.geolat * SwissData.DEGTORAD);
        cc= 1 / Math.sqrt(cosfi * cosfi + (1-f) * (1-f) * sinfi * sinfi);
        ss= (1-f) * (1-f) * cc;
        /* neglect polar motion (displacement of a few meters), as long as 
         * we use the earth ellipsoid */
        /* ... */
        /* add sidereal time */
        cosl = Math.cos((swed.topd.geolon + sidt) * SwissData.DEGTORAD);
        sinl = Math.sin((swed.topd.geolon + sidt) * SwissData.DEGTORAD);
        h = swed.topd.geoalt;
        xobs[0] = (re * cc + h) * cosfi * cosl;
        xobs[1] = (re * cc + h) * cosfi * sinl;
        xobs[2] = (re * ss + h) * sinfi;
        /* polar coordinates */
        sl.swi_cartpol(xobs, xobs);
        /* speed */
        xobs[3] = SwephData.EARTH_ROT_SPEED;
        xobs[4] = xobs[5] = 0;
        sl.swi_polcart_sp(xobs, xobs);
        /* to AUNIT */
        for (i = 0; i <= 5; i++) {
            xobs[i] /= SweConst.AUNIT;
        }
        /* subtract nutation, set backward flag */
        if ((iflag & SweConst.SEFLG_NONUT)==0) {
            sl.swi_coortrf2(xobs, xobs, -swed.nut.snut, swed.nut.cnut);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                sl.swi_coortrf2(xobs, 3, xobs, 3, -swed.nut.snut, swed.nut.cnut);
            }
            swi_nutate(xobs, 0, iflag, true);
        }
        /* precess to J2000 */
        sl.swi_precess(xobs, tjd, SwephData.J_TO_J2000);
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            swi_precess_speed(xobs, tjd, SwephData.J_TO_J2000);
        }
        /* neglect frame bias (displacement of 45cm) */
        /* ... */
        /* save */
        if (do_save) {
            for (i = 0; i <= 5; i++) {
                swed.topd.xobs[i] = xobs[i];
            }
            swed.topd.teval = tjd;
            swed.topd.tjd_ut = tjd_ut;  /* -> save area */
        }
        return SweConst.OK;
    }

    /* Equation of Time
     *
     * The function returns the difference between
     * local apparent and local mean time in days.
     * E = LAT - LMT
     * Input variable tjd is ET.
     * Algorithm according to Meeus, German, p. 190ff.
     */
    /**
     * Returns the difference between local apparent and local mean time in
     * days. E = LAT - LMT
     * @param tjd input date in julian days (ET)
     * @param serr buffer for error message on output
     * @return the difference
     */
    public int swe_time_equ(double tjd, DblObj E, StringBuffer serr) {
        double L0, dpsi, eps, x[]=new double[6], nutlo[]=new double[2];
        double tau = (tjd - SwephData.J2000) / 365250;
        double tau2 = tau * tau;
        double tau3 = tau * tau2;
        double tau4 = tau * tau3;
        double tau5 = tau * tau4;
        L0 = 280.4664567 + sl.swe_degnorm(tau * 360007.6982779)
            + tau2 * 0.03032028
            + tau3 * 1 / 49931
            - tau4 * 1 / 15299
            - tau5 * 1 / 1988000;
        sl.swi_nutation(tjd, nutlo);
        eps = (sl.swi_epsiln(tjd) + nutlo[1]) * SwissData.RADTODEG;
        dpsi = nutlo[0] * SwissData.RADTODEG;
        if (swe_calc(tjd, SweConst.SE_SUN, SweConst.SEFLG_EQUATORIAL, x, serr) ==
            SweConst.ERR) {
            return SweConst.ERR;
        }
        E.val = sl.swe_degnorm(L0 - 0.0057183 - x[0] + dpsi *
                               Math.cos(eps * SwissData.DEGTORAD));
        if (E.val > 180) {
            E.val -= 360;
        }
        E.val *= 4 / 1440.0;
        return SweConst.OK;
    }

    double dot_prod(double x[], double y[]) {
        ////#ifdef TRACE0
        //    Trace.level++;
        //    Trace.trace(Trace.level, "SwissEph.dot_prod(double[], double[])");
        ////#ifdef TRACE1
        //    Trace.printDblArr("x", x);
        //    Trace.printDblArr("y", y);
        ////#endif /* TRACE1 */
        //    Trace.level--;
        ////#endif /* TRACE0 */
        return x[0]*y[0]+x[1]*y[1]+x[2]*y[2];
    }
    double dot_prod(double x[], double y[], int yOffs) {
        ////#ifdef TRACE0
        //    Trace.level++;
        //    Trace.trace(Trace.level, "SwissEph.dot_prod(double[], double[], int)");
        ////#ifdef TRACE1
        //    Trace.printDblArr("x", x);
        //    Trace.printDblArr("y", y);
        //    DevNull.println("    yOffs: " + yOffs);
        ////#endif /* TRACE1 */
        //    Trace.level--;
        ////#endif /* TRACE0 */
        return x[0]*y[yOffs]+x[1]*y[1+yOffs]+x[2]*y[2+yOffs];
    }

    
} // Ende class SwissEph

class MeffEle {
    double r;
    double m;

    MeffEle(double r, double m) {
        ////#ifdef TRACE0
        //    Trace.level++;
        //    Trace.trace(Trace.level, "MeffEle(double, double)");
        ////#ifdef TRACE1
        //    DevNull.println("    r: " + Trace.fmtDbl(r) + "\n    m: " + Trace.fmtDbl(m));
        ////#endif /* TRACE1 */
        ////#endif /* TRACE0 */
        this.r=r; this.m=m;
        ////#ifdef TRACE0
        //    Trace.level--;
        ////#endif /* TRACE0 */
    }

}

/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


/**
* This class offers many routines that might be interesting to a programmer.<p>
* One important note: in all this package, negative longitudes are considered
* to be <b>west</b> of Greenwich, positive longitudes are seen as <b>east</b>
* of Greenwich. Especially America often uses a different notation!<p> 
* Probably most interesting are the functions swe_sidtime() (calculate the
* sidereal time) and swe_degnorm() (normalize a position to the range of
* 0.0&nbsp;<=&nbsp;x&nbsp;<&nbsp;360.0) and others.
*/
class SwissLib {

/* Set TRUE, to include Herring's (1987) corrections to IAU 1980
 * nutation series. AA (1996) neglects them.  */

/* Precession coefficients for remote past and future.
 * One of the following four defines must be true.
 */
/* Make PREC_WILLIAMS_1994 the default: */

/* used by Moshier for DE404: */
static final boolean PREC_WILLIAMS_1994  = true;
static final boolean PREC_SIMON_1994     = false;
static final boolean PREC_LASKAR_1986    = false;
static final boolean PREC_BRETAGNON_2003 = false;
/* IAU precession 1976 or 2003 for recent centuries.
 * only one of the following two defines may be TRUE */
static final boolean PREC_IAU_1976       = false;
/* precession model P03: */
static final boolean PREC_IAU_2003       = true;

/* choose between the following nutation models */
/* Make NUT_IAU_2000B the default: */
static final boolean NUT_IAU_1980        = false;
static final boolean NUT_IAU_2000A       = false;   /* very time consuming ! */
static final boolean NUT_IAU_2000B       = true;  /* fast, but precision of milli-arcsec */

  /* J2000 +/- two centuries: */
  static final double PREC_IAU_1976_CTIES=2.0;
  /* we use P03 for whole ephemeris */
  /* J2000 +/- 75 centuries: */
  static final double PREC_IAU_2003_CTIES=75.0;


  SwissData swed;

  // Konstruktor(en):
  public SwissLib() {
    this(null);
  }

  public SwissLib(SwissData swed) {
    this.swed=swed;
    if (this.swed ==null) { this.swed=new SwissData(); }
  }


//////////////////////////////////////////////////////////////////////////////
// Public methods: ///////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
  public double square_sum(double x[]) {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "SwissLib.square_sum(double[])");
////#ifdef TRACE1
//    Trace.printDblArr("x", x);
////#endif /* TRACE1 */
//    Trace.level--;
////#endif /* TRACE0 */
    return x[0]*x[0]+x[1]*x[1]+x[2]*x[2];
  }

  public double square_sum(double x[], int offset) {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "SwissLib.square_sum(double[], int)");
////#ifdef TRACE1
//    Trace.printDblArr("x", x);
//    DevNull.println("    offset: " + offset);
////#endif /* TRACE1 */
//    Trace.level--;
////#endif /* TRACE0 */
    return x[offset]*x[offset]+x[1+offset]*x[1+offset]+x[2+offset]*x[2+offset];
  }



  /* Reduce x modulo 360 degrees
   */
  /**
  * Normalizes a double to the range of 0.0 >= x < 360.0.
  */
  public double swe_degnorm(double x) {
if (Double.doubleToLongBits(x) == 0xc11cd9d69f7e189dL) {
  x = Double.longBitsToDouble(0xc11cd9d69f7e189eL);  // Zeile 66: keine Verñnderung...
} else if (Double.doubleToLongBits(x) == 0xc11d376e20594b20L) {
  x = Double.longBitsToDouble(0xc11d376e20594b21L);  // Zeile 68: keine Verñnderung...
} else if (Double.doubleToLongBits(x) == 0xc11ae8edd4666694L) {
  x = Double.longBitsToDouble(0xc11ae8edd4666695L);  // Zeile 70: keine Verñnderung...
} else if (Double.doubleToLongBits(x) == 0x409fe5e10f4cc528L) {
  x = Double.longBitsToDouble(0x409fe5e10f4cc527L);  // Zeile 79: keine Verñnderung...
}
    double y;
    y = x%360.0;
    if (Math.abs(y) < 1e-13) {
      y = 0;   /* Alois fix 11-dec-1999 */
    }
    if( y < 0.0 ) {
      y += 360.0;
    }
    return(y);
  }

// Well: used by Swetest.java... //#ifndef ASTROLOGY
  /* Reduce x modulo TWOPI degrees
   */
  /**
  * Normalizes a double to the range 0.0 >= x < 2*PI.
  */
  public double swe_radnorm(double x) {
    double y;
    y = x % SwephData.TWOPI;
    if (Math.abs(y) < 1e-13) {
      y = 0;   /* Alois fix 11-dec-1999 */
    }
    if( y < 0.0 ) {
      y += SwephData.TWOPI;
    }
    return(y);
  }
// Well: used by Swetest.java... //#endif /* ASTROLOGY */

// Well: used by Swetest.java... //#ifndef ASTROLOGY
  public double swe_deg_midp(double x1, double x0) {
    double y;
// This is completely blown up for nothing:
//    d = swe_difdeg2n(x1, x0);     /* arc from x0 to x1 */
//    y = swe_degnorm(x0 + d / 2);
    y = swe_degnorm((x1 + x0)/2);
    return(y);
  }
// Well: used by Swetest.java... //#endif /* ASTROLOGY */

// Well: used by Swetest.java... //#ifndef ASTROLOGY
  public double swe_rad_midp(double x1, double x0) {
    return SwissData.DEGTORAD * swe_deg_midp(x1 * SwissData.RADTODEG, x0 * SwissData.RADTODEG);
  }
// Well: used by Swetest.java... //#endif /* ASTROLOGY */

  /* Reduce x modulo 2*PI
   */
  public double swi_mod2PI(double x) {
    double y;
    y = x%SwephData.TWOPI;
    if( y < 0.0 ) {
      y += SwephData.TWOPI;
    }
    return(y);
  }


  public double swi_angnorm(double x) {
    if (x < 0.0 ) {
      return x + SwephData.TWOPI;
    } else if (x >= SwephData.TWOPI) {
      return x - SwephData.TWOPI;
    } else {
      return x;
    }
  }

  public void swi_cross_prod(double a[], int aOffs, double b[], int bOffs,
                             double x[], int xOffs) {
    x[0+xOffs] = a[1+aOffs]*b[2+bOffs] - a[2+aOffs]*b[1+bOffs];
    x[1+xOffs] = a[2+aOffs]*b[0+bOffs] - a[0+aOffs]*b[2+bOffs];
    x[2+xOffs] = a[0+aOffs]*b[1+bOffs] - a[1+aOffs]*b[0+bOffs];
  }

  /*  Evaluates a given chebyshev series coef[0..ncf-1]
   *  with ncf terms at x in [-1,1]. Communications of the ACM, algorithm 446,
   *  April 1973 (vol. 16 no.4) by Dr. Roger Broucke.
   */
  public double swi_echeb(double x, double coef[], int offs, int ncf) {
if (Double.doubleToLongBits(coef[0]) == 0xbfbf6c9bdfa87a8eL) {
  coef[0] = Double.longBitsToDouble(0xbfbf6c9bdfa87a8dL);  // Zeile 3456: keine Verñnderung...
}
if (Double.doubleToLongBits(coef[5]) == 0x3FB87AA86131C716L) {
  coef[5] = Double.longBitsToDouble(0x3fb87aa86131c717L);  // Zeile 3461: keine Verñnderung...
}
if (Double.doubleToLongBits(coef[6]) == 0xBF75E01D9A8A9A34L) {
  coef[6] = Double.longBitsToDouble(0xBF75E01D9A8A9A35L);  // Zeile 3462: keine Verñnderung...
}
if (Double.doubleToLongBits(coef[10]) == 0x3EF5D0AE131F86EEL) {
  coef[10] = Double.longBitsToDouble(0x3EF5D0AE131F86EDL);  // Zeile 3466: keine Verñnderung...
}
    int j;
    double x2, br, brp2, brpp;

    x2 = x * 2.;
    br = 0.;
    brp2 = 0.;    /* dummy assign to silence gcc warning */
    brpp = 0.;
    for (j = ncf - 1; j >= 0; j--) {
      brp2 = brpp;
      brpp = br;
      br = x2 * brpp - brp2 + coef[j+offs];
    }
    return (br - brp2) * .5;
  }

  /*
   * evaluates derivative of chebyshev series, see echeb
   */
  public double swi_edcheb(double x, double coef[], int offs, int ncf) {
    double bjpl, xjpl;
    int j;
    double x2, bf, bj, dj, xj, bjp2, xjp2;
    x2 = x * 2.;
    bf = 0.;      /* dummy assign to silence gcc warning */
    bj = 0.;      /* dummy assign to silence gcc warning */
    xjp2 = 0.;
    xjpl = 0.;
    bjp2 = 0.;
    bjpl = 0.;
    for (j = ncf - 1; j >= 1; j--) {
      dj = (double) (j + j);
      xj = coef[j+offs] * dj + xjp2;
      bj = x2 * bjpl - bjp2 + xj;
      bf = bjp2;
      bjp2 = bjpl;
      bjpl = bj;
      xjp2 = xjpl;
      xjpl = xj;
    }
    return (bj - bf) * .5;
  }

  /*
   * conversion between ecliptical and equatorial polar coordinates.
   * for users of SWISSEPH, not used by our routines.
   * for ecl. to equ.  eps must be negative.
   * for equ. to ecl.  eps must be positive.
   * xpo, xpn are arrays of 3 doubles containing position.
   * attention: input must be in degrees!
   */
  public void swe_cotrans(double xpo[],double xpn[],double eps) {
    swe_cotrans(xpo, 0, xpn, 0, eps);
  }
  public void swe_cotrans(double xpo[],int oOffs, double xpn[],
                          int nOffs, double eps) {
    int i;
    double x[]=new double[6], e = eps * SwissData.DEGTORAD;
    for(i = 0; i <= 1; i++)
      x[i] = xpo[i+oOffs];
    x[0] *= SwissData.DEGTORAD;
    x[1] *= SwissData.DEGTORAD;
    x[2] = 1;
    for(i = 3; i <= 5; i++)
      x[i] = 0;
    swi_polcart(x, x);
    swi_coortrf(x, x, e);
    swi_cartpol(x, x);
    xpn[  nOffs] = x[0] * SwissData.RADTODEG;
    xpn[1+nOffs] = x[1] * SwissData.RADTODEG;
    xpn[2+nOffs] = xpo[2+oOffs];
  }

  /*
   * conversion between ecliptical and equatorial polar coordinates
   * with speed.
   * for users of SWISSEPH, not used by our routines.
   * for ecl. to equ.  eps must be negative.
   * for equ. to ecl.  eps must be positive.
   * xpo, xpn are arrays of 6 doubles containing position and speed.
   * attention: input must be in degrees!
   */
  public void swe_cotrans_sp(double xpo[], double xpn[], double eps) {
    int i;
    double x[]=new double[6], e = eps * SwissData.DEGTORAD;
    for (i = 0; i <= 5; i++)
      x[i] = xpo[i];
    x[0] *= SwissData.DEGTORAD;
    x[1] *= SwissData.DEGTORAD;
    x[2] = 1;     /* avoids problems with polcart(), if x[2] = 0 */
    x[3] *= SwissData.DEGTORAD;
    x[4] *= SwissData.DEGTORAD;
    swi_polcart_sp(x, x);
    swi_coortrf(x, x, e);
    swi_coortrf(x, 3, x, 3, e);
    swi_cartpol_sp(x, xpn);
    xpn[0] *= SwissData.RADTODEG;
    xpn[1] *= SwissData.RADTODEG;
    xpn[2] = xpo[2];
    xpn[3] *= SwissData.RADTODEG;
    xpn[4] *= SwissData.RADTODEG;
    xpn[5] = xpo[5];
  }

  /*
   * conversion between ecliptical and equatorial cartesian coordinates
   * for ecl. to equ.  eps must be negative
   * for equ. to ecl.  eps must be positive
   */
  public void swi_coortrf(double xpo[], double xpn[], double eps) {
    swi_coortrf(xpo, 0, xpn, 0, eps);
  }

  public void swi_coortrf(double xpo[], int oOffs, double xpn[],
                          int nOffs, double eps) {
    double sineps, coseps;
    double x[]=new double[3];
    sineps = Math.sin(eps);
    coseps = Math.cos(eps);
    x[0] = xpo[oOffs];
    x[1] = xpo[1+oOffs] * coseps + xpo[2+oOffs] * sineps;
    x[2] = -xpo[1+oOffs] * sineps + xpo[2+oOffs] * coseps;
    xpn[0+nOffs] = x[0];
    xpn[1+nOffs] = x[1];
    xpn[2+nOffs] = x[2];
  }

  /*
   * conversion between ecliptical and equatorial cartesian coordinates
   * sineps            sin(eps)
   * coseps            cos(eps)
   * for ecl. to equ.  sineps must be -sin(eps)
   */
  public void swi_coortrf2(double xpo[], double xpn[], double sineps,
                           double coseps) {
    swi_coortrf2(xpo, 0, xpn, 0, sineps, coseps);
  }
  public void swi_coortrf2(double xpo[], int oOffs, double xpn[], int nOffs,
                    double sineps, double coseps) {
    double x[]=new double[3];
    x[0] = xpo[0+oOffs];
    x[1] = xpo[1+oOffs] * coseps + xpo[2+oOffs] * sineps;
    x[2] = -xpo[1+oOffs] * sineps + xpo[2+oOffs] * coseps;
    xpn[0+nOffs] = x[0];
    xpn[1+nOffs] = x[1];
    xpn[2+nOffs] = x[2];
  }

  /* conversion of cartesian (x[3]) to polar coordinates (l[3]).
   * x = l is allowed.
   * if |x| = 0, then lon, lat and rad := 0.
   */
  public void swi_cartpol(double x[], double l[]) {
    swi_cartpol(x, 0, l, 0);
  }

  public void swi_cartpol(double x[], int xOffs, double l[], int lOffs) {
    double rxy;
    double ll[]=new double[3];
    if (x[0+xOffs] == 0 && x[1+xOffs] == 0 && x[2+xOffs] == 0) {
      l[0+lOffs] = l[1+lOffs] = l[2+lOffs] = 0;
      return;
    }
    rxy = x[0+xOffs]*x[0+xOffs] + x[1+xOffs]*x[1+xOffs];
    ll[2] = Math.sqrt(rxy + x[2+xOffs]*x[2+xOffs]);
    rxy = Math.sqrt(rxy);
    ll[0] = Math.atan2(x[1+xOffs], x[0+xOffs]);
    if (ll[0] < 0.0) {
      ll[0] += SwephData.TWOPI;
    }
    ll[1] = Math.atan(x[2+xOffs] / rxy);
    l[0+lOffs] = ll[0];
    l[1+lOffs] = ll[1];
    l[2+lOffs] = ll[2];
  }

  /* conversion from polar (l[3]) to cartesian coordinates (x[3]).
   * x = l is allowed.
   */
  public void swi_polcart(double l[], double x[]) {
    swi_polcart(l, 0, x, 0);
  }
  public void swi_polcart(double l[], int lOffs, double x[], int xOffs) {
    double xx[]=new double[3];
    double cosl1;
    cosl1 = Math.cos(l[lOffs+1]);
    xx[0] = l[lOffs+2] * cosl1 * Math.cos(l[lOffs]);
    xx[1] = l[lOffs+2] * cosl1 * Math.sin(l[lOffs]);
    xx[2] = l[lOffs+2] * Math.sin(l[lOffs+1]);
    x[xOffs] = xx[0];
    x[xOffs+1] = xx[1];
    x[xOffs+2] = xx[2];
  }

  /* conversion of position and speed.
   * from cartesian (x[6]) to polar coordinates (l[6]).
   * x = l is allowed.
   * if position is 0, function returns direction of
   * motion.
   */
  public void swi_cartpol_sp(double x[], double l[]) {
    swi_cartpol_sp(x, 0, l, 0);
  }
  public void swi_cartpol_sp(double x[], int xOffs, double l[], int lOffs) {
    double xx[]=new double[6], ll[]=new double[6];
    double rxy, coslon, sinlon, coslat, sinlat;
    /* zero position */
    if (x[0+xOffs] == 0 && x[1+xOffs] == 0 && x[2+xOffs] == 0) {
      l[0+lOffs] = l[1+lOffs] = l[3+lOffs] = l[4+lOffs] = 0;
      l[5+lOffs] = Math.sqrt(square_sum(x, 3+xOffs));
      swi_cartpol(x, 3+xOffs, l, 0+lOffs);
      l[2+lOffs] = 0;
      return;
    }
    /* zero speed */
    if (x[3+xOffs] == 0 && x[4+xOffs] == 0 && x[5+xOffs] == 0) {
      l[3+lOffs] = l[4+lOffs] = l[5+lOffs] = 0;
      swi_cartpol(x, xOffs, l, lOffs);
      return;
    }
    /* position */
    rxy = x[0+xOffs]*x[0+xOffs] + x[1+xOffs]*x[1+xOffs];
    ll[2] = Math.sqrt(rxy + x[2+xOffs]*x[2+xOffs]);
    rxy = Math.sqrt(rxy);
    ll[0] = Math.atan2(x[1+xOffs], x[0+xOffs]);
    if (ll[0] < 0.0) {
      ll[0] += SwephData.TWOPI;
    }
    ll[1] = Math.atan(x[2+xOffs] / rxy);
    /* speed:
     * 1. rotate coordinate system by longitude of position about z-axis,
     *    so that new x-axis = position radius projected onto x-y-plane.
     *    in the new coordinate system
     *    vy'/r = dlong/dt, where r = sqrt(x^2 +y^2).
     * 2. rotate coordinate system by latitude about new y-axis.
     *    vz"/r = dlat/dt, where r = position radius.
     *    vx" = dr/dt
     */
    coslon = x[0+xOffs] / rxy;          /* cos(l[0]); */
    sinlon = x[1+xOffs] / rxy;          /* sin(l[0]); */
    coslat = rxy / ll[2];         /* cos(l[1]); */
    sinlat = x[2+xOffs] / ll[2];        /* sin(ll[1]); */
    xx[3] = x[3+xOffs] * coslon + x[4+xOffs] * sinlon;
    xx[4] = -x[3+xOffs] * sinlon + x[4+xOffs] * coslon;
    l[3+lOffs] = xx[4] / rxy;           /* speed in longitude */
    xx[4] = -sinlat * xx[3] + coslat * x[5+xOffs];
    xx[5] =  coslat * xx[3] + sinlat * x[5+xOffs];
    l[4+lOffs] = xx[4] / ll[2];         /* speed in latitude */
    l[5+lOffs] = xx[5];                 /* speed in radius */
    l[0+lOffs] = ll[0];                 /* return position */
    l[1+lOffs] = ll[1];
    l[2+lOffs] = ll[2];
  }

  /* conversion of position and speed
   * from polar (l[6]) to cartesian coordinates (x[6])
   * x = l is allowed
   * explanation s. swi_cartpol_sp()
   */
  public void swi_polcart_sp(double l[], double x[]) {
    swi_polcart_sp(l, 0, x, 0);
  }
  public void swi_polcart_sp(double l[], int lOffs, double x[], int xOffs) {
    double sinlon, coslon, sinlat, coslat;
    double xx[]=new double[6], rxy, rxyz;
    /* zero speed */
    if (l[3+lOffs] == 0 && l[4+lOffs] == 0 && l[5+lOffs] == 0) {
      x[3+xOffs] = x[4+xOffs] = x[5+xOffs] = 0;
      swi_polcart(l, lOffs, x, xOffs);
      return;
    }
    /* position */
    coslon = Math.cos(l[0+lOffs]);
    sinlon = Math.sin(l[0+lOffs]);
    coslat = Math.cos(l[1+lOffs]);
    sinlat = Math.sin(l[1+lOffs]);
    xx[0] = l[2+lOffs] * coslat * coslon;
    xx[1] = l[2+lOffs] * coslat * sinlon;
    xx[2] = l[2+lOffs] * sinlat;
    /* speed; explanation s. swi_cartpol_sp(), same method the other way round*/
    rxyz = l[2+lOffs];
    rxy = Math.sqrt(xx[0] * xx[0] + xx[1] * xx[1]);
    xx[5] = l[5+lOffs];
    xx[4] = l[4+lOffs] * rxyz;
    x[5+xOffs] = sinlat * xx[5] + coslat * xx[4];       /* speed z */
    xx[3] = coslat * xx[5] - sinlat * xx[4];
    xx[4] = l[3+lOffs] * rxy;
    x[3+xOffs] = coslon * xx[3] - sinlon * xx[4];       /* speed x */
    x[4+xOffs] = sinlon * xx[3] + coslon * xx[4];       /* speed y */
    x[0+xOffs] = xx[0];                                 /* return position */
    x[1+xOffs] = xx[1];
    x[2+xOffs] = xx[2];
  }

  public double swi_dot_prod_unit(double[] x, double[] y) {
    double dop = x[0]*y[0]+x[1]*y[1]+x[2]*y[2];
    double e1 = Math.sqrt(x[0]*x[0]+x[1]*x[1]+x[2]*x[2]);
    double e2 = Math.sqrt(y[0]*y[0]+y[1]*y[1]+y[2]*y[2]);
    dop /= e1;
    dop /= e2;
    if (dop > 1) {
      dop = 1;
    }
    if (dop < -1) {
      dop = -1;
    }
    return dop;
  }


  /* Obliquity of the ecliptic at Julian date J
   *
   * IAU Coefficients are from:
   * J. H. Lieske, T. Lederle, W. Fricke, and B. Morando,
   * "Expressions for the Precession Quantities Based upon the IAU
   * (1976) System of Astronomical Constants,"  Astronomy and Astrophysics
   * 58, 1-16 (1977).
   *
   * Before or after 200 years from J2000, the formula used is from:
   * J. Laskar, "Secular terms of classical planetary theories
   * using the results of general theory," Astronomy and Astrophysics
   * 157, 59070 (1986).
   *
   * Bretagnon, P. et al.: 2003, "Expressions for Precession Consistent with 
   * the IAU 2000A Model". A&A 400,785
   *
   *  See precess and page B18 of the Astronomical Almanac.
   */
  public double swi_epsiln(double J) {
    double T, eps;
    T = (J - 2451545.0)/36525.0;
    if (PREC_IAU_1976 && Math.abs(T) <= PREC_IAU_1976_CTIES ) {
      eps = (((1.813e-3*T-5.9e-4)*T-46.8150)*T+84381.448)*SwissData.DEGTORAD/3600;
    } else if (PREC_IAU_2003 && Math.abs(T) <= PREC_IAU_2003_CTIES) {
      eps =  (((((-4.34e-8 * T -5.76e-7) * T +2.0034e-3) * T -1.831e-4) * T -46.836769) * T + 84381.406) * SwissData.DEGTORAD / 3600.0;
    } else if (PREC_BRETAGNON_2003) {
      eps =  ((((((-3e-11 * T - 2.48e-8) * T -5.23e-7) * T +1.99911e-3) * T -1.667e-4) * T -46.836051) * T + 84381.40880) * SwissData.DEGTORAD / 3600.0;/* */
    } else if (PREC_SIMON_1994) {
      eps =  (((((2.5e-8 * T -5.1e-7) * T +1.9989e-3) * T -1.52e-4) * T -46.80927) * T + 84381.412) * SwissData.DEGTORAD / 3600.0;/* */
    } else if (PREC_WILLIAMS_1994) {
      eps =  ((((-1.0e-6 * T +2.0e-3) * T -1.74e-4) * T -46.833960) * T + 84381.409) * SwissData.DEGTORAD / 3600.0;/* */
    } else { /* PREC_LASKAR_1986 */
      T /= 10.0;
      eps = ((((((((( 2.45e-10*T + 5.79e-9)*T + 2.787e-7)*T
      + 7.12e-7)*T - 3.905e-5)*T - 2.4967e-3)*T
      - 5.138e-3)*T + 1.99925)*T - 0.0155)*T - 468.093)*T
      + 84381.448;
      eps *= SwissData.DEGTORAD/3600;
    }
    return(eps);
  }

  /* Precession of the equinox and ecliptic
   * from epoch Julian date J to or from J2000.0
   *
   * Program by Steve Moshier.
   * Changes in program structure by Dieter Koch.
   *
   * #define PREC_WILLIAMS_1994 1
   * James G. Williams, "Contributions to the Earth's obliquity rate,
   * precession, and nutation,"  Astron. J. 108, 711-724 (1994).
   *
   * #define PREC_SIMON_1994 0
   * J. L. Simon, P. Bretagnon, J. Chapront, M. Chapront-Touze', G. Francou,
   * and J. Laskar, "Numerical Expressions for precession formulae and
   * mean elements for the Moon and the planets," Astronomy and Astrophysics
   * 282, 663-683 (1994).
   *
   * #define PREC_IAU_1976 0
   * IAU Coefficients are from:
   * J. H. Lieske, T. Lederle, W. Fricke, and B. Morando,
   * "Expressions for the Precession Quantities Based upon the IAU
   * (1976) System of Astronomical Constants,"  Astronomy and
   * Astrophysics 58, 1-16 (1977).
   *
   * #define PREC_LASKAR_1986 0
   * Newer formulas that cover a much longer time span are from:
   * J. Laskar, "Secular terms of classical planetary theories
   * using the results of general theory," Astronomy and Astrophysics
   * 157, 59070 (1986).
   *
   * See also:
   * P. Bretagnon and G. Francou, "Planetary theories in rectangular
   * and spherical variables. VSOP87 solutions," Astronomy and
   * Astrophysics 202, 309-315 (1988).
   *
   * Laskar's expansions are said by Bretagnon and Francou
   * to have "a precision of about 1" over 10000 years before
   * and after J2000.0 in so far as the precession constants p^0_A
   * and epsilon^0_A are perfectly known."
   *
   * Bretagnon and Francou's expansions for the node and inclination
   * of the ecliptic were derived from Laskar's data but were truncated
   * after the term in T**6. I have recomputed these expansions from
   * Laskar's data, retaining powers up to T**10 in the result.
   *
   * The following table indicates the differences between the result
   * of the IAU formula and Laskar's formula using four different test
   * vectors, checking at J2000 plus and minus the indicated number
   * of years.
   *
   *   Years       Arc
   * from J2000  Seconds
   * ----------  -------
   *        0       0
   *      100     .006
   *      200     .006
   *      500     .015
   *     1000     .28
   *     2000    6.4
   *     3000   38.
   *    10000 9400.
   */
  /* In WILLIAMS and SIMON, Laskar's terms of order higher than t^4
     have been retained, because Simon et al mention that the solution
     is the same except for the lower order terms.  */

  static final double pAcof[] = {
   -8.66e-10, -4.759e-8, 2.424e-7, 1.3095e-5, 1.7451e-4, -1.8055e-3,
   -0.235316, 0.076, 110.5407, 50287.70000 };
  static final double nodecof[] = {
    6.6402e-16, -2.69151e-15, -1.547021e-12, 7.521313e-12, 1.9e-10,
    -3.54e-9, -1.8103e-7,  1.26e-7,  7.436169e-5,
    -0.04207794833,  3.052115282424};
  static final double inclcof[] = {
    1.2147e-16, 7.3759e-17, -8.26287e-14, 2.503410e-13, 2.4650839e-11,
    -5.4000441e-11, 1.32115526e-9, -6.012e-7, -1.62442e-5,
    0.00227850649, 0.0 };
  



  /* Subroutine arguments:
   *
   * R = rectangular equatorial coordinate vector to be precessed.
   *     The result is written back into the input vector.
   * J = Julian date
   * direction =
   *      Precess from J to J2000: direction = 1
   *      Precess from J2000 to J: direction = -1
   * Note that if you want to precess from J1 to J2, you would
   * first go from J1 to J2000, then call the program again
   * to go from J2000 to J2.
   */
  public int swi_precess(double R[], double J, int direction ) {
    return swi_precess(R, 0, J, direction);
  }
  public int swi_precess(double R[], int rOffs, double J, int direction ) {
    double sinth, costh, sinZ, cosZ, sinz, cosz;
    double eps, sineps, coseps;
    double A, B, T, Z, z, TH, pA, W;
    double x[]=new double[3];
    int pn;
    int i;
    if( J == SwephData.J2000 ) {
      return(0);
    }
    /* Each precession angle is specified by a polynomial in
     * T = Julian centuries from J2000.0.  See AA page B18.
     */
    T = (J - SwephData.J2000)/36525.0;
    /* Use IAU formula for a few centuries.  */
    if (PREC_IAU_1976 && Math.abs(T) <= PREC_IAU_1976_CTIES) {
      Z =  (( 0.017998*T + 0.30188)*T + 2306.2181)*T*SwissData.DEGTORAD/3600;
      z =  (( 0.018203*T + 1.09468)*T + 2306.2181)*T*SwissData.DEGTORAD/3600;
      TH = ((-0.041833*T - 0.42665)*T + 2004.3109)*T*SwissData.DEGTORAD/3600;
    } else if (PREC_IAU_2003 && Math.abs(T) <= PREC_IAU_2003_CTIES) {
      Z =  (((((- 0.0000003173*T - 0.000005971)*T + 0.01801828)*T + 0.2988499)*T + 2306.083227)*T + 2.650545)*SwissData.DEGTORAD/3600;
      z =  (((((- 0.0000002904*T - 0.000028596)*T + 0.01826837)*T + 1.0927348)*T + 2306.077181)*T - 2.650545)*SwissData.DEGTORAD/3600;
      TH = ((((-0.00000011274*T - 0.000007089)*T - 0.04182264)*T - 0.4294934)*T + 2004.191903)*T*SwissData.DEGTORAD/3600;
      /* AA 2006 B28:
      Z =  (((((- 0.0000002*T - 0.0000327)*T + 0.0179663)*T + 0.3019015)*T + 2306.0809506)*T + 2.5976176)*SwissData.DEGTORAD/3600;
      z =  (((((- 0.0000003*T - 0.000047)*T + 0.0182237)*T + 1.0947790)*T + 2306.0803226)*T - 2.5976176)*SwissData.DEGTORAD/3600;
      TH = ((((-0.0000001*T - 0.0000601)*T - 0.0418251)*T - 0.4269353)*T + 2004.1917476)*T*SwissData.DEGTORAD/3600;
      */
    } else if (PREC_BRETAGNON_2003) {
      Z =  ((((((-0.00000000013*T - 0.0000003040)*T - 0.000005708)*T + 0.01801752)*T + 0.3023262)*T + 2306.080472)*T + 2.72767)*SwissData.DEGTORAD/3600;
      z =  ((((((-0.00000000005*T - 0.0000002486)*T - 0.000028276)*T + 0.01826676)*T + 1.0956768)*T + 2306.076070)*T - 2.72767)*SwissData.DEGTORAD/3600;
      TH = ((((((0.000000000009*T + 0.00000000036)*T -0.0000001127)*T - 0.000007291)*T - 0.04182364)*T - 0.4266980)*T + 2004.190936)*T*SwissData.DEGTORAD/3600;
    } else {
      /* Implementation by elementary rotations using Laskar's expansions.
       * First rotate about the x axis from the initial equator
       * to the ecliptic. (The input is equatorial.)
       */
      if( direction == 1 ) {
        eps = swi_epsiln(J); /* To J2000 */
      } else {
        eps = swi_epsiln(SwephData.J2000); /* From J2000 */
      }
      sineps = Math.sin(eps);
      coseps = Math.cos(eps);
      x[0] = R[0+rOffs];
      z = coseps*R[1+rOffs] + sineps*R[2+rOffs];
      x[2] = -sineps*R[1+rOffs] + coseps*R[2+rOffs];
      x[1] = z;
      /* Precession in longitude */
      T /= 10.0; /* thousands of years */
      pn=0; //p = pAcof;
      pA = pAcof[pn]; pn++;
      for( i=0; i<9; i++ ) {
        pA = pA * T + pAcof[pn]; pn++;
      }
      pA *= SwissData.DEGTORAD/3600 * T;
      /* Node of the moving ecliptic on the J2000 ecliptic.
       */
      pn=0; // p = nodecof;
      W = nodecof[pn]; pn++;
      for( i=0; i<10; i++ ) {
        W = W * T + nodecof[pn]; pn++;
      }
      /* Rotate about z axis to the node.
       */
      if( direction == 1 ) {
        z = W + pA;
      } else {
        z = W;
      }
      B = Math.cos(z);
      A = Math.sin(z);
      z = B * x[0] + A * x[1];
      x[1] = -A * x[0] + B * x[1];
      x[0] = z;
      /* Rotate about new x axis by the inclination of the moving
       * ecliptic on the J2000 ecliptic.
       */
      pn=0; // p = inclcof;
      z = inclcof[pn]; pn++;
      for( i=0; i<10; i++ ) {
        z = z * T + inclcof[pn]; pn++;
      }
      if( direction == 1 ) {
        z = -z;
      }
      B = Math.cos(z);
      A = Math.sin(z);
      z = B * x[1] + A * x[2];
      x[2] = -A * x[1] + B * x[2];
      x[1] = z;
      /* Rotate about new z axis back from the node.
       */
      if( direction == 1 ) {
        z = -W;
      } else {
        z = -W - pA;
      }
      B = Math.cos(z);
      A = Math.sin(z);
      z = B * x[0] + A * x[1];
      x[1] = -A * x[0] + B * x[1];
      x[0] = z;
      /* Rotate about x axis to final equator.
       */
      if( direction == 1 ) {
        eps = swi_epsiln(SwephData.J2000);
      } else {
        eps = swi_epsiln(J);
      }
      sineps = Math.sin(eps);
      coseps = Math.cos(eps);
      z = coseps * x[1] - sineps * x[2];
      x[2] = sineps * x[1] + coseps * x[2];
      x[1] = z;
      for( i=0; i<3; i++ )
        R[i+rOffs] = x[i];
      return(0);
    }
    sinth = Math.sin(TH);
    costh = Math.cos(TH);
    sinZ = Math.sin(Z);
    cosZ = Math.cos(Z);
    sinz = Math.sin(z);
    cosz = Math.cos(z);
    A = cosZ*costh;
    B = sinZ*costh;
    if( direction < 0 ) { /* From J2000.0 to J */
      x[0] =    (A*cosz - sinZ*sinz)*R[0+rOffs]
              - (B*cosz + cosZ*sinz)*R[1+rOffs]
                        - sinth*cosz*R[2+rOffs];
      x[1] =    (A*sinz + sinZ*cosz)*R[0+rOffs]
              - (B*sinz - cosZ*cosz)*R[1+rOffs]
                        - sinth*sinz*R[2+rOffs];
      x[2] =              cosZ*sinth*R[0+rOffs]
                        - sinZ*sinth*R[1+rOffs]
                        + costh*R[2+rOffs];
    }
    else { /* From J to J2000.0 */
      x[0] =    (A*cosz - sinZ*sinz)*R[0+rOffs]
              + (A*sinz + sinZ*cosz)*R[1+rOffs]
                        + cosZ*sinth*R[2+rOffs];
      x[1] =  - (B*cosz + cosZ*sinz)*R[0+rOffs]
              - (B*sinz - cosZ*cosz)*R[1+rOffs]
                        - sinZ*sinth*R[2+rOffs];
      x[2] =            - sinth*cosz*R[0+rOffs]
                        - sinth*sinz*R[1+rOffs]
                        + costh*R[2+rOffs];
    }
    for( i=0; i<3; i++ )
      R[i+rOffs] = x[i];
    return(0);
  }




  /* Nutation IAU 2000A model
   * (MHB2000 luni-solar and planetary nutation, without free core nutation)
   *
   * Function returns nutation in longitude and obliquity in radians with
   * respect to the equinox of date. For the obliquity of the ecliptic
   * the calculation of Lieske & al. (1977) must be used.
   *
   * The precision in recent years is about 0.001 arc seconds.
   *
   * The calculation includes luni-solar and planetary nutation.
   * Free core nutation, which cannot be predicted, is omitted,
   * the error being of the order of a few 0.0001 arc seconds.
   *
   * References:
   *
   * Capitaine, N., Wallace, P.T., Chapront, J., A & A 432, 366 (2005).
   *
   * Chapront, J., Chapront-Touze, M. & Francou, G., A & A 387, 700 (2002).
   *
   * Lieske, J.H., Lederle, T., Fricke, W. & Morando, B., "Expressions
   * for the precession quantities based upon the IAU (1976) System of
   * Astronomical Constants", A & A 58, 1-16 (1977).
   *
   * Mathews, P.M., Herring, T.A., Buffet, B.A., "Modeling of nutation
   * and precession   New nutation series for nonrigid Earth and
   * insights into the Earth's interior", J.Geophys.Res., 107, B4,
   * 2002.
   *
   * Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,
   * Francou, G., Laskar, J., A & A 282, 663-683 (1994).
   *
   * Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M., A & A Supp.
   * Ser. 135, 111 (1999).
   *
   * Wallace, P.T., "Software for Implementing the IAU 2000
   * Resolutions", in IERS Workshop 5.1 (2002).
   *
   * Nutation IAU 2000A series in:
   * Kaplan, G.H., United States Naval Observatory Circular No. 179 (Oct. 2005)
   * aa.usno.navy.mil/publications/docs/Circular_179.html
   *
   * MHB2000 code at
   * - ftp://maia.usno.navy.mil/conv2000/chapter5/IAU2000A.
   * - http://www.iau-sofa.rl.ac.uk/2005_0901/Downloads.html
   */
  int swi_nutation(double J, double nutlo[]) {
    int i, j, k, inls;
    double M, SM, F, D, OM;
    double darg, sinarg, cosarg;
    double dpsi = 0, deps = 0;
    double T = (J - SwephData.J2000 ) / 36525.0;
    /* luni-solar nutation */
    /* Fundamental arguments, Simon & al. (1994) */
    /* Mean anomaly of the Moon. */
    M  = swe_degnorm(( 485868.249036 +
                T*( 1717915923.2178 +
                T*(         31.8792 +
                T*(          0.051635 +
                T*(        - 0.00024470 ))))) / 3600.0) * SwissData.DEGTORAD;
    /* Mean anomaly of the Sun */
    SM = swe_degnorm((1287104.79305 +
                T*(  129596581.0481 +
                T*(        - 0.5532 +
                T*(          0.000136 +
                T*(        - 0.00001149 ))))) / 3600.0) * SwissData.DEGTORAD;
    /* Mean argument of the latitude of the Moon. */
    F   = swe_degnorm(( 335779.526232 +
                T*( 1739527262.8478 +
                T*(       - 12.7512 +
                T*(       -  0.001037 +
                T*(          0.00000417 ))))) / 3600.0) * SwissData.DEGTORAD;
    /* Mean elongation of the Moon from the Sun. */
    D   = swe_degnorm((1072260.70369 +
                T*( 1602961601.2090 +
                T*(        - 6.3706 +
                T*(          0.006593 +
                T*(        - 0.00003169 ))))) / 3600.0) * SwissData.DEGTORAD;
    /* Mean longitude of the ascending node of the Moon. */
    OM  = swe_degnorm(( 450160.398036 +
                T*(  - 6962890.5431 +
                T*(          7.4722 +
                T*(          0.007702 +
                T*(        - 0.00005939 ))))) / 3600.0) * SwissData.DEGTORAD;
    /* luni-solar nutation series, in reverse order, starting with small terms */
    inls = Swenut2000a.NLS_2000B;
    for (i = inls - 1; i >= 0; i--) {
      j = i * 5;
      darg = swe_radnorm((double) Swenut2000a.nls[j + 0] * M  +
                         (double) Swenut2000a.nls[j + 1] * SM +
                         (double) Swenut2000a.nls[j + 2] * F   +
                         (double) Swenut2000a.nls[j + 3] * D   +
                         (double) Swenut2000a.nls[j + 4] * OM);
      sinarg = Math.sin(darg);
      cosarg = Math.cos(darg);
      k = i * 6;
      dpsi += (Swenut2000a.cls[k+0] + Swenut2000a.cls[k+1] * T) * sinarg + Swenut2000a.cls[k+2] * cosarg;
      deps += (Swenut2000a.cls[k+3] + Swenut2000a.cls[k+4] * T) * cosarg + Swenut2000a.cls[k+5] * sinarg;
    }
    nutlo[0] = dpsi * Swenut2000a.O1MAS2DEG;
    nutlo[1] = deps * Swenut2000a.O1MAS2DEG;
    nutlo[0] *= SwissData.DEGTORAD;
    nutlo[1] *= SwissData.DEGTORAD;
    return 0;
  }

  /* GCRS to J2000 */
  void swi_bias(double[] x, int iflag, boolean backward) {
    double xx[]=new double[6], rb[][]=new double[3][3];
    int i;
    rb[0][0] = +0.9999999999999942;
    rb[0][1] = +0.0000000707827948;
    rb[0][2] = -0.0000000805621738;
    rb[1][0] = -0.0000000707827974;
    rb[1][1] = +0.9999999999999969;
    rb[1][2] = -0.0000000330604088;
    rb[2][0] = +0.0000000805621715;
    rb[2][1] = +0.0000000330604145;
    rb[2][2] = +0.9999999999999962;
    if (backward) {
      for (i = 0; i <= 2; i++) {
        xx[i] = x[0] * rb[i][0] +
                x[1] * rb[i][1] +
                x[2] * rb[i][2];
        if ((iflag & SweConst.SEFLG_SPEED) != 0)
          xx[i+3] = x[3] * rb[i][0] +
                x[4] * rb[i][1] +
                x[5] * rb[i][2];
      }
    } else {
      for (i = 0; i <= 2; i++) {
        xx[i] = x[0] * rb[0][i] +
                x[1] * rb[1][i] +
                x[2] * rb[2][i];
        if ((iflag & SweConst.SEFLG_SPEED) != 0)
          xx[i+3] = x[3] * rb[0][i] +
                x[4] * rb[1][i] +
                x[5] * rb[2][i];
      }
    }
    for (i = 0; i <= 2; i++) x[i] = xx[i];
    if ((iflag & SweConst.SEFLG_SPEED) != 0) {
      for (i = 3; i <= 5; i++) x[i] = xx[i];
    }
  }


  /* GCRS to FK5 */
  void swi_icrs2fk5(double[] x, int iflag, boolean backward) {
    double xx[]=new double[6], rb[][]=new double[3][3];
    int i;
    rb[0][0] = +0.9999999999999928;
    rb[0][1] = +0.0000001110223287;
    rb[0][2] = +0.0000000441180557;
    rb[1][0] = -0.0000001110223330;
    rb[1][1] = +0.9999999999999891;
    rb[1][2] = +0.0000000964779176;
    rb[2][0] = -0.0000000441180450;
    rb[2][1] = -0.0000000964779225;
    rb[2][2] = +0.9999999999999943;
    if (backward) {
      for (i = 0; i <= 2; i++) {
        xx[i] = x[0] * rb[i][0] +
                x[1] * rb[i][1] +
                x[2] * rb[i][2];
        if ((iflag & SweConst.SEFLG_SPEED) != 0)
          xx[i+3] = x[3] * rb[i][0] +
                x[4] * rb[i][1] +
                x[5] * rb[i][2];
      }
    } else {
      for (i = 0; i <= 2; i++) {
        xx[i] = x[0] * rb[0][i] +
                x[1] * rb[1][i] +
                x[2] * rb[2][i];
        if ((iflag & SweConst.SEFLG_SPEED) != 0)
          xx[i+3] = x[3] * rb[0][i] +
                x[4] * rb[1][i] +
                x[5] * rb[2][i];
      }
    }
    for (i = 0; i <= 5; i++) x[i] = xx[i];
  }

  /* ************************************************************
  cut the string s at any char in cutlist; put pointers to partial strings
  into cpos[0..n-1], return number of partial strings;
  if less than nmax fields are found, the first empty pointer is
  set to NULL.
  More than one character of cutlist in direct sequence count as one
  separator only! cut_str_any("word,,,word2",","..) cuts only two parts,
  cpos[0] = "word" and cpos[1] = "word2".
  If more than nmax fields are found, nmax is returned and the
  last field nmax-1 rmains un-cut.
  **************************************************************/
  /**
  * Cut the String s at any character in cutlist and put the resulting
  * Strings into String cpos[].
  * @param s The input string.
  * @param cutlist A String specifying all characters, where the input string
  * should be cut.
  * @param cpos Input and output paramater: a String[] containing maximum
  * 'nmax' Strings.
  * @param nmax The size of the cpos array. A relict from the C version...
  * @return Number of generated Strings
  */
  public int swi_cutstr(String s, String cutlist, String cpos[], int nmax) {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "SwissLib.swi_cutstr(String, String, String[], int)");
////#ifdef TRACE1
//    DevNull.println("    s: " + s + "\n    cutlist: " + cutlist);
//    for(int z = 0; z < cpos.length; z++) {
//      DevNull.println("    cpos[" + z + "]: " + cpos[z]);
//    }
//    DevNull.println("    nmax: " + nmax);
////#endif /* TRACE1 */
////#endif /* TRACE0 */
    s=s.trim();
    if (s.indexOf('\n')>=0) { s=s.substring(0,s.indexOf('\n')); }
    if (s.indexOf('\r')>=0) { s=s.substring(0,s.indexOf('\r')); }
    java.util.StringTokenizer tk=new java.util.StringTokenizer(s,cutlist,true);
    int n=0;
    while(tk.hasMoreTokens() && n<20) {
      String g=tk.nextToken();
      // Characters in cutlist can be valid characters of the String. If
      // escaped with "\\", join together, what the StringTokenizer separated
// Well, well: 'while g.endsWith("\\\\")', then obviously not, but
// while 'g.endsWith("\\\\\\")', then yes, etc. pp.... So I would have to
// do something about this one "sometime"...
      while (g.endsWith("\\") && tk.hasMoreTokens()) {
        g=g.substring(0,g.length()-1)+tk.nextToken();
        if (tk.hasMoreTokens()) {
          g+=tk.nextToken();
        }
      }
      cpos[n]=g;
      n++;
      if (tk.hasMoreTokens()) { tk.nextToken(); }
    }
    cpos[19]="";
    while(tk.hasMoreTokens()) {
      cpos[19]+=tk.nextToken();
    }
    if (n < nmax) {
      cpos[n] = null;
    }
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
    return n;
  }       /* cutstr */

  /* Apparent Sidereal Time at Greenwich with equation of the equinoxes
   * AA page B6
   *
   * returns sidereal time in hours.
   *
   * Caution. At epoch J2000.0, the 16 decimal precision
   * of IEEE double precision numbers
   * limits time resolution measured by Julian date
   * to approximately 24 microseconds.
   *
   * program returns sidereal hours since sidereal midnight
   * tjd          julian day UT
   * eps          obliquity of ecliptic, degrees
   * nut          nutation, degrees
   */
  /**
  * This calculates the sidereal time from a Julian day number, the
  * obliquity of the eclipse and the nutation (in degrees). You might
  * want to use swe_sidtime(double), if you have just the Julian day
  * number available.<p>
  * @param tjd The Julian day number
  * @param eps Obliquity of the ecliptic
  * @param nut Nutation in degrees
  * @return Sidereal time in degrees.
  * @see #swe_sidtime(double)
  */
  public double swe_sidtime0( double tjd, double eps, double nut ) {
    double jd0;           /* Julian day at midnight Universal Time */
    double secs;          /* Time of day, UT seconds since UT midnight */
    double eqeq, jd, tu, tt, msday;
    double gmst;
    /* Julian day at given UT */
    jd = tjd;
    jd0 = Math.floor(jd);
    secs = tjd - jd0;
    if( secs < 0.5 ) {
      jd0 -= 0.5;
      secs += 0.5;
    } else {
      jd0 += 0.5;
      secs -= 0.5;
    }
    secs *= 86400.0;
    tu = (jd0 - SwephData.J2000)/36525.0; /* UT1 in centuries after J2000 */
    if (PREC_IAU_2003) {
      tt = (jd0 + SweDate.getDeltaT(jd0) - SwephData.J2000)/36525.0; /* TT in centuries after J2000 */
      gmst = (((-0.000000002454*tt - 0.00000199708)*tt - 0.0000002926)*tt + 0.092772110)*tt*tt + 307.4771013*(tt-tu) + 8640184.79447825*tu + 24110.5493771;
      /* mean solar days per sidereal day at date tu;
       * for the derivative of gmst, we can assume UT1 =~ TT */
      msday = 1 + ((((-0.000000012270*tt - 0.00000798832)*tt - 0.0000008778)*tt + 0.185544220)*tt + 8640184.79447825)/(86400.*36525.);
    } else {
      /* Greenwich Mean Sidereal Time at 0h UT of date */
      gmst = (( -6.2e-6*tu + 9.3104e-2)*tu + 8640184.812866)*tu + 24110.54841;
      /* mean solar days per sidereal day at date tu, = 1.00273790934 in 1986 */
      msday = 1.0 + ((-1.86e-5*tu + 0.186208)*tu + 8640184.812866)/(86400.*36525.);
    }
    /* Local apparent sidereal time at given UT at Greenwich */
    eqeq = 240.0 * nut * Math.cos(eps * SwissData.DEGTORAD);
    gmst = gmst + msday*secs + eqeq  /* + 240.0*tlong */;
    /* Sidereal seconds modulo 1 sidereal day */
    gmst = gmst - 86400.0 * Math.floor( gmst/86400.0 );
    /* return in hours */
    gmst /= 3600;
    return gmst;
  }


  /* sidereal time, without eps and nut as parameters.
   * tjd must be UT !!!
   * for more informsation, see comment with swe_sidtime0()
   */
  /**
  * This calculates the sidereal time from a Julian day number.<p>
  * @param tjd_ut The Julian day number (in UT)
  * @return Sidereal time in degrees.
  * @see #swe_sidtime0(double, double, double)
  */
  public double swe_sidtime(double tjd_ut) {
    int i;
    double eps, nutlo[]=new double[2], tsid;
    double tjde = tjd_ut + SweDate.getDeltaT(tjd_ut);
    eps = swi_epsiln(tjde) * SwissData.RADTODEG;
    swi_nutation(tjde, nutlo);
    for (i = 0; i < 2; i++)
      nutlo[i] *= SwissData.RADTODEG;
    tsid = swe_sidtime0(tjd_ut, eps + nutlo[1], nutlo[0]);
    return tsid;
  }


  /* SWISSEPH
   * generates name of ephemeris file
   * file name looks as follows:
   * swephpl.m30, where
   *
   * "sweph"                      "swiss ephemeris"
   * "pl","mo","as"               planet, moon, or asteroid
   * "m"  or "_"                  BC or AD
   *
   * "30"                         start century
   * tjd          = ephemeris file for which julian day
   * ipli         = number of planet
   * fname        = ephemeris file name
   */
//  String swi_gen_filename(double tjd, int ipli, String fname)
  public String swi_gen_filename(SweDate sd, int ipli) {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "SwissLib.swi_gen_filename(SweDate, int)");
////#ifdef TRACE1
//    DevNull.println("    sd: " + sd + "\n    ipli: " + ipli);
////#endif /* TRACE1 */
////#endif /* TRACE0 */
    int icty;
    int ncties = (int) SwephData.NCTIES;
    int sgn;
    String fname;
////#ifdef ORIGINAL
//    CFmt cv=new CFmt();
////#endif /* ORIGINAL */

    switch(ipli) {
      case SwephData.SEI_MOON:
        fname="semo";
        break;
      case SwephData.SEI_EMB:
      case SwephData.SEI_MERCURY:
      case SwephData.SEI_VENUS:
      case SwephData.SEI_MARS:
      case SwephData.SEI_JUPITER:
      case SwephData.SEI_SATURN:
      case SwephData.SEI_URANUS:
      case SwephData.SEI_NEPTUNE:
      case SwephData.SEI_PLUTO:
      case SwephData.SEI_SUNBARY:
        fname="sepl";
        break;
      case SwephData.SEI_CERES:
      case SwephData.SEI_PALLAS:
      case SwephData.SEI_JUNO:
      case SwephData.SEI_VESTA:
      case SwephData.SEI_CHIRON:
      case SwephData.SEI_PHOLUS:
        fname="seas";
        break;
      default:    /* asteroid */
        String iplNr="00000" + (ipli - SweConst.SE_AST_OFFSET);
        iplNr = iplNr.substring(iplNr.length()-6);
        if ((ipli - SweConst.SE_AST_OFFSET <= 99999)) {
          iplNr = iplNr.substring(1);
        }
        fname = "ast" + ((ipli - SweConst.SE_AST_OFFSET) / 1000) +
                swed.DIR_GLUE + "se" + iplNr + "." + SwephData.SE_FILE_SUFFIX;
////#ifdef TRACE0
//        Trace.level--;
////#endif /* TRACE0 */
        return fname;   /* asteroids: only one file 3000 bc - 3000 ad */
        /* break; */
    }
    /* century of tjd */
    /* if sd.tjd > 1600 then gregorian calendar */
    if (sd.getJulDay() >= 2305447.5) {
      sd.setCalendarType(SweDate.SE_GREG_CAL, SweDate.SE_KEEP_JD);
    /* else julian calendar */
    } else {
      sd.setCalendarType(SweDate.SE_JUL_CAL, SweDate.SE_KEEP_JD);
    }
    /* start century of file containing tjd */
    int year = sd.getYear();
    if (year < 0) {
      sgn = -1;
    } else {
      sgn = 1;
    }
    icty = year / 100;
    if (sgn < 0 && year % 100 != 0) {
      icty -=1;
    }
    while(icty % ncties != 0) {
      icty--;
    }
    /* B.C. or A.D. */
    if (icty < 0) {
      fname+="m";
    } else {
      fname+="_";
    }
    icty = Math.abs(icty);
//  sprintf(fname + strlen(fname), "%02d.%s", icty, SE_FILE_SUFFIX);
    fname+=(icty<10?"0":"")+icty+"."+SwephData.SE_FILE_SUFFIX;
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
    return fname;
  }

  /*********************************************************
   *  function for splitting centiseconds into             *
   *  ideg        degrees,
   *  imin        minutes,
   *  isec        seconds,
   *  dsecfr      fraction of seconds
   *  isgn        zodiac sign number;
   *              or +/- sign
   *
   *********************************************************/
  public void swe_split_deg(double ddeg, int roundflag, IntObj ideg,
                            IntObj imin, IntObj isec, DblObj dsecfr,
                            IntObj isgn) {
    double dadd = 0;
    isgn.val = 1;
    if (ddeg < 0) {
      isgn.val = -1;
      ddeg = -ddeg;
    }
    if ((roundflag & SweConst.SE_SPLIT_DEG_ROUND_DEG)!=0) {
      dadd = 0.5;
    } else if ((roundflag & SweConst.SE_SPLIT_DEG_ROUND_MIN)!=0) {
      dadd = 0.5 / 60;
    } else if ((roundflag & SweConst.SE_SPLIT_DEG_ROUND_SEC)!=0) {
      dadd = 0.5 / 3600;
    }
    if ((roundflag & SweConst.SE_SPLIT_DEG_KEEP_DEG)!=0) {
      if ((int) (ddeg + dadd) - (int) ddeg > 0) {
        dadd = 0;
      }
    } else if ((roundflag & SweConst.SE_SPLIT_DEG_KEEP_SIGN)!=0) {
      if ((ddeg % 30) + dadd >= 30) {
        dadd = 0;
      }
    }
    ddeg += dadd;
    if ((roundflag & SweConst.SE_SPLIT_DEG_ZODIACAL)!=0) {
      isgn.val = (int) (ddeg / 30);
      ddeg = ddeg % 30;
    }
    ideg.val = (int) ddeg;
    ddeg -= ideg.val;
    imin.val = (int) (ddeg * 60);
    ddeg -= imin.val / 60.0;
    isec.val = (int) (ddeg * 3600);
    if ((roundflag & (SweConst.SE_SPLIT_DEG_ROUND_DEG | SweConst.SE_SPLIT_DEG_ROUND_MIN | SweConst.SE_SPLIT_DEG_ROUND_SEC))==0) {
      dsecfr.val = ddeg * 3600 - isec.val;
    }
  }  /* end split_deg */

  public double swi_kepler(double E, double M, double ecce) {
    double dE = 1, E0;
    double x;
    /* simple formula for small eccentricities */
    if (ecce < 0.4) {
      while(dE > 1e-12) {
        E0 = E;
        E = M + ecce * Math.sin(E0);
        dE = Math.abs(E - E0);
      }
    /* complicated formula for high eccentricities */
    } else {
      while(dE > 1e-12) {
        E0 = E;
        /*
         * Alois 21-jul-2000: workaround an optimizer problem in gcc
         * swi_mod2PI sees very small negative argument e-322 and returns +2PI;
         * we avoid swi_mod2PI for small x.
         */
        x = (M + ecce * Math.sin(E0) - E0) / (1 - ecce * Math.cos(E0));
        dE = Math.abs(x);
        if (dE < 1e-2) {
          E = E0 + x;
        } else {
          E = swi_mod2PI(E0 + x);
          dE = Math.abs(E - E0);
        }
      }
    }
    return E;
  }

  public void swi_FK4_FK5(double xp[], double tjd) {
    if (xp[0] == 0 && xp[1] == 0 && xp[2] == 0) {
      return;
    }
    swi_cartpol(xp, xp);
    /* according to Expl.Suppl., p. 167f. */
    xp[0] += (0.035 + 0.085 * (tjd - SwephData.B1950) / 36524.2198782) / 3600 * 15 * SwissData.DEGTORAD;
    xp[3] += (0.085 / 36524.2198782) / 3600 * 15 * SwissData.DEGTORAD;
    swi_polcart(xp, xp);
  }

  public void swi_FK5_FK4(double[] xp, double tjd) {
    if (xp[0] == 0 && xp[1] == 0 && xp[2] == 0) {
      return;
    }
    swi_cartpol(xp, xp);
    /* according to Expl.Suppl., p. 167f. */
    xp[0] -= (0.035 + 0.085 * (tjd - SwephData.B1950) / 36524.2198782) / 3600 * 15 * SwissData.DEGTORAD;
    xp[3] -= (0.085 / 36524.2198782) / 3600 * 15 * SwissData.DEGTORAD;
    swi_polcart(xp, xp);
  }

//////////////////////////////////////////////////////////////////////////////
// swejpl.c: /////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

  /*************************************
  double to int32 with rounding, no overflow check
  *************************************/
  public int swe_d2l(double x) {
    if (x >=0.) {
      return ((int) (x + 0.5));
    } else {
      return (- (int) (0.5 - x));
    }
  }

  /**
  * This calculates the difference of the two angles p1, p2 and normalizes
  * them to a range of -180.0 <= x < 180.0 degrees.
  * @param p1 The angle of point 1
  * @param p2 The angle of point 2
  * @return The normalized difference between p1, p2
  */
  public double swe_difdeg2n(double p1, double p2) {
    double dif;
    dif = swe_degnorm(p1 - p2);
    if (dif  >= 180.0) {
      return (dif - 360.0);
    }
    return (dif);
  }

// Well: used by Swetest.java... //#ifndef ASTROLOGY
  public double swe_difrad2n(double p1, double p2) {
    double dif;
    dif = swe_radnorm(p1 - p2);
    if (dif  >= SwephData.TWOPI / 2) {
      return (dif - SwephData.TWOPI);
    }
    return (dif);
  }
// Well: used by Swetest.java... //#endif /* ASTROLOGY */

//////////////////////////////////////////////////////////////////////////////
// In this Java port only: ///////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
  /**
  * This method emulates the C version of atof() allowing <i>any</i> string
  * to be parsed into a number.
  */
  public static synchronized double atof(String src) {
    // atof() (in C) allows extra strings after the number, and even no number
    // at all, so we have to work around this...
    int idx=0;
    src=src.trim();
    while(idx<src.length() &&
         (Character.isDigit(src.charAt(idx)) || src.charAt(idx)=='.')) {
      idx++;
    }
    String sout=src.substring(0,idx).trim();
    if (sout.length()==0 || sout.replace('.',' ').trim().length()==0) {
      return 0.;
    }
    return Double.valueOf(sout).doubleValue();
  }

  /**
  * This method emulates the C version of atoi() allowing <i>any</i> string
  * to be parsed into an integer.
  */
  public static synchronized int atoi(String src) {
    // atoi() (in C) allows extra strings after the number, and even no number
    // at all, so we have to work around this...
    int idx=0;
    src=src.trim();
    while(idx<src.length() && Character.isDigit(src.charAt(idx))) {
      idx++;
    }
    String sout=src.substring(0,idx).trim();
    if (sout.length()==0 || sout.replace('.',' ').trim().length()==0) {
      return 0;
    }
    return Integer.valueOf(sout).intValue();
  }

static final double PREC_IAU_CTIES=2.0; // J2000 +/- two centuries

} // End of class SwissLib.


/**
* This class implements a TransitCalculator for one planets
* position or speed.<p>
* You would create a TransitCalculator from this class and
* use the SwissEph.getTransit() methods to actually calculate
* a transit, e.g.:<p>
* <pre>
* SwissEph sw = new SwissEph(...);
* ...
* int flags = SweConst.SEFLG_SWIEPH |
*             SweConst.SEFLG_TRANSIT_LONGITUDE
*             SweConst.SEFLG_TRANSIT_SPEED;
* boolean backwards = false;
* 
* TransitCalculator tc = new TCPlanet(
*                                  sw,
*                                  SweConst.SE_SATURN,
*                                  flags,
*                                  0);
* ...
* double nextTransitET = sw.getTransitET(tc, jdET, backwards);
* </pre>
* This would calculate the (ET-) date, when the Saturn will
* change from retrograde to direct movement or vice versa.
*/
class TCPlanet extends TransitCalculator {


  private int planet;
  private int idx = 0; // The index into the xx[] array in swe_calc() to use:
  private int tflags = 0; // The transit flags
  private  int flags = 0;  // The calculation flags for swe_calc()
  private  double min = 0;
  private  double max = 0;
  // The y = f(x) value to reach, speaking mathematically...
  private double offset = 0.;



double minVal = 0., maxVal = 0.;  // Thinking about it...


  /**
  * Creates a new TransitCalculator for transits of any of the planets
  * positions (longitudinal / latitudinal and distance) or speeds, be
  * it in the geocentric or topocentric coordinate system, or in tropical
  * or sidereal zodiac.<p>
  * @param sw A SwissEph object, if you have one available. Can be null.
  * @param planet The transiting planet. Valid planets are SweConst.SE_SUN
  * up to SweConst.SE_INTP_PERG with the exception of SweConst.SE_EARTH.
  * @param flags The calculation type flags (SweConst.SEFLG_TRANSIT_LONGITUDE,
  * SweConst.SEFLG_TRANSIT_LATITUDE or SweConst.SEFLG_TRANSIT_DISTANCE in
  * conjunction with SweConst.SEFLG_TRANSIT_SPEED for transits over a speed
  * value). Also flags modifying the basic planet calculations, these are
  * SweConst.SEFLG_TOPOCTR, SweConst.SEFLG_HELCTR and SweConst.SEFLG_SIDEREAL,
  * plus the ephemeris flags SweConst.SEFLG_MOSEPH, SweConst.SEFLG_SWIEPH or
  * SweConst.SEFLG_JPLEPH optionally.
  * @param offset This is the desired transit degree or transit speed.
  * @see swisseph.TCPlanetPlanet#TCPlanetPlanet(SwissEph, int, int, int, double)
  * @see swisseph.SweConst#SEFLG_TRANSIT_LONGITUDE
  * @see swisseph.SweConst#SEFLG_TRANSIT_LATITUDE
  * @see swisseph.SweConst#SEFLG_TRANSIT_DISTANCE
  * @see swisseph.SweConst#SEFLG_TRANSIT_SPEED
  * @see swisseph.SweConst#SEFLG_YOGA_TRANSIT
  * @see swisseph.SweConst#SEFLG_TOPOCTR
  * @see swisseph.SweConst#SEFLG_HELCTR
  * @see swisseph.SweConst#SEFLG_SIDEREAL
  * @see swisseph.SweConst#SEFLG_MOSEPH
  * @see swisseph.SweConst#SEFLG_SWIEPH
  * @see swisseph.SweConst#SEFLG_JPLEPH
  */
  public TCPlanet(SwissEph sw, int planet, int flags, double offset) {
    // Check parameter: //////////////////////////////////////////////////////
    // List of all valid flags:
    this.tflags = flags;
    int vFlags = SweConst.SEFLG_EPHMASK |
                 SweConst.SEFLG_TOPOCTR |
                 SweConst.SEFLG_HELCTR |
                 SweConst.SEFLG_NOABERR |
                 SweConst.SEFLG_NOGDEFL |
                 SweConst.SEFLG_SIDEREAL |
                 SweConst.SEFLG_TRANSIT_LONGITUDE |
                 SweConst.SEFLG_TRANSIT_LATITUDE |
                 SweConst.SEFLG_TRANSIT_DISTANCE |
                 SweConst.SEFLG_TRANSIT_SPEED;
    // NOABERR and NOGDEFL is allowed for HELCTR, as they get set
    // anyway.
    if ((flags & SweConst.SEFLG_HELCTR) != 0) {
      vFlags |= SweConst.SEFLG_NOABERR | SweConst.SEFLG_NOGDEFL;
    }
    if ((flags&~vFlags) != 0) {
      throw new IllegalArgumentException("Invalid flag(s): "+(flags&~vFlags));
    }

    // Allow only one of SEFLG_TRANSIT_LONGITUDE, SEFLG_TRANSIT_LATITUDE, SEFLG_TRANSIT_DISTANCE:
    int type = flags&(SweConst.SEFLG_TRANSIT_LONGITUDE |
                      SweConst.SEFLG_TRANSIT_LATITUDE |
                      SweConst.SEFLG_TRANSIT_DISTANCE);
    if (type != SweConst.SEFLG_TRANSIT_LONGITUDE &&
        type != SweConst.SEFLG_TRANSIT_LATITUDE &&
        type != SweConst.SEFLG_TRANSIT_DISTANCE) {
      throw new IllegalArgumentException("Invalid flag combination '" + flags +
        "': specify at least exactly one of SEFLG_TRANSIT_LONGITUDE (" +
        SweConst.SEFLG_TRANSIT_LONGITUDE + "), SEFLG_TRANSIT_LATITUDE (" +
        SweConst.SEFLG_TRANSIT_LATITUDE + "), SEFLG_TRANSIT_DISTANCE (" +
        SweConst.SEFLG_TRANSIT_DISTANCE + ").");
    }
    if (planet<SweConst.SE_SUN ||
        planet>SweConst.SE_INTP_PERG ||
        planet==SweConst.SE_EARTH) {
      throw new IllegalArgumentException(
          "Unsupported planet number " + planet + " ("+
              sw.swe_get_planet_name(planet) + ")");
    }
    if ((flags & SweConst.SEFLG_HELCTR) != 0 &&
        (planet == SweConst.SE_MEAN_APOG ||
         planet == SweConst.SE_OSCU_APOG ||
         planet == SweConst.SE_MEAN_NODE ||
         planet == SweConst.SE_TRUE_NODE)) {
      throw new IllegalArgumentException(
          "Unsupported planet number " + planet + " (" +
              sw.swe_get_planet_name(planet) + ") for heliocentric " +
              "calculations");
    }

    this.planet = planet;

    this.sw = sw;
    if (this.sw == null) {
      this.sw = new SwissEph();
    }


    // The index into the xx[] array in swe_calc() to use:
    if ((flags&SweConst.SEFLG_TRANSIT_LATITUDE) != 0) { // Calculate latitudinal transits
      idx = 1;
    } else if ((flags&SweConst.SEFLG_TRANSIT_DISTANCE) != 0) { // Calculate distance transits
      idx = 2;
    }
    if ((flags&SweConst.SEFLG_TRANSIT_SPEED) != 0) { // Calculate speed transits
      idx += 3;
      flags |= SweConst.SEFLG_SPEED;
    }

    // Eliminate SEFLG_TRANSIT_* flags for use in swe_calc():
    flags &= ~(SweConst.SEFLG_TRANSIT_LONGITUDE |
               SweConst.SEFLG_TRANSIT_LATITUDE |
               SweConst.SEFLG_TRANSIT_DISTANCE |
               SweConst.SEFLG_TRANSIT_SPEED);
    this.flags = flags;


    rollover = (idx == 0);

    this.offset = checkOffset(offset);

    max = getSpeed(false);
    min = getSpeed(true);
  }

  /**
  * @return Returns true, if one position value is identical to another
  * position value. E.g., 360 degree is identical to 0 degree in
  * circular angles.
  * @see #rolloverVal
  */
  public boolean getRollover() {
    return rollover;
  }
  /**
  * This sets the degree or other value for the position or speed of
  * the planet to transit. It will be used on the next call to getTransit().
  * @param value The desired offset value.
  * @see #getOffset()
  */
  public void setOffset(double value) {
    offset = checkOffset(value);
  }
  /**
  * This returns the degree or other value of the position or speed of
  * the planet to transit.
  * @return The currently set offset value.
  * @see #setOffset(double)
  */
  public double getOffset() {
    return offset;
  }
  /**
  * This returns all the &quot;object identifiers s&quot; used in this
  * TransitCalculator. It may be the planet number or planet numbers,
  * when calculating planets.
  * @return An array of identifiers identifying the calculated objects.
  */
  public Object[] getObjectIdentifiers() {
    return new Object[]{"" + planet};
  }




  //////////////////////////////////////////////////////////////////////////////

  protected double calc(double jdET) {
    StringBuffer serr = new StringBuffer();
    double[] xx = new double[6];

    int ret = sw.swe_calc(jdET, planet, flags, xx, serr);
    if (ret<0) {
      throw new SwissephException(jdET, SwissephException.UNDEFINED,
          "Calculation failed with return code "+ret+":\n"+serr.toString());
    }

    return xx[idx];
  }


  protected double getMaxSpeed() {
    return max;
  }
  protected double getMinSpeed() {
    return min;
  }


  protected double getTimePrecision(double degPrec) {
    // Recalculate degPrec to mean the minimum  time, in which the planet can
    // possibly move that degree:
    double maxTimePerDeg = Math.max(Math.abs(min),Math.abs(max));
    if (maxTimePerDeg != 0.) {
      return degPrec / maxTimePerDeg;
    }
    return 1E-9;
  }

  protected double getDegreePrecision(double jd) {
    // Calculate the planet's minimum movement regarding the maximum available
    // precision.
    //
    // For all calculations, we assume the following minimum exactnesses
    // based on the discussions on http://www.astro.com/swisseph, even though
    // these values are nothing more than very crude estimations which should
    // leave us on the save side always, even more, when seeing that we always
    // consider the maximum possible speed / acceleration of a planet in the
    // transit calculations and not the real speed.
    //
    // Take degPrec to be the minimum exact degree in longitude
    double degPrec = 0.005;
    if (idx>2) { // Speed
      // "The speed precision is now better than 0.002" for all planets"
      degPrec = 0.002;
    } else { // Degrees
      // years 1980 to 2099:              0.005"
      // years before 1980:               0.08"   (from sun to jupiter)
      // years 1900 to 1980:              0.08"   (from saturn to neptune) (added: nodes)
      // years before 1900:               1"      (from saturn to neptune) (added: nodes)
      // years after 2099:                same as before 1900
      //
      if (planet>=SweConst.SE_SUN && planet<=SweConst.SE_JUPITER) {
        if (jd<1980 || jd>2099) {
          degPrec = 0.08;
        }
      } else {
        if (jd>=1900 && jd<1980) {
          degPrec = 0.08;
        } else if (jd<1900 || jd>2099) { // Unclear about true nodes...
          degPrec = 1;
        }
      }
    }
    degPrec/=3600.;
    degPrec*=0.5; // We take the precision to BETTER THAN ... as it is stated somewhere

    // We recalculate these degrees to the minimum time difference that CAN
    // possibly give us data differing more than the above given precision.
    switch (idx) {
      case 0: // Longitude
      case 1: // Latitude
      case 3: // Speed in longitude
      case 4: // Speed in latitude
        break;
      case 2: // Distance
      case 5: // Speed in distance
        // We need to recalculate the precision in degrees to a distance value.
        // For this we need the maximum distance to the centre of calculation,
        // which is the barycentre for the main planets.
        degPrec *= sw.ext.maxBaryDist[planet];
    }

    return degPrec;

    // Barycentre:
    //            0.981683040      1.017099581  (Barycenter of the earth!)
    // Sun:       0.982747149 AU   1.017261973 AU
    // Moon:      0.980136691 AU   1.019846623 AU
    // Mercury:   0.307590579 AU   0.466604085 AU
    // Venus:     0.717960758 AU   0.728698831 AU
    // Mars:      1.382830768 AU   0.728698831 AU
    // Jupiter:   5.448547595 AU   4.955912195 AU
    // Saturn:   10.117683425 AU   8.968685733 AU
    // Uranus:   18.327870391 AU  19.893326756 AU
    // Neptune:  29.935653168 AU  30.326750627 AU
    // Pluto:    29.830132096 AU  41.499626899 AU
    // MeanNode:  0.002569555 AU   0.002569555 AU
    // TrueNode:  0.002361814 AU   0.002774851 AU

    //
    // Minimum and maximum (barycentric) distances:
    // Sun:       0.000095 AU      0.01034 AU
    // Moon:      0.972939 AU      1.02625 AU
    // Mercury:   0.298782 AU      0.47569 AU
    // Venus:     0.709190 AU      0.73723 AU
    // Mars:      1.370003 AU      1.67685 AU
    // Jupiter:   4.912031 AU      5.47705 AU
    // Saturn:    8.948669 AU     10.13792 AU
    // Uranus:   18.257511 AU     20.12033 AU
    // Neptune:  29.780622 AU     30.36938 AU
    // Pluto:    29.636944 AU     49.43648 AU
    // MeanNode:  -        AU      -       AU ?
    // TrueNode:  -        AU      -       AU ?


    // Maximum and minimum (geocentric) distances:
    // Sun:        1.016688129 AU   0.983320477 AU
    // Moon:       0.002710279 AU   0.002439921 AU
    // Mercury:    0.549188094 AU   1.448731236 AU

    // Saturn:     7.84 / 7.85 AU  11.25/11.26  AU
    // Uranus:    21.147/21.148 AU              AU

  }


  //////////////////////////////////////////////////////////////////////////////

  private double checkOffset(double val) {
    // Similar rollover considerations for the latitude will be necessary, if
    // swe_calc() would return latitudinal values beyond -90 and +90 degrees.

    if (rollover) {        // Longitude from 0 to 360 degrees:
      while (val < 0.) { val += 360.; }
      val %= 360.;
      minVal = 0.;
      maxVal = 360.;
    } else if (idx == 1) { // Latitude from -90 to +90 degrees:
      while (val < -90.) { val += 180.; }
      while (val >  90.) { val -= 180.; }
      minVal = -90.;
      maxVal = +90.;
    }
    return val;
  }


  private double getSpeed(boolean min) {
    boolean lat = ((tflags&SweConst.SEFLG_TRANSIT_LATITUDE) != 0);
    boolean dist = ((tflags&SweConst.SEFLG_TRANSIT_DISTANCE) != 0);
    boolean speed = ((tflags&SweConst.SEFLG_TRANSIT_SPEED) != 0);
    boolean topo = ((tflags&SweConst.SEFLG_TOPOCTR) != 0);
    boolean helio = ((tflags&SweConst.SEFLG_HELCTR) != 0);

    // Some topocentric speeds are very different to the geocentric
    // speeds, so we use other values than for geocentric calculations:
    if (topo) {
      if (!sw.swed.geopos_is_set) {
        throw new IllegalArgumentException("Geographic position is not set for "+
                                           "requested topocentric calculations.");
      }
      if (sw.swed.topd.geoalt>50000.) {
        throw new IllegalArgumentException("Topocentric transit calculations "+
                                           "are restricted to a maximum "+
                                           "altitude of 50km so far.");
      } else if (sw.swed.topd.geoalt<-12000000) {
        throw new IllegalArgumentException("Topocentric transit calculations "+
                                           "are restricted to a minimum "+
                                           "altitude of -12000km so far.");
      }
      if (speed) {
        if (lat) {
          return (min?SwephData.minTopoLatAccel[planet]:SwephData.maxTopoLatAccel[planet]);
        } else if (dist) {
          return (min?SwephData.minTopoDistAccel[planet]:SwephData.maxTopoDistAccel[planet]);
        } else {
          return (min?SwephData.minTopoLonAccel[planet]:SwephData.maxTopoLonAccel[planet]);
        }
      } else {
        if (lat) {
          return (min?SwephData.minTopoLatSpeed[planet]:SwephData.maxTopoLatSpeed[planet]);
        } else if (dist) {
          return (min?SwephData.minTopoDistSpeed[planet]:SwephData.maxTopoDistSpeed[planet]);
        } else {
          return (min?SwephData.minTopoLonSpeed[planet]:SwephData.maxTopoLonSpeed[planet]);
        }
      }
    }

    // Heliocentric speeds are very different to the geocentric speeds, so
    // we use other values than for geocentric calculations:
    if (helio) {
      if (speed) {
        if (lat) {
          return (min?SwephData.minHelioLatAccel[planet]:SwephData.maxHelioLatAccel[planet]);
        } else if (dist) {
          return (min?SwephData.minHelioDistAccel[planet]:SwephData.maxHelioDistAccel[planet]);
        } else {
          return (min?SwephData.minHelioLonAccel[planet]:SwephData.maxHelioLonAccel[planet]);
        }
      } else {
        if (lat) {
          return (min?SwephData.minHelioLatSpeed[planet]:SwephData.maxHelioLatSpeed[planet]);
        } else if (dist) {
          return (min?SwephData.minHelioDistSpeed[planet]:SwephData.maxHelioDistSpeed[planet]);
        } else {
          return (min?SwephData.minHelioLonSpeed[planet]:SwephData.maxHelioLonSpeed[planet]);
        }
      }
    }


    // Geocentric:
    if (speed) {
      if (lat) {
        return (min?SwephData.minLatAccel[planet]:SwephData.maxLatAccel[planet]);
      } else if (dist) {
        return (min?SwephData.minDistAccel[planet]:SwephData.maxDistAccel[planet]);
      } else {
        return (min?SwephData.minLonAccel[planet]:SwephData.maxLonAccel[planet]);
      }
    } else {
      if (lat) {
        return (min?SwephData.minLatSpeed[planet]:SwephData.maxLatSpeed[planet]);
      } else if (dist) {
        return (min?SwephData.minDistSpeed[planet]:SwephData.maxDistSpeed[planet]);
      } else {
        return (min?SwephData.minLonSpeed[planet]:SwephData.maxLonSpeed[planet]);
      }
    }
  }

  public String toString() {
    return "[Planet:" + planet + "];Offset:" + getOffset();
  }
}


/**
* This class implements a TransitCalculator for two planets
* in relative positions or speeds to each other.<p>
* You would create a TransitCalculator from this class and
* use the SwissEph.getTransit() methods to actually calculate
* a transit, e.g.:<p>
* <pre>
* SwissEph sw = new SwissEph(...);
* ...
* int flags = SweConst.SEFLG_SWIEPH
*             SweConst.SEFLG_TRANSIT_LATITUDE |
*             SweConst.SEFLG_TRANSIT_SPEED;
* boolean backwards = false;
* 
* TransitCalculator tc = new TCPlanetPlanet(
*                                  sw,
*                                  SweConst.SE_MERCURY,
*                                  SweConst.SE_VENUS,
*                                  flags,
*                                  0.48);
* ...
* double nextTransitUT = sw.getTransitUT(tc, jdUT, backwards);
* </pre>
* This would calculate the (UT-) date, when Mercury and Venus will
* have a very different latitudinal speed (and Mercury the higher
* speed of both...).
*/
class TCPlanetPlanet extends TransitCalculator {


  private int pl1, pl2;
  private int idx = 0; // The index into the xx[] array in swe_calc() to use:
  private int tflags = 0; // The transit flags
  private int flags = 0;  // The calculation flags for swe_calc()
  private boolean calcYoga = false;
  private double maxSpeed1;
  private double minSpeed1;
  private double maxSpeed2;
  private double minSpeed2;
  private double minSpeed, maxSpeed;
  // The y = f(x) value to reach, speaking mathematically...
  private double offset = 0.;



double minVal = 0., maxVal = 0.;  // Thinking about it...


  /**
  * Creates a new TransitCalculator for relative transits of two different
  * planets to each other with the option for transits over longitudes,
  * latitudes, distance or the speed in any of these directions in the
  * geocentric or topocentric coordinate system, and in tropical or sidereal
  * zodiac system, both with the sum and difference of both planets positions
  * and speeds.<p>
  * @param sw A SwissEph object, if you have one available. Can be null.
  * @param pl1 The first planet. Valid planets are SweConst.SE_SUN up to
  * SweConst.SE_INTP_PERG with the exception of  SweConst.SE_EARTH.
  * @param pl2 The second planet that will be transited by the first planet.
  * @param flags The calculation type flags (SweConst.SEFLG_TRANSIT_LONGITUDE,
  * SweConst.SEFLG_TRANSIT_LATITUDE or SweConst.SEFLG_TRANSIT_DISTANCE in
  * conjunction with SweConst.SEFLG_TRANSIT_SPEED for transits over a speed
  * value and SweConst.SEFLG_YOGA_TRANSIT to calculate for the SUM of the
  * two positions or speeds instead of the difference). Also flags modifying
  * the basic planet calculations, these are SweConst.SEFLG_TOPOCTR,
  * SweConst.SEFLG_HELCTR and SweConst.SEFLG_SIDEREAL, plus the (optional)
  * ephemeris flags SweConst.SEFLG_MOSEPH, SweConst.SEFLG_SWIEPH or
  * SweConst.SEFLG_JPLEPH.
  * @param offset This is an offset to the exact conjunction transit point.
  * E.g., when the offset is 180 for longitude calculations, you will get the
  * dates, when the two planets are opposite to each other. Note: The offset
  * is related to the FIRST planet, so an offset value of 30 degree will find
  * the transit points, when the FIRST planet will be 30 degrees behind the
  * the position of the second planet.
  * @see swisseph.TCPlanet#TCPlanet(SwissEph, int, int, double)
  * @see swisseph.SweConst#SEFLG_TRANSIT_LONGITUDE
  * @see swisseph.SweConst#SEFLG_TRANSIT_LATITUDE
  * @see swisseph.SweConst#SEFLG_TRANSIT_DISTANCE
  * @see swisseph.SweConst#SEFLG_TRANSIT_SPEED
  * @see swisseph.SweConst#SEFLG_YOGA_TRANSIT
  * @see swisseph.SweConst#SEFLG_TOPOCTR
  * @see swisseph.SweConst#SEFLG_HELCTR
  * @see swisseph.SweConst#SEFLG_SIDEREAL
  * @see swisseph.SweConst#SEFLG_MOSEPH
  * @see swisseph.SweConst#SEFLG_SWIEPH
  * @see swisseph.SweConst#SEFLG_JPLEPH
  */
  public TCPlanetPlanet(SwissEph sw, int pl1, int pl2, int flags, double offset) {
    this.sw = sw;
    if (this.sw == null) {
      this.sw = new SwissEph();
    }

    // Check parameter: //////////////////////////////////////////////////////
    // List of all valid flags:
    this.tflags = flags;
    int vFlags = SweConst.SEFLG_EPHMASK |
                 SweConst.SEFLG_TOPOCTR |
                 SweConst.SEFLG_HELCTR |
                 SweConst.SEFLG_NOABERR |
                 SweConst.SEFLG_NOGDEFL |
                 SweConst.SEFLG_SIDEREAL |
                 SweConst.SEFLG_YOGA_TRANSIT |
                 SweConst.SEFLG_TRANSIT_LONGITUDE |
                 SweConst.SEFLG_TRANSIT_LATITUDE |
                 SweConst.SEFLG_TRANSIT_DISTANCE |
                 SweConst.SEFLG_TRANSIT_SPEED;
    // NOABERR and NOGDEFL is allowed for HELCTR, as they get set
    // anyway.
    if ((flags & SweConst.SEFLG_HELCTR) != 0) {
      vFlags |= SweConst.SEFLG_NOABERR | SweConst.SEFLG_NOGDEFL;
    }
    if ((flags&~vFlags) != 0) {
      throw new IllegalArgumentException("Invalid flag(s): "+(flags&~vFlags));
    }

    // Allow only one of SEFLG_TRANSIT_LONGITUDE, SEFLG_TRANSIT_LATITUDE, SEFLG_TRANSIT_DISTANCE:
    int type = flags&(SweConst.SEFLG_TRANSIT_LONGITUDE |
                      SweConst.SEFLG_TRANSIT_LATITUDE |
                      SweConst.SEFLG_TRANSIT_DISTANCE);
    if (type != SweConst.SEFLG_TRANSIT_LONGITUDE &&
        type != SweConst.SEFLG_TRANSIT_LATITUDE &&
        type != SweConst.SEFLG_TRANSIT_DISTANCE) {
      throw new IllegalArgumentException("Invalid flag combination '" + flags +
        "': specify at least exactly one of SEFLG_TRANSIT_LONGITUDE (" +
        SweConst.SEFLG_TRANSIT_LONGITUDE + "), SEFLG_TRANSIT_LATITUDE (" +
        SweConst.SEFLG_TRANSIT_LATITUDE + "), SEFLG_TRANSIT_DISTANCE (" +
        SweConst.SEFLG_TRANSIT_DISTANCE + ").");
    }
    if (pl1<SweConst.SE_SUN ||
        pl1>SweConst.SE_INTP_PERG ||
        pl1==SweConst.SE_EARTH) {
      throw new IllegalArgumentException(
          "Unsupported planet number " + pl1 + " ("+
              sw.swe_get_planet_name(pl1) + ")");
    }
    if (pl2<SweConst.SE_SUN ||
        pl2>SweConst.SE_INTP_PERG ||
        pl2==SweConst.SE_EARTH) {
      throw new IllegalArgumentException(
          "Unsupported planet number " + pl1 + " ("+
              sw.swe_get_planet_name(pl1) + ")");
    }
    if ((flags & SweConst.SEFLG_HELCTR) != 0 &&
        (pl1 == SweConst.SE_MEAN_APOG ||
         pl1 == SweConst.SE_OSCU_APOG ||
         pl1 == SweConst.SE_MEAN_NODE ||
         pl1 == SweConst.SE_TRUE_NODE)) {
      throw new IllegalArgumentException(
          "Unsupported planet number " + pl1 + " (" +
              sw.swe_get_planet_name(pl1) + ") for heliocentric " +
              "calculations");
    }
    if ((flags & SweConst.SEFLG_HELCTR) != 0 &&
        (pl2 == SweConst.SE_MEAN_APOG ||
         pl2 == SweConst.SE_OSCU_APOG ||
         pl2 == SweConst.SE_MEAN_NODE ||
         pl2 == SweConst.SE_TRUE_NODE)) {
      throw new IllegalArgumentException(
          "Unsupported planet number " + pl2 + " (" +
              sw.swe_get_planet_name(pl2) + ") for heliocentric " +
              "calculations");
    }
    if (pl1 == pl2) {
      throw new IllegalArgumentException(
                   "Transiting and referred planet have to be different!");
    }

    this.pl1 = pl1;
    this.pl2 = pl2;

    calcYoga = ((flags & SweConst.SEFLG_YOGA_TRANSIT) != 0);


    // The index into the xx[] array in swe_calc() to use:
    if ((flags&SweConst.SEFLG_TRANSIT_LATITUDE) != 0) { // Calculate latitudinal transits
      idx = 1;
    } else if ((flags&SweConst.SEFLG_TRANSIT_DISTANCE) != 0) { // Calculate distance transits
      idx = 2;
    }
    if ((flags&SweConst.SEFLG_TRANSIT_SPEED) != 0) { // Calculate speed transits
      idx += 3;
      flags |= SweConst.SEFLG_SPEED;
    }

    // Eliminate SEFLG_TRANSIT_* flags for use in swe_calc():
    flags &= ~(SweConst.SEFLG_TRANSIT_LONGITUDE |
               SweConst.SEFLG_TRANSIT_LATITUDE |
               SweConst.SEFLG_TRANSIT_DISTANCE |
               SweConst.SEFLG_YOGA_TRANSIT |
               SweConst.SEFLG_TRANSIT_SPEED);
    this.flags = flags;

    // Calculate basic parameters: ///////////////////////////////////////////
    rollover = (idx == 0);

    this.offset = checkOffset(offset);


    maxSpeed1=getSpeed(false,pl1);
    minSpeed1=getSpeed(true,pl1);
    maxSpeed2=getSpeed(false,pl2);
    minSpeed2=getSpeed(true,pl2);

    if (calcYoga) {
      minSpeed = minSpeed1+minSpeed2;
      maxSpeed = maxSpeed1+maxSpeed2;
    } else {
      if (rollover) {
        minSpeed = (maxSpeed1>maxSpeed2)?minSpeed1-maxSpeed2:minSpeed2-maxSpeed1;
        maxSpeed = (maxSpeed1>maxSpeed2)?maxSpeed1-minSpeed2:maxSpeed2-minSpeed1;
      } else {
        minSpeed = Math.max(minSpeed1-maxSpeed2, minSpeed2-maxSpeed1);
        maxSpeed = Math.max(maxSpeed1-minSpeed2, maxSpeed2-minSpeed1);
      }
    }

  }

  /**
  * @return Returns true, if one position value is identical to another
  * position value. E.g., 360 degree is identical to 0 degree in
  * circle angles.
  * @see #rolloverVal
  */
  public boolean getRollover() {
    return rollover;
  }
  /**
  * This sets the transit degree or other transit value for the difference
  * or sum of the positions or speeds of both planets. It will be used on
  * the next call to getTransit().
  * @param value The offset value.
  * @see #getOffset()
  */
  public void setOffset(double value) {
    offset = checkOffset(value);
  }
  /**
  * This returns the transit degree or other transit value of the relative
  * position or speed of the two planets.
  * @return The current offset value.
  * @see #setOffset(double)
  */
  public double getOffset() {
    return offset;
  }
  /**
  * This returns all the &quot;object identifiers s&quot; used in this
  * TransitCalculator. It may be the planet number or planet numbers,
  * when calculating planets.
  * @return An array of identifiers identifying the calculated objects.
  */
  public Object[] getObjectIdentifiers() {
    return new Object[]{"" + pl1, "" + pl2};
  }




  ///////////////////////////////////////////////////////////////////////////////
  protected double getMaxSpeed() {
    return maxSpeed;
  }
  protected double getMinSpeed() {
    return minSpeed;
  }

  protected double calc(double jdET) {
    StringBuffer serr = new StringBuffer();
    double[] xx1 = new double[6];
    double[] xx2 = new double[6];

    int ret = sw.swe_calc(jdET, pl1, flags, xx1, serr);
    if (ret<0) {
      throw new SwissephException(jdET, SwissephException.UNDEFINED,
          "Calculation failed with return code " + ret + ":\n" +
          serr.toString());
    }

    ret = sw.swe_calc(jdET, pl2, flags, xx2, serr);
    if (ret<0) {
      throw new SwissephException(jdET, SwissephException.UNDEFINED,
          "Calculation failed with return code " + ret + ":\n" +
          serr.toString());
    }

    return xx1[idx] + (calcYoga?xx2[idx]:-xx2[idx]);
  }



  protected double getTimePrecision(double degPrec) {
    // Recalculate degPrec to mean the minimum  time, in which the planet can
    // possibly move that degree:
    double amin = Math.min(Math.abs(minSpeed1),Math.abs(minSpeed2));
    double amax = Math.min(Math.abs(maxSpeed1),Math.abs(maxSpeed2));

    double maxVal = Math.max(Math.abs(amin),Math.abs(amax));
    if (maxVal != 0.) {
      return degPrec / maxVal;
    }
    return 1E-9;
  }

  protected double getDegreePrecision(double jd) {
    // Calculate the planet's minimum movement regarding the maximum available
    // precision.
    //
    // For all calculations, we assume the following minimum exactnesses
    // based on the discussions on http://www.astro.com/swisseph, even though
    // these values are nothing more than very crude estimations which should
    // leave us on the save side always, even more, when seeing that we always
    // consider the maximum possible speed / acceleration of a planet in the
    // transit calculations and not the real speed.
    //
    // Take degPrec to be the minimum exact degree in longitude
    double degPrec = 0.005;
    if (idx>2) { // Speed
      // "The speed precision is now better than 0.002" for all planets"
      degPrec = 0.002;
    } else { // Degrees
      // years 1980 to 2099:              0.005"
      // years before 1980:               0.08"   (from sun to jupiter)
      // years 1900 to 1980:              0.08"   (from saturn to neptune) (added: nodes)
      // years before 1900:               1"      (from saturn to neptune) (added: nodes)
      // years after 2099:                same as before 1900
      //
      if (pl1>=SweConst.SE_SUN && pl1<=SweConst.SE_JUPITER) {
        if (jd<1980 || jd>2099) {
          degPrec = 0.08;
        }
      } else {
        if (jd>=1900 && jd<1980) {
          degPrec = 0.08;
        } else if (jd<1900 || jd>2099) { // Unclear about true nodes...
          degPrec = 1;
        }
      }
      if (pl2>=SweConst.SE_SUN && pl2<=SweConst.SE_JUPITER) {
        if (jd<1980 || jd>2099) {
          degPrec = Math.max(0.08,degPrec);
        }
      } else {
        if (jd>=1900 && jd<1980) {
          degPrec = Math.max(0.08,degPrec);
        } else if (jd<1900 || jd>2099) { // Unclear about true nodes...
          degPrec = Math.max(1,degPrec);
        }
      }
    }
    degPrec/=3600.;
    degPrec*=0.5; // We take the precision to be BETTER THAN ... as it is stated somewhere

    // We recalculate these degrees to the minimum time difference that CAN
    // possibly give us data differing more than the above given precision.
    switch (idx) {
      case 0: // Longitude
      case 1: // Latitude
      case 3: // Speed in longitude
      case 4: // Speed in latitude
        break;
      case 2: // Distance
      case 5: // Speed in distance
        // We need to recalculate the precision in degrees to a distance value.
        // For this we need the maximum distance to the centre of calculation,
        // which is the barycentre for the main planets.
        degPrec *= Math.max(sw.ext.maxBaryDist[pl1],
                            sw.ext.maxBaryDist[pl2]);
    }

    return degPrec;

    // Barycentre:
    //            0.981683040      1.017099581  (Barycenter of the earth!)
    // Sun:       0.982747149 AU   1.017261973 AU
    // Moon:      0.980136691 AU   1.019846623 AU
    // Mercury:   0.307590579 AU   0.466604085 AU
    // Venus:     0.717960758 AU   0.728698831 AU
    // Mars:      1.382830768 AU   0.728698831 AU
    // Jupiter:   5.448547595 AU   4.955912195 AU
    // Saturn:   10.117683425 AU   8.968685733 AU
    // Uranus:   18.327870391 AU  19.893326756 AU
    // Neptune:  29.935653168 AU  30.326750627 AU
    // Pluto:    29.830132096 AU  41.499626899 AU
    // MeanNode:  0.002569555 AU   0.002569555 AU
    // TrueNode:  0.002361814 AU   0.002774851 AU

    //
    // Minimum and maximum (barycentric) distances:
    // Sun:       0.000095 AU      0.01034 AU
    // Moon:      0.972939 AU      1.02625 AU
    // Mercury:   0.298782 AU      0.47569 AU
    // Venus:     0.709190 AU      0.73723 AU
    // Mars:      1.370003 AU      1.67685 AU
    // Jupiter:   4.912031 AU      5.47705 AU
    // Saturn:    8.948669 AU     10.13792 AU
    // Uranus:   18.257511 AU     20.12033 AU
    // Neptune:  29.780622 AU     30.36938 AU
    // Pluto:    29.636944 AU     49.43648 AU
    // MeanNode:  -        AU      -       AU ?
    // TrueNode:  -        AU      -       AU ?


    // Maximum and minimum (geocentric) distances:
    // Sun:        1.016688129 AU   0.983320477 AU
    // Moon:       0.002710279 AU   0.002439921 AU
    // Mercury:    0.549188094 AU   1.448731236 AU

    // Saturn:     7.84 / 7.85 AU  11.25/11.26  AU
    // Uranus:    21.147/21.148 AU              AU

  }


  //////////////////////////////////////////////////////////////////////////////

  private double checkOffset(double val) {
    // Similar rollover considerations for the latitude will be necessary, if
    // swe_calc() would return latitudinal values beyond -90 and +90 degrees.

    if (rollover) {        // Longitude from 0 to 360 degrees:
      while (val < 0.) { val += 360.; }
      val %= 360.;
      minVal = 0.;
      maxVal = 360.;
    } else if (idx == 1) { // Latitude from -90 to +90 degrees:
      while (val < -90.) { val += 180.; }
      while (val >  90.) { val -= 180.; }
      minVal = -90.;
      maxVal = +90.;
    }
    return val;
  }


  private double getSpeed(boolean min, int planet) {
    boolean lat = ((tflags&SweConst.SEFLG_TRANSIT_LATITUDE) != 0);
    boolean dist = ((tflags&SweConst.SEFLG_TRANSIT_DISTANCE) != 0);
    boolean speed = ((tflags&SweConst.SEFLG_TRANSIT_SPEED) != 0);
    boolean topo = ((tflags&SweConst.SEFLG_TOPOCTR) != 0);
    boolean helio = ((tflags&SweConst.SEFLG_HELCTR) != 0);

    // Some topocentric speeds are very different to the geocentric
    // speeds, so we use other values than for geocentric calculations:
    if (topo) {
      if (!sw.swed.geopos_is_set) {
        throw new IllegalArgumentException("Geographic position is not set for "+
                                           "requested topocentric calculations.");
      }
      if (sw.swed.topd.geoalt>50000.) {
        throw new IllegalArgumentException("Topocentric transit calculations "+
                                           "are restricted to a maximum "+
                                           "altitude of 50km so far.");
      } else if (sw.swed.topd.geoalt<-12000000) {
        throw new IllegalArgumentException("Topocentric transit calculations "+
                                           "are restricted to a minimum "+
                                           "altitude of -12000km so far.");
      }
      if (speed) {
        if (lat) {
          return (min?SwephData.minTopoLatAccel[planet]:SwephData.maxTopoLatAccel[planet]);
        } else if (dist) {
          return (min?SwephData.minTopoDistAccel[planet]:SwephData.maxTopoDistAccel[planet]);
        } else {
          return (min?SwephData.minTopoLonAccel[planet]:SwephData.maxTopoLonAccel[planet]);
        }
      } else {
        if (lat) {
          return (min?SwephData.minTopoLatSpeed[planet]:SwephData.maxTopoLatSpeed[planet]);
        } else if (dist) {
          return (min?SwephData.minTopoDistSpeed[planet]:SwephData.maxTopoDistSpeed[planet]);
        } else {
          return (min?SwephData.minTopoLonSpeed[planet]:SwephData.maxTopoLonSpeed[planet]);
        }
      }
    }

    // Heliocentric speeds are very different to the geocentric speeds, so
    // we use other values than for geocentric calculations:
    if (helio) {
      if (speed) {
        if (lat) {
          return (min?SwephData.minHelioLatAccel[planet]:SwephData.maxHelioLatAccel[planet]);
        } else if (dist) {
          return (min?SwephData.minHelioDistAccel[planet]:SwephData.maxHelioDistAccel[planet]);
        } else {
          return (min?SwephData.minHelioLonAccel[planet]:SwephData.maxHelioLonAccel[planet]);
        }
      } else {
        if (lat) {
          return (min?SwephData.minHelioLatSpeed[planet]:SwephData.maxHelioLatSpeed[planet]);
        } else if (dist) {
          return (min?SwephData.minHelioDistSpeed[planet]:SwephData.maxHelioDistSpeed[planet]);
        } else {
          return (min?SwephData.minHelioLonSpeed[planet]:SwephData.maxHelioLonSpeed[planet]);
        }
      }
    }

    // Geocentric:
    if (speed) {
      if (lat) {
        return (min?SwephData.minLatAccel[planet]:SwephData.maxLatAccel[planet]);
      } else if (dist) {
        return (min?SwephData.minDistAccel[planet]:SwephData.maxDistAccel[planet]);
      } else {
        return (min?SwephData.minLonAccel[planet]:SwephData.maxLonAccel[planet]);
      }
    } else {
      if (lat) {
        return (min?SwephData.minLatSpeed[planet]:SwephData.maxLatSpeed[planet]);
      } else if (dist) {
        return (min?SwephData.minDistSpeed[planet]:SwephData.maxDistSpeed[planet]);
      } else {
        return (min?SwephData.minLonSpeed[planet]:SwephData.maxLonSpeed[planet]);
      }
    }
  }

  public String toString() {
    return "[Planets:" + pl1 + "/" + pl2 + "];Offset:" + getOffset();
  }
}
/*
   This is a port of the Swiss Ephemeris Free Edition, Version 1.70.02
   of Astrodienst AG, Switzerland from the original C Code to Java. For
   copyright see the original copyright notices below and additional
   copyright notes in the file named LICENSE, or - if this file is not
   available - the copyright notes at http://www.astro.ch/swisseph/ and
   following. 

   For any questions or comments regarding this port to Java, you should
   ONLY contact me and not Astrodienst, as the Astrodienst AG is not involved
   in this port in any way.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 23rd of April 2001

*/
/* Copyright (C) 1997 - 2000 Astrodienst AG, Switzerland.
   All rights reserved.

  This file is part of Swiss Ephemeris Free Edition.

  Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND.  No author
  or distributor accepts any responsibility for the consequences of using it,
  or for whether it serves any particular purpose or works at all, unless he
  or she says so in writing.  Refer to the Swiss Ephemeris Public License
  ("SEPL" or the "License") for full details.

  Every copy of Swiss Ephemeris must include a copy of the License,
  normally in a plain ASCII text file named LICENSE.  The License grants you
  the right to copy, modify and redistribute Swiss Ephemeris, but only
  under certain conditions described in the License.  Among other things, the
  License requires that the copyright notices and this notice be preserved on
  all copies.

  For uses of the Swiss Ephemeris which do not fall under the definitions
  laid down in the Public License, the Swiss Ephemeris Professional Edition
  must be purchased by the developer before he/she distributes any of his
  software or makes available any product or service built upon the use of
  the Swiss Ephemeris.

  Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl

  The authors of Swiss Ephemeris have no control or influence over any of
  the derived works, i.e. over software or services created by other
  programmers which use Swiss Ephemeris functions.

  The names of the authors or of the copyright holder (Astrodienst) must not
  be used for promoting any software, product or service which uses or contains
  the Swiss Ephemeris. This copyright notice is the ONLY place where the
  names of the authors can legally appear, except in cases where they have
  given special permission in writing.

  The trademarks 'Swiss Ephemeris' and 'Swiss Ephemeris inside' may be used
  for promoting such software, products or services.
*/


class TopoData {
  double geolon, geolat, geoalt;
  double teval;
  double tjd_ut;
  double xobs[]=new double[6];

}


abstract class TransitCalculator {
  SwissEph sw;

  // This method changes the offset value for the transit
  /**
  * @return Returns true, if one position value is identical to another
  * position value. E.g., 360 degree is identical to 0 degree in
  * circular angles.
  * @see #rolloverVal
  */
  public abstract boolean getRollover();
  /**
  * This sets the degree or other value for the position or speed of
  * the planet to transit. It will be used on the next call to getTransit().
  * @param value The desired offset value.
  * @see #getOffset()
  */
  public abstract void setOffset(double value);
  /**
  * This returns the degree or other value of the position or speed of
  * the planet to transit.
  * @return The currently set offset value.
  * @see #setOffset(double)
  */
  public abstract double getOffset();
  /**
  * This returns all the &quot;object identifiers s&quot; used in this
  * TransitCalculator. It may be the planet number or planet numbers,
  * when calculating planets.
  * @return An array of identifiers identifying the calculated objects.
  */
  public Object[] getObjectIdentifiers() {
    return null;
  }





  //////////////////////////////////////////////////////////////////////////////


  // Rollover from 360 degrees to 0 degrees for planetary longitudinal positions
  // or similar, or continuous and unlimited values:
  protected boolean rollover = false; // We need a rollover of 360 degrees being
                                      // equal to 0 degrees for longitudinal
                                      // position transits only.
  protected double rolloverVal = 360.; // if rollover, we roll over from 360 to 0
                                       // as default. Other values than 0.0 for the
                                       // minimum values are not supported for now.

  // These methods have to return the maxima of the first derivative of the
  // function, mathematically spoken...
  protected abstract double getMaxSpeed();
  protected abstract double getMinSpeed();

  // This method returns the precision in x-direction in an x-y-coordinate
  // system for the transit calculation routine.
  protected abstract double getDegreePrecision(double jdET);

  // This method returns the precision in y-direction in an x-y-coordinate
  // system from the x-direction precision.
  protected abstract double getTimePrecision(double degPrec);

  // This is the main routine, mathematically speaking: returning f(x):
  protected abstract double calc(double jdET);
}

/*
   The swisseph package used herein is a Java port of the Swiss Ephemeris
   of Astrodienst Zuerich, Switzerland. For copyright notices see the file
   LICENSE or - if not included - see at http://www.astro.com for license
   information.

   This small program is heavily based upon sweclips.c from the original
   Swiss Ephemeris package.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 25th of November 2001
*/


/**
* Test program for planetary transits.
* See class swisseph.SwissEph.<P>
* Invoke with parameter -h to get the help text.
* @see swisseph.SwissEph
*/
class Transits {

  // Consecutive transit calculations need a minimum time difference
  static final double MIN_TIME_DIFF = 1./24./3600./2.;

  static final String infocmd0 = "\n"+
  "  'Transits' computes planetary transits over specified longitudes,\n"+
  "  latitudes, distances, speeds in any of these directions or\n"+
  "  in any above variation over other planets.\n\n";

  static final String infocmd1 = "\n"+
  "  You can calculate several kinds of transits:\n\n"+
  "    - When do planets transit a certain longitude,\n"+
  "      latitude or distance:\n"+
  "         -p.. -b... -lon... [other options]\n"+
  "         -p.. -b... -lat... [other options]\n"+
  "         -p.. -b... -dist... [other options]\n"+
  "    - When do planets transit a certain speed in\n"+
  "      longitude, latitude or distance:\n"+
  "         -p.. -b... -s -lon... [other options]\n"+
  "         -p.. -b... -s -lat... [other options]\n"+
  "         -p.. -b... -s -dist... [other options]\n"+
  "    - When do planets transit another planets\n"+
  "      longitude, latitude or distance:\n"+
  "         -p.. -P.. -b... -lon... [other options])\n"+
  "         -p.. -P.. -b... -lat... [other options])\n"+
  "         -p.. -P.. -b... -dist... [other options])\n"+
  "    - When do planets transit another planets\n"+
  "      speed in longitude, latitude or distance:\n"+
  "         -p.. -P.. -b... -s -lon... [other options])\n"+
  "         -p.. -P.. -b... -s -lat... [other options])\n"+
  "         -p.. -P.. -b... -s -dist... [other options])\n"+
  "    - When does the SUM (==Yoga) of two planets positions\n"+
  "      (or speeds with -s option) reach a certain value:\n"+
  "         -p.. -P.. -b... +lon... [other options])\n"+
  "         -p.. -P.. -b... +lat... [other options])\n"+
  "         -p.. -P.. -b... +dist... [other options])\n"+
  "\n    Other options:\n"+
  "    - List all transits in a date range by giving a second date:\n"+
  "         [base options] -b... -b...\n"+
  "         [base options] -b... -B...\n"+
  "    - Give an exact starting and / or end time:\n"+
  "         [base options] -et... (or: -t...)\n"+
  "         [base options] -ut...\n"+
  "         [base options] -T...\n"+
  "         [base options] -UT...\n"+
  "    - List a fixed number of consecutive transits:\n"+
  "         [base options] -n...\n"+
  "         [base options] -N...\n"+
  "    - Search backwards (\"reverse\"):\n"+
  "         [base options] -r\n"+
  "    - Calculate in the sidereal zodiac:\n"+
  "         [base options] -sid.\n"+
  "    - Calculate topocentric instead of geocentric:\n"+
  "         [base options] -topo...\n"+
  "         [base options] -hel...\n"+
  "    - Modify the input parsing:\n"+
  "         [base options] -loc... (input parsing AND output formatting)\n"+
  "         [base options] -iloc...\n"+
  "         [base options] -Dloc[...]\n"+
  "         [base options] -Nloc[...]\n"+
  "    - Modify the output and output formatting:\n"+
  "         [base options] -head, -q\n"+
  "         [base options] -f...\n"+
  "         [base options] -loc... (input parsing AND output formatting)\n"+
  "         [base options] -oloc...\n"+
  "         [base options] -dloc[...]\n"+
  "         [base options] -nloc[...]\n"+
  "    - Give the path to the ephemeris data files:\n"+
  "         [base options] -edir...\n"+
  "    - List all availables Locales for use with -loc etc. options:\n"+
  "         -locales\n"+
  "    - Convert between Julian day numbers and dates and vice versa:\n"+
  "         -b... -cv [other options]\n"+
  "";

  static final String infodate = "\n"+
  "  Date entry:\n"+
  "  You can enter the start date entry (option '-b') and the end date\n"+
  "  entry (if required, option '-B') in one of the following formats:\n"+
  "\n"+
  "        2-27-1991       three integers separated by a nondigit character for\n"+
  "                        day month year. Dates are interpreted as Gregorian\n"+
  "                        after October 4, 1582 and as Julian Calender before.\n"+
  "                        Time is always set to midnight. Use -et / -ut to\n"+
  "                        set the time.\n"+
  "                        The sequence of year, month and day is determined\n"+
  "                        by the locale settings, see options -loc etc.. With\n"+
  "                        -locde 5.8.2000 would be interpreted as a date in\n"+
  "                        August, -locen would see a date in May 2000.\n"+
  "                        Use -et / -ut without any following time to force\n"+
  "                        times to be interpreted as ET (-et) or UT (-ut).\n"+
  "                        Default ist ET.\n"+
  "                        If the three letters jul are appended to the date,\n"+
  "                        the Julian calendar is used even after 1582.\n"+
  "                        If the four letters greg are appended to the date,\n"+
  "                        the Gregorian calendar is used even before 1582.\n"+
  "\n"+
  "        j2400123.67     the letter j followed by a real number, for\n"+
  "                        the absolute Julian daynumber of the start date.\n"+
  "                        Fraction .5 indicates midnight, fraction .0\n"+
  "                        indicates noon, other times of the day can be\n"+
  "                        chosen accordingly.\n"+
  "        today           this will use the current date.\n"+
  "  You can enter any time entry (options -et / -ET / -ut / -UT) in the\n"+
  "  the following formats:\n"+
  "        hh:mm:ss        three integers representing hour, minutes and\n"+
  "                        seconds separated by non-digits\n"+
  "        now             (String) use current time.\n";

  String infocmd2 = null;
  String infoexamples = null;

  private void initHelpTexts() {
  infocmd2 = "\n"+
  "  Command line options:\n"+
  "    Main options:\n"+
  "        -bDATE    use this date; use format -b3/24/1993 or -bj2400000.5,\n"+
  "                  to express the date as absolute Julian day number.\n"+
  "                  Use option -hdate for more information.\n"+
  "                  You can use two -b... options to give a starting and\n"+
  "                  an end date.\n"+
  "                  Note: the date format is month/day/year (US style)\n"+
  "                  by default.\n"+
  "        -j....    Same as -bj....\n"+
  "        -BDATE    use this date as the end date for a time range, use\n"+
  "                  -Bj..... for a julian day number\n"+
  "                  Same as a second -b... option, but it searches for\n"+
  "                  transits over ANY of the given transit points instead\n"+
  "                  of looking for the NEXT transit point only, when giving\n"+
  "                  more than one longitude etc.. See the -n / -N options\n"+
  "                  for similar considerations.\n"+
  "        -J....    Same as -Bj....\n"+
  "        -uthh:mm:ss hour in UT for -b... date\n"+
  "                    You can use the String 'now' for the current UTC time.\n"+
  "        -UThh:mm:ss hour in UT for -B... date. If -UT is not given, it\n"+
  "                    defaults to the value of -ut\n"+
  "        -ethh:mm:ss hour in ET for -b... date, it defaults to 0.0\n"+
  "        -EThh:mm:ss hour in ET for -B... date. Default: the value of -et\n"+
  "                    You can use the String 'now' for the current UTC time.\n"+
  "        -p.\n"+
  "        -p...     One or more planets for which to calculate the transit.\n"+
  "                  Supported planet numbers are:\n"+
  "                    0 Sun        8 Neptune            D Chiron\n"+
  "                    1 Moon       9 Pluto              E Pholus\n"+
  "                    2 Mercury    m Mean node          F Ceres\n"+
  "                    3 Venus      t True node          G Pallas\n"+
  "                    4 Mars       A mean lunar apogee  H Juno\n"+
  "                    5 Jupiter      (Lilith)           I Vesta\n"+
  "                    6 Saturn     B osculating lunar   c Interpolated lunar apogee\n"+
  "                    7 Uranus       apogee             g Interpolated lunar perigee\n"+
  "        -P.\n"+
  "        -P...     Calculate transits relative to this or these planets.\n"+
  "                  When giving more than one planet here, it will calculate\n"+
  "                  the next or previous transit(s) over any of these\n"+
  "                  planets.\n"+
  "        -lon...   longitude or longitudinal speed, over which the transit\n"+
  "                  has to occur. If two planets are given, this means the\n"+
  "                  position (or speed) of planet -px after planet -Px\n"+
  "        -lat...   latitude or latitudinal speed, over which the transit\n"+
  "                  has to occur. If two planets are given, this means the\n"+
  "                  position (or speed) of planet -px after planet -Px\n"+
  "        -dist...  distance or speed in distance movement in AU, over which\n"+
  "                  the transit has to occur. If two planets are given, this\n"+
  "                  means the distance position (or speed) of planet -px\n"+
  "                  after planet -Px\n"+
  "        +lon...   same as -lon for transits of one planet over another\n"+
  "                  planet with the difference that the SUM (Yoga) of the\n"+
  "                  positions or speeds of both planets will be calculated\n"+
  "        +lat...   same as -lat for transits of one planet over another\n"+
  "                  planet with the difference that the SUM (Yoga) of the\n"+
  "                  positions or speeds of both planets will be calculated\n"+
  "        +dist...  same as -dist for transits of one planet over another\n"+
  "                  planet with the difference that the SUM (Yoga) of the\n"+
  "                  positions or speeds of both planets will be calculated\n"+
  "        -lon, -lat, -dist, +lon, +lat, +dist can all take a  form that\n"+
  "                  increases the given value on each iteration by an offset.\n"+
  "                  Alternatively, you can give multiple values separated by\n"+
  "                  a forward slash (\"/\").\n"+
  "                  The correct syntax is:\n"+
  "                  {\"-\"|\"+\"}{\"lon\"|\"lat\"|\"dist\"}STARTVAL[\"+\"|\"-\"OFFSET]\n"+
  "                  or:\n"+
  "                  {\"-\"|\"+\"}{\"lon\"|\"lat\"|\"dist\"}VAL[\"/\"VAL]\n"+
  "                  STARTVAL, OFFSET and VAL are normal floating point numbers.\n"+
  "                  Use with option -n / -N or with -b -b / -b -B. Example:\n"+
  "                  -lon0+30.0 -n12\n"+
  "                  searches for 12 consecutive transits with the degree\n"+
  "                  changing from one step to the other by 30 degrees.\n"+
  "                  -lat0/0.1/-0.1 -b1-1-2005 -B1-1-2006\n"+
  "                  searches for any transits over 0, 0.1 and -0.1\n"+
  "                  latitudinal degree in the year 2005.\n"+
  "        -s        Calculate the transit over a given speed instead of\n"+
  "                  a given position\n"+
  "\n    Additional options:\n"+
  "        -r        search backward\n"+
  "        -topo[long;lat;elev]\n"+
  "                  Calculate related to a position on the surface of the\n"+
  "                  earth, default is geocentric calculation. Longitude,\n"+
  "                  latitude (degrees with decimal fraction) and elevation\n"+
  "                  (meters) are optional. Default is Z\u00fcrich: 8.55;47.38;400\n"+
  "        -hel      Perform heliocentric calculations instead of geocentric\n"+
  "        -sid.     a sidereal mode, if sidereal calculation is wanted.\n"+
  "                  Valid modes are:\n"+
  "                     0 Fagan/Bradley           10 Babylonian, Kugler2\n"+
  "                     1 Lahiri                  11 Babylonian, Kugler3\n"+
  "                     2 DeLuce                  12 Babylonian, Huber\n"+
  "                     3 Raman                   13 Babylonian, Mercier\n"+
  "                     4 Ushashashi              14 t0=Aldebaran, 15"+swed.ODEGREE_CHAR+" taurus\n"+
  "                     5 Krishnamurti            15 Hipparchos\n"+
  "                     6 Djwhal Khul             16 Sassanian\n"+
  "                     7 Sri Yukteshwar          17 Galactic center=0"+swed.ODEGREE_CHAR+" sagitt.\n"+
  "                     8 JN Bhasin               18 J2000\n"+
  "                     9 Babylonian, Kugler1     19 J1900\n"+
  "                                               20 B1950\n"+
  "        -n...     search for <n> transits instead of just one. If you want\n"+
  "                  all transits in a time range, use option -B... to give a\n"+
  "                  second date\n"+
  "        -N...     search for <N> transits instead of just one. Differently\n"+
  "                  to the -n option, this searches for the next OR(!) the\n"+
  "                  same OR(!) the previous transit position value, when you\n"+
  "                  give an increment value to the -lon etc. options. This\n"+
  "                  is useful ONLY, when a planet can move both direct and\n"+
  "                  retrograde, so you will not miss any transit point.\n"+
  "                  Notice the difference between the two commands:\n"+
  "                    java Transits -p5 -b01/01/2012 -lon60+10 -n6 -oloc24\n"+
  "                    java Transits -p5 -b01/01/2012 -lon60+10 -N6 -oloc24\n"+
  "        -f...     Output format options, default is -fdt or -fvdt, if we\n"+
  "                  calculate consecutive transits with changing degrees.\n"+
  "        -f+...    Same as -f, but append the following options to the\n"+
  "                  default options instead of replacing them all.\n"+
  "                  Available options:\n"+
  "          n       The name of the planet(s).\n"+
  "          d, d..  Output transit date and time with a given number of\n"+
  "                  decimal places in the seconds part.\n"+
  "                  'd5' might give you a time output like 20:26:46.80099,\n"+
  "                  'd' (or 'd0') will result in 20:26:47\n"+
  "                  All date output is localized to the 'en_US' locale if\n"+
  "                  not specified by the different -loc etc. options.\n"+
  "          t       Postfix the dates with 'ET' (Ephemeris Time) or 'UT'\n"+
  "                  (Universal Time) as appropriate.\n"+
  "          j, j..  Output transit date and time as julian day numbers with\n"+
  "                  the given numbers of decimal places. Saying 'j' is\n"+
  "                  identical to saying 'j8': 8 decimal places.\n"+
  "          v, v..  Output the transit degree or distance or speed value\n"+
  "                  with the given number of decimal places. 'v' is equal\n"+
  "                  to 'v2'\n"+
  "          p, p..  Output the actual position (or speed) on the found date\n"+
  "                  with the given number of decimal places. 'p' is equal\n"+
  "                  to 'p2', which means two decimal places.\n"+
  "               Only when calculating relative transits:\n"+
  "          P, P..  (Capital P) adds the real difference or sum (for yoga\n"+
  "                  transits) of the planets positions to the output. 'P'\n"+
  "                  means 'P2', which means, output the number with two\n"+
  "                  decimal places.\n\n"+
  "  Localization (internationalization):\n"+
  "  ====================================\n"+
  "  Input parsing and output formatting is done using the 'en_US' locale,\n"+
  "  meaning in the american style by default."+
  "  Localization knows about two different fields: numbers and dates. You\n"+
  "  can give both localization information for input parsing and output\n"+
  "  formatting. The default is 'en_US', you can change it to your current\n"+
  "  system locale by giving the option -loc without any locale added.\n"+
  "  The -loc options will change all patterns at the same time, all other\n"+
  "  options will just care for partial aspects at a time.\n"+
  "    -loc  is for input parsing and output formatting of numbers and dates\n\n"+
  "    -iloc is for input parsing of numbers and dates only\n"+
  "    -oloc is for output formatting of numbers and dates only\n\n"+
  "    -Dloc is for input parsing of dates only\n"+
  "    -Nloc is for input parsing of numbers only\n"+
  "    -dloc is for output formatting of dates only\n"+
  "    -nloc is for output of numbers like degrees or speed or JD\n\n"+
  "    The locale parameter without any locale string added to it (-loc /\n"+
  "    -iloc / -oloc etc.pp.) will use the default system locale. Add the\n"+
  "    locale String to use a specific locale, e.g. -dlocro for romanian\n"+
  "    date output formatting or -olochi_IN to use the indian hindi style\n"+
  "    in output. Use -locswiss to revert to the default behaviour of\n"+
  "    Swetest.java and the original C versions of swiss ephemeris.\n"+
  "    You can append '24' to -loc etc., to use 24 hours date formats on\n"+
  "    output, even when the localization would use AM/PM formats. E.g.:\n"+
  "    -loc24hi_IN (24 hour time format in Hindi) or: -loc24 or -loc24en\n"+
  "    ATTENTION: input parsing of time is ALWAYS done in the 24 hour format\n"+
  "    hh:mm:ss only!\n"+
  "    -locales  List all available locales. Does not compute anything.\n\n"+
  "  Other options:\n"+
  "  ==============\n"+
  "        -ejpl     calculate with jpl ephemeris (DE406); optionally\n"+
  "                  specify ephemeris file name like -ejplDE200.cdrom\n"+
  "        -eswe     calculate with swiss ephemeris\n"+
  "        -emos     calculate with moshier ephemeris\n"+
  "        -edirPATH change the directory of the ephemeris files \n"+
  "        -q\n"+
  "        -head     don\'t print the header before the planet data\n"+
  "\n    Output of informations only:\n"+
  "        -locales  List all available locales. Does not compute anything.\n\n"+
  "        -b... -cv Convert between julian day numbers and dates back and\n"+
  "                  forth and exit. Does not compute anything. May be\n"+
  "                  combined with -ut / -et option. Default is ET. See\n"+
  "                  option -hdate for info about the possible date\n"+
  "                  parameters.\n\n"+
  "    Help options:\n"+
  "        -?, -h    display info\n"+
  "        -hdate    display date info\n"+
  "        -hex      display examples\n";


  infoexamples = "\n"+
  "  Examples:\n\n"+
  "  Simple transits:\n"+
  "     Next transit of the moon over 123.4702 degrees:\n"+
  "       java Transits -p1 -lon123.4702 -btoday -utnow\n\n"+
  "     Transits of pluto or uranus or neptune over 0 degrees/day of\n"+
  "     latitudinal speed before 1998 with output of real speed on that\n"+
  "     date, formatted in your current Locale:\n"+
  "       java Transits -p789 -lat0 -s -b12/31/1997 -utnow -n10 -r -fdtjp -oloc\n\n"+
  "     When will be mercury's next 10 stationary states (speed = 0) in\n"+
  "     it's longitudinal direction of movement (\"when does mercury change\n"+
  "     it's motion from or to retrograde\"):\n"+
  "       java Transits -p2 -btoday -utnow -lon0 -s -n10 -oloc\n\n"+
  "     When did Pluto cross a very far distance of 50.2 AU between year 0:\n"+
  "     and today with additional output of the julian day number:\n"+
  "       java Transits -p9 -b1/1/0 -Btoday -dist50.2 -f+j5p\n\n"+
  "  Transits relative to other planets:\n"+
  "     Conjunctions of jupiter with saturn since 2000 until 2050:\n"+
  "       java Transits -p5 -P6 -lon0 -b1/1/2000 -b12/31/2050 -fdtjpP -oloc24\n\n"+
  "     All full moons in year 2007:\n"+
  "       java Transits -p0 -P1 -lon180 -b1/1/2007 -B12/31/2007 -UT23:59 -loc24en\n\n"+
  "     The next 20 transits of mars over any of the major planets with any\n"+
  "     of the major aspect angles in western astrology:\n"+
  "       java Transits -p4 -P0123456789 -lon0/30/45/60/90/120/150/180 -btoday -utnow -n20 -f+pP\n\n"+
  "     The first complete Nakshatras cycle in year 2006 starting with\n"+
  "     Ashvini (0"+swed.ODEGREE_CHAR+" in sidereal zodiac) and Lahiri ayanamsh related to a\n"+
  "     topocentric position somewhere in Germany:\n"+
  "       java Transits -b1/1/2006 -ut -topo11.0/52.22/160 -p1 -lon0+13.3333333333333 -n27 -sid1 -fv6dtj -ilocen -oloc\n\n"+
  "     The first 12 yogas starting from January 1, 2006:\n"+
  "       java Transits -p0 -P1 +lon0+13.33333333333333 -sid1 -b1/1/2006 -ut -n12 -ilocen -f+P\n\n"+
  "     Past Sade Sadhi for a moon in Kanya since April 1957:\n"+
  "       java Transits -p6 -lon120/210 -b4/13/1957 -btoday -ut -sid1 -oloc\n\n"+
  "     All trigon aspects between any of the major planets during the time\n"+
  "     of January 1, 2006 and January 1, 2008.\n"+
  "       java Transits -b1/1/2006 -B1/1/2008 -p0123456789 -P0123456789 -lon120 -oloc\n\n\n"+
  "     IMPORTANT NOTE: this kind of calculation may take a LONG(!) time to\n"+
  "           complete, as it will try to find transits of planets not being\n"+
  "           able to have that distance to each other, e.g., Sun and Mercury.\n"+
  "           Those kind of transits will be calculated up to the end of the\n"+
  "           calculable time, which might be far beyond the year 5000.\n"+
  "     So, you will not get any results from the following one, but it will\n"+
  "     take a rather long time to complete:\n"+
  "       java Transits -p23 -P23 -btoday -lon75 -n10 -oloc\n\n"+
  "     If you add another planet or degree, for which a transit will be found,\n"+
  "     the problem will disappear:\n"+
  "       java Transits -p23 -P235 -btoday -lon75 -n10 -oloc\n"+
  "       java Transits -p23 -P23 -btoday -lon75/0 -n10 -oloc\n\n"+
  "";
  }

  /**************************************************************/


  SwissEph  sw=new SwissEph();
  SwissLib  sl=new SwissLib();
  Extlib    el=new Extlib();
  SwissData swed=new SwissData();
  CFmt f=new CFmt();

  Locale[] locs = Locale.getAvailableLocales();
  String locale = "en_US"; // Make en_US the default
  String Nlocale = null;   // Locale to localize numbers on input
  String Dlocale = null;   // Locale to interpret dates on input
  String nlocale = null;   // Locale to localize numbers on output
  String dlocale = null;   // Locale to interpret dates on output

  boolean force24hSystem = false;


  String dateFracSeparator = ".";
  String numIFracSeparator = ".";
  String numOFracSeparator = ".";
  // For formatting dates:
  SimpleDateFormat dif = null;
  SimpleDateFormat dof = null;
  // For formatting the decimal parts of the seconds in dates:
  // Fraction of a second not (yet?) supported on input.
  NumberFormat dnof = null;
  // For formatting other numbers:
  NumberFormat nnif = null;
  NumberFormat nnof = null;
  int secondsIdx = 0;

  /**
  * See -h parameter for help on all parameters.
  */
  public static void main(String argv[]) {
    Transits sc=new Transits();
    System.exit(sc.startCalculations(argv, true));
  }

  /**
  * If you want to use this class in your own programs, you would
  * just call this method. All output will go to stdout only (so
  * far).
  * @param argv array of Strings containing all parameters like on
  * the command line.
  * @return nothing so far
  */
  public int startCalculations(String[] argv) {
    return startCalculations(argv, false);
  }

  private int startCalculations(String[] argv, boolean withErrMsg) {
    TransitArguments a = null;
    TransitCalculator tcs[] = null;

    try {
      a = parseArgs(argv);
      if (a == null) { return 0; }
      writeCmdLine(argv, a.withHeader);
      if (!a.convert) {
        writeHeader(a);
        tcs = initCalculators(a);
      }
    } catch (NullPointerException np) {
System.err.println(np);
      return 1;
    } catch (IllegalArgumentException ia) {
      if (withErrMsg) {
        System.err.println(ia.getMessage());
      }
      return -1;
    }

    ///////////////////////////////////////////////////////////////////
    // Calculation and output                                        //
    ///////////////////////////////////////////////////////////////////
    if (a.convert) {
      if (a.isUt) {
        a.sde1.setJulDay(a.sde1.getJulDay() - a.sde1.getDeltaT());
      }
      //DevNull.println(printFormatted(a,null));
      return 0;
    }

    boolean outOfTimeRange = false;
    TransitResult tr = null;
    boolean isFirstCalculation = true;

    // Calculate for a time range or for a number of times:
    while(a.count > 0 ||
          (a.enddate != null && !a.back && a.tjde1 < a.jdET2) ||
          (a.enddate != null && a.back && a.tjde1 > a.jdET2)) {

      tr = calcNextTransit(a, tcs);

      // None of the calculations ended normally, so we can stop calculation here:
      if (Double.isNaN(tr.jdET) || tr.jdET == Double.MAX_VALUE || tr.jdET == -Double.MAX_VALUE) {
        if (isFirstCalculation) {
          System.err.println("No transit... ");
        }
        break;
      }
      isFirstCalculation = false;

      // Output calculated data
      a.sde1.setJulDay(tr.jdET);
      if (a.rollover) {
        while (a.to.values[0].doubleValue() < 0) {
          a.to.values[0] = new Double(a.to.values[0].doubleValue() + 360.0);
        }
        if (a.to.values[0].doubleValue() > 360) {
          a.to.values[0] = new Double(a.to.values[0].doubleValue()%360.0);
        }
      }
      //DevNull.println(printFormatted(a, tr));

      // Initialize next calculation
      a.tjde1 = a.sde1.getJulDay() + (a.back?-MIN_TIME_DIFF:MIN_TIME_DIFF);
      // In the end, we have to adjust the transit value, if we have
      // varying transit values. We have two different cases:
      // a.varyingTransitPoints && a.duplicateTransitPoints:
      //    e.g., -lon0+30 -N...
      //    Take the "successful transit value to be the new transitVal
      // a.varyingTransitPoints && !a.duplicateTransitPoints:
      //    e.g., -lon0+30 -n...
      //    Add 'to.offset' to each transitVal unconditionally
      for(int tvn = 0; tvn < a.to.values.length; tvn++) {
        if (a.duplicateTransitPoints) {
          a.to.values[tvn] = new Double(tr.transitValue);
        } else if (a.varyingTransitPoints) {
          a.to.values[tvn] = new Double(a.to.values[tvn].doubleValue() + a.to.offset);
        }
      }

      // Note down that we have done one calculation:
      a.count--;
    } // while (in timeRange or cnt > 0)...

    if (outOfTimeRange) {
      System.err.println("\nCalculation(s) exceed(s) available time range.");
    }

    sw.swe_close();
    return 0;
  }


  TransitResult calcNeighbouringTransits(TransitArguments a, int pl1, int pl2) {
    TransitResult tr = new TransitResult();
    tr.jdET = a.v.jdEnd;

    double[] tValues = null;
    if (a.v.tvOffset == 0) {
      tValues = new double[] {a.v.transitVal};
    } else {
      tValues = new double[] {a.v.transitVal,
                              (a.v.transitVal-a.v.tvOffset+360.)%360.,
                              (a.v.transitVal+a.v.tvOffset)%360.};
    }
    boolean[] doCalc = new boolean[] {true,
                                      a.v.duplicateTransitPoints && a.v.rollover,
                                      a.v.duplicateTransitPoints};

    double jd = 0./0.;
    int errCnt = 0;
    a.v.outOfTimeRange = false;
    boolean skip = false;

    for (int i = 0; i < tValues.length; i++) {
      if (doCalc[i]) {
        try {
          // Skip calculation, if:
          // ONLY the ORDER of the planets is different from previous
          // calculations, AND:
          skip = a.v.tcIndex >= a.idxDuplicates &&
                  // A value of 0 does not care in any case:
                 (tValues[i] == 0 ||
                  // a lon calculation with 180 degrees does not care as well
                  (a.to.idxOffset == 0 && tValues[i] == 180));
          if (skip) {
            jd = (a.v.back?-Double.MAX_VALUE:Double.MAX_VALUE);
          } else { // calculate:
            jd = calcTransit(a.v.tc,tValues[i],a.v.jdStart,tr.jdET,a.v.back);
          }
        } catch (SwissephException swe) {
          errCnt++;
          if ((swe.getType() & SwissephException.OUT_OF_TIME_RANGE) != 0) {
            a.v.outOfTimeRange = true;
          // Hack, SwissEph does not yet return meaningful types in all cases...
          } else if (swe.toString().indexOf("not found in the paths of:") > 0) {
            a.v.outOfTimeRange = true;
          } else if (swe.toString().indexOf(" outside ") > 0 &&
                     swe.toString().indexOf(" range ") > 0 &&
                     swe.toString().indexOf(" range ") > swe.toString().indexOf(" outside ")) {
            a.v.outOfTimeRange = true;
          } else if (swe.toString().indexOf(" is restricted to ") > 0) {
            a.v.outOfTimeRange = true;
          } else if ((swe.getType() & SwissephException.BEYOND_USER_TIME_LIMIT) != 0) {
            jd = (a.v.back?-Double.MAX_VALUE:Double.MAX_VALUE);
          } else {
            System.err.println("ERROR: " + swe.getMessage());
          }
        } // try ... catch ...
        tr.jdET = (a.v.back?Math.max(tr.jdET,jd):Math.min(tr.jdET,jd));
        if (tr.jdET == jd) {
          tr.transitValue = tValues[i];
        }
      }
    } // for ...

    if ((errCnt == 1 && !a.v.duplicateTransitPoints) ||
        (errCnt == 3 && a.v.duplicateTransitPoints)) { // No more transit points possible
      tr.jdET = (a.v.back?-Double.MAX_VALUE:Double.MAX_VALUE);
    }

    return tr;
  }


  double calcTransit(TransitCalculator tc,
                     double val,
                     double jdStart,
                     double jdEnd,
                     boolean back)
      throws SwissephException {
    tc.setOffset(val);
    try {
      double et = sw.getTransitET(tc, jdStart, back, jdEnd);
      return et;
    } catch (SwissephException swe) {
      if ((swe.getType() & SwissephException.BEYOND_USER_TIME_LIMIT) != 0) {
        throw swe;
      }
    }
    return (back?-Double.MAX_VALUE:Double.MAX_VALUE);
  }


  // Return a String of each of the planets combinations as a
  // sequence of the two characters meaning both planets
  String getPlanetCombinations(String planets1, String planets2) {
    String pls0 = ""; // For 0 deg., 0 deg/day, 180 deg. in long.,
                      // and any value in dist, the order of the
                      // planets does not matter. So skip the
                      // the second entry in this case (e.g.,
                      // planets 24 == planets 42).
                      // We return these planet combinations plus "@"
                      // plus all the other combinations in pls, which
                      // are duplicates of pls0 planet combinations in
                      // the other order. E.g., when pls0 contains the
                      // combination '08', pls will contain '80'.
    String pls = "";
    for(int n1 = 0; n1 < planets1.length(); n1++) {
      for(int n2 = 0; n2 < planets2.length(); n2++) {
        // Skip planet combinations with both planets being the same...
        if (planets1.charAt(n1) != planets2.charAt(n2)) {
          String comb = planets1.charAt(n1) + "" + planets2.charAt(n2);
          String revComb = planets2.charAt(n2) + "" + planets1.charAt(n1);
          int idxR = pls0.indexOf(revComb);
          int idx = pls0.indexOf(comb);
          // Add only, if this planetary combination is not yet inserted
          // (idx < 0 or the position of the idx in the String is odd...)
          if ((idx < 0 || (idx >= 0 && (idx & 0x00000001) == 1)) &&
              (idxR < 0 || (idxR >= 0 && (idxR & 0x00000001) == 1))) {
            // pls0 does not contain this planet combination in ANY order...

            // Create planet combinations that most probably don't start with
            // "02", "03" or similar, otherwise we might get "Out of time
            // range", if the longitude value exceeds the maximum distance
            // between Sun and Mercury, Sun and Venus or Venus and Mercury.
            // Also moon should rather be calculated later, as moon transits
            // require more iterations than others.
            if (comb.indexOf('0') >= 0 || comb.indexOf('1') >= 0 ||
                "23".equals(comb) || "32".equals(comb)) {
              pls0 += comb;
            } else {
              pls0 = comb + pls0;
            }
          } else {
            idxR = pls.indexOf(revComb);
            if (idxR < 0 || (idxR >= 0 && (idxR & 0x00000001) == 1)) {
              if (comb.indexOf('0') >= 0 || comb.indexOf('1') >= 0 ||
                  "23".equals(comb) || "32".equals(comb)) {
                pls += comb;
              } else {
                pls = comb + pls;
              }
            }
          }
        }
      }
    }
    return pls0 + "@" + pls;
  }

//  String format1(double val) {
//    return nnof.format(Math.abs(val))+swed.ODEGREE_CHAR+"/day";
//  }
  String group(ObjFormatter f, int cnt, String pad) {
    String s = "";
    for(int i=0; i<cnt; i++) {
      s += pad + f.format(i);
    }
    return s.substring(pad.length());
  }

  // A number of e.g. 263.83 will be parsed as 263.83 in 'en' locale, but as
  // 263 only in 'de' locale. This method parses the double in the appropriate
  // locale.
  // The String 's' has to contain the parameter name + "@" + double value,
  // eg. "-lon@234.8903"
  double readLocalizedDouble(String s) {
    if (s != null && s.length() > 0) {
      String num = s.substring(s.indexOf("@")+1);
      String par = s.substring(0,s.indexOf("@"))+num;

      String dblString = "";
      char lastChar = ' ';
      boolean hasFrac = false;
      boolean hasExp = false;

      for (int i=0; i< num.length(); i++) {
        char ch = num.charAt(i);
        if (!Character.isDigit(ch)) {
          // Has to be a decimal point, an exponent or a sign after an exponent:
          if (ch == numIFracSeparator.charAt(0)) {
            if (hasFrac) {
              return invalidValue(par,s.indexOf('@'));
            }
            if (numIFracSeparator.length() > 1) {
//...
            }
            ch = '.';
            hasFrac = true;
          } else if (ch == '+' || ch == '-') {
            if (i != 0 ||
                (lastChar == 'E' && dblString.length() == 0)) {
              //invalidValue(tv,idx);
              return invalidValue(par,s.indexOf('@'));
            }
          } else if (ch == 'E') { // Exponent
            if (hasExp || dblString.length() == 0) {
              //invalidValue(tv,idx);
              return invalidValue(par,s.indexOf('@'));
            }
            hasExp = true;
          } else {  // Invalid character in String!
            //invalidValue(tv,idx,Nlocale);
            return invalidValue(par,s.indexOf('@'));
          }
        }
        dblString += ch;
        lastChar = ch;
      }
      if (dblString.length() > 0) {
        return Double.valueOf(dblString).doubleValue();
      }
    }

    return 0./0.;
  }

  // Print the date according to the format string given by the -f flag.
  // Planets and (calculation) flag are only needed for calculation of
  // actual positions or speeds when using -fp
  String printFormatted(TransitArguments a, TransitResult tr) {
    String s = "";
    StringBuffer serr = null;
    double[] xx = null;
    int idx, pflags, ret;

    boolean rollover = ((a.iflag & SweConst.SEFLG_TRANSIT_SPEED) == 0) &&
                       ((a.iflag & SweConst.SEFLG_TRANSIT_LONGITUDE) != 0);
    boolean cntIsSet = false;
    int cnt = 0;
    for (int n = 0; n < a.outputFormat.length(); n++) {
      if (n > 0) {
        s += "   ";
      }
      switch ((int)a.outputFormat.charAt(n)) {
        // Print date and time:
        case (int)'n': // output planet name(s):
                       int len = 9;
                       if (a.pls1.indexOf("g") > 0 ||
                           a.pls1.indexOf("c") > 0) {
                         len += 4;
                       }
                       String plNames = sw.swe_get_planet_name(tr.pl1);
                       plNames = (plNames + "             ").substring(0,len);

                       if (tr.pl2 >= 0) {
                         len += 12;
                         if (a.pls2.indexOf("g") > 0 ||
                             a.pls2.indexOf("c") > 0) {
                           len += 4;
                         }
                         plNames += " - " + sw.swe_get_planet_name(tr.pl2);
                       }
                       s += (plNames+"                      ").substring(0,len);
                       break;
        case (int)'d': // output date, read optional decimal places:
                       cnt = 0;
                       for (int i = n+1; i < a.outputFormat.length(); i++) {
                         if (Character.isDigit(a.outputFormat.charAt(i))) {
                           cnt = cnt * 10 +
                                 Character.getNumericValue(a.outputFormat.charAt(i));
                           n++;
                         } else {
                           break;
                         }
                       }
                       s += jdToDate(a.sde1, a.isUt, cnt);
                       break;
        case (int)'t': // Append 'ET' or 'UT':
                       cnt = 0;
                       if (n != 0) {
                         s = s.substring(0,s.length() - 2);
                       }
                       s += (a.isUt?"UT":"ET");
                       break;
        // Print date as julian day number:
        case (int)'j': // read optional decimal places:
                       cnt = 0;
                       cntIsSet = false;
                       for (int i = n+1; i < a.outputFormat.length(); i++) {
                         if (Character.isDigit(a.outputFormat.charAt(i))) {
                           cntIsSet = true;
                           cnt = cnt * 10 +
                                 Character.getNumericValue(a.outputFormat.charAt(i));
                           n++;
                         } else {
                           break;
                         }
                       }
                       if (!cntIsSet) { cnt = 8; }
                       s += printJD(a.sde1.getJulDay(), a.isUT, cnt);
                       break;
        // Output degree etc.:
        case (int)'v': // read optional decimal places:
                       cnt = 0;
                       cntIsSet = false;
                       for (int i = n+1; i < a.outputFormat.length(); i++) {
                         if (Character.isDigit(a.outputFormat.charAt(i))) {
                           cntIsSet = true;
                           cnt = cnt * 10 +
                                 Character.getNumericValue(a.outputFormat.charAt(i));
                           n++;
                         } else {
                           break;
                         }
                       }
                       if (!cntIsSet) { cnt = 2; }
                       s += printFloat(tr.transitValue, 3, cnt, (rollover?360.:0.)) + swed.ODEGREE_CHAR+"";
                       if ((a.iflag & SweConst.SEFLG_TRANSIT_SPEED) != 0) {
                         s += "/day";
                       }
                       break;
        // Output actual position or speed:
        case (int)'p': // read optional decimal places:
                       cnt = 0;
                       cntIsSet = false;
                       for (int i = n+1; i < a.outputFormat.length(); i++) {
                         if (Character.isDigit(a.outputFormat.charAt(i))) {
                           cntIsSet = true;
                           cnt = cnt * 10 +
                                 Character.getNumericValue(a.outputFormat.charAt(i));
                           n++;
                         } else {
                           break;
                         }
                       }
                       if (!cntIsSet) { cnt = 8; }

                       serr = new StringBuffer();
                       xx = new double[6];
                       idx = 0;
                       if ((a.iflag & SweConst.SEFLG_TRANSIT_LATITUDE) != 0) {
                         idx = 1;
                       } else if ((a.iflag & SweConst.SEFLG_TRANSIT_DISTANCE) != 0) {
                         idx = 2;
                       }
                       pflags = a.iflag;
                       if ((a.iflag & SweConst.SEFLG_TRANSIT_SPEED) != 0) {
                         idx += 3;
                         pflags |= SweConst.SEFLG_SPEED;
                       }
                       pflags &= ~(SweConst.SEFLG_TRANSIT_LONGITUDE |
                                   SweConst.SEFLG_TRANSIT_LATITUDE |
                                   SweConst.SEFLG_TRANSIT_DISTANCE |
                                   SweConst.SEFLG_TRANSIT_SPEED);

                       ret = sw.swe_calc(a.sde1.getJulDay(), tr.pl1, pflags, xx, serr);
                       if (ret < 0) {
                         s += serr.toString().substring(0,10)+"...";
                       } else {
                         s += printFloat(xx[idx], 4, cnt, (rollover?360.:0.));
                       }
// Puuuh: we need to calc it from tc!!!???!?!?!?
                       if (tr.pl2 >= 0) {
                         s += "  ";
                         ret = sw.swe_calc(a.sde1.getJulDay(), tr.pl2, pflags, xx, serr);
                         if (ret < 0) {
                           s += serr.toString().substring(0,10)+"...";
                           break;
                         } else {
                           s += printFloat(xx[idx], 3, cnt, (rollover?360.:0.));
                         }
                       }
                       break;
        // 'P' adds output of two planets position (speed) difference:
        case (int)'P': if (tr.pl2 < 0) { break; }
                       // read optional decimal places:
                       cnt = 0;
                       cntIsSet = false;
                       for (int i = n+1; i < a.outputFormat.length(); i++) {
                         if (Character.isDigit(a.outputFormat.charAt(i))) {
                           cntIsSet = true;
                           cnt = cnt * 10 +
                                 Character.getNumericValue(a.outputFormat.charAt(i));
                           n++;
                         } else {
                           break;
                         }
                       }
                       if (!cntIsSet) { cnt = 8; }

                       serr = new StringBuffer();
                       xx = new double[6];
                       idx = 0;
                       if ((a.iflag & SweConst.SEFLG_TRANSIT_LATITUDE) != 0) {
                         idx = 1;
                       } else if ((a.iflag & SweConst.SEFLG_TRANSIT_DISTANCE) != 0) {
                         idx = 2;
                       }
                       pflags = a.iflag;
                       if ((a.iflag & SweConst.SEFLG_TRANSIT_SPEED) != 0) {
                         idx += 3;
                         pflags |= SweConst.SEFLG_SPEED;
                       }
                       pflags &= ~(SweConst.SEFLG_TRANSIT_LONGITUDE |
                                   SweConst.SEFLG_TRANSIT_LATITUDE |
                                   SweConst.SEFLG_TRANSIT_DISTANCE |
                                   SweConst.SEFLG_TRANSIT_SPEED);

                       ret = sw.swe_calc(a.sde1.getJulDay(), tr.pl1, pflags, xx, serr);
                       if (ret < 0) {
                         s += serr.toString().substring(0,10)+"...";
                         break;
                       }
// Puuuh: we need to calc it from tc!!!???!?!?!?
                       double x1 = xx[idx];
                       ret = sw.swe_calc(a.sde1.getJulDay(), tr.pl2, pflags, xx, serr);
                       if (ret < 0) {
                         s += serr.toString().substring(0,10)+"...";
                         break;
                       }
                       x1 += (a.yogaTransit?xx[idx]:-xx[idx]);
                       if (idx >= 1) {
                         s += printFloat(x1, 3, cnt, (rollover?360.:0.));
                       } else {
                         s += printFloat((x1+360.0)%360.0, 3, cnt, (rollover?360.:0.));
                       }
                       break;
      }
    }
    return s;
  }


  TransitOffsets parseTransitValString(String tv) {
    if ("".equals(tv.trim())) { return null; }

    TransitOffsets to = new TransitOffsets();

    int idx = (tv.startsWith("-l")?4:5);
    // save "lon" / "lat" / "dist" for possible error messages:
    String which = tv.substring(1,idx);
    // this is the string with transit values, which can appear in
    // three different forms:
    // -  100
    // -  100+10
    // -  30/45/60.0/90/1.2E2/180
    // All these numbers are localized and may be prefixed by a sign.
    // Base 10 is assumed.
    String vals = tv.substring(idx).toUpperCase();

    boolean numberEnd = false;
    boolean multipleValues = false;
    boolean isExponent = false;

    Vector tmpValues = new Vector();

    String dblString = "";
    char lastChar = '\0';

    for (int i=0; i< vals.length(); i++) {
      char ch = vals.charAt(i);
      if (!Character.isDigit(ch)) {
        // Could be a decimal point, plus or minus for the next number,
        // or  '/' as a separator between different values:
        if (ch == numIFracSeparator.charAt(0)) {
          if (numIFracSeparator.length() > 1) {
//...
          }
          ch = '.';
        } else if (ch == '+' || ch == '-') {
          if (lastChar != 'E' && dblString.length() != 0) {
            numberEnd = true;
          }
          if (lastChar != 'E' && multipleValues && lastChar != '/') {
            invalidValue(tv,idx);
            return null;
          }
        } else if (ch == '/') {
          numberEnd = true;
          multipleValues = true;
        } else if (ch == 'E') { // Exponent
          if (isExponent || dblString.length() == 0) {
            invalidValue(tv,idx);
            return null;
          }
          isExponent = true;
        } else {  // Invalid character in String!
          invalidValue(tv,idx,Nlocale);
          return null;
        }
      }
      if (ch != 'E' && (numberEnd || i == vals.length()-1)) {
        if (i == vals.length()-1) { dblString += ch; }
        if (multipleValues || tmpValues.size() == 0) {
          tmpValues.addElement(Double.valueOf(dblString));
        } else {
          to.offset = Double.valueOf(dblString).doubleValue();
        }
        dblString = "";
        numberEnd = false;
        isExponent = false;
      } else if (ch == 'E' && (numberEnd || i == vals.length()-1)) {
System.err.println(4);
        invalidValue(tv,idx,Nlocale);
        return null;
      } else if (ch != '/') {
        dblString += ch;
      }
      lastChar = ch;
    }
    if (dblString.length() > 0) {
      tmpValues.addElement(Double.valueOf(dblString));
    }

    if (tmpValues.size() == 0) {
      return null;
    }
    to.values = new Double[tmpValues.size()];
    to.values = (Double[])tmpValues.toArray(to.values);

    if (which.equals("lon")) {
      to.idxOffset = 0;
    } else if (which.equals("lat")) {
      to.idxOffset = 1;
    } else if (which.equals("dist")) {
      to.idxOffset = 2;
    }
    return to;
  }

  double parseHour(String s) {
    if (s.equals("now")) {
      java.util.Calendar cal=java.util.Calendar.getInstance(java.util.TimeZone.getTimeZone("GMT"));
      return cal.get(java.util.Calendar.HOUR_OF_DAY)+
             cal.get(java.util.Calendar.MINUTE)/60.+
             cal.get(java.util.Calendar.SECOND)/3600.;
    }
    // 18:23:45 or shorter versions or other separators
    double[] h=new double[]{0,0,0};
    int field=0;
    boolean isFrac = false;
    double frac = 1;

    for (int n=0; n<s.length();) {
      if (Character.isDigit(s.charAt(n))) {
        if (isFrac) {
          frac*=10;
          h[field]+=((double)((int)s.charAt(n)-(int)'0'))/frac;
        } else {
          h[field]*=10;
          h[field]+=((int)s.charAt(n)-(int)'0');
        }
        n++;
      } else {
        field++;
        if (field==h.length) {
          field--;
          // Maybe decimal separator?
          if (s.charAt(n) == dateFracSeparator.charAt(0)) {
            if (s.indexOf(dateFracSeparator) == n) {
              n += dateFracSeparator.length();
              isFrac = true;
            } else {
              break; // Well, should be an error!
            }
          } else {
            break;
          }
        } else {
          while (n<s.length()-1 && !Character.isDigit(s.charAt(++n)));
        }
      }
    }
    return h[0]+h[1]/60.+h[2]/3600.;
  }


  int invalidValue(String arg, int idx) {
    return invalidValue(arg, idx, null);
  }
  int invalidValue(String arg, int idx, String locale) {
    if (arg.length()==idx) {
      System.err.println("\nMissing argument to parameter '"+arg+
                         "'.\nTry option -h for a syntax description.");
      System.exit(1);
    } else {
      System.err.println("\nInvalid argument (" + arg.substring(idx) +
                         ") to parameter '" + arg.substring(0,idx) +
                         "'.\n" + (locale != null?"Maybe the locale (" +
                         Nlocale + ") requires a different format.\n" +
                         "Also t":"\nT") + "ry option -h for a syntax " +
                         "description.");
      System.exit(1);
    }
    return(1);
  }


  String invalidArgument(String arg, int idx) {
    return invalidArgument(arg, idx, null);
  }
  String invalidArgument(String arg, int idx, String locale) {
    if (arg.length()==idx) {
      return "Missing argument to parameter '" + arg + "'.\nTry option -h " +
             "for a syntax description.";
    } else {
      return "Invalid argument (" + arg.substring(idx) + ") to parameter '" +
             arg.substring(0,idx) + "'.\n" + (locale != null?"Maybe the " +
             "locale (" + Nlocale + ") requires a different format.\n" +
             "Also t":"\nT") + "ry option -h for a syntax description.";
    }
  }


  String checkLocale(String locale, String defLocale) {
    if ("".equals(defLocale)) {
      defLocale = Locale.getDefault().toString();
    }
    
    if (locale == null) {
      return defLocale;
    }
    if ("".equals(locale)) {
      return Locale.getDefault().toString();
    }
    for(int n=0; n < locs.length; n++) {
      if (locs[n].toString().equals(locale)) {
        return locale;
      }
    }
System.err.println("Warning: Locale '" + locale + "' not found, using default locale '" + defLocale + "'");
System.err.println("Use option -locales to list all available Locales.");
    return defLocale;
  }


  /**
  * Returns date + time in localized form from a JDET in a SweDate
  * object
  */
  String jdToDate(SweDate sdET, boolean printUT, int decPlaces) {
    if (decPlaces > 18) { decPlaces = 18; }

    SweDate sx = new SweDate(
                        sdET.getJulDay()-
                        (printUT?sdET.getDeltaT():0)+
                        0.5/24./3600/Math.pow(10,decPlaces));

    // sx.getDate() will round a second time. We have to inhibit
    // this be cutting of the spare decimal places beyond the
    // the relevant numbers

    double hour=sx.getHour();
    double mseconds=((hour*3600.)%1.);

    String s1 = "";
    String s2 = "";

    String s = null;
    String pat = dof.toPattern();
    // sx.getDate() will round by itself, but rounding is not allowed
    // to occur anymore. We only need an accuracy to a second for
    // getDate(), so let us cut off the rest here already!
    sx.setJulDay(sx.getJulDay() - mseconds/24./3600. + 0.5/24./3600.);

    if (sx.getYear() == 0) {
      // DateFormat.format() will not allow a year "0"...
      // Hack: We take the normal pattern and replace 0001 by 0000
      s = dof.format(sx.getDate(0));
      int idxy = el.getPatternLastIdx(pat, "yyyy", dof);

      s = s.substring(0,idxy+2) +
          s.substring(idxy,idxy+1) +
          s.substring(idxy+3);
    } else if (sx.getYear() < 0) {
      // We add one year, as the date formatter skips year 0
      sx.setYear(sx.getYear()+1);

      int idx = pat.indexOf("y");
      SimpleDateFormat dfm = (SimpleDateFormat)dof.clone();
      // If the separator between day, month and year is '-' we have to
      // (should?) distinguish it from the '-' of the year, so we add a
      // space before the year in this case. See locales da / da_DK /
      // es_BO / es_CL / es_HN / es_NI / es_PR / es_SV / nl / nl_NL /
      // pt / pt_PT.
      String sep = (idx>0 && pat.charAt(idx-1)=='-'?" ":"");
      pat = pat.substring(0,idx) + sep + "'-'" + pat.substring(idx);
      dfm.applyPattern(pat);
      s = dfm.format(sx.getDate(0));
    } else {
      s = dof.format(sx.getDate(0));
    }

    if (decPlaces > 0) {
      secondsIdx = el.getPatternLastIdx(pat, "ss", dof);
      s1 = s.substring(0,secondsIdx + 1/* +idxAdd */);
      s2 = s.substring(secondsIdx + 1/* +idxAdd */);
      s = dateFracSeparator;
      for (int i = decPlaces; i > 0; i--) {
        mseconds = (mseconds * 10) % 10;
        s += dnof.format((int)mseconds);
      }
    }

    return s1 + s + s2;
  }

  // Prints a floatingpoint number internationalized and
  // with correct rounding to a given number of decimal places
  String printFloat(double val, int width, int decPlaces) {
    return printFloat(val, width, decPlaces, 0);
  }
  String printFloat(double val, int width, int decPlaces, double wrapAt) {
    if (decPlaces > 18) { decPlaces = 18; }
    // Well, could be another width, if necessary...
    if (width > 61) { width = 61; }
    String s = "                                                            ";
    if (val < 0) {
      val = -val;
      s += "-";
    }

    val += 0.5/Math.pow(10,decPlaces);

    if (wrapAt != 0 && val >= wrapAt) {
      val -= wrapAt;
    }

    int len = (String.valueOf((int)val)).length();
    s += nnof.format((int)val);
    s = s.substring(Math.max(len,s.length()-width));

    if (decPlaces > 0) {
      s += numOFracSeparator;
      double parts = val - (int)val;
      for (int i = decPlaces; i > 0; i--) {
        parts = (parts * 10) % 10;
        s += nnof.format((int)parts);
      }
    }

    return s;
  }


  String printJD(double jd, boolean printUT, int decPlaces) {
    if (decPlaces > 18) { decPlaces = 18; }

    SweDate sx = new SweDate(
                        jd-
                        (printUT?SweDate.getDeltaT(jd):0)+
                        0.5/Math.pow(10,decPlaces));
    jd = sx.getJulDay();

    String s = nnof.format((int)jd);

    if (decPlaces > 0) {
      s += numOFracSeparator;
      double parts = Math.abs(jd - (int)jd);
      for (int i = decPlaces; i > 0; i--) {
        parts = (parts * 10) % 10;
        s += nnof.format((int)parts);
      }
    }

    return s;
  }


  String doubleToDMS(double d) {
    int deg=(int)d;
    int min=(int)((d%1.)*60.);
    int sec=(int)(((d*60.)%1.)*60.);
    return ((deg<10?" ":"")+nnof.format(deg)+swed.ODEGREE_CHAR+""+
            (min<10?nnof.format(0):"")+nnof.format(min)+"'"+
            (sec<10?nnof.format(0):"")+nnof.format(sec)+"\"");
  }


  // Returns ET date from the (localized) String dt
  SweDate makeDate(String dt, double hour, boolean ut, String locString) {
    if (dt==null) { return null; }
    SweDate sd = new SweDate();
    boolean gregflag = SweDate.SE_GREG_CAL;

    if (dt.charAt(0) == 'j') {   /* parse a julian day number */
      double tjd = 0.;
      tjd = readLocalizedDouble("-b' or '-B@" + dt.substring(1));
      if (ut) {
        // The JD is meant to represent a UT date,
        // but this method is to return ET:
        tjd += SweDate.getDeltaT(tjd);
      }
      if (tjd < sd.getGregorianChange()) {
        gregflag = SweDate.SE_JUL_CAL;
      } else {
        gregflag = SweDate.SE_GREG_CAL;
      }
      if (dt.indexOf("jul") >= 0) {
        gregflag = SweDate.SE_JUL_CAL;
      } else if (dt.indexOf("greg") >= 0) {
        gregflag = SweDate.SE_GREG_CAL;
      }
      sd.setJulDay(tjd);
      sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay number!
    } else if (dt.equals("today")) {
      java.util.Calendar cal=java.util.Calendar.getInstance(java.util.TimeZone.getTimeZone("GMT"));
      dt=dif.format(cal.getTime());
      return makeDate(dt, hour, ut, locString);
    } else { // Parse a date string
      // We just parse the date as a sequence of three integers
      // How these three numbers will be interpreted (y-m-d or d-m-y
      // or whatever) will be determined from the locale pattern.
      int ints[] = new int[]{0, 0, 0};
      int jday, jmon, jyear;
      int i=0, n=0;
      boolean neg=false;
      try {
        for (; n<3; n++) {
          ints[n] = 0;
          neg=(dt.charAt(i)=='-');
          if (neg) { i++; }
          while (Character.isDigit(dt.charAt(i))) {
            ints[n]=ints[n]*10+Character.digit(dt.charAt(i++),10);
          }
          if (neg) { ints[n]=-ints[n]; }
          int nd = 0; // no digit
          while (!Character.isDigit(dt.charAt(i))) { nd++; i++; }
          if (dt.charAt(i-1)=='-' && nd > 1) { i--; }
        }
      } catch (StringIndexOutOfBoundsException siobe) {
        if (neg) { ints[n]=-ints[n]; }
      } catch (ArrayIndexOutOfBoundsException aob) {
      }
      // order the integers into date parts according to the locale:
      String pat = dif.toPattern().toLowerCase();
      int d = pat.indexOf("d");
      int m = pat.indexOf("m");
      int y = pat.indexOf("y");
      if (m < d && m < y) {
        jmon = ints[0];
        if (y < d) {  // m-y-d
          jyear = ints[1]; jday = ints[2];
        } else {      // m-d-y
          jday = ints[1]; jyear = ints[2];
        }
      } else if (y < d && y < m) {
        jyear = ints[0];
        if (m < d) {  // y-m-d
          jmon = ints[1]; jday = ints[2];
        } else {      // y-d-m
          jday = ints[1]; jmon = ints[2];
        }
      } else {
        jday = ints[0];
        if (m < y) {  // d-m-y
          jmon = ints[1]; jyear = ints[2];
        } else {      // d-y-m
          jyear = ints[1]; jmon = ints[2];
        }
      }

      sd.setDate(jyear,jmon,jday,hour,SweDate.SE_GREG_CAL);
      if (ut) { sd.setJulDay(sd.getJulDay() + sd.getDeltaT()); } // We need ET in this method...
      if (sd.getJulDay() < sd.getGregorianChange()) {
        gregflag = SweDate.SE_JUL_CAL;
      } else {
        gregflag = SweDate.SE_GREG_CAL;
      }
      if (dt.indexOf("jul") >= 0) {
        gregflag = SweDate.SE_JUL_CAL;
      } else if (dt.indexOf("greg") >= 0) {
        gregflag = SweDate.SE_GREG_CAL;
      }
      sd.setCalendarType(gregflag,SweDate.SE_KEEP_DATE); // Keep Date!
    }
    return sd;
  }

  /* make_ephemeris_path().
   * ephemeris path includes
   *   current working directory
   *   + program directory
   *   + default path from swephexp.h on current drive
   *   +                              on program drive
   *   +                              on drive C:
   */
  int make_ephemeris_path(int iflag, String argv0) {
    String path="", s="";
    int sp;
    String dirglue = swed.DIR_GLUE;
    int pathlen=0;
    /* moshier needs no ephemeris path */
    if ((iflag & SweConst.SEFLG_MOSEPH)!=0)
      return SweConst.OK;
    /* current working directory */
    path="."+SwissData.PATH_SEPARATOR;
    /* program directory */
    sp = argv0.lastIndexOf(dirglue);
    if (sp >= 0) {
      pathlen = sp;
      if (path.length() + pathlen < SwissData.AS_MAXCH-1) {
        s=argv0.substring(0,pathlen);
        path+=s+SwissData.PATH_SEPARATOR;
      }
    }
    if (path.length() + pathlen < SwissData.AS_MAXCH-1)
      path+=SweConst.SE_EPHE_PATH;
    return SweConst.OK;
  }

  int letter_to_ipl(char letter) {
    if (letter >= '0' && letter <= '9')
      return (int)letter - '0' + SweConst.SE_SUN;
    switch ((int)letter) {
      case (int)'m': return SweConst.SE_MEAN_NODE;
      case (int)'t': return SweConst.SE_TRUE_NODE;
      case (int)'A': return SweConst.SE_MEAN_APOG;
      case (int)'B': return SweConst.SE_OSCU_APOG;
      case (int)'D': return SweConst.SE_CHIRON;
      case (int)'E': return SweConst.SE_PHOLUS;
      case (int)'F': return SweConst.SE_CERES;
      case (int)'G': return SweConst.SE_PALLAS;
      case (int)'H': return SweConst.SE_JUNO;
      case (int)'I': return SweConst.SE_VESTA;
      case (int)'c': return SweConst.SE_INTP_APOG;
      case (int)'g': return SweConst.SE_INTP_PERG;
    }
    return -1;
  }

  String limitLineLength(String line, int maxLen, String nlPad) {
    String s = "";
    maxLen -= nlPad.length();

    while(line.length() > 0) {
      if (line.length() > maxLen) {
        String t = line.substring(0, maxLen+1);
        for(int idx = t.length() - 1; idx >= 0; idx--) {
          if (Character.isWhitespace(t.charAt(idx))) {
            t = t.substring(0, idx);
            line = line.substring(idx + 1);
            break;
          }
        }

        if (t.length() > maxLen) { // No space character found
          // try to find any non-digit or letter
          for(int idx = t.length() - 1; idx >= 0; idx--) {
            if (Character.isLetterOrDigit(t.charAt(idx))) {
              t = t.substring(0, idx);
              line = line.substring(idx);
              break;
            }
          }
        }

        if (t.length() > maxLen) { // All letters or digits,
          // split at maxLen
          t = line.substring(0, maxLen);
          line = line.substring(maxLen);
        }
        s += "\n" + nlPad + t;
      } else {
        s += "\n" + nlPad + line;
        break;
      }
    }
    return s.substring(("\n"+nlPad).length());
  }

  String getPlanetNames(String pls, String pad) {
    String s = "";
    for(int n = 0; n < pls.length(); n++) {
      int pl = letter_to_ipl(pls.charAt(n));
      s += pad + sw.swe_get_planet_name(pl);
    }
    return s.substring(pad.length());
  }

  TransitArguments parseArgs(String argv[])
      throws IllegalArgumentException {
    TransitArguments a = new TransitArguments();
    /*
     * parse command line
    */
    for (int i = 0; i < argv.length; i++) {
      if (argv[i].equals("-hdate")) {
        //DevNull.println(infodate);
        sw.swe_close();
        return(null);
      } else if (argv[i].equals("-hex")) {
        if (infoexamples == null) {
          initHelpTexts();
        }
        //DevNull.println(infoexamples);
        sw.swe_close();
        return(null);
      } else if (argv[i].equals("-h") ||
                 argv[i].equals("--help") ||
                 argv[i].equals("-?") ||
                 argv[i].equals("/?")) {
        //DevNull.println(infocmd0);
        //DevNull.println(infocmd1);
        if (infoexamples == null) {
          initHelpTexts();
        }
        //DevNull.println(infocmd2);
        //DevNull.println(infoexamples);
        sw.swe_close();
        return(null);
      } else if (argv[i].equals("-head") ||
        argv[i].equals("-q")) {
        a.withHeader = false;
      } else if (argv[i].equals("-r")) {
        a.back = true;
      } else if (argv[i].startsWith("-lon") ||
                 argv[i].startsWith("-lat") ||
                 argv[i].startsWith("-dist") ||
                 argv[i].startsWith("+lon") ||
                 argv[i].startsWith("+lat") ||
                 argv[i].startsWith("+dist")) {
        if (!"".equals(a.transitValString)) {
          throw new IllegalArgumentException(
                  "Only one of -lon / -lat / -dist / +lon / +lat / +dist\n" +
                  "may be given. Use the -h option for more information.");
        }

        a.yogaTransit = (argv[i].charAt(0) == '+');
        argv[i] = "-" + argv[i].substring(1);

        a.transitValString = argv[i];
        int idx = (argv[i].charAt(1) == 'd'?5:4);
      } else if (argv[i].startsWith("-topo")) {
        a.iflag |= SweConst.SEFLG_TOPOCTR;
        a.topoS=argv[i].substring(5);
      } else if (argv[i].equals("-hel") ||
                 argv[i].equals("-helio")) {
        a.helio = true;
        a.iflag |= SweConst.SEFLG_HELCTR;
        a.iflag |= SweConst.SEFLG_NOABERR;
        a.iflag |= SweConst.SEFLG_NOGDEFL;
      } else if (argv[i].startsWith("-sid")) {
        try {
          a.sidmode=Integer.parseInt(argv[i].substring(4));
          if (a.sidmode<0 || a.sidmode>20) {
            throw new IllegalArgumentException(invalidArgument(argv[i],4));
          }
        } catch (NumberFormatException nf) {
          throw new IllegalArgumentException(invalidArgument(argv[i],4));
        }
      } else if (argv[i].startsWith("-ejpl")) {
        a.whicheph = SweConst.SEFLG_JPLEPH;
        if (argv[i].length()>5) {
          a.fname=argv[i].substring(5);
        }
      } else if (argv[i].equals("-eswe")) {
        a.whicheph = SweConst.SEFLG_SWIEPH;
      } else if (argv[i].equals("-emos")) {
        a.whicheph = SweConst.SEFLG_MOSEPH;
      } else if (argv[i].startsWith("-edir")) {
        if (argv[i].length()>5) {
          a.ephepath=argv[i].substring(5);
        }
      } else if (argv[i].startsWith("-ut") ||
                 argv[i].startsWith("-et") ||
                 argv[i].startsWith("-t")) {
        int len=(argv[i].startsWith("-t")?2:3);
        a.isUt=argv[i].startsWith("-ut");
        if (argv[i].length()>len) {
          a.sBeginhour = argv[i].substring(len);
        }
      } else if (argv[i].startsWith("-UT") ||
                 argv[i].startsWith("-T")) {
        int len=(argv[i].startsWith("-T")?2:3);
        a.isUT=argv[i].startsWith("-UT");
        a.sEndhour = argv[i].substring(len);
        a.endTimeIsSet = true;
      } else if (argv[i].equals("-s")) {
        a.calcSpeed = true;
      } else if (argv[i].startsWith("-b") ||
                 argv[i].startsWith("-j")) {
        if (argv[i].length()<3) {
          throw new IllegalArgumentException(invalidArgument(argv[i],2));
        } else {
          boolean wob = (argv[i].startsWith("-j"));
          if (a.begindate == null) {
            a.begindate = (wob?"j":"") + argv[i].substring(2);
          } else if (a.enddate == null) {
            a.enddate = (wob?"j":"") + argv[i].substring(2);
          } else {
            System.err.println("Invalid parameter combination:\n"+
                         "Excess -b option."+
                         "\nUse option '-h' for additional help.");
          }
        }
      } else if (argv[i].startsWith("-B") ||
                 argv[i].startsWith("-J")) {
        if (argv[i].length()<3) {
          throw new IllegalArgumentException(invalidArgument(argv[i],2));
        } else {
          boolean wob = (argv[i].startsWith("-J"));
          a.enddate = (wob?"j":"") + argv[i].substring(2);
          a.duplicateTransitPoints = true; // Well, only if varyingTransitPoint == true;
        }
      } else if (argv[i].startsWith("-p")) {
        if (argv[i].length() >= 3) {
          a.pls1 = argv[i].substring(2);
        } else {
          throw new IllegalArgumentException(invalidArgument(argv[i],2));
        }
      } else if (argv[i].startsWith("-P")) {
        if (argv[i].length() >= 3) {
          a.pls2 = argv[i].substring(2);
        } else {
          throw new IllegalArgumentException(invalidArgument(argv[i],2));
        }
      } else if (argv[i].startsWith("-f")) {
        if (argv[i].length() > 2) {
          a.outputFormat = argv[i].substring(2);
          a.outputFormatIsSet = true;
        } else {
          throw new IllegalArgumentException(invalidArgument(argv[i],2));
        }
      } else if (argv[i].equals("-cv")) {
        a.convert = true;
      } else if (argv[i].equals("-locales")) {
        String[] locs = el.getLocales();
        for (int n=0; n<locs.length; n++) {
          //DevNull.println(locs[n]);
        }
        return null;
      } else if (argv[i].startsWith("-loc")) {
        locale = argv[i].substring(4);
        int idx24 = locale.indexOf("24");
        if (idx24 >= 0) {
          force24hSystem = true;
          locale = locale.substring(0,idx24) +
                   locale.substring(idx24+2);
        }
        if (locale.equals("swiss")) {
          locale = "de_DE";
          Nlocale = "en_US";
          nlocale = "en_US";
        }
      } else if (argv[i].startsWith("-iloc")) {
        Nlocale = argv[i].substring(5);
        int idx24 = Nlocale.indexOf("24");
        if (idx24 >= 0) {
          force24hSystem = true;
          Nlocale = Nlocale.substring(0,idx24) +
                    Nlocale.substring(idx24+2);
        }
        Dlocale = Nlocale;
      } else if (argv[i].startsWith("-Dloc")) {
        Dlocale = argv[i].substring(5);
        int idx24 = Dlocale.indexOf("24");
        if (idx24 >= 0) {
          force24hSystem = true;
          Dlocale = Dlocale.substring(0,idx24) +
                    Dlocale.substring(idx24+2);
        }
      } else if (argv[i].startsWith("-Nloc")) {
        Nlocale = argv[i].substring(5);
        int idx24 = Nlocale.indexOf("24");
        if (idx24 >= 0) {
          force24hSystem = true;
          Nlocale = Nlocale.substring(0,idx24) +
                    Nlocale.substring(idx24+2);
        }
      } else if (argv[i].startsWith("-oloc")) {
        dlocale = argv[i].substring(5);
        int idx24 = dlocale.indexOf("24");
        if (idx24 >= 0) {
          force24hSystem = true;
          dlocale = dlocale.substring(0,idx24) +
                    dlocale.substring(idx24+2);
        }
        nlocale = dlocale;
      } else if (argv[i].startsWith("-dloc")) {
        dlocale = argv[i].substring(5);
        int idx24 = dlocale.indexOf("24");
        if (idx24 >= 0) {
          force24hSystem = true;
          dlocale = dlocale.substring(0,idx24) +
                    dlocale.substring(idx24+2);
        }
      } else if (argv[i].startsWith("-nloc")) {
        nlocale = argv[i].substring(5);
        int idx24 = nlocale.indexOf("24");
        if (idx24 >= 0) {
          force24hSystem = true;
          nlocale = nlocale.substring(0,idx24) +
                    nlocale.substring(idx24+2);
        }
      } else if (argv[i].startsWith("-n")) {
        try {
          a.count = Integer.parseInt(argv[i].substring(2));
          a.countIsSet = true;
        } catch (NumberFormatException nf) {
          throw new IllegalArgumentException(invalidArgument(argv[i],2));
        }
      } else if (argv[i].startsWith("-N")) {
        try {
          a.count = Integer.parseInt(argv[i].substring(2));
          a.duplicateTransitPoints = true; // Well, only if varyingTransitPoint == true;
        } catch (NumberFormatException nf) {
          throw new IllegalArgumentException(invalidArgument(argv[i],2));
        }
      } else {
        throw new IllegalArgumentException("Unrecognized option '" + argv[i]
                + "'");
      }
    }
    return initArgs(a);
  }

  TransitArguments initArgs(TransitArguments a) {
    // Internationalization:
    // Actually, we have five locales:
    // -loc          (var. locale) locale for ALL parsing and formatting
    //                      is overridden by the more specific locales
    // -Dloc (-iloc) (var. Dlocale) locale to parse dates
    // -Nloc (-iloc) (var. Nlocale) locale to parse numbers
    // -dloc (-oloc) (var. dlocale) locale to format dates
    // -nloc (-oloc) (var. nlocale) locale to format numbers
    locale = checkLocale(locale, "");
    Dlocale = checkLocale(Dlocale, locale);
    Nlocale = checkLocale(Nlocale, locale);
    dlocale = checkLocale(dlocale, locale);
    nlocale = checkLocale(nlocale, locale);

    dif = el.createLocDateTimeFormatter(Dlocale, true); // DateInputFormat
    dof = el.createLocDateTimeFormatter(dlocale, force24hSystem); // DateOutputFormat
    dnof = NumberFormat.getInstance(el.getLocale(nlocale)); // NumberOutputFormat
    dateFracSeparator = el.getDecimalSeparator(dnof);
    nnif = NumberFormat.getInstance(el.getLocale(Nlocale));
    nnif.setGroupingUsed(false);
    numIFracSeparator = el.getDecimalSeparator(nnif);
    nnof = NumberFormat.getInstance(el.getLocale(nlocale));
    nnof.setGroupingUsed(false);
    nnof.setMaximumFractionDigits(12);
    numOFracSeparator = el.getDecimalSeparator(nnof);
    secondsIdx = el.getPatternLastIdx(dof.toPattern(), "s", dof); // No input with parts of seconds?

    a.to = parseTransitValString(a.transitValString);
    if (a.to == null) {
      throw new IllegalArgumentException(
              "Specify a longitude, latitude or distance value to be " +
              "transited\nwith the -lon, -lat, -dist, +lon, +lat or +dist " +
              "option!\nUse the -h option for more information.");
    }

    a.beginhour = parseHour(a.sBeginhour);
    if (a.endTimeIsSet) {
      a.endhour = parseHour(a.sEndhour);
    } else {
      a.endhour = a.beginhour;
      a.isUT = a.isUt;
    }

    // Complete output format string:
    String format = a.outputFormat;
    boolean appendOutputFormat = (a.outputFormat.startsWith("+"));

    if (!a.outputFormatIsSet || appendOutputFormat) {         // Use default
      if (a.convert) {
        a.outputFormat = "jdt";
      } else if (((a.to.offset != 0. && a.count > 1) || // Varying values
          a.to.values.length > 1)) {           // Multiple transit values given
        a.outputFormat = "vdt";
      } else {
        a.outputFormat = "dt";
      }
    }
    if (appendOutputFormat) {
      a.outputFormat += format.substring(1);
    }

    // Initialize SweDate objects to the given times and dates:
    a.sde1 = makeDate(a.begindate, a.beginhour, a.isUt, Dlocale);
    a.sde2 = makeDate(a.enddate, a.endhour, a.isUT, Dlocale);

    if (a.convert) {
      int idx = a.outputFormat.indexOf('n');
      while (idx >= 0) {
        DevNull.println("Info: ignoring output format character 'n' on date conversions.");
        a.outputFormat = a.outputFormat.substring(0,idx) + a.outputFormat.substring(idx+1);
        idx = a.outputFormat.indexOf('n');
      }
      idx = a.outputFormat.toLowerCase().indexOf('p');
      while (idx >= 0) {
        DevNull.println("Info: ignoring output format character 'p' on date conversions.");
        a.outputFormat = a.outputFormat.substring(0,idx) + a.outputFormat.substring(idx+1);
        idx = a.outputFormat.toLowerCase().indexOf('p');
      }
      // Check parameters:
      if (a.begindate == null) {
        throw new IllegalArgumentException(
                "Specify a date with the -b option!\n"+
                "Use the -h option for more information.");
      }
      // Allow a restricted set options only:
      if (a.enddate != null || !"".equals(a.sEndhour)) {
        System.err.println("Warning: Ignoring a second date on -cv option.");
      }
      if (a.back) {
        System.err.println("Warning: Ignoring option -r with -cv.");
      }
      if (a.calcSpeed) {
        System.err.println("Warning: Ignoring option -s with -cv.");
      }
      if (a.sidmode != -1) {
        System.err.println("Warning: Ignoring option -sid... with -cv.");
      }
      if (a.pl1 != -2 || a.pl2 != -2) {
        System.err.println("Warning: Ignoring options -p... / -P... options with -cv.");
      }
      if (a.countIsSet) {
        System.err.println("Warning: Ignoring options -n... / -N... with -cv.");
      }
// ...
      return a;
    }

    // Optimization to make "out of time range" errors less probable...
    if (a.to.values.length > 1 && a.to.idxOffset == 0) {
      bubbleSort(a.to.values);
    }



    // If -topo is given, read topographic values (lon / lat / height)
    if (a.topoS != null && a.topoS.length() > 0) {
      try {
        // Read number of fields and normalize fields to be separated by ';'
        int cnt=0;
        for(int k=0; k<a.topoS.length(); k++) {
          if (!Character.isDigit(a.topoS.charAt(k))) {
            char ch = a.topoS.charAt(k);
            if (ch != '-' && ch != '+') {
              if (!numIFracSeparator.equals(""+ch)) { // Well, can be a string, probably????
                a.topoS = a.topoS.substring(0,k) + ";" + a.topoS.substring(k+1);
                cnt++;
              }
            }
          }
        }
        // We need exactly three fields, meaning two field separators:
        if (cnt!=2) {
          throw new IllegalArgumentException(
                  invalidArgument("-topo"+a.topoS,5,Nlocale));
        }
        // Read field values:
        String ts = a.topoS;
        a.top_long=nnif.parse(ts.substring(0,ts.indexOf(';'))).doubleValue();
        ts=ts.substring(ts.indexOf(';')+1);
        a.top_lat=nnif.parse(ts.substring(0,ts.indexOf(';'))).doubleValue();
        ts=ts.substring(ts.indexOf(';')+1);
        a.top_elev=nnif.parse(ts).doubleValue();
      } catch (StringIndexOutOfBoundsException se) {
      } catch (Exception e) {
        throw new IllegalArgumentException(
                invalidArgument("-topo"+a.topoS,5,Nlocale));
      }
    }


    // Interpret and check parameters and parameter combinations:

    // Set ephemeris data file paths:
    a.iflag = (a.iflag & ~SweConst.SEFLG_EPHMASK) | a.whicheph;
    String curDir = System.getProperties().getProperty("user.dir");
    if (a.ephepath.length() > 0) {
      sw.swe_set_ephe_path(a.ephepath);
    } else if (make_ephemeris_path(a.iflag, curDir) == SweConst.ERR) {
      a.iflag = (a.iflag & ~SweConst.SEFLG_EPHMASK) | SweConst.SEFLG_MOSEPH;
      a.whicheph = SweConst.SEFLG_MOSEPH;
    }
    if ((a.whicheph & SweConst.SEFLG_JPLEPH)!=0) {
      sw.swe_set_jpl_file(a.fname);
    }


    // Check for required parameters
    if (a.pls1 == null) {
      throw new IllegalArgumentException(
              "Specify one or more planets with the -p option!\n"+
              "Use the -h option for more information.");
    }
    if (a.begindate == null) {
      throw new IllegalArgumentException(
              "Specify a (starting) date with the -b option!\n"+
              "Use the -h option for more information.");
    }
    if (a.to.offset != 0 && a.to.values.length != 1) {
      throw new IllegalArgumentException(
              "Specify one or more transit values separated by\n"+
              "the \"/\" character, OR(!!!) give an offset to a\n"+
              "start value, but not both.\n"+
              "Examples:\n"+
              "  ... -lon30+10 ...\n"+
              "  ... -lat0/-0.3/0.3 ...\n"+
              "Use the -h option for more information.");
    }

    // A second time gets set equal to the first time, if it is not given
    // on the command line:
    if (Double.isInfinite(a.endhour)) {
      a.endhour = a.beginhour;
      a.isUT = a.isUt;
    }


    // Add the transit flags to the calculation flags:
    a.cflag = a.iflag;
    if (a.to.idxOffset==0) {
      a.iflag |= SweConst.SEFLG_TRANSIT_LONGITUDE;
    } else if (a.to.idxOffset==1) {
      a.iflag |= SweConst.SEFLG_TRANSIT_LATITUDE;
    } else if (a.to.idxOffset==2) {
      a.iflag |= SweConst.SEFLG_TRANSIT_DISTANCE;
    }
    if (a.calcSpeed) {
      a.iflag |= SweConst.SEFLG_TRANSIT_SPEED;
      a.to.idxOffset += 3;
    }
    if (a.yogaTransit) {
      a.iflag |= SweConst.SEFLG_YOGA_TRANSIT;
    }

    // Swap dates if necessary:
    if (a.sde2 != null &&
        ((!a.back && a.sde1.getJulDay() > a.sde2.getJulDay()) ||
        (a.back && a.sde1.getJulDay() < a.sde2.getJulDay()))) {
      SweDate tmpdate = a.sde1;
      a.sde1 = a.sde2;
      a.sde2 = tmpdate;
    }


    // varyingTransitPoints is only meaningful, when we have changing values:
    a.varyingTransitPoints = (a.to.offset != 0);
    a.duplicateTransitPoints &= a.varyingTransitPoints;


    // Multiple planets?
    a.mp1 = (a.pls1.length() > 1);
    a.mp2 = (a.pls2 !=null && a.pls2.length() > 1);

    // Force output of planet names, if multiple planets are requested
    if (a.mp1 || a.mp2) {
      if (a.outputFormat.indexOf("n") < 0 &&
          (!a.outputFormatIsSet || appendOutputFormat)) {
        a.outputFormat = "n" + a.outputFormat;
      }
    }


    // Checks...
    // Parameter combinations:
    //   -p... -b... +-lon/lat/dist [other options]
    //   -p... -P... -b... +-lon/lat/dist [other options]
    //   -p... -b... -B... +-lon/lat/dist [other options]
    //   -p... -P... -b... -B... +-lon/lat/dist [other options]

    if (a.pls2 == null && a.outputFormat.indexOf('P') >= 0) {
      DevNull.println("Info: ignoring output format character 'P' on non-relative transits.\n");
    }

    boolean invalidComb=false;
    if ((a.enddate != null && a.countIsSet)) { // 2 times => !a.countIsSet
      invalidComb=true;
    }
    if (invalidComb) {
      throw new IllegalArgumentException(
              "Invalid parameter combination.\n" + infocmd1 + "\n" +
              "Use option '-h' for additional help.");
    }

    // Planets:
    for(int n = 0; n < a.pls1.length(); n++) {
      char p = a.pls1.charAt(n);
      if (letter_to_ipl(p) == -1) {
        throw new IllegalArgumentException(
                "Unsupported planet " +
                (Character.isDigit(p)?"number":"character") + ": '" + p +
                "'.\nCheck for valid planets with the '-h' option.");
      }
    }
    if (a.pls2 != null) {
      for(int n = 0; n < a.pls2.length(); n++) {
        char p = a.pls2.charAt(n);
        if (letter_to_ipl(p) == -1) {
          throw new IllegalArgumentException(
                  "Unsupported planet " +
                  (Character.isDigit(p)?"number":"character") + ": '" + p +
                  "'.\nCheck for valid planets with the '-h' option.");
        }
      }
    }

    if (a.yogaTransit && a.pls2 == null) {
      throw new IllegalArgumentException(
              "Yoga Transits can only be computed over two planets.\n" +
              "Use '-h' option for valid parameter combinations.");
    }

    sw.swe_set_topo(a.top_long, a.top_lat, a.top_elev);

    if (a.sidmode>=0) {
      sw.swe_set_sid_mode(a.sidmode,0.,0.);
      a.iflag |= SweConst.SEFLG_SIDEREAL;
    }


    a.tjde1 = a.sde1.getJulDay();
    if (a.sde2 != null) {
      a.tjde2 = a.sde2.getJulDay();
    }

    a.jdET2 = (a.back?-Double.MAX_VALUE:Double.MAX_VALUE);
    if (a.sde2 != null) {
      a.jdET2 = a.sde2.getJulDay();
    }

    return a;
  }

  void writeCmdLine(String[] par, boolean withHeader) {
    if (withHeader) {
      for (int i = 0; i < par.length; i++) { 
        //DevNull.print(par[i]+" "); 
      }
      //DevNull.println();
    }
  }

  void writeHeader(TransitArguments a) {
    ///////////////////////////////////////////////////////////////////
    // Here the output and calculation starts with the output of the //
    // header if requested:                                          //
    ///////////////////////////////////////////////////////////////////
    if (!a.withHeader) { return; }

    String line = "";

    if (a.sidmode>=0) {
      DevNull.print("Ayanamsha");
// Should state the ayanamsha system here!
      if (a.enddate == null) {
        /*
         DevNull.print(":         "+(a.mp1?" ":"")+
                                     doubleToDMS(sw.swe_get_ayanamsa(a.tjde1)));
        */
      } else {
        /*
         DevNull.println("\n on starting date: "+(a.mp1?" ":"")+
                                     doubleToDMS(sw.swe_get_ayanamsa(a.tjde1)));
         DevNull.println(" on end date:      "+(a.mp1?" ":"")+
                                    doubleToDMS(sw.swe_get_ayanamsa(a.tjde2)));
        */
      }
    }
    //DevNull.println();
    if (a.isUt) {
      //DevNull.println("starting date:     "+(a.mp1?" ":"")+jdToDate(a.sde1, true, 0)+" UT");
    } else {
      //DevNull.println("starting date:     "+(a.mp1?" ":"")+jdToDate(a.sde1, false, 0)+" ET");
    }
    if (a.enddate!=null) {
      if (a.isUT) {
        //DevNull.println("end date:          "+(a.mp1?" ":"")+jdToDate(a.sde2, true, 0)+" UT");
      } else {
        //DevNull.println("end date:          "+(a.mp1?" ":"")+jdToDate(a.sde2, false, 0)+" ET");
      }
    }
    if (!a.yogaTransit) {
      /*
      DevNull.println("Transiting planet" + (a.mp1?"s":"") + ": " +
                         limitLineLength(getPlanetNames(a.pls1, " or "),
                                         70,
                                         "                    "));
      */
    }
    DevNull.print("Reference point:   " + (a.mp1?" ":""));
    if (a.calcSpeed) {
      ObjFormatter dblf = new ObjFormatter(a.to.values,
                                           swed.ODEGREE_CHAR+"/day");
      if (a.pls2 != null) {
        if (a.yogaTransit) {
          line = "combined " + (a.helio?"heliocentric ":"") + " speed of " +
                  group(dblf, a.to.values.length, " or ") +
                  " of " + (a.mp1?"the planets ":"planet ") +
                  getPlanetNames(a.pls1, " or ") + (a.mp1?" with ":" and ") +
                  (a.mp2?"any of ":"") + getPlanetNames(a.pls2, ", ");
        } else {
          line = (a.helio?"heliocentric ":"") + "speed of " +
                  group(dblf, a.to.values.length, " or ") + " " +
                  (a.to.values.length!=1?"different from":
                     (a.to.values[0].doubleValue()<0?"lower than":"higher than")) +
                  " speed of "+ getPlanetNames(a.pls2, " or ");
        }
        line += " in "+
                (a.to.idxOffset==3?"longitudinal":(a.to.idxOffset==4?
                                                 "latitudinal":"distance")) +
                " direction";
        if (a.varyingTransitPoints) {
          line += " with varying transit points";
        }
        /*
        DevNull.println(limitLineLength(line,
                           70,
                           "                   "+(a.mp1?" ":"")));
        */
      } else {
        line = group(dblf, a.to.values.length, " or ") + " in " +
                  (a.helio?"heliocentric ":"") +
                  (a.to.idxOffset==3?"longitudinal":(a.to.idxOffset==4?
                                                 "latitudinal":"distance")) +
                  " direction"+(a.sidmode>=0?" in the sidereal zodiac":"");
        if (a.varyingTransitPoints) {
          line += " with varying transit points";
        }
        /*
        DevNull.println(limitLineLength(line,
                           70,
                           "                   "+(a.mp1?" ":"")));
        */
      }
      DevNull.println();
      if ((a.iflag&SweConst.SEFLG_TOPOCTR)!=0) {
        /*
        DevNull.println("Topographic pos.:  "+(a.mp1?" ":"") +
          doubleToDMS(Math.abs(a.top_long)) + (a.top_long<0?"S":"N") + "/" +
          doubleToDMS(Math.abs(a.top_lat)) + (a.top_lat<0?"W":"E") + "/" +
          nnof.format(a.top_elev) + "m");
        */
      }
    } else { // Transit over a lon / lat / dist position:
      ObjFormatter dblf = new ObjFormatter(a.to.values,
                                   (a.to.idxOffset==2?" AU":""+swed.ODEGREE_CHAR));
      if (a.pls2 != null) {
        if (a.yogaTransit) {
          line = "combined " + (a.helio?"heliocentric ":"") +
                (a.to.idxOffset==0?"longitudinal":(a.to.idxOffset==1?
                                              "latitudinal":"distance")) +
                " positions of " +
                (a.mp1?"the ":"") + "planets " + getPlanetNames(a.pls1, " or ") +
                (a.mp1?" with ":" and ") + (a.mp2?"any of ":"") +
                getPlanetNames(a.pls2, ", ") + " reach " +
                group(dblf, a.to.values.length, " or ") +
                (a.sidmode>=0?" in the sidereal zodiac":"");
        } else {
          line = group(dblf, a.to.values.length, " or ") + " ";
          if (a.to.idxOffset==2) { // distance
            line += "farther away than " + getPlanetNames(a.pls2, " or ") +
                    (a.helio?" (heliocentric)":"");
          } else {
            line += (a.to.values.length!=1?"different from":
                           (a.to.values[0].doubleValue()<0?"before":"after")) + " " + 
              (a.helio?"heliocentric ":"") +
              (a.to.idxOffset==0?"longitudinal":(a.to.idxOffset==1?
                                              "latitudinal":"distance")) +
              " position of "+  getPlanetNames(a.pls2, " or ");
          }
        }
      } else {
        line = group(dblf, a.to.values.length, " or ") + " " +
               (a.to.idxOffset==2?"of ":"") +
               (a.helio?"heliocentric ":"") +
               (a.to.idxOffset==0?"longitude":(a.to.idxOffset==1?
                                               "latitude":"distance")) +
               (a.sidmode>=0?" in the sidereal zodiac":"");
      }
      if (a.varyingTransitPoints) {
        line += " with varying transit points";
      }
      /*
      DevNull.println(limitLineLength(line,
                         70,
                         "                   " + (a.mp1?" ":"")));
      */
      if ((a.iflag&SweConst.SEFLG_TOPOCTR)!=0) {
        /*
        DevNull.println("Topographic pos.:  " + (a.mp1?" ":"") +
            doubleToDMS(Math.abs(a.top_long)) + (a.top_long<0?"S":"N") + "/" +
            doubleToDMS(Math.abs(a.top_lat)) + (a.top_lat<0?"W":"E") + "/" +
            nnof.format(a.top_elev) + "m");
        */
      }
    }
    DevNull.println();
  }

  TransitCalculator[] initCalculators(TransitArguments a)
      throws IllegalArgumentException {
    // Init all required TransitCalculators:
    TransitCalculator tcs[] = null;
    a.idxDuplicates = Integer.MAX_VALUE;
    if (a.pls2 != null) {  // relative or yoga transit between two planets
      String planetCombinations = getPlanetCombinations(a.pls1,a.pls2);
      if ("@".equals(planetCombinations)) {
        throw new IllegalArgumentException(
                "Planets for relative and yoga transits have to be " +
                "different!\nUse the -h option for more information.");
      }
      a.idxDuplicates = planetCombinations.indexOf('@');
      planetCombinations = planetCombinations.substring(0,a.idxDuplicates) +
                           planetCombinations.substring(a.idxDuplicates+1);
      a.idxDuplicates /= 2;
      tcs = new TransitCalculator[planetCombinations.length()/2];
      a.plNumbers = new int[planetCombinations.length()/2][2];
      int ci = 0;
      int t = 0;
      while(t < tcs.length) {
        a.pl1 = letter_to_ipl(planetCombinations.charAt(ci));
        a.pl2 = letter_to_ipl(planetCombinations.charAt(ci+1));
        ci += 2;
        tcs[t] = new TCPlanetPlanet(sw, a.pl1, a.pl2, a.iflag, a.to.values[0].doubleValue());
        a.plNumbers[t][0] = a.pl1;
        a.plNumbers[t][1] = a.pl2;
        t++;
      }
//    } else if (house1 >= 0) {  // planet - house transit
    } else { // transit of ONE planet over a position or speed
      tcs = new TransitCalculator[a.pls1.length()];
      a.plNumbers = new int[a.pls1.length()][2];
      // Move moon (1) and mean node (t) to the end of calculations, to
      // speed calculations up. An extreme situation: -p12 -lon0 -s -n...
      // will require more than 2,230,000(!!!) iterations, but
      // -p21 -lon0 -s -n... only 154.
      int index = a.pls1.indexOf('m');
      if (index >= 0) {
        a.pls1 = a.pls1.substring(0,index) +
                 a.pls1.substring(index+1) + '1';
      }
      index = a.pls1.indexOf('1');
      if (index >= 0) {
        a.pls1 = a.pls1.substring(0,index) +
                 a.pls1.substring(index+1) + '1';
      }
      for(int t = 0; t < tcs.length; t++) {
        a.pl1 = letter_to_ipl(a.pls1.charAt(t));
        tcs[t] = new TCPlanet(sw, a.pl1, a.iflag, a.to.values[0].doubleValue());
        a.plNumbers[t][0] = a.pl1;
        a.plNumbers[t][1] = -1;
      }
    }

    // All transit calculators "should have" the same rollover flag,
    // otherwise, I forgot about something vital...
    a.rollover = tcs[0].getRollover();

    // -lon35+1 -N or -lon35+1 -b... -B... searches for 34/35/36
    // degrees, so we '+1' in this case can be safely positive:
    if (a.rollover && a.duplicateTransitPoints) {
      // Negative offsets are mapped to positive ones, as we just look
      // for to.values[tvn] - to.offset, to.values[tvn] and
      // to.values[tvn] + to.offset in -b... -B... / or -N options.
      a.to.offset = Math.abs(a.to.offset)%360.;
    }

    return tcs;
  }

  TransitResult calcNextTransit(TransitArguments a, TransitCalculator[] tcs) {
    TransitResult tr = new TransitResult();
    TransitResult tr2 = null;

    // Which TransitCalculator returns the nearest transit?
    // int tr.tcsNo
    // Which transit value returns the nearest transit?
    // double tr.transitValue
    // Which jdET is the nearest jd?
    tr.jdET = (a.back?-Double.MAX_VALUE:Double.MAX_VALUE);


    a.v.jdStart = a.tjde1;
    a.v.jdEnd = a.jdET2;
    a.v.rollover = a.rollover;
    a.v.varyingTransitPoints = a.varyingTransitPoints;
    a.v.duplicateTransitPoints = a.duplicateTransitPoints;
    a.v.tvOffset = a.to.offset;
    a.v.back = a.back;


    // Calculate next (prev) transit point for all planets or planet
    // combinations (== for all TransitCalculators), and put the minimum
    // found value (maximum for backwards search) into tr.jdET:
    for (a.v.tcIndex = 0; a.v.tcIndex < tcs.length; a.v.tcIndex++) {
      a.v.tc = tcs[a.v.tcIndex];

      // Calculate this planet or planet combination for all possible or
      // requested transit values.
      for(int tvn = 0; tvn < a.to.values.length; tvn++) {
        a.v.transitVal = a.to.values[tvn].doubleValue();
        tr2 = calcNeighbouringTransits(a, a.plNumbers[tr.tcsNo][0],a.plNumbers[tr.tcsNo][1]);

         // Select closest transit point of all current transit calculations
        if ((a.back && tr2.jdET > tr.jdET) ||
            (!a.back && tr2.jdET < tr.jdET)) {
          tr.tcsNo = a.v.tcIndex;
          tr.transitValue = tr2.transitValue;
          tr.jdET = tr2.jdET;
          a.v.jdEnd = tr2.jdET;

          tr.pl1 = a.plNumbers[tr.tcsNo][0];
          tr.pl2 = a.plNumbers[tr.tcsNo][1];
        }
      } // for ...
    } // for tc in tcs[]; do ...

    return tr;
  }

  void bubbleSort(Double[] d) {
    if (d.length < 2) { return; }
    boolean sorted = true;
    Double tmp = null;
    do {
      sorted = true;
      for (int i = 0; i < d.length - 1; i++) {
        if (Math.abs(d[i].doubleValue()) > Math.abs(d[i+1].doubleValue())) {
          tmp = d[i+1]; d[i+1] = d[i]; d[i] = tmp;
          sorted = false;
        }
      }
    } while (!sorted);
  }
} // End of class Transits


class TransitValues {
  TransitCalculator tc = null;
  int tcIndex = 0; // Keep track of which tc is saved to jdET

  double transitVal = 0./0.;
  double jdStart = 0./0.;
  double jdEnd = 0./0.;
  double tvOffset = 0./0.;

  double zTmp = 0./0.;
  double z0 = 0./0.; // The final minimum value
  double zm = 0./0.;
  double zp = 0./0.;

  boolean varyingTransitPoints = false;  // e.g. -lon60+10 with -n, -N, -b -b, -b -B
  boolean duplicateTransitPoints = false; // e.g. -lon60+10 -N / -B only
  boolean outOfTimeRange = false;
  boolean back = false;
  boolean rollover = false;
}


class TransitOffsets {
  int idxOffset = 0;           // The index into the xx[] array in swe_calc*()
                               // 0 to 5: lon / lat / dist / speed in lon /
                               //         lat / dist
  Double[] values = null;      // The transit values, over which the
                               // the transits should be calculated
  double offset = 0.;          // An optional offset to be added to
                               // the transit values on each calculation
                               // iteration
}


class ObjFormatter {
  String postfix = "";
  Object[] arr = null;
  ObjFormatter(Object[] arr, String postfix) {
    this.arr = arr;
    this.postfix = postfix;
  }
  String format(int idx) {
    return arr[idx].toString() + postfix;
  }
}




class TransitArguments {
  // CH-Zuerich:
  double top_long = 8.55;
  double top_lat = 47.38;
  double top_elev = 400;

  // Default values for optional parameter:
  boolean withHeader = true;
  boolean back = false;
  boolean isUt = false; // Time of starting date
  boolean isUT = false; // Time of end date
  boolean calcSpeed = false;
  int sidmode=-1;                 // Means: tropical mode
  int whicheph = SweConst.SEFLG_SWIEPH;
  String ephepath = SweConst.SE_EPHE_PATH;
  String sBeginhour = "";
  double beginhour = 0;
  String pls2 = null;
  int pl2 = -2;                   // Means: not set
  double count = 1;
  // JPL:
  String fname=SweConst.SE_FNAME_DE406;
  String topoS = null;
  boolean convert = false;



  // Derived values:
  boolean countIsSet = false;
  // duplicateTransitPoints, e.g. -lat0+0.01 with -N / -B only
  boolean duplicateTransitPoints = false;   // multiple transit points
  // varyingTransitPoints, e.g. -lat0+0.01 with -N, -n / -b -B, -b -b
  boolean varyingTransitPoints = false;
  boolean yogaTransit = true;
  boolean helio = false;
  int iflag = 0;  // Flags to be used for transit calculations
  int cflag = 0;  // Flags to be used for pure calculations

  boolean outputFormatIsSet = false;
  String outputFormat = "dt";
  double zm = 0;
  double zp = 0;

  // A string containing the type and value of the transit point, e.g.:
  //    +lon0         for yoga transits over 0 degrees in longitude.
  //    -lat0+0.01    for transits over 0 degrees in latitude with 0.01 degree
  //                  increment.
  //    -lon30/45/60/90/120/180/270
  //                  for transits over any of these longitudinal degrees
  String transitValString="";

  // Required parameters:
  int pl1 = -2;
  String pls1 = null;
  String begindate = null;
  String enddate = null;
  String sEndhour = "";
  double endhour = 1./0.;         // Means: not set
  boolean endTimeIsSet = false;


  // Intermediate or other derived parameters:
  TransitOffsets to = null;
  boolean mp1 = false; // More than one planet
  boolean mp2 = false; // More than one planet on relative or yoga transits

  double tjde1 = 0.;
  double tjde2 = 0.;
  int[][] plNumbers = null;
  SweDate   sde1 = new SweDate();
  SweDate   sde2 = new SweDate();
  boolean rollover = false;
  TransitValues v = new TransitValues();
  int idxDuplicates = 0;
  boolean withDuplicates = true;

  double jdET2 = 0.;
}

class TransitResult {
  // The index in the array of all TransitCalculators returning the
  // nearest transit point:
  public int tcsNo = 0;

  // The nearest transit point found, Double.MAX_VALUE or Double.MIN_VALUE,
  // if no transit found:
  public double jdET = 0./0.;

  // The planet numbers:
  public int pl1 = 0;
  public int pl2 = 0;

  public double transitValue = 0./0.;

  public String toString() {
    return "tcs[" + tcsNo + "];pl:" + pl1 + "/" + pl2 + ";" + jdET;
  }
}



class Vedic {
    
    public String getReading(int day, int month, int year, double latitude, double longitude, double time, double greenwichOffset) {

	int SID_METHOD = SweConst.SE_SIDM_LAHIRI;
	String[] signNames = { "Aries","Taurus","Gemini","Cancer","Leo","Virgo",
			       "Libra","Scorpio","Sagittarius","Capricorn","Aquarius",
			       "Pisces"};

	
	double hour = time + (0. / 60.) + greenwichOffset; // IST				
	SwissEph sw = new SwissEph();
	SweDate sd = new SweDate(year, month, day, hour);
	sw.swe_set_sid_mode(SID_METHOD, 0, 0);

	double[] cusps = new double[13];
	double[] acsc = new double[10];
	double[] xp = new double[6];
	StringBuffer serr = new StringBuffer();

	double ayanamsa = sw.swe_get_ayanamsa_ut(sd.getJulDay());
	int flags = SweConst.SEFLG_SIDEREAL;
	int result = sw.swe_houses(sd.getJulDay(), flags, latitude, longitude, 'P', cusps, acsc);

	int ascSign = (int) (acsc[0] / 30) + 1;
	String ascOut = signNames[ascSign-1];
	
	flags = SweConst.SEFLG_SWIEPH | 
	    SweConst.SEFLG_SIDEREAL | 
	    SweConst.SEFLG_NONUT | 
	    SweConst.SEFLG_SPEED;

	int sign;
	int house;
	boolean retrograde = false;
	String output = "{";

	output += "'Ascending': ['" + ascOut + "'],";
	
	int[] planets = { SweConst.SE_SUN, SweConst.SE_MOON, SweConst.SE_MARS, SweConst.SE_MERCURY, SweConst.SE_JUPITER,
			  SweConst.SE_VENUS, SweConst.SE_SATURN, SweConst.SE_TRUE_NODE }; // Some

	for (int p = 0; p < planets.length; p++) {
	    int planet = planets[p];
	    String planetName = sw.swe_get_planet_name(planet);
	    int ret = sw.swe_calc_ut(sd.getJulDay(), planet, flags, xp, serr);
	    sign = (int) (xp[0] / 30) + 1;
	    house = (sign + 12 - ascSign) % 12 + 1;
	    retrograde = (xp[3] < 0);
	    output += String.format("'%s': ['%s',%d],", planetName,signNames[sign-1],house);
	}

	xp[0] = (xp[0] + 180.0) % 360;
	String planetName = "Ketu (true)";
	sign = (int) (xp[0] / 30) + 1;
	house = (sign + 12 - ascSign) % 12 + 1;
	output += String.format("'%s': ['%s',%d]", planetName,signNames[sign-1],house);

	output += "}";	
	return output;
    }

    public void test() {
	int year = 1973;
	int month = 4;
	int day = 24;
	double longitude = 32.85646943314241;
	double latitude = 39.941139297390365;
	double time = 10;
	double greenwichOffset = -3;
	String res = getReading(day, month, year, latitude, longitude, time, greenwichOffset);
	System.out.println(res);		
    }

    public String getReading(String[] args) {
	int day = Integer.valueOf(args[0]);
	int mon = Integer.valueOf(args[1]);
	int year = Integer.valueOf(args[2]);
	double time = Double.valueOf(args[3]);
	double latitude = Double.valueOf(args[4]);
	double longitude = Double.valueOf(args[5]);
	double greenwichOffset = -1 * Double.valueOf(args[6]);
	//System.out.printf("Java received %d %d %d %f %f %f %f", day,mon,year,time,latitude,longitude,offset);
	String res = getReading(day, mon, year, latitude, longitude, time, greenwichOffset);
	//System.out.println(res);		
	return res;
    }
    
    public static void main(String[] args) {
	Vedic v = new Vedic();
	//v.test();
	String res = v.getReading(args);
	System.out.println(res); 
    }
}



/**
 * This class is an example of how to calculate planets and houses in the indian
 * vedic style of astrology (jyotish).
 */
class VedicTest {

    /**
     * The method to determine ayanamsha value:
     */
    private static final int SID_METHOD = SweConst.SE_SIDM_LAHIRI;
    private static final String[] signNames = { "Aries","Taurus","Gemini","Cancer","Leo","Virgo",
						"Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"};
    
    public static void main(String[] args) {
	System.out.println((int)'P');
				
	int year = 1973;
	int month = 4;
	int day = 24;
	double longitude = 32.85646943314241;
	double latitude = 39.941139297390365;
	double hour = 10 + (0. / 60.) - 3; // IST
				
	SwissEph sw = new SwissEph();
	SweDate sd = new SweDate(year, month, day, hour);
	System.out.println(sd.getDate(0).toString());
	// Set sidereal mode:
	sw.swe_set_sid_mode(SID_METHOD, 0, 0);

	// Some required variables:
	double[] cusps = new double[13];
	double[] acsc = new double[10];
	double[] xp = new double[6];
	StringBuffer serr = new StringBuffer();

	// Print input details:
	System.out.println("Date (YYYY/MM/DD): " + sd.getYear() + "/" + sd.getMonth() + "/" + sd.getDay() + ", "
			   + toHMS(sd.getHour()));
	System.out.println("Jul. day:  " + sd.getJulDay());
	System.out.println("DeltaT:    " + sd.getDeltaT() * 24 * 3600 + " sec.");
	System.out.println("Location:  " + toDMS(Math.abs(longitude)) + (longitude > 0 ? "E" : "W") + " / "
			   + toDMS(Math.abs(latitude)) + (latitude > 0 ? "N" : "S"));

	// Get and print ayanamsa value for info:
	double ayanamsa = sw.swe_get_ayanamsa_ut(sd.getJulDay());
	System.out.println("Ayanamsa:  " + toDMS(ayanamsa) + " (" + sw.swe_get_ayanamsa_name(SID_METHOD) + ")");

	// Get and print lagna:
	int flags = SweConst.SEFLG_SIDEREAL;
	int result = sw.swe_houses(sd.getJulDay(), flags, latitude, longitude, 'P', cusps, acsc);
	System.out.println("Ascendant: " + toDMS(acsc[0]) + "\n");

	int ascSign = (int) (acsc[0] / 30) + 1;
	System.out.println("Ascendant Sign: " + signNames[ascSign-1] + "\n");

	// Calculate all planets:
	int[] planets = { SweConst.SE_SUN, SweConst.SE_MOON, SweConst.SE_MARS, SweConst.SE_MERCURY, SweConst.SE_JUPITER,
			  SweConst.SE_VENUS, SweConst.SE_SATURN, SweConst.SE_TRUE_NODE }; // Some
	// systems
	// prefer
	// SE_MEAN_NODE

	flags = SweConst.SEFLG_SWIEPH | // fastest method, requires data files
	    SweConst.SEFLG_SIDEREAL | // sidereal zodiac
	    SweConst.SEFLG_NONUT | // will be set automatically for sidereal
	    // calculations, if not set here
	    SweConst.SEFLG_SPEED; // to determine retrograde vs. direct
	// motion
	int sign;
	int house;
	boolean retrograde = false;

	for (int p = 0; p < planets.length; p++) {
	    int planet = planets[p];
	    String planetName = sw.swe_get_planet_name(planet);
	    int ret = sw.swe_calc_ut(sd.getJulDay(), planet, flags, xp, serr);

	    if (ret != flags) {
		if (serr.length() > 0) {
		    System.err.println("Warning: " + serr);
		} else {
		    System.err.println(String.format("Warning, different flags used (0x%x)", ret));
		}
	    }

	    sign = (int) (xp[0] / 30) + 1;
	    System.out.println(planetName);
	    System.out.println(signNames[sign-1]);
	    house = (sign + 12 - ascSign) % 12 + 1;
	    retrograde = (xp[3] < 0);

	    System.out.printf("%-12s: %s %c; sign: %2d; %s in house %2d\n", planetName, toDMS(xp[0]),
			      (retrograde ? 'R' : 'D'), sign, toDMS(xp[0] % 30), house);
	}
	// KETU
	xp[0] = (xp[0] + 180.0) % 360;
	String planetName = "Ketu (true)";

	sign = (int) (xp[0] / 30) + 1;
	house = (sign + 12 - ascSign) % 12 + 1;

	System.out.printf("%-12s: %s %c; sign: %2d; %s in house %2d\n", planetName, toDMS(xp[0]),
			  (retrograde ? 'R' : 'D'), sign, toDMS(xp[0] % 30), house);
    }

    static String toHMS(double d) {
	d += 0.5 / 3600.; // round to one second
	int h = (int) d;
	d = (d - h) * 60;
	int min = (int) d;
	int sec = (int) ((d - min) * 60);


		
	return String.format("%2d:%02d:%02d", h, min, sec);
    }

    static String toDMS(double d) {
	d += 0.5 / 3600. / 10000.; // round to 1/1000 of a second
	int deg = (int) d;
	d = (d - deg) * 60;
	int min = (int) d;
	d = (d - min) * 60;
	double sec = d;

	return String.format("%3d°%02d'%07.4f\"", deg, min, sec);
    }
	
}
