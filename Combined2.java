/// commons-lang3-3.13.0.jar is needed for compilation
import java.util.Calendar;
import java.util.Date;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Arrays;
import java.text.*;  // DateFormat etc.
import java.util.*;
import java.net.*;
import java.io.*;
import java.util.StringTokenizer;
import java.util.TimeZone;
import java.math.*;

class AyaInit {
  double t0;
  double ayan_t0;

  AyaInit(double t0, double ayan_t0) {
    this.t0=t0;
    this.ayan_t0=ayan_t0;
  }
}


class CFmt {
  // public:
  // Constructors:

  
  public CFmt() {
    this.hexByteCnt=8;
  }

  
  public CFmt(int hexByteCnt) {
    setHexByteCnt(hexByteCnt);
  }


  // Public Methods: /////////////////////////////////////////////////////////

  
  public void setHexByteCnt(int hexByteCnt) {
    if (hexByteCnt==8 || hexByteCnt==4) {
      this.hexByteCnt=hexByteCnt;
    }
  }

  
  public int getHexByteCnt() {
    return this.hexByteCnt;
  }




  // Methods for conversion: /////////////////////////////////////////////////
  // char "c":
  
  public String fmt( String conv, char c ) {
    return fmt(conv, new Character(c).toString());
  }


  // Strings "s":
  
  public String fmt( String conv, String s ) {
    CFmtCvt cv = new CFmtCvt(conv);
    if (cv.type=='c') {
      s=s.substring(0,1);
    } else if (cv.type!='s') {
      return "";
    }

    // Precision:
    if (cv.withPrec && cv.precision<s.length() && cv.type!='c') {
      s=s.substring(0,cv.precision);
    }

    // MinimumFieldWidth:
    if (cv.minimum>320) { cv.minimum=320; }
    String padString=empty;
    if (cv.padChar=='0' && !cv.fMinus) { padString=zeros; }
    if (cv.withMin && s.length()<cv.minimum) {
      if (cv.fMinus) {
        s+=padString.substring(0,cv.minimum-s.length());
      } else {
        s=padString.substring(0,cv.minimum-s.length())+s;
      }
    }

    return s;
  }



  // byte d,i,o,p,u,x,X:
  
  public String fmt( String conv, byte bval ) {
    return intFmt(conv, (long) bval, 'b');
  }

  // integer d,i,o,p,u,x,X:
  
  public String fmt( String conv, int ival  ) {
    return intFmt(conv, (long) ival, 'i');
  }

  // long d,i,o,p,u,x,X:
  
  public String fmt( String conv, long lval  ) {
    return intFmt(conv, lval, 'l');
  }



  // float f, e, E, g, G:
  
  public String fmt( String conv, float fval  ) {
    return fmt( conv, (double)fval );
  }

  // double f, e, E, g, G:
  
  public String fmt( String conv, double dval  ) {
    CFmtCvt cv = new CFmtCvt(conv);
    boolean isG=false;
    boolean neg=false;
    String res="";

    neg=(Double.doubleToLongBits(dval)&0x8000000000000000L)!=0L;

    if (Double.isNaN(dval)) { res="nan"; }
    if (dval == Double.NEGATIVE_INFINITY ||
        dval == Double.POSITIVE_INFINITY) {
      if (cv.precision<8) { res="Inf";
      } else { res="Infinity";
      }
    }
    if (neg) { dval=-dval; }

    if (res=="") {
      if (!cv.withPrec) { cv.precision=6; cv.withPrec=true; }

      if (cv.type=='g' || cv.type=='G') { isG=true; }

// Rounding is not accurate!!!
double dval_tmp=dval; // postpone rounding
      // Rounding:
      // cv.precision:
      // e, E, f: no. of digits after decimalpoint
      // g, G   : max. no. of significant digits
      int pexp=0;
      int nexp=0;
      if (dval_tmp!=0.) {
        double fd=dval_tmp;
        while (fd>=10.) { fd/=10.; pexp++; }
        while (fd<1.) { fd*=10.; nexp++; }
        if (isG) {
          if (cv.precision==0) { cv.precision++; }
          dval_tmp+=5*Math.pow(10,pexp-nexp-cv.precision);
        } else {
          if (cv.type=='e' || cv.type=='E') { // Exponential number:
            dval_tmp+=5*Math.pow(10,-cv.precision-1+pexp-nexp);
          } else { // Floatingpoint number without exponent:
            dval_tmp+=5*Math.pow(10,-cv.precision-1);
          }
        }
      }

      // Mapping 'g' and 'G' to 'f', 'e' or 'E' and changing the meaning
      // of 'precision' to the meaning of precision in 'f, 'e', 'E'
      // (precision='f', 'e', 'E': Count of digits after the decimalpoint
      //            'g', 'G':      Count of all signifikant digits):
      if (isG) {
        if (dval_tmp!=0. && (dval_tmp<1E-4 || dval_tmp>=Math.pow(10,cv.precision))) {
          if (cv.precision>0) { cv.precision--; } // Digit before decimalpoint
          if (cv.type=='g') { cv.type='e';
          } else { cv.type='E';
          }
        } else {
          cv.precision=cv.precision-pexp-1+nexp;
          cv.type='f';
        }
        if (cv.precision<0) { cv.precision=0; }
      }

      if (cv.type!='f' && cv.type!='e' && cv.type!='E') {
        return "";
      }

      String integer="";
      String mantisse="";
      int exponent=0;
      int i;

      // Zahl zerlegen in Integer-Anteil, Mantisse und Exponenten:
//DevNull.println("\n@@@ "+Long.toBinaryString(Double.doubleToLongBits(dval)));
//      res=Double.toString(dval);
res=dblToString(dval,cv.precision); // Includes rounding!!!
//DevNull.println(">>> "+res);
      exponent=res.indexOf(".")-1;
      integer=res.substring(0,exponent+1);
      mantisse=res.substring(exponent+2);
      if (mantisse.indexOf("E")>=0) {
        exponent+=Integer.parseInt(mantisse.substring(mantisse.indexOf("E")+1));
        mantisse=mantisse.substring(0,mantisse.indexOf("E"));
      }

      // "integer" is supposed to hold all digits
      if (integer.charAt(0)=='0' && dval!=0.) {
        exponent--; i=0;
        integer=integer.substring(1);
        while (i<mantisse.length() && mantisse.charAt(i)=='0') {
          exponent--; i++;
        }
        mantisse=mantisse.substring(i);
      }
      integer+=mantisse;
      mantisse="";

      // Separating integer part and mantissa into the desired forms ('f', 'e')
      if (cv.type=='f') {
        if (exponent<0) {
          mantisse=zeros.substring(0,-exponent-1)+integer;
          integer="0";
        } else {
          if (integer.length()<exponent+1) {
            integer+=zeros.substring(0,exponent+1-integer.length());
          }
          mantisse=integer.substring(exponent+1);
          integer=integer.substring(0,exponent+1);
        }
      } else { // Exponential form
        mantisse=integer.substring(1);
        integer=integer.substring(0,1);
      }

      // Precision:
      if (cv.precision>320) { cv.precision=320; }
      // Count of digits after the decimalpoint:
      int len=mantisse.length();
      if (cv.precision>len && (!isG || cv.fHash)) {
        // Add '0's:
        mantisse+=zeros.substring(0,cv.precision-len);
      } else if (cv.precision<len) {
        // Truncate:
        mantisse=mantisse.substring(0,cv.precision);
      }
      if (isG && !cv.fHash) {
        // Truncate leftover zeros at the end of the mantissa:
        i=mantisse.length()-1;
        while (i>=0 && mantisse.charAt(i)=='0') {
          i--;
        }
        mantisse=mantisse.substring(0,i+1);
      }

      res=integer;
      if (cv.fHash || (cv.withPrec && !isG && cv.precision>0) ||
          (isG && cv.withPrec && mantisse.length()>0 )) {
        res+="."+mantisse;
      }

      if (cv.type=='e' || cv.type=='E') {
        if (cv.type=='e') { res+="e"; } else { res+='E'; }
        if (exponent<0) {
          exponent=-exponent; res+="-";
        } else {
          res+="+";
        }
        if (exponent<10) {
          res+="0";
        }
        res+=Integer.toString(exponent);
      }
    }

    String prefix="";
    if (neg) { prefix="-";
    } else if (cv.fPlus) { prefix="+";
    } else if (cv.fSpace) { prefix=" ";
    }

    if (cv.withMin && cv.padChar=='0') {
      int len=prefix.length();
      // Pad left, before a sign or others will be prefixed!
      if (res.length()+len<cv.minimum && !cv.fMinus) {
        res=zeros.substring(0,cv.minimum-res.length()-len)+res;
      }
    }
    res=prefix+res;


    // MinimumFieldWidth:
    if (cv.withMin) {
      if (res.length()<cv.minimum) {
        if (cv.minimum>320) { cv.minimum=320; }
        if (cv.fMinus) {
          res+=empty.substring(0,cv.minimum-res.length());
        } else {
          String padString=empty;
          if (cv.padChar=='0') { padString=zeros; }
          res=padString.substring(0,cv.minimum-res.length())+res;
        }
      }
    }

    return res;
  } // double







  // Private Methods: ////////////////////////////////////////////////////////
  private String intFmt( String conv, long lval, char baseType ) {
    CFmtCvt cv = new CFmtCvt(conv);
    if (cv.type!='d' && cv.type!='i' && cv.type!='o' && cv.type!='p' &&
        cv.type!='u' && cv.type!='x' && cv.type!='X') {
      return "";
    }
    if (baseType=='l' && cv.type=='u') { return ""; }

    boolean neg=false;
    String res="";
    String padString=empty;

    if (cv.type=='d' || cv.type=='i') { // signed decimal
      if (lval<0) { lval=-lval; neg=true; }
      res=String.valueOf(lval);
    } else if (cv.type=='o') { // unsigned octal
      res=Long.toOctalString(lval);
      if (lval<0 && this.hexByteCnt==4 && baseType!='l') {
        // 1 777 777 777 777 777 777 777 -> 37777777777 [         -1]
        // 1 777 777 777 760 000 000 000 -> 20000000000 [-2147483648]
        if (res.charAt(11)=='7') {
          res="3"+res.substring(12);
        } else {
          res="2"+res.substring(12);
        }
      }
    } else if (cv.type=='u') { // unsigned decimal
      if (lval>=0) {
        res=Long.toString(lval);
      } else { // Negative number to be interpreted as positive
        res=Long.toString(256L*256L*256L*256L+lval);
      }
    } else if (cv.type=='x' || cv.type=='p' || cv.type=='X') {
                                                     // unsigned hexadecimal
      // "p" exists ONLY as "%p" without any modifications and then seems to
      // be identical with "%x"!
      res=Long.toHexString(lval);
      if (cv.type=='p' && (cv.withPrec || cv.withMin || cv.fMinus ||
                                    cv.fPlus || cv.fSpace || cv.fHash)) {
        return "";
      }
      if (this.hexByteCnt==4 && baseType!='l') { res=res.substring(8); }
    }

    // Precision:
    // Minimum count of digits (WITHOUT sign!). Add zeros before the number
    // if necessary.
    if (!cv.withPrec) { cv.precision=1; }
    if (cv.precision>320) { cv.precision=320; }
    if (cv.precision>res.length()) {
      res=zeros.substring(0,cv.precision-res.length())+res;
    } else if (cv.precision==0 && lval==0) {
      res="";
    }

    String prefix="";
    if (cv.type=='d' || cv.type=='i') { // negative / positive
      // Flags:
      if (neg) {
        prefix="-";
      } else if (cv.fPlus) {
        prefix="+";
      } else if (cv.fSpace) {
        prefix=" ";
      }
    } else if (cv.type=='o' && cv.fHash && res.charAt(0)!='0') {
      res="0"+res;
    } else if (cv.fHash && lval!=0 && (cv.type=='x' || cv.type=='X')) {
      prefix="0x";
    }


    // MinimumFieldWidth:
    if (cv.minimum>320) { cv.minimum=320; }
    if (cv.withPrec) { cv.padChar=' '; }
    if (cv.padChar=='0' && !cv.fMinus) { padString=zeros; }
    if (cv.withMin) {
      if (cv.padChar=='0') {
        // First pad, then add sign in front:
        int len=prefix.length();
        if (res.length()+len<cv.minimum) {
          res=padString.substring(0,cv.minimum-res.length()-len)+res;
        }
        res=prefix+res;
      } else {
        // First the sign, then pad the string
        res=prefix+res;
        if (res.length()<cv.minimum) {
          if (cv.fMinus) {
            res+=empty.substring(0,cv.minimum-res.length());
          } else {
            res=empty.substring(0,cv.minimum-res.length())+res;
          }
        }
      }
    } else {
      res=prefix+res;
    }

    if (cv.type=='X') { // ALL letters uppercase
      res=res.toUpperCase();
    }

    return res;
  }

  private int hexByteCnt;

  // 340 chars (how much max.?)
  static private final String empty="                                        "+
        "                                                            "+
        "                                                            "+
        "                                                            "+
        "                                                            "+
        "                                                            ";
  static private final String zeros="0000000000000000000000000000000000000000"+
        "000000000000000000000000000000000000000000000000000000000000"+
        "000000000000000000000000000000000000000000000000000000000000"+
        "000000000000000000000000000000000000000000000000000000000000"+
        "000000000000000000000000000000000000000000000000000000000000"+
        "000000000000000000000000000000000000000000000000000000000000";

  private BigDecimal const2_52=new BigDecimal("2251799813685248");
  private BigDecimal const2=new BigDecimal("2");

  private String dblToString(double d, int prec) {
    long exp, i, lMant;
    boolean nexp=false;

// Fuer positive Zahlen gilt:
// 2^(Exponent+1) + 2^Exponent * Mantisse / 2^51
//
// mit Exponent    = double_bitmap & 0x3ff0000000000000,
// Exp. Vorzeichen = double_bitmap & 0x4000000000000000
// und Mantisse    = double_bitmap & 0x000fffffffffffff
//

    lMant=Double.doubleToLongBits(d)&0x000fffffffffffffL;
    exp =(Double.doubleToLongBits(d)&0x3ff0000000000000L) >> 52;
    nexp=(Double.doubleToLongBits(d)&0x4000000000000000L) == 0L;
    if (nexp) { exp=-1024+exp; }

    BigDecimal mant=new BigDecimal(Long.toString(lMant));
    BigDecimal res=new BigDecimal("0");

    BigDecimal res1;
    if (exp==0 && lMant==0L) {
      res1=new BigDecimal("0");
    } else {
      res1=new BigDecimal("1");
      if (exp>0) {
        for(i=0; i<exp; i++) {
          res1=res1.multiply(const2);
        }
      } else {
        for(i=0; i>exp; i--) {
          res1=res1.divide(const2,50,BigDecimal.ROUND_HALF_UP);
        }
      }
    }

    res=res1.multiply(const2);
    res=res.add(res1.multiply(mant.divide(const2_52,50,BigDecimal.ROUND_HALF_UP)));
    res=res.add((new BigDecimal("5")).movePointLeft(prec+1));

    return res.toString();
  }

} // End of class CFmt




class CFmtCvt { // Interprets a formatting string
  char flag='\0';
  boolean fMinus=false;
  boolean fPlus=false;
  boolean fSpace=false;
  boolean fHash=false;
  char padChar=' ';
  int minimum=0;
  int precision=0;
  boolean longSpec=false; // longSpec does not have any meaning???
  char type='\0';

  boolean withMin=false;
  boolean withPrec=false;
  boolean validConv=false;

  CFmtCvt(String cv) {
    char ch;
    int len=cv.length()-1;

    if (len>=1 && cv.charAt(0)=='%') {
      int i=1;

      type=cv.charAt(len); len--;
      if (cv.charAt(len)=='l') { longSpec=true; len--; }

      // Flags:
      do {
        ch=cv.charAt(i);
        if (ch=='-')      { fMinus=true; }
        else if (ch=='+') { fPlus=true;  }
        else if (ch==' ') { fSpace=true; }
        else if (ch=='#') { fHash=true;  }
        i++;
      } while (i<=len && (ch=='-' || ch=='+' || ch==' ' || ch=='#'));
      i--;

      // Minimum fieldwidth:
      ch=cv.charAt(i);
      if (ch=='0') {
        withMin=true;
        padChar='0';
        withMin=true;
        i++; if (i>len) { return; }
        ch=cv.charAt(i);
      }
      if (Character.isDigit(ch)) {
        withMin=true;
        minimum=Character.digit(ch,10);
        i++; if (i>len) { return; }
        ch=cv.charAt(i);
        while (Character.isDigit(ch)) {
          minimum=10*minimum+Character.digit(ch,10);
          i++; if (i>len) { return; }
          ch=cv.charAt(i);
        }
      }

      // Precision:
      if (ch=='.') {
        withPrec=true;
        i++; if (i>len) { return; }
        ch=cv.charAt(i);
        while (Character.isDigit(ch)) {
          precision=10*precision+Character.digit(ch,10);
          i++; ch=cv.charAt(i);
        }
      }
    }
  }
} // End of class CFmtCvt



class DblObj {
  
  public double val;

// //#ifdef TRACE0
//   public DblObj() {
//     DevNull.println(System.currentTimeMillis()+" DblObj()");
//   }
// //#endif /* TRACE0 */

}


class DevNull {

  public static void print(String s) {}

  public static void println(String s) {}

  public static void println() {}

}

class Epsilon {
  /* obliquity of ecliptic */
  double teps, eps, seps, ceps;         /* jd, eps, sin(eps), cos(eps) */

  void clearData() {
    teps=0.0;
    eps=0.0;
    seps=0.0;
    ceps=0.0;
  }


}
/*
   This is an extension to the Java port of the Swiss Ephemeris package
   of Astrodienst AG, Zuerich (Switzerland).

   Thomas Mack, mack@ifis.cs.tu-bs.de, 3rd of December, 2001

*/




class Extensions {

  SwissEph sw;

  Extensions(SwissEph sw) {
    this.sw = sw;
  }




  // transitVal is the longitude or latitude or speed, for which the
  // transit is to be calculated.
  // getTransit() will return the current date and time, when the
  // transit ist occuring on that date. If you really want the next
  // transit AFTER that date, add at least calcTimePrecision(...) to
  // your jdET, as this is the minimum time difference, for which the
  // available precision allows.
  // You can NOT rely on the assumption that you will get realistically
  // differentiable transit values with a time difference of
  // calcTimePrecision(...), but at least it does not make ANY sense
  // to recalculate a transit with a time difference SMALLER than the
  // value returned by calcTimePrecision().
  //
  // A problem:
  // When a transit takes a long time, this means, when the planet
  // stays a long time very near to the transit point, the program
  // may appear to be abitrary in its results. The reason is, that
  // it does not look for the EXACT transit point, but for an area
  // around the exact transit point that is defined by the maximum
  // available precision for the position calculation.

  // You may get many transits for just one planetary transit, as we
  // cannot differentiate transits, when they are in an area of values
  // which is beyond the maximum available precision. E.g., when the
  // sun is in the latitudinal area of 0.0019 to 0.0021 for maybe two
  // days, there is no chance to differentiate between any dates in
  // this area of time: You will get the input date returned as the
  // transit date always, when the input date is in the area of these
  // two days.
  double getTransit(TransitCalculator tc, double jdET, boolean back,
                    double jdMax)
         throws IllegalArgumentException, SwissephException {
//System.err.println(" -- " + (""+jdET).substring(0,Math.min((""+jdET).length(),12)) + " - " + jdMax);
    double max = tc.getMaxSpeed();
    double min = tc.getMinSpeed();

    double jdPlus, jdMinus;
    double lastJD = jdET;

    boolean found = false;
    boolean above;
    double lastVal;
    double val;
    double offset = tc.getOffset();



    boolean xneg = (max < 0);
    boolean mneg = (min < 0);
    if (!xneg && !mneg) { min = max; }
    if (xneg && mneg) { max = min; }

    double degPrec = tc.getDegreePrecision(jdET)/2.; // Divided by two to have a range of +-degPrec
    double timePrec = tc.getTimePrecision(degPrec);


    val = tc.calc(jdET);
    if (offset-val == 0.) { // If not 0.0 but "very small", then
                            // interpolate after another calculation
                            // in the calculation loop below
      return jdET;
    }


    if (max == 0. && min == 0.) { // No possible change in position or speed
      throw new SwissephException(jdET, SwissephException.OUT_OF_TIME_RANGE,
          "No transit possible due to lack of variation of speed or position.");
    }

    while (true) {
      if (tc.rollover) {
        while (val >= tc.rolloverVal) { val -= tc.rolloverVal; }
        while (val < 0.) { val += tc.rolloverVal; }
      }
      above = (val >= offset);

      lastJD = jdET;
      lastVal = val;

      //while (tc.rollover && val<offset) { val += tc.rolloverVal; }
      if (tc.rollover && !above) { val += tc.rolloverVal; }

      // Find next reasonable point to probe.
      if (tc.rollover) {
        // In most cases here we cannot find out for sure if the distance
        // is decreasing or increasing. We take the smaller one of these:
        jdPlus  = Math.min(val-offset,360-val+offset)/Math.abs(max);
        jdMinus = Math.min(val-offset,360-val+offset)/Math.abs(min);
        if (back) {
          jdET -= Math.min(jdPlus,jdMinus);
        } else {
          jdET += Math.min(jdPlus,jdMinus);
        }
      } else { // Latitude, distance and speed calculations...
        //jdPlus = (back?(val-offset):(offset-val))/max;
        //jdMinus = (back?(val-offset):(offset-val))/min;
        jdPlus = (offset-val)/max;
        jdMinus = (offset-val)/min;
        if (back) {
          if (jdPlus >= 0 && jdMinus >= 0) {
            throw new SwissephException(jdET, SwissephException.OUT_OF_TIME_RANGE,
                -1, "No transit in ephemeris time range."); // I mean: No transits possible...
          } else if (jdPlus >= 0) {
            jdET += jdMinus;
          } else { // if (jdMinus >= 0)
            jdET += jdPlus;
          }
        } else {
          if (jdPlus <= 0 && jdMinus <= 0) {
            throw new SwissephException(jdET, SwissephException.OUT_OF_TIME_RANGE,
                -1, "No transit in ephemeris time range."); // I mean: No transits possible...
          } else if (jdPlus <= 0) {
            jdET += jdMinus;
          } else { // if (jdMinus <= 0)
            jdET += jdPlus;
          }
        }
      }


      // Add at least "timePrec" time to the last time:
      if (Math.abs(jdET - lastJD) < timePrec) {
        jdET = lastJD + (back?-timePrec:+timePrec);
      }
      if (jdET == lastJD) {
//System.err.println(" =t " + (""+val).substring(0,Math.min((""+val).length(),12)) + " " + jdET);
        return jdET;
      }
      val = tc.calc(jdET);
      if (tc.rollover && val >= tc.rolloverVal) { val %= tc.rolloverVal; }
      while (tc.rollover && val < 0.) { val += tc.rolloverVal; }

      // Hits the transiting point exactly...:
      if (offset-val == 0.) {
//System.err.println(" =v " + (""+val).substring(0,Math.min((""+val).length(),12)) + " " + jdET);
        return jdET;
      }

      // The planet may have moved forward or backward, in one of these
      // directions it would have crossed the transit point.
      //
      // Whatever distance could have been reached in lesser time (forward or
      // backward move), we take it to be the direction of movement.
      boolean pxway = true;
      if (tc.rollover) {
        double deltadeg1 = val-lastVal;
        if (deltadeg1<0) { deltadeg1+=tc.rolloverVal; }
        double deltadeg2 = lastVal-val;
        if (deltadeg2<0) { deltadeg2+=tc.rolloverVal; }
        pxway = Math.abs(deltadeg1/max)<Math.abs(deltadeg2/min);
      } else {
        pxway = lastVal<=val;
      }

      found = (// transits from higher deg. to lower deg.:
               ( above && val<=offset && !pxway) ||
               // transits from lower deg. to higher deg.:
               (!above && val>=offset &&  pxway)) ||
              (tc.rollover && (
               // transits from above the transit degree via rollover over
               // 0 degrees to a higher degree:
               (offset<lastVal && val>340. && lastVal<20. && !pxway) ||
               // transits from below the transit degree via rollover over
               // 360 degrees to a lower degree:
               (offset>lastVal && val<20. && lastVal>340. &&  pxway) ||
               // transits from below the transit degree via rollover over
               // 0 degrees to a higher degree:
               (offset>val && val>340. && lastVal<20. && !pxway) ||
               // transits from above the transit degree via rollover over
               // 360 degrees to a lower degree:
               (offset<val && val<20. && lastVal>340. &&  pxway))
              );

      if (found) { // Return an interpolated value, but not prior to (after)
                   // the initial time (if backward):
//System.err.println(" :: (" + above + " && " + val + "<=" + offset + " && !" + pxway + ") || " );
        if (tc.rollover) {
          if (tc.rollover && Math.abs(val - lastVal) > 300.) {   // How to do it formally correct???
            // Probably one value is about 359.99 and the other one is in the area of 0.01
            if (val > lastVal) { lastVal += tc.rolloverVal; } else { val += tc.rolloverVal; }
            if (offset < 10.) { offset += tc.rolloverVal; } // How to do it formally correct???
          }
          // offset-lastVal and val-lastVal have to have equal signs
          if (val-lastVal < 0 && offset-lastVal > 0) {
            val += tc.rolloverVal;
          } else if (val-lastVal > 0 && offset-lastVal < 0) {
            offset += tc.rolloverVal;
          }
        }
        double jdRet = lastJD+(jdET-lastJD)*(offset-lastVal)/(val-lastVal);
//System.err.println(" fd " + ("  "+val).substring(1).substring(0,12) + " " + Math.min(jdRet,jdET));
        if (back) {
          return Math.max(jdRet, jdET);
        } else {
          return Math.min(jdRet, jdET);
        }
      }
      if ((back && jdET < jdMax) ||
          (!back && jdET > jdMax)) {
//System.err.println(" ex " + ("  "+val).substring(1).substring(0,12) + " " + jdET);
        throw new SwissephException(jdET, SwissephException.BEYOND_USER_TIME_LIMIT,
            -1, "User time limit of " + jdMax + " has been reached.");
      }
    }
  }




  // The precision of a distance calculation is related to the barycentric
  // distance
  // E.g.: java Swetest -b1.1.0 -p0 -n100000 -fR -bary | sort -n
  protected double maxBaryDist[] = new double[] {
     0.009570999,    // 0 Sun        ==  0                   1.017545559
     1.028809521,    // 1 Moon       ==  1
     0.466604085,    // 2 Mercury    ==  2
     0.728698831,    // 3 Venus      ==  3
     0.728698831,    // 4 Mars       ==  4
     4.955912195,    // 5 Jupiter    ==  5
     8.968685733,    // 6 Saturn     ==  6
    19.893326756,    // 7 Uranus     ==  7
    30.326750627,    // 8 Neptune    ==  8
    41.499626899,    // 9 Pluto      ==  9
     0.002569555,    // m MeanNode   == 10
     0.002774851,    // t TrueNode   == 11
     1.0,            // A Mean Apog. == 12            // Does not vary distance anyway
     0.002782378,    // B Oscu.Apog. == 13
     0.0,            // C Earth      == 14 (skip)
     0.05,           // D Chiron     == 15            // No distance available, is 0.05 good???
    31.901319663,    // E Pholus     == 16
     3.012409508,    // F Ceres      == 17
     3.721614106,    // G Pallas     == 18
     3.326307148,    // H Juno       == 19
     2.570197288,    // I Vesta      == 20
  };



}
/*
   This is an extension to the Java port of the Swiss Ephemeris package
   of Astrodienst AG, Zuerich (Switzerland).

   Thomas Mack, mack@ifis.cs.tu-bs.de, 25th of November, 2004

*/

class FileData {
  final byte SEI_FILE_NMAXPLAN=50;

  String fnam;          /* ephemeris file name */
  int fversion;         /* version number of file */
  String astnam;        /* asteroid name, if asteroid file */
  int sweph_denum;     /* DE number of JPL ephemeris, which this file
                         * is derived from. */
  FilePtr fptr;/* ephemeris file pointer */
  double tfstart;       /* file may be used from this date */
  double tfend;         /*      through this date          */
  int iflg;             /* byte reorder flag and little/bigendian flag */
  short npl;            /* how many planets in file */
  int ipl[] = new int[SEI_FILE_NMAXPLAN]; /* planet numbers */

  void clearData() {
    int j;
    fnam="";
    fversion=0;
    astnam="";
    sweph_denum=0;
    try {
      if (fptr!=null) { fptr.close(); }
    } catch (java.io.IOException e) {
// NBT
    }
    fptr=null;
    tfstart=0.0;
    tfend=0.0;
    iflg=0;
    npl=0;
    for(j=0; j<SEI_FILE_NMAXPLAN; j++) { ipl[j]=0; }
  }

// Attention: read_const() has to be called from "swed.fidat[ifno]", where
// "ifno" has to be the first parameter in read_const:
//  struct FileData *fdp = &swed.fidat[ifno];
//
  /* SWISSEPH
   * reads constants on ephemeris file
   * ifno         file #
   * serr         error string
   */
  int read_const(int ifno, StringBuffer serr, SwissData swed) {
    String s="";
    String s2="";
    String sastnam="";
    int i, ipli, kpl;
    int fendian, freord;
    int lastnam = 19;
//Renamed in JAVA to fptr:// FilePtr fp;
    long lng;
    long ulng; // hat 'unsigned' long hier eine wesentliche Bedeutung?
    long flen, fpos;
    short nplan;
    PlanData pdp;
//Skipped in JAVA:// FileData fdp = swed.fidat[ifno];
    String serr_file_damage = "Ephemeris file "+fnam+" is damaged. ";
//Skipped in JAVA:// int errmsglen = serr_file_damage.length();
    int nbytes_ipl = 2;

    try {
      
      byte b=0;
      char cLast;
      do {
        cLast=(char)b;
        b=fptr.readByte();
        s+=(char)b;
      } while (cLast!='\r' && (char)(b)!='\n' && s.length()<SwissData.AS_MAXCH);

      s=s.trim();
      int offs=0;
      int ver=-1;
      while (!Character.isDigit(s.charAt(offs))) { offs++; }
      try {
        ver=Integer.parseInt(s.substring(offs));
      } catch (NumberFormatException n) {
        DevNull.println(serr_file_damage+" (1)");
        fptr.close();
        throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
            SweConst.ERR, serr);
      }
// Use SwissLib.atoi(...) ?
      fversion=ver;

      
      b=0; s="";
      do {
        cLast=(char)b;
        b=fptr.readByte();
        s+=(char)b;
      } while (cLast!='\r' && (char)(b)!='\n' && s.length()<SwissData.AS_MAXCH);

      s2=fnam.substring(fnam.lastIndexOf(swed.DIR_GLUE)+1).toLowerCase();
      s=s.trim().toLowerCase();
      if (!s.equals(s2)) {
        // Http addresses will end with '/' independent of DIR_GLUE...
        s2=fnam.substring(fnam.lastIndexOf("/")+1).toLowerCase();
        if (!s.equals(s2)) {
          s2=fnam.substring(fnam.lastIndexOf(swed.DIR_GLUE)+1).toLowerCase();
          //DevNull.println("Ephemeris file name '"+s2+"' is wrong; rename to '"+s+"'");
          fptr.close();
          throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
              SweConst.ERR, serr);
        }
      }
      
      b=0; s="";
      do {
        cLast=(char)b;
        b=fptr.readByte();
        s+=(char)b;
      } while (cLast!='\r' && (char)(b)!='\n' && s.length()<SwissData.AS_MAXCH);

      
      // Read up to end of line or AS_MAXCH*2 into var. 's':
      if (ifno == SwephData.SEI_FILE_ANY_AST) {
        b=0; s="";
        do {
          cLast=(char)b;
          b=fptr.readByte();
          s+=(char)b;
        } while (cLast!='\r' && (char)(b)!='\n' && s.length()<SwissData.AS_MAXCH*2);
        /* MPC number and name; will be analyzed below:
         * search "asteroid name" */
        String sp = s;
        // Strip leading white space from 'sp':
        while(Character.isWhitespace(sp.charAt(0))) {
          sp = sp.substring(1);
        }
        // Remove leading numbers from 'sp':
        while(Character.isDigit(sp.charAt(0))) {
          sp = sp.substring(1);
        }
        // Skip next character as well:
        sp = sp.substring(1);
        i = s.length() - sp.length();
        sastnam = sp.substring(0,lastnam+i);
        /* save elements, they are required for swe_plan_pheno() */
        swed.astelem = s;
        /* required for magnitude */
        swed.ast_H = SwissLib.atof(s.substring(35 + i));
        swed.ast_G = SwissLib.atof(s.substring(42 + i));
        if (swed.ast_G == 0) swed.ast_G = 0.15;
        /* diameter in kilometers, not always given: */
        s2 = s.substring(51 + i, 58 + i);
        swed.ast_diam = SwissLib.atof(s2);
        if (swed.ast_diam == 0) {
          /* estimate the diameter from magnitude; assume albedo = 0.15 */
          swed.ast_diam = 1329/Math.sqrt(0.15) * Math.pow(10, -0.2 * swed.ast_H);
        }
      }
      
      int testendian = fptr.readInt();
      /* is byte order correct?            */
lng = 0;
      if (testendian == SwephData.SEI_FILE_TEST_ENDIAN) {
        freord = SwephData.SEI_FILE_NOREORD;
      } else {
        freord = SwephData.SEI_FILE_REORD;
        lng = ((testendian & 0x000000ff) << 24) +
              ((testendian & 0x0000ff00) << 8 ) +
              ((testendian & 0x00ff0000) >> 8 ) +
              ((testendian & 0xff000000) >> 24);
        if (lng != SwephData.SEI_FILE_TEST_ENDIAN) {
          throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
              SweConst.ERR, "File is damaged: byte ordering info not correct.");
        }
      }
      /* is file bigendian or littlendian?
       * test first byte of test integer, which is highest if bigendian */
      if (SwephData.SEI_FILE_TEST_ENDIAN / 16777216 ==
          (testendian & 0x000000ff)) {
        fendian = SwephData.SEI_FILE_BIGENDIAN;
      } else {
        fendian = SwephData.SEI_FILE_LITENDIAN;
      }
      iflg = freord | fendian;
      
      lng=(long)read4(fptr, SwephData.SEI_CURR_FPOS, false, freord, fendian);
      if (lng < 0) { lng &= 0xffffffff; }
      fpos=fptr.getFilePointer();
      flen=fptr.length();
      if (lng!=flen) {
        DevNull.println(serr_file_damage+" (2)");
        fptr.close();
        throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
            SweConst.ERR, serr);
      }
//      fptr.seek(flen-1);
      fptr.seek(fpos);
      
      sweph_denum = read4(fptr, fpos, false, freord, fendian);
      swed.jpldenum = sweph_denum;
      
      tfstart=read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      tfend=read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      
      nplan=read2(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      if (nplan > 256) {
        nbytes_ipl = 4;
        nplan %= 256;
      }
      if (nplan < 1 || nplan > 20) {
        DevNull.println(serr_file_damage+" (3)");
        fptr.close();
        throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
            SweConst.ERR, serr);
      }
      npl = nplan;
      /* which ones?                       */
//do_fread((void *) fdp->ipl, nbytes_ipl, (int) nplan, sizeof(int), fp,...
//          target            how many      count      how many
//                          bytes to read           bytes to write
// nbytes_ipl can be 2 and 4 only...
      if (nbytes_ipl == 2) {
        for(i=0; i<nplan; i++) {
          ipl[i]=(int)(read2(fptr, SwephData.SEI_CURR_FPOS, freord, fendian));
        }
      } else if (nbytes_ipl == 4) {
        for(i=0; i<nplan; i++) {
          ipl[i]=read4(fptr, SwephData.SEI_CURR_FPOS, false, freord, fendian);
        }
      } else { // Can't be???
        DevNull.println(serr_file_damage+" (3b)");
      }
      
      if (ifno == SwephData.SEI_FILE_ANY_AST) {
        String sastno;
        int j;
        /* name of asteroid is taken from orbital elements record
         * read above */
        j = 4;      /* old astorb.dat had only 4 characters for MPC# */
        while (sastnam.charAt(j) != ' ' && j < 10) {  /* new astorb.dat has 5 */
          j++;
        }
        sastno=sastnam.substring(0,Math.min(sastnam.length(),j)).trim();
        i = Integer.parseInt(sastno);
        if (i == ipl[0] - SweConst.SE_AST_OFFSET) {
          /* element record is from bowell database */
          astnam=sastnam.substring(Math.min(sastnam.length(),j+1),
                                   Math.min(sastnam.length(),j+1+lastnam));
          /* overread old ast. name field */
          s="";
          for(i=0; i<30; i++) {
            s+=(char)fptr.readByte();
          }
        } else {
          /* older elements record structure: the name
           * is taken from old name field */
          astnam="";
          for(i=0; i<30; i++) {
            astnam+=(char)fptr.readByte();
          }
        }
        astnam=astnam.trim();
      }
      
      fpos = fptr.getFilePointer();
      /* read CRC from file */
      ulng=(long)(read4(fptr, SwephData.SEI_CURR_FPOS, false, freord, fendian));
      /* read check area from file */
      fptr.seek(0L);
      /* must check that defined length of s is less than fpos */
      if (fpos - 1 > 2 * SwissData.AS_MAXCH) {
        DevNull.println(serr_file_damage+" (4)");
        fptr.close();
        throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
            SweConst.ERR, serr);
      }
      b=0; s="";
byte[] ba=new byte[2*SwissData.AS_MAXCH];
      for(i=0;i<fpos;i++) {
        cLast=(char)b;
        b=fptr.readByte();
//DevNull.println(b);
        ba[i]=b;
        s+=(char)b;
      }
  if ((int)swi_crc32(/*(unsigned char *)*/ ba, (int) fpos) != (int)ulng) {
    System.err.println(serr_file_damage+" (5)");
    fptr.close();
    throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
        SweConst.ERR, serr);
  }
      fptr.seek(fpos+4L);
      
      /* clight, aunit, helgravconst, ratme, sunradius
       * these constants are currently not in use */
      swed.gcdat.clight       = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      swed.gcdat.aunit        = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      swed.gcdat.helgravconst = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      swed.gcdat.ratme        = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      swed.gcdat.sunradius    = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      
      for (kpl = 0; kpl < npl; kpl++) {
        /* get SEI_ planet number */
        ipli = ipl[kpl];
        if (ipli >= SweConst.SE_AST_OFFSET) {
          pdp = swed.pldat[SwephData.SEI_ANYBODY];
        } else {
          pdp = swed.pldat[ipli];
        }
        pdp.ibdy = ipli;
        /* file position of planet's index */
        pdp.lndx0=(long)(read4(fptr, SwephData.SEI_CURR_FPOS, false, freord, fendian))&0xffffffffL;
        /* flags: helio/geocentric, rotation, reference ellipse */
        pdp.iflg=fptr.readUnsignedByte();
        /* number of chebyshew coefficients / segment  */
        /* = interpolation order +1                    */
        pdp.ncoe=fptr.readUnsignedByte();
        /* rmax = normalisation factor */
        lng=read4(fptr, SwephData.SEI_CURR_FPOS, false, freord, fendian);
        pdp.rmax = (double)lng / 1000.0;
        /* start and end epoch of planetary ephemeris,   */
        /* segment length, and orbital elements          */
        pdp.tfstart  = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.tfend    = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.dseg     = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.nndx     = (int) ((pdp.tfend - pdp.tfstart + 0.1) /pdp.dseg);
        pdp.telem    = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.prot     = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.dprot    = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.qrot     = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.dqrot    = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.peri     = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.dperi    = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        /* alloc space for chebyshew coefficients */
        /* if reference ellipse is used, read its coefficients */
        if ((pdp.iflg & SwephData.SEI_FLG_ELLIPSE)!=0) {
          if (pdp.refep != null) { /* if switch to other eph. file */
            pdp.refep = null;
            if (pdp.segp != null) {
              pdp.segp = null; /* array of coefficients of ephemeris segment */
            }
          }
          pdp.refep = new double[2*pdp.ncoe];
          for(i=0;i<2*pdp.ncoe;i++) {
            pdp.refep[i]=read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
          }
        }
      }
    } catch (java.io.IOException e) {
      try {
        fptr.close();
      } catch (java.io.IOException e2) {
      }
      DevNull.println(serr_file_damage+" (6)");
      DevNull.println(e.getMessage());
      throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
          SweConst.ERR, serr);
    }
    return SweConst.OK;
  }


  /*
   * The following C code (by Rob Warnock rpw3@sgi.com) does CRC-32 in
   * BigEndian/BigEndian byte/bit order. That is, the data is sent most
   * significant byte first, and each of the bits within a byte is sent most
   * significant bit first, as in FDDI. You will need to twiddle with it to do
   * Ethernet CRC, i.e., BigEndian/LittleEndian byte/bit order.
   *
   * The CRCs this code generates agree with the vendor-supplied Verilog models
   * of several of the popular FDDI "MAC" chips.
   */
  /* unsigned long [...] */
  static long crc32_table[]=null;
  /* Initialized first time "crc32()" is called. If you prefer, you can
   * statically initialize it at compile time. [Another exercise.]
   */

  long swi_crc32(/*unsigned???*/ byte[] buf, int len) {
    int pn;
    /*unsigned*/ long crc;
    if (crc32_table==null) {  /* if not already done, */
      init_crc32();   /* build table */
    }
    crc = 0xffffffffL;       /* preload shift register, per CRC-32 spec */
    for (pn = 0; len > 0; ++pn, --len) {
      crc = ((crc << 8)&0xffffffffL) ^ crc32_table[(int)((crc >> 24) ^ ((long)buf[pn]&0xff))];
    }
    return ~crc;            /* transmit complement, per CRC-32 spec */
  }

  /*
   * Build auxiliary table for parallel byte-at-a-time CRC-32.
   */
  static final int CRC32_POLY=0x04c11db7;    /* AUTODIN II, Ethernet, & FDDI */

  void init_crc32() {
    long i, j;
    long c;
    crc32_table = new long[256];
    for (i = 0; i < 256; ++i) {
      for (c = i << 24, j = 8; j > 0; --j) {
        c = (c & 0x80000000L)!=0 ? (c << 1) ^ CRC32_POLY : (c << 1);
      }
      c=c & 0xffffffffL;
      crc32_table[(int)i] = c;
    }
  }


  short read2(FilePtr fp, long fpos, int freord, int fendian)
      throws java.io.IOException {
    if (fpos >= 0) {
      fp.seek(fpos);
    }
    short val=(short)fp.readShort();

    if (freord != 0) {
      val = (short)(( val << 8 ) +
            ( val >>> 8 ));
    }
    return val;
  }

  int read3(FilePtr fp, long fpos, int freord, int fendian)
      throws java.io.IOException {
    if (fpos >= 0) {
      fp.seek(fpos);
    }
    int val=(int)fp.readUnsignedByte();
    int i2=(int)fp.readShort(); if(i2<0){i2&=0xffff;}
    val=(val<<16)+i2;

    if (freord != 0) {
      val = (( val & 0x000000ff ) << 24) +
            (( val & 0x0000ff00 ) <<  8) +
            (( val & 0x00ff0000 ) >>  8) +
            (( val & 0xff000000 ) >> 24);

      boolean do_shift = ((fendian == SwephData.SEI_FILE_BIGENDIAN && freord != 0) ||
                          (fendian == SwephData.SEI_FILE_LITENDIAN && freord == 0));

      return (do_shift?val>>8:val);
    }
    return val;
  }

  int read4(FilePtr fp, long fpos, boolean unsigned, int freord, int fendian)
      throws java.io.IOException {
    if (fpos >= 0) {
      fp.seek(fpos);
    }
    int val=(int)fp.readInt();

    if (freord != 0) {
      if (unsigned) {
        val = (( val & 0x000000ff ) << 24) +
              (( val & 0x0000ff00 ) <<  8) +
              (( val & 0x00ff0000 ) >>  8) +
              (( val & 0xff000000 ) >> 24);
      } else {
        val = (( val & 0x000000ff ) << 24) +
              (( val & 0x0000ff00 ) <<  8) +
              (( val & 0x00ff0000 ) >>  8) +
              (( val & 0xff000000 ) >>> 24);
      }
    } else {
      if (unsigned && val<0) { val&=0x7fffffff; }
    }

    return val;
  }

  double read8(FilePtr fp, long fpos, int freord, int fendian)
      throws java.io.IOException {
    if (fpos >= 0) {
      fp.seek(fpos);
    }

    long val=Double.doubleToLongBits(fp.readDouble());

    if (freord != 0) {
      val = (( val & 0x00000000000000ffL ) << 56) +
            (( val & 0x000000000000ff00L ) << 40) +
            (( val & 0x0000000000ff0000L ) << 24) +
            (( val & 0x00000000ff000000L ) <<  8) +
            (( val & 0x000000ff00000000L ) >>  8) +
            (( val & 0x0000ff0000000000L ) >> 24) +
            (( val & 0x00ff000000000000L ) >> 40) +
            (( val & 0xff00000000000000L ) >> 56);
    }

    return Double.longBitsToDouble(val);
  }

  /* fetch chebyshew coefficients from sweph file for
   * tjd          time
   * ipli         planet number
   * ifno         file number
   * serr         error string
   */
  int get_new_segment(SwissData swed, double tjd, int ipli, int ifno,
                      StringBuffer serr) {
    int i, j, k, m, n, o, icoord;
    int iseg;
    int fpos;
    int nsizes, nsize[]=new int[6];
    int nco;
    int idbl;
    /* unsigned */ short c[]=new short[4]; // unsigned (byte) ist wichtig?
    PlanData pdp = swed.pldat[ipli];
    FileData fdp = swed.fidat[ifno];
    int freord  = (int) (fdp.iflg & SwephData.SEI_FILE_REORD);
    int fendian = (int) (fdp.iflg & SwephData.SEI_FILE_LITENDIAN);
    /* unsigned long */ long longs[]=new long[SwephData.MAXORD+1]; // unsigned ist wichtig?
    /* compute segment number */


    iseg = (int) ((tjd - pdp.tfstart) / pdp.dseg);
    /*if (tjd - pdp->tfstart < 0)
        return(NOT_AVAILABLE);*/
    pdp.tseg0 = pdp.tfstart + iseg * pdp.dseg;
    pdp.tseg1 = pdp.tseg0 + pdp.dseg;
    /* get file position of coefficients from file */
    fpos = (int)pdp.lndx0 + iseg * 3;
    try {
      fpos = read3(fptr, fpos, freord, fendian);
      fptr.seek(fpos);
      /* clear space of chebyshew coefficients */
      if (pdp.segp == null) {
        pdp.segp = new double[pdp.ncoe*3];
      }
      for(i=0;i<pdp.segp.length;i++) { pdp.segp[i]=0.; }
      /* read coefficients for 3 coordinates */
      for (icoord = 0; icoord < 3; icoord++) {
        idbl = icoord * pdp.ncoe;
        /* first read header */
        /* first bit indicates number of sizes of packed coefficients */
        c[0]=(short)fptr.readUnsignedByte();
        c[1]=(short)fptr.readUnsignedByte();
        if ((c[0] & 128)!=0) {
          nsizes = 6;
          c[2]=(short)fptr.readUnsignedByte();
          c[3]=(short)fptr.readUnsignedByte();
          nsize[0] = (int) c[1] / 16;
          nsize[1] = (int) c[1] % 16;
          nsize[2] = (int) c[2] / 16;
          nsize[3] = (int) c[2] % 16;
          nsize[4] = (int) c[3] / 16;
          nsize[5] = (int) c[3] % 16;
          nco = nsize[0] + nsize[1] + nsize[2] + nsize[3] + nsize[4] + nsize[5];
        } else {
          nsizes = 4;
          nsize[0] = (int) c[0] / 16;
          nsize[1] = (int) c[0] % 16;
          nsize[2] = (int) c[1] / 16;
          nsize[3] = (int) c[1] % 16;
          nco = nsize[0] + nsize[1] + nsize[2] + nsize[3];
        }
        /* there may not be more coefficients than interpolation
         * order + 1 */
        if (nco > pdp.ncoe) {
          if (serr != null) {
            serr.append("error in ephemeris file "+fdp.fnam+": "+nco+
                        " coefficients instead of "+pdp.ncoe+". ");
          }
          throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
              SweConst.ERR, serr);
        }
        /* now unpack */
int kCnt;
        for (i = 0; i < nsizes; i++) {
          if (nsize[i] == 0) {
            continue;
          }
          if (i < 4) {
            j = (4 - i);
            k = nsize[i];
            for(kCnt=0; kCnt<k; kCnt++) {
              switch(j) {
                case 1: longs[kCnt]=(int)fptr.readUnsignedByte();
                        break;
                case 2: longs[kCnt]=(int)read2(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
                        if(longs[kCnt]<0){longs[kCnt]&=0xffff;}
                        break;
                case 3: longs[kCnt]=read3(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
                        if(longs[kCnt]<0){longs[kCnt]&=0xffffff;}
                        break;
                case 4: longs[kCnt]=read4(fptr, SwephData.SEI_CURR_FPOS, false, freord, fendian);
                        if(longs[kCnt]<0){longs[kCnt]&=0xffffffff;}
                        break;
              }
            }
            for (m = 0; m < k; m++, idbl++) {
              if ((longs[m] & 1)!=0) {   /* will be negative */
                pdp.segp[idbl] = -((((longs[m]+1) / 2)&0x7fffffffL) / 1e+9 * pdp.rmax / 2);
              } else {
                pdp.segp[idbl] = ((longs[m] / 2)&0x7fffffffL) / 1e+9 * pdp.rmax / 2;
              }
            }
          } else if (i == 4) {              /* half byte packing */
            j = 1;
            k = (nsize[i] + 1) / 2;
            for(kCnt=0; kCnt<k; kCnt++) {
              longs[kCnt]=(int)fptr.readUnsignedByte();
            }
            for (m = 0, j = 0;
                 m < k && j < nsize[i];
                 m++) {
              for (n = 0, o = 16;
                   n < 2 && j < nsize[i];
                   n++, j++, idbl++, longs[m] %= o, o /= 16) {
                if ((longs[m] & o)!=0) {
                  pdp.segp[idbl] = -(((longs[m]+o) / o / 2) * pdp.rmax /
                                                                    2 / 1e+9);
                } else {
                  pdp.segp[idbl] = (longs[m] / o / 2) * pdp.rmax / 2 / 1e+9;
                }
              }
            }
          } else if (i == 5) {              /* quarter byte packing */
            j = 1;
            k = (nsize[i] + 3) / 4;
            for(kCnt=0; kCnt<k; kCnt++) {
              longs[kCnt]=(int)fptr.readUnsignedByte();
            }
            for (m = 0, j = 0;
                 m < k && j < nsize[i];
                 m++) {
              for (n = 0, o = 64;
                   n < 4 && j < nsize[i];
                   n++, j++, idbl++, longs[m] %= o, o /= 4) {
                if ((longs[m] & o)!=0) {
                  pdp.segp[idbl] = -(((longs[m]+o) / o / 2) * pdp.rmax /
                                                                    2 / 1e+9);
                } else {
                  pdp.segp[idbl] = (longs[m] / o / 2) * pdp.rmax / 2 / 1e+9;
                }
              }
            }
          }
        }
      }
      return SweConst.OK;
    } catch (java.io.IOException e) {
      serr.append("file error in swisseph.FileData: "+e.getMessage());
      throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
          SweConst.ERR, serr);
    }
  }

  /* SWISSEPH
   * reads from a file and, if necessary, reorders bytes
   * targ         target pointer
   * size         size of item to be read
   * count        number of items
   * corrsize     in what size should it be returned
   *              (e.g. 3 byte int -> 4 byte int)
   * fp           file pointer
   * fpos         file position: if (fpos >= 0) then fseek
   * freord       reorder bytes or no
   * fendian      little/bigendian
   * ifno         file number
   * serr         error string
   */


} // Ende der Klasse FileData.


//////////////////////////////////////////////////////////////////////////////
// Anmerkungen: //////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// String fnam;     Fuer Ausgaben von Fehlermeldungen und zum
//                  Zwischenspeichern.
// int fversion;    Wird nicht genutzt, aber aus der Datei ausgelesen.
//                  Sollte zugreifbar sein.
// String astnam;   Wird aus der Datei ausgelesen und in "swe_get_planet_name"
//                  zurueckgeliefert.
// int sweph_denum; Wird aus der Datei ausgelesen und in "sweph"
//                  einmal genutzt (4 Bytes uebrigens):
//                  if (fdp->sweph_denum >= 403 && ipl < SEI_ANYBODY) {
//                    swi_IERS_FK5(xp, xp, 1);
//                    [...]
//                  }
// java.io.RandomAccessFile fptr;
// double tfstart;  Beginn und Ende des Zeitraumes, ueber den die Datei
// double tfend;    Daten enthaelt. Wird ausgewertet.
// int iflg;        Enthaelt zwei Flags in Bit 1 und Bit 2: "little endian /
//                  big endian" und "reorder Bytes". sizeof(long), vermutlich
//                  4 Bytes=int;
// short npl;       Wird aus der Datei mit zwei Bytes ausgelesen. Anzahl der
//                  Planeten in der Datei. Aufgrund dieser Information werden
//                  "npl"-mal Konstanten ueber die Planeten aus der Datei
//                  ausgelesen (PlanData p: p.lndx0; p.iflg; p.ncoe; p.rmax;
//                  p.tfstart bis p.dperi; p.refep und FileData.ipl).
// short ipl[];     2 Bytes==int. Offenbar Nummer der Planeten...



class FilePtr {
  public static final String useragent="swisseph-java-1.70.03(00)";

  private static final int MAX_FAILURES=100;

  RandomAccessFile fp;
  Socket sk;
  InputStream is;
  BufferedOutputStream os;
  String fnamp;
  private long fpos=0;
  private String host;
  private int port;
  private int BUFSIZE=20;
  // Holds max. 1 BUFSIZE byte chunks of read data: startidx, endidx, data:
  private long[] startIdx=new long[1];  // long, as it holds the file pointer pos.
  private long[] endIdx=new long[1];
  private byte[][] data;
  private byte inbuf[];
  private int idx=0; // What to fill next.
  private long savedLength=-1;


  
  public FilePtr(RandomAccessFile fp,
                 Socket sk,
                 InputStream is,
                 BufferedOutputStream os,
                 String fnamp,
                 long fileLength,
                 int bufsize) throws IOException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr(RandomAccessFile, Socket, InputStream, BufferedOutputStream, String, long, int)");
////#ifdef TRACE1
//    DevNull.println("    fp: " + fp + "\n    sk: " + sk + "\n    is: " + is + "\n    os: " + os + "\n    fnamp: " + fnamp + "\n    fileLength: " + fileLength + "\n    bufsize: " + bufsize);
////#endif /* TRACE1 */
////#endif /* TRACE0 */
    this.fp=fp;
    this.sk=sk;
    this.is=is;
    this.os=os;
    this.fnamp=fnamp;
    this.savedLength=fileLength;
    this.BUFSIZE=bufsize;
    data=new byte[BUFSIZE][1];
    inbuf=new byte[BUFSIZE];
    for (int i=0;i<data[0].length;i++) {
      startIdx[i]=-1; // Means: no data at this index.
    }
    if (fp==null) {
      try {
        URL u=new URL(fnamp);
        host=u.getHost();
        port=u.getPort();
        if (port<0) { port=80; } // Default port for http...
      } catch ( MalformedURLException me) {
////#ifdef TRACE0
//        Trace.level--;
////#endif /* TRACE0 */
        throw new IOException("Malformed URL '"+fnamp+"'");
      }
    }
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
  }




  
  public byte readByte() throws IOException, EOFException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.readByte()");
////#endif /* TRACE0 */
    if (startIdx[idx]<0 || fpos<startIdx[idx] || fpos>endIdx[idx]) {
      readToBuffer();
    }
    fpos++;
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
    return data[(int)(fpos-1-startIdx[idx])][idx];
  }

  
  public int readUnsignedByte() throws IOException, EOFException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.readUnsignedByte()");
//    Trace.level--;
////#endif /* TRACE0 */
    return ((int)readByte()) & 0xff;
  }


  
  public short readShort() throws IOException, EOFException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.readShort()");
//    Trace.level--;
////#endif /* TRACE0 */
    return (short)((readByte()<<8)+readUnsignedByte());
  }

  
  public int readInt() throws IOException, EOFException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.readInt()");
//    Trace.level--;
////#endif /* TRACE0 */
    return (((int)readByte())<<24)+
           (((int)readUnsignedByte())<<16)+
           (((int)readUnsignedByte())<<8)+
           (int)readUnsignedByte();
  }

  
  public double readDouble() throws IOException, EOFException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.readDouble()");
////#endif /* TRACE0 */
    long ldb=(((long)readUnsignedByte())<<56)+
             (((long)readUnsignedByte())<<48)+
             (((long)readUnsignedByte())<<40)+
             (((long)readUnsignedByte())<<32)+
             (((long)readUnsignedByte())<<24)+
             (((long)readUnsignedByte())<<16)+
             (((long)readUnsignedByte())<<8)+
             (long)readUnsignedByte();
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
    return Double.longBitsToDouble(ldb);
  }

  
  public String readLine() throws IOException, EOFException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.readLine()");
////#endif /* TRACE0 */
    String sout="";
    try {
      char ch;
      while ((ch=(char)readUnsignedByte())!='\n') {
        sout+=ch;
      }
      sout+=ch;
    } catch (EOFException e) {
      if (sout.length()==0) {
////#ifdef TRACE0
//        Trace.level--;
////#endif /* TRACE0 */
        throw e;
      }
    }

////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
    return sout;
  }

  
  public void close() throws IOException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.close()");
////#endif /* TRACE0 */
    try {
      fnamp="";
      if (fp!=null) { fp.close(); }
      fp=null;
      if (sk!=null) { sk.close(); }
      sk=null;
      is=null;
      os=null;
    } catch (IOException ie) {
      try {
        if (sk!=null) { sk.close(); }
        sk=null;
        is=null;
        os=null;
      } catch (IOException ies) {
////#ifdef TRACE0
//        Trace.level--;
////#endif /* TRACE0 */
        throw ies;
      }
////#ifdef TRACE0
//      Trace.level--;
////#endif /* TRACE0 */
      throw ie;
    }
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
  }

  
  public long getFilePointer() {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.getFilePointer()");
//    Trace.level--;
////#endif /* TRACE0 */
    return fpos;
  }

  
  public long length() throws IOException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.length()");
////#endif /* TRACE0 */
    if (fp!=null && savedLength<0) { savedLength=fp.length(); }
    if (fp!=null || savedLength>=0) {
////#ifdef TRACE0
//          Trace.level--;
////#endif /* TRACE0 */
      return savedLength;
    }

    long len=0;
    String s="HEAD "+fnamp+" HTTP/1.1\r\n"+
             "User-Agent: "+useragent+"\r\n"+
             "Host: "+host+":"+port+"\r\n\r\n";
    String sout = "";
    int failures = 0;
    int rc = 0;
    while (true) {
      try {
        URLwrite(os,s);
        sout=URLread(is);
      } catch (IOException ioe) {
        if (++failures>=MAX_FAILURES) {
////#ifdef TRACE0
//          Trace.level--;
////#endif /* TRACE0 */
          throw new IOException("(java.net.SocketException) "+ioe.getMessage());
        }
        reconnect();
        continue;
      }
      rc=checkHeader(sout);
      if (rc<0) { // What has happened? Invalid header?
        if (++failures>=MAX_FAILURES) {
////#ifdef TRACE0
//          Trace.level--;
////#endif /* TRACE0 */
          throw new IOException("Failed to read a valid / complete header.");
        }
        reconnect();
        continue;
      }
      break;
    }
    int idx=sout.indexOf("Content-Length:");
    if (rc==200 && sout.indexOf("Content-Length:") >= 0) {
      sout=sout.substring(idx+"Content-Length:".length());
      sout=sout.substring(0,sout.indexOf("\n")).trim();
      len=Long.parseLong(sout);
    } else {
////#ifdef TRACE0
//      Trace.level--;
////#endif /* TRACE0 */
      throw new IOException("Can't determine length of (HTTP-)file '"+fnamp+
                            "'. HTTP error code: "+rc);
    }
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
    return len;
  }

  
  public void seek(long pos) {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.seek()");
//    Trace.level--;
////#endif /* TRACE0 */
    fpos=pos;
  }

  
  void skipBytes(int count) throws IOException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.skipBytes(int)");
////#ifdef TRACE1
//    DevNull.println("    count: " + count);
////#endif /* TRACE1 */
////#endif /* TRACE0 */
    if (fpos+count>=length()) {
////#ifdef TRACE0
//      Trace.level--;
////#endif /* TRACE0 */
      throw new EOFException("Filepointer position "+(fpos+count)+" exceeds "+
                             "file length by "+(fpos+count-length()+1)+
                             " byte(s).");
    }
    fpos+=count;
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
  }


// RFC 2068: Response = Status-Line
//                      * ( general-header
//                        | response-header
//                        | entity-header )
//                     CRLF
//                     [ message-body ]
//
// Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
//
// Status-Code should (has to?) be 206
//


  private String URLread(InputStream is) throws IOException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.URLread(InputStream)");
////#ifdef TRACE1
//    DevNull.println("    is: " + is);
////#endif /* TRACE1 */
////#endif /* TRACE0 */
    StringBuffer sret=new StringBuffer("");
    int av = is.read();
    if (av == -1) {
////#ifdef TRACE0
//      Trace.level--;
////#endif /* TRACE0 */
      throw new IOException("No bytes available.");
    }
    sret.append((char)av);
    while (is.available()>0) {
      sret.append((char)is.read());
    }
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
    return sret.toString();
  }

  private void URLwrite(BufferedOutputStream os, String s) throws IOException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.URLwrite(BufferedOutputStream, String)");
////#ifdef TRACE1
//    DevNull.println("    os: " + os + " \n    s: " + s);
////#endif /* TRACE1 */
////#endif /* TRACE0 */
    for(int n=0; n<s.length(); n++) {
      os.write((byte)s.charAt(n));
    }
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
    os.flush();
  }

  // Returns the data part of the html response in String s
  private String htmlStrip(String s) {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.htmlStrip(String)");
////#ifdef TRACE1
//    DevNull.println("    s: " + s);
////#endif /* TRACE1 */
////#endif /* TRACE0 */
    int idx=s.indexOf("\r\n\r\n");
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
    if (idx>=0) {
      return s.substring(idx+4);
    }
    return "";
  }

  // Returns the http return code or -1, if not available
  private int checkHeader(String s) {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.checkHeader(String)");
////#ifdef TRACE1
//    DevNull.println("    s: " + s);
////#endif /* TRACE1 */
////#endif /* TRACE0 */
    try {
      int ix1=s.indexOf(" ");
      int ix2=s.indexOf(" ",ix1+1);
////#ifdef TRACE0
//      Trace.level--;
////#endif /* TRACE0 */
      if (ix1<0 || ix2<0 || ix1<8 || ix1+4!=ix2) { return -1; }
      return Integer.parseInt(s.substring(ix1+1,ix2));
    } catch (NumberFormatException nf) {
////#ifdef TRACE0
//      Trace.level--;
////#endif /* TRACE0 */
      return -1;
    }
  }


  // Reads a chunk of data to the buffer data[][idx]
  private void readToBuffer() throws IOException, EOFException {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "FilePtr.readToBuffer()");
////#endif /* TRACE0 */
    // Directly reading a file:
    if (fp!=null) { 
      fp.seek(fpos);
      int cnt=fp.read(inbuf);
// Probably, RandomAccessFile.read(byte[n]) performes n read operations???
      if (cnt==-1) {
////#ifdef TRACE0
//        Trace.level--;
////#endif /* TRACE0 */
        throw new EOFException("Filepointer position "+fpos+" exceeds file"+
                               " length by "+(fpos-length()+1)+" byte(s).");
      }
      for(int n=0;n<cnt;n++) {
        data[n][idx]=inbuf[n];
      } 
      startIdx[idx]=fpos;
      endIdx[idx]=fpos+cnt-1;
////#ifdef TRACE0
//      Trace.level--;
////#endif /* TRACE0 */
      return;
    }

    // Reading via http:
    if (fpos>=length()) {
////#ifdef TRACE0
//      Trace.level--;
////#endif /* TRACE0 */
      throw new EOFException("Filepointer position "+fpos+" exceeds file "+
                             "length by "+(fpos-length()+1)+" byte(s).");
    }
    String s="GET "+fnamp+" HTTP/1.1\r\n"+
             "User-Agent: "+useragent+"\r\n"+
             "Host: "+host+":"+port+"\r\n"+
             "Range: bytes="+fpos+"-"+
                                Math.min(length()-1,fpos+BUFSIZE-1)+"\r\n\r\n";
    String sout="";
    int slen=0;
    int failures=0;
    while (true) {
      try {
        URLwrite(os,s);
        sout=URLread(is);
      } catch (IOException ioe) {
        if (++failures>=MAX_FAILURES) {
////#ifdef TRACE0
//          Trace.level--;
////#endif /* TRACE0 */
          throw new IOException("(java.net.SocketException) "+ioe.getMessage());
        }
        reconnect();
        continue;
      }
      int rc=checkHeader(sout);
      if (rc<0) { // What has happened?
        if (++failures>=MAX_FAILURES) { // Too many failures in a row, abort:
////#ifdef TRACE0
//          Trace.level--;
////#endif /* TRACE0 */
          throw new IOException("Failed to read successfully from address\n'"+
                                fnamp+"'. The http reply from the server was "+
                                sout.length()+
                                " bytes long and it's content is:\n\n"+sout);
        }
        continue;
      }
      sout=htmlStrip(sout); // keep data part of http response only
      slen=sout.length();
      if ((rc!=200 /* OK */ && rc!=206 /* Partial content */) ||
          slen>BUFSIZE ||
          (slen<BUFSIZE && savedLength>=0 && fpos+slen != savedLength)) {
        if (++failures>=MAX_FAILURES) {
////#ifdef TRACE0
//          Trace.level--;
////#endif /* TRACE0 */
          throw new IOException("HTTP read failed with HTTP response "+rc+
                                ". Read "+slen+" bytes, requested "+BUFSIZE+
                                " bytes.");
        }
        continue;
      }
      if (slen==0) { // How is this to happen???
        if (++failures>=MAX_FAILURES) {
////#ifdef TRACE0
//          Trace.level--;
////#endif /* TRACE0 */
          throw new EOFException("Filepointer position "+fpos+" exceeds file "+
                                 "length by "+(fpos-length()+1)+" byte(s).");
        }
        continue;
      }
      break;
    }
    startIdx[idx]=fpos;
    endIdx[idx]=fpos+slen-1;
    for(int n=0;n<slen;n++) {
      data[n][idx]=(byte)sout.charAt(n);
    }
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
  }

  private void reconnect() throws IOException {
////#ifdef TRACE0
//    DevNull.println(System.currentTimeMillis()+" FilePtr.reconnect()");
////#endif /* TRACE0 */
System.err.println("reconnecting...");
    sk.close();
    sk=new Socket(host,port);
    sk.setSoTimeout(5000);
    is=sk.getInputStream();
    os=new BufferedOutputStream(sk.getOutputStream());
  }
}

class GenConst {
 double clight,
        aunit,
        helgravconst,
        ratme,
        sunradius;

}


class Houses {
  
  double cusp[]=new double[37];
  
  double ac;
  
  double mc;
  
  double vertex;
  
  double equasc;
  
  double coasc1;
  
  double coasc2;
  
  double polasc;

}


class IntObj {
  
  public int val;

}
class Nut {
  /* nutation */
  double tnut;
  double nutlo[];      /* nutation in longitude and obliquity */
  double snut, cnut;    /* sine and cosine of nutation in obliquity */
  double matrix[][];

  Nut() {
    nutlo = new double[2];
    matrix = new double[3][3];
  }

  void clearData() {
    int i,j;
    tnut=0.0;
    snut=0.0;
    cnut=0.0;
    for(j=0; j<nutlo.length; j++) { nutlo[j]=0.0; }
    for(j=0; j<matrix.length; j++) {
      for(i=0; i<matrix[j].length; i++) {
        matrix[j][i]=0.0;
      }
    }
  }
}

class PlanData {
  double x[]=new double[6]; /* position and speed vectors equatorial J2000 */
  double xreturn[]=new double[24]; /* return positions:
                         * xreturn+0    ecliptic polar coordinates
                         * xreturn+6    ecliptic cartesian coordinates
                         * xreturn+12   equatorial polar coordinates
                         * xreturn+18   equatorial cartesian coordinates
                         */

  /* the following data are read from file only once, immediately after
   * file has been opened */
  int ibdy=0;           /* internal body number */
  int iflg=0;          /* contains several bit flags describing the data:
                         * SEI_FLG_HELIO: true if helio, false if bary
                         * SEI_FLG_ROTATE: TRUE if coefficients are referred
                         *      to coordinate system of orbital plane
                         * SEI_FLG_ELLIPSE: TRUE if reference ellipse */
  int ncoe=0;           /* # of coefficients of ephemeris polynomial,
                           is polynomial order + 1  */
  /* where is the segment index on the file */
  long lndx0=0;         /* file position of begin of planet's index */
  int nndx=0;           /* number of index entries on file: computed */
  double tfstart=0;     /* file contains ephemeris for tfstart thru tfend */
  double tfend=0;       /*      for this particular planet !!!            */
  double dseg=0;        /* segment size (days covered by a polynomial)  */
  /* orbital elements: */
  double telem=0;       /* epoch of elements */
  double prot=0;
  double qrot=0;
  double dprot=0;
  double dqrot=0;
  double rmax=0;        /* normalisation factor of cheby coefficients */
  /* in addition, if reference ellipse is used: */
  double peri=0;
  double dperi=0;
////  double *refep;        /* pointer to cheby coeffs of reference ellipse,
////                         * size of data is 2 x ncoe */
  double refep[]=null;  /* pointer to cheby coeffs of reference ellipse,
                         * size of data is 2 x ncoe */
  /* unpacked segment information, only updated when a segment is read: */
  double tseg0=0, tseg1=0;  /* start and end jd of current segment */
////  double *segp;         /* pointer to unpacked cheby coeffs of segment;
////                         * the size is 3 x ncoe */
  double segp[]=null;   /* pointer to unpacked cheby coeffs of segment;
                         * the size is 3 x ncoe */
  int neval=0;          /* how many coefficients to evaluate. this may
                         * be less than ncoe */
  /* result of most recent data evaluation for this body: */
  double teval=0;       /* time for which previous computation was made */
  int iephe=0;          /* which ephemeris was used */
  int xflgs=0;         /* hel., light-time, aberr., prec. flags etc. */

  PlanData() {
    for(int i=0;i<x.length;i++) { x[i]=0.; } // Really?
    for(int i=0;i<x.length;i++) { xreturn[i]=0.; } // Really?
  }


  void clearData() {
    int j;

    ibdy=0;
    iflg=0;
    ncoe=0;
    lndx0=0;
    nndx=0;
    tfstart=0.0;
    tfend=0.0;
    dseg=0.0;
    telem=0.0;
    prot=0.0;
    qrot=0.0;
    dprot=0.0;
    dqrot=0.0;
    rmax=0.0;
    peri=0.0;
    dperi=0.0;
    tseg0=0.0;
    tseg1=0.0;
    neval=0;
    teval=0.0;
    iephe=0;
    xflgs=0;
    for(j=0; j<x.length; j++) { x[j]=0.0; }
    for(j=0; j<xreturn.length; j++) { xreturn[j]=0.0; }
    refep=null;
    segp=null;
  }
}


class Plantbl {
  short max_harmonic[]=new short[9];
  short max_power_of_t;
  byte[] arg_tbl;
  double[] lon_tbl;
  double[] lat_tbl;
  double[] rad_tbl;
  double distance;

  Plantbl(short[] max_harmonic, short max_power_of_t, byte[] arg_tbl,
          double[] lon_tbl, double[] lat_tbl, double[] rad_tbl,
          double distance) {
    this.max_harmonic=max_harmonic;
    this.max_power_of_t=max_power_of_t;
    this.arg_tbl=arg_tbl;
    this.lon_tbl=lon_tbl;
    this.lat_tbl=lat_tbl;
    this.rad_tbl=rad_tbl;
    this.distance=distance;
  }
}


class SavePositions {
  int ipl;
  double tsave=0.;
  int iflgsave;
  /* position at t = tsave,
   * in ecliptic polar (offset 0),
   *    ecliptic cartesian (offset 6),
   *    equatorial polar (offset 12),
   *    and equatorial cartesian coordinates (offset 18).
   * 6 doubles each for position and speed coordinates.
   */
  double xsaves[]=new double[24];

  void clearData() {
    for (int i=0; i<xsaves.length; i++) {
      xsaves[i]=0.;
    }
    ipl=0; tsave=0.; iflgsave=0;
  }



}


class SidData {
  int sid_mode=0;
  double ayan_t0=0.;
  double t0=0.;

}


class Swecl {

  SwissEph  sw=null;
  SwissLib  sl=null;
  Swemmoon  sm=null;
  SwissData swed=null;


  private static final double DSUN=(1392000000.0 / SweConst.AUNIT);
  private static final double DMOON=(3476300.0 / SweConst.AUNIT);
  private static final double DEARTH=(6378140.0 * 2 / SweConst.AUNIT);
  private static final double RSUN=(DSUN / 2);
  private static final double RMOON=(DMOON / 2);
  private static final double REARTH=(DEARTH / 2);
  private static final int SEI_OCC_FAST=(16 * 1024);

  private static final double lnlog=Math.log(10);
  private double log10(double x) { return Math.log(x)/lnlog; }


  
  Swecl() {
    this(null, null, null, null);
    sw=new SwissEph();
    sl=new SwissLib();
    sm=new Swemmoon();
    swed=new SwissData();
  }

  
  Swecl(SwissEph sw, SwissLib sl, Swemmoon sm, SwissData swed) {
    this.sw=sw;
    this.sl=sl;
    this.sm=sm;
    this.swed=swed;
    if (sw==null) { this.sw=new SwissEph(); }
    if (sl==null) { this.sl=new SwissLib(); }
    if (sm==null) { this.sm=new Swemmoon(); }
    if (swed==null) { this.swed=new SwissData(); }
  }

  /* Computes geographic location and type of solar eclipse
   * for a given tjd
   * iflag:        to indicate ephemeris to be used
   *                        (SEFLG_JPLEPH, SEFLG_SWIEPH, SEFLG_MOSEPH)
   *
   * Algorithms for the central line is taken from Montenbruck, pp. 179ff.,
   * with the exception, that we consider refraction for the maxima of
   * partial and noncentral eclipses.
   * Geographical positions are referred to sea level / the mean ellipsoid.
   *
   * Errors:
   * - from uncertainty of JPL-ephemerides (0.01 arcsec):
   *        about 40 meters
   * - from displacement of shadow points by atmospheric refraction:
   *      a few meters
   * - from deviation of the geoid from the ellipsoid
   *      a few meters
   * - from polar motion
   *      a few meters
   * For geographical locations that are interesting for observation,
   * the error is always < 100 m.
   * However, if the sun is close to the horizon,
   * all of these errors can grow up to a km or more.
   *
   * Function returns:
   * -1 (ERR)        on error (e.g. if swe_calc() for sun or moon fails)
   * 0                if there is no solar eclipse at tjd
   * SE_ECL_TOTAL
   * SE_ECL_ANNULAR
   * SE_ECL_TOTAL | SE_ECL_CENTRAL
   * SE_ECL_TOTAL | SE_ECL_NONCENTRAL
   * SE_ECL_ANNULAR | SE_ECL_CENTRAL
   * SE_ECL_ANNULAR | SE_ECL_NONCENTRAL
   * SE_ECL_PARTIAL
   *
   * geopos[0]:        geographic longitude of central line
   * geopos[1]:        geographic latitude of central line
   *
   * not implemented so far:
   *
   * geopos[2]:        geographic longitude of northern limit of umbra
   * geopos[3]:        geographic latitude of northern limit of umbra
   * geopos[4]:        geographic longitude of southern limit of umbra
   * geopos[5]:        geographic latitude of southern limit of umbra
   * geopos[6]:        geographic longitude of northern limit of penumbra
   * geopos[7]:        geographic latitude of northern limit of penumbra
   * geopos[8]:        geographic longitude of southern limit of penumbra
   * geopos[9]:        geographic latitude of southern limit of penumbra
   *
   * Attention: "northern" and "southern" limits of umbra do not
   * necessarily correspond to the northernmost or southernmost
   * geographic position, where the total, annular, or partial
   * phase is visible at a given time.
   * Imagine a situation in northern summer, when the sun illuminates
   * the northern polar circle. The southernmost point of the core
   * shadow may then touch the north pole, and therefore the
   * northernmost point will be more in the south.
   * Note also that with annular eclipses, the northern edge is
   * usually geographically the southern one. With annular-total
   * ones, the two lines cross, usually twice. The maximum is always
   * total in such cases.
   *
   * attr[0]        fraction of solar diameter covered by moon (magnitude)
   * attr[1]        ratio of lunar diameter to solar one
   * attr[2]        fraction of solar disc covered by moon (obscuration)
   * attr[3]      diameter of core shadow in km
   * attr[4]        azimuth of sun at tjd
   * attr[5]        true altitude of sun above horizon at tjd
   * attr[6]        apparent altitude of sun above horizon at tjd
   * attr[7]        angular distance of moon from sun in degrees
   *         declare as attr[20] at least !
   */
  
  int swe_sol_eclipse_where(double tjd_ut,
                            int ifl,
                            double[] geopos,
                            double[] attr,
                            StringBuffer serr) {
    int retflag, retflag2;
    double dcore[]=new double[10];
    ifl &= SweConst.SEFLG_EPHMASK;
    if ((retflag = eclipse_where(tjd_ut, SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) < 0) {
      return retflag;
    }
    if ((retflag2 = eclipse_how(tjd_ut, SweConst.SE_SUN, null, ifl, geopos[0], geopos[1], 0, attr, serr)) == SweConst.ERR) {
      return retflag2;
    }
    attr[3] = dcore[0];
    return retflag;
  }

  int swe_lun_occult_where(double tjd_ut,
                           int ipl,
                           StringBuffer starname,
                           int ifl,
                           double[] geopos,
                           double[] attr,
                           StringBuffer serr) {
    int retflag, retflag2;
    double dcore[]=new double[10];
    ifl &= SweConst.SEFLG_EPHMASK;
    if ((retflag = eclipse_where(tjd_ut, ipl, starname, ifl, geopos, dcore, serr)) < 0) {
      return retflag;
    }
    if ((retflag2 = eclipse_how(tjd_ut, ipl, starname, ifl, geopos[0], geopos[1], 0, attr, serr)) == SweConst.ERR) {
      return retflag2;
    }
    attr[3] = dcore[0];
    return retflag;
  }

  /* Used by several swe_sol_eclipse_ functions.
   * Like swe_sol_eclipse_where(), but instead of attr[0], it returns:
   *
   * dcore[0]:        core shadow width in km
   * dcore[2]:        distance of shadow axis from geocenter r0
   * dcore[3]:        diameter of core shadow on fundamental plane d0
   * dcore[4]:        diameter of half-shadow on fundamental plane D0
   */
  private int eclipse_where(double tjd_ut, int ipl, StringBuffer starname, int ifl,
                            double[] geopos, double[] dcore, StringBuffer serr) {
    int i;
    int retc = 0, niter = 0;
    double e[]=new double[6], et[]=new double[6], erm[]=new double[6],
           rm[]=new double[6], rs[]=new double[6], rmt[]=new double[6],
           rst[]=new double[6], xs[]=new double[6], xst[]=new double[6];
    double xssv[]=new double[16], x[]=new double[6];
    double lm[]=new double[6], ls[]=new double[6], lx[]=new double[6];
    double dsm, dsmt, d0, D0, s0, r0, d, s, dm;
    double de = 6378140.0 / SweConst.AUNIT;
    double earthobl = 1 - SwephData.EARTH_OBLATENESS;
    double deltat, tjd, sidt;
    double drad;
    double sinf1, sinf2, cosf1, cosf2;
    int iflag, iflag2;
    /* double ecce = Math.sqrt(2 * SwephData.EARTH_OBLATENESS - SwephData.EARTH_OBLATENESS * SwephData.EARTH_OBLATENESS); */
    boolean no_eclipse = false;
    Epsilon oe = swed.oec;
    for (i = 0; i < 10; i++)
      dcore[i] = 0;
    /* nutation need not be in lunar and solar positions,
     * if mean sidereal time will be used */
    iflag = SweConst.SEFLG_SPEED | SweConst.SEFLG_EQUATORIAL | ifl;
    iflag2 = iflag | SweConst.SEFLG_RADIANS;
    iflag  = iflag | SweConst.SEFLG_XYZ;
    deltat = SweDate.getDeltaT(tjd_ut);
    tjd = tjd_ut + deltat;
    /* moon in cartesian coordinates */
    if ((retc = sw.swe_calc(tjd, SweConst.SE_MOON, iflag, rm, serr)) == SweConst.ERR) {
      return retc;
    }
    /* moon in polar coordinates */
    if ((retc = sw.swe_calc(tjd, SweConst.SE_MOON, iflag2, lm, serr)) == SweConst.ERR)
      return retc;
    /* sun in cartesian coordinates */
    if ((retc = calc_planet_star(tjd, ipl, starname, iflag, rs, serr)) == SweConst.ERR)
      return retc;
    /* sun in polar coordinates */
    if ((retc = calc_planet_star(tjd, ipl, starname, iflag2, ls, serr)) == SweConst.ERR)
      return retc;
    /* save sun position */
    for (i = 0; i <= 2; i++)
      rst[i] = rs[i];
    /* save moon position */
    for (i = 0; i <= 2; i++)
      rmt[i] = rm[i];
    if ((iflag & SweConst.SEFLG_NONUT)!=0) {
      sidt = sl.swe_sidtime0(tjd_ut, oe.eps * SwissData.RADTODEG, 0) * 15 *
                                                            SwissData.DEGTORAD;
    } else {
      sidt = sl.swe_sidtime(tjd_ut) * 15 * SwissData.DEGTORAD;
    }
    /*
     * radius of planet disk in AU
     */
    if (starname != null && starname.length() > 0)
      drad = 0;
    else if (ipl < SwephData.NDIAM)
      drad = SwephData.pla_diam[ipl] / 2 / SweConst.AUNIT;
    else if (ipl > SweConst.SE_AST_OFFSET)
      drad = swed.ast_diam / 2 * 1000 / SweConst.AUNIT; /* km -> m -> AU */
    else
      drad = 0;
//iter_where:
    while(true) {
      for (i = 0; i <= 2; i++) {
        rs[i] = rst[i];
        rm[i] = rmt[i];
      }
      /* Account for oblateness of earth:
       * Instead of flattening the earth, we apply the
       * correction to the z coordinate of the moon and
       * the sun. This makes the calculation easier.
       */
      for (i = 0; i <= 2; i++)
        lx[i] = lm[i];
      sl.swi_polcart(lx, rm);
      rm[2] /= earthobl;
      /* distance of moon from geocenter */
      dm = Math.sqrt(sl.square_sum(rm));
      /* Account for oblateness of earth */
      for (i = 0; i <= 2; i++)
        lx[i] = ls[i];
      sl.swi_polcart(lx, rs);
      rs[2] /= earthobl;
      /* sun - moon vector */
      for (i = 0; i <= 2; i++) {
        e[i] = (rm[i] - rs[i]);
        et[i] = (rmt[i] - rst[i]);
      }
      /* distance sun - moon */
      dsm = Math.sqrt(sl.square_sum(e));
      dsmt = Math.sqrt(sl.square_sum(et));
      /* sun - moon unit vector */
      for (i = 0; i <= 2; i++) {
        e[i] /= dsm;
        et[i] /= dsmt;
        erm[i] = rm[i] / dm;
      }
      sinf1 = ((drad - RMOON) / dsm);
      cosf1 = Math.sqrt(1 - sinf1 * sinf1);
      sinf2 = ((drad + RMOON) / dsm);
      cosf2 = Math.sqrt(1 - sinf2 * sinf2);
      /* distance of moon from fundamental plane */
      s0 = -sw.dot_prod(rm, e);
      /* distance of shadow axis from geocenter */
      r0 = Math.sqrt(dm * dm - s0 * s0);
      /* diameter of core shadow on fundamental plane */
      d0 = (s0 / dsm * (drad * 2 - DMOON) - DMOON) / cosf1;
      /* diameter of half-shadow on fundamental plane */
      D0 = (s0 / dsm * (drad * 2 + DMOON) + DMOON) / cosf2;
      dcore[2] = r0;
      dcore[3] = d0;
      dcore[4] = D0;
      dcore[5] = cosf1;
      dcore[6] = cosf2;
      for (i = 2; i < 5; i++)
        dcore[i] *= SweConst.AUNIT / 1000.0;
      
      retc = 0;
      if (de * cosf1 >= r0) {
        retc |= SweConst.SE_ECL_CENTRAL;
      } else if (r0 <= de * cosf1 + Math.abs(d0) / 2) {
        retc |= SweConst.SE_ECL_NONCENTRAL;
      } else if (r0 <= de * cosf2 + D0 / 2) {
        retc |= (SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_NONCENTRAL);
      } else {
        if (serr != null) {
          serr.setLength(0);
          serr.append("no solar eclipse at tjd = "+tjd);
        }
        for (i = 0; i < 10; i++)
          geopos[i] = 0;
//    *dcore = 0;
        dcore[0] = 0;
        retc = 0;
        d = 0;
        no_eclipse = true;
        /*return retc;*/
      }
      /* distance of shadow point from fundamental plane */
      d = s0 * s0 + de * de - dm * dm;
      if (d > 0) {
        d = Math.sqrt(d);
      } else {
        d = 0;
      }
      /* distance of moon from shadow point on earth */
      s = s0 - d;
      /* next: geographic position of eclipse center.
       * if shadow axis does not touch the earth,
       * place on earth with maximum occultation is computed.
       */
      /* geographic position of eclipse center (maximum) */
      for (i = 0; i <= 2; i++)
        xs[i] = rm[i] + s * e[i];
      /* we need geographic position with correct z, as well */
      for (i = 0; i <= 2; i++)
        xst[i] = xs[i];
      xst[2] *= earthobl;
      sl.swi_cartpol(xst, xst);
      if (niter <= 0) {
        double cosfi = Math.cos(xst[1]);
        double sinfi = Math.sin(xst[1]);
        double eobl = SwephData.EARTH_OBLATENESS;
        double cc= 1 / Math.sqrt(cosfi * cosfi + (1-eobl) * (1-eobl) * sinfi * sinfi);
        double ss= (1-eobl) * (1-eobl) * cc;
        earthobl =  ss;
        niter++;
//      goto iter_where;
        continue;
      }
      sl.swi_polcart(xst, xst);
      /* to longitude and latitude */
      sl.swi_cartpol(xs, xs);
      /* measure from sidereal time at greenwich */
      xs[0] -= sidt;
      xs[0] *= SwissData.RADTODEG;
      xs[1] *= SwissData.RADTODEG;
      xs[0] = sl.swe_degnorm(xs[0]);
      /* west is negative */
      if (xs[0] > 180) {
        xs[0] -= 360;
      }
      xssv[0] = xs[0];
      xssv[1] = xs[1];
      geopos[0] = xs[0];
      geopos[1] = xs[1];
      /* diameter of core shadow:
       * first, distance moon - place of eclipse on earth */
      for (i = 0; i <= 2; i++)
        x[i] = rmt[i] - xst[i];
      s = Math.sqrt(sl.square_sum(x));
      /* diameter of core shadow at place of maximum eclipse */
      dcore[0] = (s / dsmt * ( drad * 2 - DMOON) - DMOON) * cosf1;
      dcore[0] *= SweConst.AUNIT / 1000.0;
      /* diameter of penumbra at place of maximum eclipse */
      dcore[1] = (s / dsmt * ( drad * 2 + DMOON) + DMOON) * cosf2;
      dcore[1] *= SweConst.AUNIT / 1000.0;
      if ((retc & SweConst.SE_ECL_PARTIAL)==0 && !no_eclipse) {
        if (dcore[0] > 0) {
          retc |= SweConst.SE_ECL_ANNULAR;
        } else {
          /*printf("total\n");*/
          retc |= SweConst.SE_ECL_TOTAL;
        }
      }
      break; // while (true) ... [goto iter_where]
    }
    return retc;
  }

  private int calc_planet_star(double tjd_et, int ipl, StringBuffer starname, int iflag, double[] x, StringBuffer serr) {
    int i;
    int retc = SweConst.OK;
    if (starname == null || starname.length() == 0) {
      retc = sw.swe_calc(tjd_et, ipl, iflag, x, serr);
    } else {
      if ((retc = sw.swe_fixstar(starname, tjd_et, iflag, x, serr)) ==
                                                                SweConst.OK) {
        /* fixstars have the standard distance 1.
         * in the occultation routines, this might lead to errors
         * if interpreted as AU distance. To avoid this, we make it very high.
         */
        if ((iflag & SweConst.SEFLG_XYZ)!=0) {
          for (i = 0; i < 3; i++)
            x[i] *= 100000000;
        } else {
          x[2] *= 100000000;
        }
      }
    }
    return retc;
  }

  /* Computes attributes of a solar eclipse for given tjd, geo. longitude,
   * geo. latitude, and geo. height.
   *
   * retflag        SE_ECL_TOTAL or SE_ECL_ANNULAR or SE_ECL_PARTIAL
   *              SE_ECL_NONCENTRAL
   *              if 0, no eclipse is visible at geogr. position.
   *
   * attr[0]        fraction of solar diameter covered by moon (magnitude)
   * attr[1]        ratio of lunar diameter to solar one
   * attr[2]        fraction of solar disc covered by moon (obscuration)
   * attr[3]      diameter of core shadow in km
   * attr[4]        azimuth of sun at tjd
   * attr[5]        true altitude of sun above horizon at tjd
   * attr[6]        apparent altitude of sun above horizon at tjd
   * attr[7]        elongation of moon in degrees
   *         declare as attr[20] at least !
   *
   */
  
  int swe_sol_eclipse_how(double tjd_ut,
                          int ifl,
                          double[] geopos,
                          double[] attr,
                          StringBuffer serr) {
    int retflag, retflag2;
    double dcore[]=new double[10];
    double geopos2[]=new double[20];
    ifl &= SweConst.SEFLG_EPHMASK;
    if ((retflag = eclipse_how(tjd_ut, SweConst.SE_SUN, null, ifl, geopos[0],
                               geopos[1], geopos[2], attr, serr)) == SweConst.ERR) {
      return retflag;
    }
    if ((retflag2 = eclipse_where(tjd_ut, SweConst.SE_SUN, null, ifl, geopos2,
                                  dcore, serr)) == SweConst.ERR) {
      return retflag2;
    }
    if (retflag!=0) {
      retflag |= (retflag2 & (SweConst.SE_ECL_CENTRAL | SweConst.SE_ECL_NONCENTRAL));
    }
    attr[3] = dcore[0];
    return retflag;
  }

  private int eclipse_how(double tjd_ut, int ipl, StringBuffer starname,
                          int ifl, double geolon, double geolat, double geohgt,
                          double[] attr, StringBuffer serr) {
    int i;
    int retc = 0;
    double te;
    double xs[]=new double[6], xm[]=new double[6], ls[]=new double[6],
           lm[]=new double[6], x1[]=new double[6], x2[]=new double[6];
    double rmoon, rsun, rsplusrm, rsminusrm;
    double dctr;
    double drad;
    int iflag = SweConst.SEFLG_EQUATORIAL | SweConst.SEFLG_TOPOCTR | ifl;
    int iflagcart = iflag | SweConst.SEFLG_XYZ;
    double mdd, eps, sidt, armc, xh[]=new double[6], hmin_appr;
    double lsun, lmoon, lctr, lsunleft, a, b, sc1, sc2;
    for (i = 0; i < 10; i++)
      attr[i] = 0;
    te = tjd_ut + SweDate.getDeltaT(tjd_ut);
    sw.swe_set_topo(geolon, geolat, geohgt);
    if (calc_planet_star(te, ipl, starname, iflag, ls, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    if (sw.swe_calc(te, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    if (calc_planet_star(te, ipl, starname, iflagcart, xs, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    if (sw.swe_calc(te, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    /*
     * radius of planet disk in AU
     */
    if (starname != null && starname.length() > 0)
      drad = 0;
    else if (ipl < SwephData.NDIAM)
      drad = SwephData.pla_diam[ipl] / 2 / SweConst.AUNIT;
    else if (ipl > SweConst.SE_AST_OFFSET)
      drad = swed.ast_diam / 2 * 1000 / SweConst.AUNIT; /* km -> m -> AU */
    else
      drad = 0;
    /*
     * azimuth and altitude of sun or planet
     */
    eps = sl.swi_epsiln(te);
    if ((iflag & SweConst.SEFLG_NONUT)!=0) {
      sidt = sl.swe_sidtime0(tjd_ut, eps * SwissData.RADTODEG, 0) * 15;
    } else {
      sidt = sl.swe_sidtime(tjd_ut) * 15;
    }
    armc = sidt + geolon;
    mdd = sl.swe_degnorm(ls[0] - armc);
    xh[0] = sl.swe_degnorm(mdd - 90);
    xh[1] = ls[1];
    xh[2] = ls[2];
    sl.swe_cotrans(xh, 0, xh, 0, 90 - geolat);   /* azimuth from east, counterclock */
    /* eclipse description */
    rmoon = Math.asin(RMOON / lm[2]) * SwissData.RADTODEG;
    rsun = Math.asin(drad / ls[2]) * SwissData.RADTODEG;
    rsplusrm = rsun + rmoon;
    rsminusrm = rsun - rmoon;
    for (i = 0; i < 3; i++) {
      x1[i] = xs[i] / ls[2];
      x2[i] = xm[i] / lm[2];
    }
    dctr = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
    /*
     * phase
     */
    if (dctr < rsminusrm) {
      retc = SweConst.SE_ECL_ANNULAR;
    } else if (dctr < Math.abs(rsminusrm)) {
      retc = SweConst.SE_ECL_TOTAL;
    } else if (dctr < rsplusrm) {
      retc = SweConst.SE_ECL_PARTIAL;
    } else {
      retc = 0;
      if (serr != null) {
        serr.setLength(0);
        serr.append("no solar eclipse at tjd = "+tjd_ut);
      }
    }
    /*
     * percentage of eclipse
     */
    /*
     * eclipse magnitude:
     * fraction of solar diameter covered by moon
     */
    lsun = Math.asin(rsun / 2 * SwissData.DEGTORAD) * 2;
    lmoon = Math.asin(rmoon / 2 * SwissData.DEGTORAD) * 2;
    lctr = Math.asin(dctr / 2 * SwissData.DEGTORAD) * 2;
    lsunleft = Math.asin((-dctr + rsun + rmoon) * SwissData.DEGTORAD / 2) * 2;
    if (lsun > 0)
      attr[0] = lsunleft / lsun / 2;
    else
      attr[0] = 100;
    /*
     * ratio of diameter of moon to that of sun
     */
    if (lsun > 0)
      attr[1] = lmoon / lsun;
    else
      attr[1] = 0;
    /*
     * obscuration:
     * fraction of solar disc obscured by moon
     */
    if (retc == 0 || lsun == 0) {
      attr[2] = 100;
    } else if (retc == SweConst.SE_ECL_TOTAL || retc == SweConst.SE_ECL_ANNULAR) {
      attr[2] = lmoon * lmoon / lsun / lsun;
    } else {
      a = 2 * lctr * lmoon;
      b = 2 * lctr * lsun;
      if (a < 1e-9) {
        attr[2] = lmoon * lmoon / lsun / lsun;
      } else {
        a = (lctr * lctr + lmoon * lmoon - lsun * lsun) / a;
        if (a > 1) a = 1;
        if (a < -1) a = -1;
        b = (lctr * lctr + lsun * lsun - lmoon * lmoon) / b;
        if (b > 1) b = 1;
        if (b < -1) b = -1;
        a = Math.acos(a);
        b = Math.acos(b);
        sc1 = a * lmoon * lmoon / 2;
        sc2 = b * lsun * lsun / 2;
        sc1 -= (Math.cos(a) * Math.sin(a)) * lmoon * lmoon / 2;
        sc2 -= (Math.cos(b) * Math.sin(b)) * lsun * lsun / 2;
        attr[2] = (sc1 + sc2) * 2 / SwephData.PI / lsun / lsun;
      }
    }
    attr[7] = dctr;
    /* approximate minimum height for visibility, considering
     * refraction and dip
     * 34.4556': refraction at horizon, from Bennets formulae
     * 1.75' / Math.sqrt(geohgt): dip of horizon
     * 0.37' / Math.sqrt(geohgt): refraction between horizon and observer */
    hmin_appr = -(34.4556 + (1.75 + 0.37) * Math.sqrt(geohgt)) / 60;
    if (xh[1] + rsun + Math.abs(hmin_appr) >= 0 && retc!=0) {
      retc |= SweConst.SE_ECL_VISIBLE;        /* eclipse visible */
    }
    attr[4] = sl.swe_degnorm(90 - xh[0]);   /* azimuth, from north, clockwise */
    attr[5] = xh[1]; /* height */
    return retc;
  }

  /* When is the next solar eclipse anywhere on earth?
   *
   * input parameters:
   *
   * tjd_start    start time for search (UT)
   * ifl          ephemeris to be used (SEFLG_SWIEPH, etc.)
   * ifltype      eclipse type to be searched (SE_ECL_TOTAL, etc.)
   *              0, if any type of eclipse is required
   *
   * return values:
   *
   * retflag      SE_ECL_TOTAL or SE_ECL_ANNULAR or SE_ECL_PARTIAL
   *              or SE_ECL_ANNULAR_TOTAL
   *              SE_ECL_CENTRAL
   *              SE_ECL_NONCENTRAL
   *
   * tret[0]      time of maximum eclipse
   * tret[1]      time, when eclipse takes place at local apparent noon
   * tret[2]      time of eclipse begin
   * tret[3]      time of eclipse end
   * tret[4]      time of totality begin
   * tret[5]      time of totality end
   * tret[6]      time of center line begin
   * tret[7]      time of center line end
   * tret[8]      time when annular-total eclipse becomes total
   *                 not implemented so far
   * tret[9]      time when annular-total eclipse becomes annular again
   *                 not implemented so far
   *         declare as tret[10] at least!
   *
   */
  
  int swe_sol_eclipse_when_glob(double tjd_start, int ifl, int ifltype,
                                double tret[], int backward,
                                StringBuffer serr) {
    int i, j, k, m, n, o, i1 = 0, i2 = 0;
    int retflag = 0, retflag2 = 0;
    double de = 6378.140, a;
    double t, tt, tjd, tjds, dt, dta, dtb;
    DblObj dtint=new DblObj();
    double T, T2, T3, T4, K, M, Mm;
    double E, Ff;
    double xs[]=new double[6], xm[]=new double[6],
           ls[]=new double[6], lm[]=new double[6];
    double rmoon, rsun, dcore[]=new double[10];
    double dc[]=new double[3];
    DblObj dctr=new DblObj();
    double twohr = 2.0 / 24.0;
    double tenmin = 10.0 / 24.0 / 60.0;
    DblObj dt1=new DblObj(), dt2=new DblObj();
    double geopos[]=new double[20], attr[]=new double[20];
    double dtstart, dtdiv;
    double xa[]=new double[6], xb[]=new double[6];
    int direction = 1;
    boolean dont_times = false;
    int iflag, iflagcart;
    ifl &= SweConst.SEFLG_EPHMASK;
    iflag = SweConst.SEFLG_EQUATORIAL | ifl;
    iflagcart = iflag | SweConst.SEFLG_XYZ;
    if (ifltype == (SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_CENTRAL)) {
      if (serr != null) {
        serr.setLength(0);
        serr.append("central partial eclipses do not exist");
      }
      return SweConst.ERR;
    }
    if (ifltype == 0) {
      ifltype = SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_ANNULAR
             | SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_ANNULAR_TOTAL
             | SweConst.SE_ECL_NONCENTRAL | SweConst.SE_ECL_CENTRAL;
    }
    if (backward!=0) {
      direction = -1;
    }
    K = (int) ((tjd_start - SwephData.J2000) / 365.2425 * 12.3685);
    K -= direction;
//next_try:
    while(true) {
      retflag = 0;
      dont_times = false;
      for (i = 0; i <= 9; i++)
        tret[i] = 0;
      T = K / 1236.85;
      T2 = T * T; T3 = T2 * T; T4 = T3 * T;
      Ff = sl.swe_degnorm(160.7108 + 390.67050274 * K
                   - 0.0016341 * T2
                   - 0.00000227 * T3
                   + 0.000000011 * T4);
      if (Ff > 180) {
        Ff -= 180;
      }
      if (Ff > 21 && Ff < 159) {    /* no eclipse possible */
        K += direction;
        continue;
      }
      /* approximate time of geocentric maximum eclipse
       * formula from Meeus, German, p. 381 */
      tjd = 2451550.09765 + 29.530588853 * K
                          + 0.0001337 * T2
                          - 0.000000150 * T3
                          + 0.00000000073 * T4;
      M = sl.swe_degnorm(2.5534 + 29.10535669 * K
                          - 0.0000218 * T2
                          - 0.00000011 * T3);
      Mm = sl.swe_degnorm(201.5643 + 385.81693528 * K
                          + 0.1017438 * T2
                          + 0.00001239 * T3
                          + 0.000000058 * T4);
      E = 1 - 0.002516 * T - 0.0000074 * T2;
      M *= SwissData.DEGTORAD;
      Mm *= SwissData.DEGTORAD;
      tjd = tjd - 0.4075 * Math.sin(Mm)
                + 0.1721 * E * Math.sin(M);
      /*
       * time of maximum eclipse (if eclipse) =
       * minimum geocentric angle between sun and moon edges.
       * After this time has been determined, check
       * whether or not an eclipse is taking place with
       * the functions eclipse_where() and _how().
       */
      dtstart = 1;
      if (tjd < 2000000) {
        dtstart = 5;
      }
      dtdiv = 4;
      for (dt = dtstart;
           dt > 0.0001;
           dt /= dtdiv) {
        for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
          if (sw.swe_calc(t, SweConst.SE_SUN, iflag, ls, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_SUN, iflagcart, xs, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          for (m = 0; m < 3; m++) {
            xa[m] = xs[m] / ls[2];
            xb[m] = xm[m] / lm[2];
          }
          dc[i] = Math.acos(sl.swi_dot_prod_unit(xa, xb)) * SwissData.RADTODEG;
          rmoon = Math.asin(RMOON / lm[2]) * SwissData.RADTODEG;
          rsun = Math.asin(RSUN / ls[2]) * SwissData.RADTODEG;
          dc[i] -= (rmoon + rsun);
        }
        find_maximum(dc[0], dc[1], dc[2], dt, dtint, dctr);
        tjd += dtint.val + dt;
      }
      tjds = tjd = tjd - SweDate.getDeltaT(tjd);
      if ((retflag = eclipse_where(tjd, SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
        return retflag;
      }
      retflag2 = retflag;
        /* in extreme cases _where() returns no eclipse, where there is
         * actually a very small one, therefore call _how() with the
         * coordinates returned by _where(): */
      if ((retflag2 = eclipse_how(tjd, SweConst.SE_SUN, null, ifl, geopos[0], geopos[1], 0, attr,
                                                        serr)) == SweConst.ERR) {
        return retflag2;
      }
      if (retflag2 == 0) {
        K += direction;
        continue;
      }
      tret[0] = tjd;
      if ((backward!=0 && tret[0] >= tjd_start - 0.0001)
        || (backward==0 && tret[0] <= tjd_start + 0.0001)) {
        K += direction;
        continue;
      }
      /*
       * eclipse type, SE_ECL_TOTAL, _ANNULAR, etc.
       * SE_ECL_ANNULAR_TOTAL will be discovered later
       */
      if ((retflag = eclipse_where(tjd, SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
        return retflag;
      }
      if (retflag == 0) {   /* can happen with extremely small percentage */
        retflag = SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_NONCENTRAL;
        tret[4] = tret[5] = tjd;    /* fix this ???? */
        dont_times = true;
      }
      /*
       * check whether or not eclipse type found is wanted
       */
      /* non central eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_NONCENTRAL)==0 &&
                                   (retflag & SweConst.SE_ECL_NONCENTRAL)!=0) {
        K += direction;
        continue;
      }
      /* central eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_CENTRAL)==0 &&
                                      (retflag & SweConst.SE_ECL_CENTRAL)!=0) {
        K += direction;
        continue;
      }
      /* non annular eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_ANNULAR)==0 &&
                                      (retflag & SweConst.SE_ECL_ANNULAR)!=0) {
        K += direction;
        continue;
      }
      /* non partial eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_PARTIAL)==0 &&
                                      (retflag & SweConst.SE_ECL_PARTIAL)!=0) {
        K += direction;
        continue;
      }
      /* annular-total eclipse will be discovered later */
      if ((ifltype & (SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_ANNULAR_TOTAL))==0
                    && (retflag & SweConst.SE_ECL_TOTAL)!=0) {
        K += direction;
        continue;
      }
      if (dont_times) {
        break;
      }
      /*
       * n = 0: times of eclipse begin and end
       * n = 1: times of totality begin and end
       * n = 2: times of center line begin and end
       */
      if ((retflag & SweConst.SE_ECL_PARTIAL)!=0) {
        o = 0;
      } else if ((retflag & SweConst.SE_ECL_NONCENTRAL)!=0) {
        o = 1;
      }
      else
        o = 2;
      dta = twohr;
      dtb = tenmin;
      for (n = 0; n <= o; n++) {
        if (n == 0) {
          /*dc[1] = dcore[3] / 2 + de - dcore[1];*/
          i1 = 2; i2 = 3;
        } else if (n == 1) {
          if ((retflag & SweConst.SE_ECL_PARTIAL)!=0) {
            continue;
          }
          i1 = 4; i2 = 5;
        } else if (n == 2) {
          if ((retflag & SweConst.SE_ECL_NONCENTRAL)!=0) {
            continue;
          }
          i1 = 6; i2 = 7;
        }
        for (i = 0, t = tjd - dta; i <= 2; i += 1, t += dta) {
          if ((retflag2 = eclipse_where(t, SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
            return retflag2;
          }
          if (n == 0) {
            dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
          } else if (n == 1) {
            dc[i] = Math.abs(dcore[3]) / 2 + de / dcore[6] - dcore[2];
          } else if (n == 2) {
            dc[i] = de / dcore[6] - dcore[2];
          }
        }
        find_zero(dc[0], dc[1], dc[2], dta, dt1, dt2);
        tret[i1] = tjd + dt1.val + dta;
        tret[i2] = tjd + dt2.val + dta;
        for (m = 0, dt = dtb; m < 3; m++, dt /= 3) {
          for (j = i1; j <= i2; j += (i2 - i1)) {
            for (i = 0, t = tret[j] - dt; i < 2; i++, t += dt) {
              if ((retflag2 = eclipse_where(t, SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
                return retflag2;
              }
              if (n == 0) {
                dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
              } else if (n == 1) {
                dc[i] = Math.abs(dcore[3]) / 2 + de / dcore[6] - dcore[2];
              } else if (n == 2) {
                dc[i] = de / dcore[6] - dcore[2];
              }
            }
            dt1.val = dc[1] / ((dc[1] - dc[0]) / dt);
            tret[j] -= dt1.val;
          }
        }
      }
      /*
       * annular-total eclipses
       */
      if ((retflag & SweConst.SE_ECL_TOTAL)!=0) {
        if ((retflag2 = eclipse_where(tret[0], SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
          return retflag2;
        }
        dc[0] = dcore[0];
        if ((retflag2 = eclipse_where(tret[4], SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
          return retflag2;
        }
        dc[1] = dcore[0];
        if ((retflag2 = eclipse_where(tret[5], SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
          return retflag2;
        }
        dc[2] = dcore[0];
        /* the maximum is always total, and there is either one or
         * to times before and after, when the core shadow becomes
         * zero and totality changes into annularity or vice versa.
         */
        if (dc[0] * dc[1] < 0 || dc[0] * dc[2] < 0) {
          retflag |= SweConst.SE_ECL_ANNULAR_TOTAL;
          retflag &= ~SweConst.SE_ECL_TOTAL;
        }
      }
      /* if eclipse is given but not wanted: */
      if ((ifltype & SweConst.SE_ECL_TOTAL)==0 &&
          (retflag & SweConst.SE_ECL_TOTAL)!=0) {
        K += direction;
        continue;
      }
      /* if annular_total eclipse is given but not wanted: */
      if ((ifltype & SweConst.SE_ECL_ANNULAR_TOTAL)==0 &&
          (retflag & SweConst.SE_ECL_ANNULAR_TOTAL)!=0) {
        K += direction;
        continue;
      }
      /*
       * time of maximum eclipse at local apparent noon
       */
      /* first, find out, if there is a solar transit
       * between begin and end of eclipse */
      k = 2;
      for (i = 0; i < 2; i++) {
        j = i + k;
        tt = tret[j] + SweDate.getDeltaT(tret[j]);
        if (sw.swe_calc(tt, SweConst.SE_SUN, iflag, ls, serr) == SweConst.ERR) {
          return SweConst.ERR;
        }
        if (sw.swe_calc(tt, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR) {
          return SweConst.ERR;
        }
        dc[i] = sl.swe_degnorm(ls[0] - lm[0]);
        if (dc[i] > 180) {
          dc[i] -= 360;
        }
      }
      if (dc[0] * dc[1] >= 0) {     /* no transit */
        tret[1] = 0;
      } else {
        tjd = tjds;
        dt = 0.1;
        dt1.val = (tret[3] - tret[2]) / 2.0;
        if (dt1.val < dt) {
          dt = dt1.val / 2.0;
        }
        for (j = 0;
            dt > 0.01;
            j++, dt /= 3) {
          for (i = 0, t = tjd; i <= 1; i++, t -= dt) {
            tt = t + SweDate.getDeltaT(t);
            if (sw.swe_calc(tt, SweConst.SE_SUN, iflag, ls, serr) ==
                                                                 SweConst.ERR) {
              return SweConst.ERR;
            }
            if (sw.swe_calc(tt, SweConst.SE_MOON, iflag, lm, serr) ==
                                                                 SweConst.ERR) {
              return SweConst.ERR;
            }
            dc[i] = sl.swe_degnorm(ls[0] - lm[0]);
            if (dc[i] > 180) {
              dc[i] -= 360;
            }
            if (dc[i] > 180) {
              dc[i] -= 360;
            }
          }
          a = (dc[1] - dc[0]) / dt;
          if (a < 1e-10) {
            break;
          }
          dt1.val = dc[0] / a;
          tjd += dt1.val;
        }
        tret[1] = tjd;
      }
      break;
    } // while (true)
    return retflag;
    /*
     * the time of maximum occultation is practically identical
     * with the time of maximum core shadow diameter.
     *
     * the time, when duration of totality is maximal,
     * is not an interesting computation either. Near the maximum
     * occulation, the time of totality can be the same by
     * a second for hundreds of kilometers (for 10 minutes
     * or more).
     *
     * for annular eclipses the maximum duration is close to the
     * beginning and the end of the center lines, where is also
     * the minimum of core shadow diameter.
     */
  }

  /* When is the next lunar occultation anywhere on earth?
   * This function also finds solar eclipses, but is less efficient
   * than swe_sol_eclipse_when_glob().
   *
   * input parameters:
   *
   * tjd_start          start time for search (UT)
   * ipl                planet number of occulted body
   * starname           name of occulted star. Must be NULL or "", if a planetary
   *                    occultation is to be calculated. For the use of this
   *                    field, also see swe_fixstar().
   * ifl                      ephemeris to be used (SEFLG_SWIEPH, etc.)
   *                  ephemeris flag. If you want to have only one conjunction
   *                    of the moon with the body tested, add the following flag:
   *                    ifl |= SE_ECL_ONE_TRY. If this flag is not set,
   *                    the function will search for an occultation until it
   *                    finds one. For bodies with ecliptical latitudes > 5,
   *                    the function may search successlessly until it reaches
   *                    the end of the ephemeris.
   *
   * ifltype          eclipse type to be searched (SE_ECL_TOTAL, etc.)
   *                    0, if any type of eclipse is wanted
   *                    this functionality also works with occultations
   *
   * return values:
   *
   * retflag    SE_ECL_TOTAL or SE_ECL_ANNULAR or SE_ECL_PARTIAL
   *              or SE_ECL_ANNULAR_TOTAL
   *              SE_ECL_CENTRAL
   *              SE_ECL_NONCENTRAL
   *
   * tret[0]    time of maximum eclipse
   * tret[1]    time, when eclipse takes place at local apparent noon
   * tret[2]    time of eclipse begin
   * tret[3]    time of eclipse end
   * tret[4]    time of totality begin
   * tret[5]    time of totality end
   * tret[6]    time of center line begin
   * tret[7]    time of center line end
   * tret[8]    time when annular-total eclipse becomes total
   *               not implemented so far
   * tret[9]    time when annular-total eclipse becomes annular again
   *               not implemented so far
   *         declare as tret[10] at least!
   *
   */
  int swe_lun_occult_when_glob(
       double tjd_start, int ipl, StringBuffer starname, int ifl, int ifltype,
       double[] tret, int backward, StringBuffer serr) {
    int i, j, k, m, n, o, i1=0, i2=0;
    int retflag = 0, retflag2 = 0;
    double de = 6378.140, a;
    double t, tt, tjd=0, tjds, dt, dta, dtb;
    DblObj dtint=new DblObj();
    double drad;
    double xs[]=new double[6], xm[]=new double[6], ls[]=new double[6], lm[]=new double[6];
    double rmoon, rsun, dcore[]=new double[10];
    double dc[]=new double[20];
    DblObj dctr=new DblObj();
    double twohr = 2.0 / 24.0;
    double tenmin = 10.0 / 24.0 / 60.0;
    DblObj dt1=new DblObj(), dt2=new DblObj();
    double dadd = 10, dadd2 = 6;
    int nstartpos = 10;
    double geopos[]=new double[20];
    double dtstart, dtdiv;
    int direction = 1;
    int iflag, iflagcart;
    boolean dont_times = false;
    int one_try = backward & SweConst.SE_ECL_ONE_TRY;
    ifl &= SweConst.SEFLG_EPHMASK;
    iflag = SweConst.SEFLG_EQUATORIAL | ifl;
    iflagcart = iflag | SweConst.SEFLG_XYZ;
    backward &= 1L;
    /*
     * initializations
     */
    if (ifltype == (SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_CENTRAL)) {
      if (serr != null) {
        serr.setLength(0);
        serr.append("central partial eclipses do not exist");
      }
      return SweConst.ERR;
    }
    if (ifltype == 0)
      ifltype = SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_ANNULAR | SweConst.SE_ECL_PARTIAL
             | SweConst.SE_ECL_ANNULAR_TOTAL | SweConst.SE_ECL_NONCENTRAL | SweConst.SE_ECL_CENTRAL;
    retflag = 0;
    dont_times = false;
    if ((backward & SEI_OCC_FAST) != 0)
      dont_times = true;
    for (i = 0; i <= 9; i++)
      tret[i] = 0;
    if (backward!=0)
      direction = -1;
    t = tjd_start - direction * 0.001;
    while(true) {
//next_try:
      for (i = 0; i < nstartpos; i++, t += direction * dadd2) {
        if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SweConst.ERR)
            return SweConst.ERR;
        if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR)
            return SweConst.ERR;
        dc[i] = Math.acos(sl.swi_dot_prod_unit(xs, xm)) * SwissData.RADTODEG;
        if (i > 1 && dc[i] > dc[i-1] && dc[i-2] > dc[i-1]) {
          tjd = t - direction * dadd2;
          break;
        } else if (i == nstartpos-1) {
          for (j = 0; j < nstartpos; j++)
            //DevNull.print(dc[j] + " ");
          System.err.println("problem planet");
          System.exit(0);
        }
      }
      /*
       * radius of planet disk in AU
       */
      if (starname != null && starname.length() > 0)
        drad = 0;
      else if (ipl < SwephData.NDIAM)
        drad = SwephData.pla_diam[ipl] / 2 / SweConst.AUNIT;
      else if (ipl > SweConst.SE_AST_OFFSET)
        drad = swed.ast_diam / 2 * 1000 / SweConst.AUNIT; /* km -> m -> AU */
      else
        drad = 0;
      /*
       * time of maximum eclipse (if eclipse) =
       * minimum geocentric angle between sun and moon edges.
       * After this time has been determined, check
       * whether or not an eclipse is taking place with
       * the functions eclipse_where() and _how().
       */
      dtstart = dadd2; /* originally 1 */
      dtdiv = 3;
      for (dt = dtstart;
           dt > 0.0001;
           dt /= dtdiv) {
        for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
          if (calc_planet_star(t, ipl, starname, iflag, ls, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (sw.swe_calc(t, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR)
            return SweConst.ERR;
          dc[i] = Math.acos(sl.swi_dot_prod_unit(xs, xm)) * SwissData.RADTODEG;
          rmoon = Math.asin(RMOON / lm[2]) * SwissData.RADTODEG;
          rsun = Math.asin(drad / ls[2]) * SwissData.RADTODEG;
          dc[i] -= (rmoon + rsun);
        }
        find_maximum(dc[0], dc[1], dc[2], dt, dtint, dctr);
        tjd += dtint.val + dt;
      }
      tjd -= SweDate.getDeltaT(tjd);
      tjds = tjd;
      if ((retflag = eclipse_where(tjd, ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
        return retflag;
      retflag2 = retflag;
        /* in extreme cases _where() returns no eclipse, where there is
         * actually a very small one, therefore call _how() with the
         * coordinates returned by _where(): */
      /* if ((retflag2 = eclipse_how(tjd, ipl, starname, ifl, geopos[0], geopos[1], 0, attr, serr)) == SweConst.ERR)
        return retflag2; */
      if (retflag2 == 0) {
        /* only one try! */
        if (one_try!=0) {
          tret[0] = tjd;
          return 0;
        }
        t= tjd + direction * dadd;
//    goto next_try;
        continue;
      }
      tret[0] = tjd;
      if ((backward!=0 && tret[0] >= tjd_start - 0.0001)
        || (backward==0 && tret[0] <= tjd_start + 0.0001)) {
        t= tjd + direction * dadd;
//    goto next_try;
        continue;
      }
      /*
       * eclipse type, SE_ECL_TOTAL, _ANNULAR, etc.
       * SE_ECL_ANNULAR_TOTAL will be discovered later
       */
      if ((retflag = eclipse_where(tjd, ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
        return retflag;
      if (retflag == 0) { /* can happen with extremely small percentage */
        retflag = SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_NONCENTRAL;
        tret[4] = tret[5] = tjd;  /* fix this ???? */
        retflag = SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_NONCENTRAL;
        tret[4] = tret[5] = tjd;  /* fix this ???? */
        dont_times = true;
      }
      /*
       * check whether or not eclipse type found is wanted
       */
      /* non central eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_NONCENTRAL)==0 && (retflag & SweConst.SE_ECL_NONCENTRAL)!=0) {
        t= tjd + direction * dadd;
//    goto next_try;
        continue;
      }
      /* central eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_CENTRAL)==0 && (retflag & SweConst.SE_ECL_CENTRAL)!=0) {
        t= tjd + direction * dadd;
//    goto next_try;
        continue;
      }
      /* non annular eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_ANNULAR)==0 && (retflag & SweConst.SE_ECL_ANNULAR)!=0) {
        t= tjd + direction * dadd;
//    goto next_try;
        continue;
      }
      /* non partial eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_PARTIAL)==0 && (retflag & SweConst.SE_ECL_PARTIAL)!=0) {
        t= tjd + direction * dadd;
//    goto next_try;
        continue;
      }
      /* annular-total eclipse will be discovered later */
      if ((ifltype & (SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_ANNULAR_TOTAL))==0 && (retflag & SweConst.SE_ECL_TOTAL)!=0) {
        t= tjd + direction * dadd;
//    goto next_try;
        continue;
      }
      if (dont_times)
//        goto end_search_global;
        return retflag;
      /*
       * n = 0: times of eclipse begin and end
       * n = 1: times of totality begin and end
       * n = 2: times of center line begin and end
       */
      if ((retflag & SweConst.SE_ECL_PARTIAL)!=0)
        o = 0;
      else if ((retflag & SweConst.SE_ECL_NONCENTRAL)!=0)
        o = 1;
      else
        o = 2;
      dta = twohr;
      dtb = tenmin;
      for (n = 0; n <= o; n++) {
        if (n == 0) {
          /*dc[1] = dcore[3] / 2 + de - dcore[1];*/
          i1 = 2; i2 = 3;
        } else if (n == 1) {
          if ((retflag & SweConst.SE_ECL_PARTIAL)!=0)
            continue;
          i1 = 4; i2 = 5;
        } else if (n == 2) {
          if ((retflag & SweConst.SE_ECL_NONCENTRAL)!=0)
            continue;
          i1 = 6; i2 = 7;
        }
        for (i = 0, t = tjd - dta; i <= 2; i += 1, t += dta) {
          if ((retflag2 = eclipse_where(t, ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
            return retflag2;
          if (n == 0)
            dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
          else if (n == 1)
            dc[i] = Math.abs(dcore[3]) / 2 + de / dcore[6] - dcore[2];
          else if (n == 2)
            dc[i] = de / dcore[6] - dcore[2];
        }
        find_zero(dc[0], dc[1], dc[2], dta, dt1, dt2);
        tret[i1] = tjd + dt1.val + dta;
        tret[i2] = tjd + dt2.val + dta;
        for (m = 0, dt = dtb; m < 3; m++, dt /= 3) {
          for (j = i1; j <= i2; j += (i2 - i1)) {
            for (i = 0, t = tret[j] - dt; i < 2; i++, t += dt) {
              if ((retflag2 = eclipse_where(t, ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
                return retflag2;
              if (n == 0)
                dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
              else if (n == 1)
                dc[i] = Math.abs(dcore[3]) / 2 + de / dcore[6] - dcore[2];
              else if (n == 2)
                dc[i] = de / dcore[6] - dcore[2];
            }
            dt1.val = dc[1] / ((dc[1] - dc[0]) / dt);
            tret[j] -= dt1.val;
          }
        }
      }
      /*
       * annular-total eclipses
       */
      if ((retflag & SweConst.SE_ECL_TOTAL)!=0) {
        if ((retflag2 = eclipse_where(tret[0], ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
          return retflag2;
        dc[0] = dcore[0];
        if ((retflag2 = eclipse_where(tret[4], ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
          return retflag2;
        dc[1] = dcore[0];
        if ((retflag2 = eclipse_where(tret[5], ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
          return retflag2;
        dc[2] = dcore[0];
        /* the maximum is always total, and there is either one or
         * to times before and after, when the core shadow becomes
         * zero and totality changes into annularity or vice versa.
         */
        if (dc[0] * dc[1] < 0 || dc[0] * dc[2] < 0) {
          retflag |= SweConst.SE_ECL_ANNULAR_TOTAL;
          retflag &= ~SweConst.SE_ECL_TOTAL;
        }
      }
      /* if eclipse is given but not wanted: */
      if ((ifltype & SweConst.SE_ECL_TOTAL)==0 && (retflag & SweConst.SE_ECL_TOTAL)!=0) {
        t= tjd + direction * dadd;
//    goto next_try;
        continue;
      }
      /* if annular_total eclipse is given but not wanted: */
      if ((ifltype & SweConst.SE_ECL_ANNULAR_TOTAL)==0 && (retflag & SweConst.SE_ECL_ANNULAR_TOTAL)!=0) {
        t= tjd + direction * dadd;
//    goto next_try;
        continue;
      }
      /*
       * time of maximum eclipse at local apparent noon
       */
      /* first, find out, if there is a solar transit
       * between begin and end of eclipse */
      k = 2;
      for (i = 0; i < 2; i++) {
        j = i + k;
        tt = tret[j] + SweDate.getDeltaT(tret[j]);
        if (calc_planet_star(tt, ipl, starname, iflag, ls, serr) == SweConst.ERR)
            return SweConst.ERR;
        if (sw.swe_calc(tt, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR)
            return SweConst.ERR;
        dc[i] = sl.swe_degnorm(ls[0] - lm[0]);
        if (dc[i] > 180)
          dc[i] -= 360;
      }
      if (dc[0] * dc[1] >= 0)     /* no transit */
        tret[1] = 0;
      else {
        tjd = tjds;
        dt = 0.1;
        dt1.val = (tret[3] - tret[2]) / 2.0;
        if (dt1.val < dt)
          dt = dt1.val / 2.0;
        for (j = 0;
             dt > 0.01;
             j++, dt /= 3) {
          for (i = 0, t = tjd; i <= 1; i++, t -= dt) {
            tt = t + SweDate.getDeltaT(t);
            if (calc_planet_star(tt, ipl, starname, iflag, ls, serr) == SweConst.ERR)
              return SweConst.ERR;
            if (sw.swe_calc(tt, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR)
              return SweConst.ERR;
            dc[i] = sl.swe_degnorm(ls[0] - lm[0]);
            if (dc[i] > 180)
              dc[i] -= 360;
            if (dc[i] > 180)
              dc[i] -= 360;
          }
          a = (dc[1] - dc[0]) / dt;
          if (a < 1e-10)
            break;
          dt1.val = dc[0] / a;
          tjd += dt1.val;
        }
        tret[1] = tjd;
      }
      break;
    }
//end_search_global:
    return retflag;
    /*
     * the time of maximum occultation is practically identical
     * with the time of maximum core shadow diameter.
     *
     * the time, when duration of totality is maximal,
     * is not an interesting computation either. Near the maximum
     * occulation, the time of totality can be the same by
     * a second for hundreds of kilometers (for 10 minutes
     * or more).
     *
     * for annular eclipses the maximum duration is close to the
     * beginning and the end of the center lines, where is also
     * the minimum of core shadow diameter.
     * beginning and the end of the center lines, where is also
     * the minimum of core shadow diameter.
     */
  }
 
 

  /* When is the next solar eclipse at a given geographical position?
   * Note the uncertainty of Delta T for the remote past and for
   * the future.
   *
   * retflag        SE_ECL_TOTAL or SE_ECL_ANNULAR or SE_ECL_PARTIAL
   *              SE_ECL_VISIBLE,
   *              SE_ECL_MAX_VISIBLE,
   *              SE_ECL_1ST_VISIBLE, SE_ECL_2ND_VISIBLE
   *              SE_ECL_3ST_VISIBLE, SE_ECL_4ND_VISIBLE
   *
   * tret[0]        time of maximum eclipse
   * tret[1]        time of first contact
   * tret[2]        time of second contact
   * tret[3]        time of third contact
   * tret[4]        time of forth contact
   * tret[5]        time of sun rise between first and forth contact
                          (not implemented so far)
   * tret[6]        time of sun set beween first and forth contact
                          (not implemented so far)
   *
   * attr[0]        fraction of solar diameter covered by moon (magnitude)
   * attr[1]        ratio of lunar diameter to solar one
   * attr[2]        fraction of solar disc covered by moon (obscuration)
   * attr[3]      diameter of core shadow in km
   * attr[4]        azimuth of sun at tjd
   * attr[5]        true altitude of sun above horizon at tjd
   * attr[6]        apparent altitude of sun above horizon at tjd
   * attr[7]        elongation of moon in degrees
   *         declare as attr[20] at least !
   */

  int swe_sol_eclipse_when_loc(double tjd_start, int ifl,
                               double[] geopos, double[] tret,
                               double[] attr, int backward,
                               StringBuffer serr) {
    int retflag = 0, retflag2 = 0;
    double geopos2[]=new double[20], dcore[]=new double[10];
    ifl &= SweConst.SEFLG_EPHMASK;
    if ((retflag = eclipse_when_loc(tjd_start, ifl, geopos, tret, attr,
                                                        backward, serr)) <= 0) {
      return retflag;
    }
    /*
     * diameter of core shadow
     */
    if ((retflag2 = eclipse_where(tret[0], SweConst.SE_SUN, null, ifl, geopos2, dcore, serr)) ==
                                                                SweConst.ERR) {
      return retflag2;
    }
    retflag |= (retflag2 & SweConst.SE_ECL_NONCENTRAL);
    attr[3] = dcore[0];
    return retflag;
  }

  /* Same declaration as swe_sol_eclipse_when_loc().
   * In addition:
   * int32 ipl          planet number of occulted body
   * char* starname     name of occulted star. Must be NULL or "", if a planetary
   *                    occultation is to be calculated. For the use of this
   *                    field, also see swe_fixstar().
   * int32 ifl        ephemeris flag. If you want to have only one conjunction
   *                    of the moon with the body tested, add the following flag:
   *                    ifl |= SE_ECL_ONE_TRY. If this flag is not set,
   *                    the function will search for an occultation until it
   *                    finds one. For bodies with ecliptical latitudes > 5,
   *                    the function may search successlessly until it reaches
   *                    the end of the ephemeris.
   */
  int swe_lun_occult_when_loc(double tjd_start, int ipl, StringBuffer starname, int ifl,
       double[] geopos, double[] tret, double[] attr, int backward, StringBuffer serr) {
    int retflag = 0, retflag2 = 0;
    double geopos2[]=new double[20], dcore[]=new double[10];
    ifl &= SweConst.SEFLG_EPHMASK;
    if ((retflag = occult_when_loc(tjd_start, ipl, starname, ifl, geopos, tret, attr, backward, serr)) <= 0)
      return retflag;
    /*
     * diameter of core shadow
     */
    if ((retflag2 = eclipse_where(tret[0], ipl, starname, ifl, geopos2, dcore, serr)) == SweConst.ERR)
      return retflag2;
    retflag |= (retflag2 & SweConst.SE_ECL_NONCENTRAL);
    attr[3] = dcore[0];
    return retflag;
  }

  private int eclipse_when_loc(double tjd_start, int ifl, double[] geopos,
                               double[] tret, double[] attr, int backward,
                               StringBuffer serr) {
    int i, j, k, m;
    int retflag = 0;
    double t, tjd, dt, K, T, T2, T3, T4, F, M, Mm;
    DblObj dtint=new DblObj();
    double E, Ff, A1, Om;
    double xs[]=new double[6], xm[]=new double[6],
           ls[]=new double[6], lm[]=new double[6],
           x1[]=new double[6], x2[]=new double[6], dm, ds;
    double rmoon, rsun, rsplusrm, rsminusrm;
    double dc[]=new double[3], dctrmin;
    DblObj dctr=new DblObj();
    double twomin = 2.0 / 24.0 / 60.0;
    double tensec = 10.0 / 24.0 / 60.0 / 60.0;
    double twohr = 2.0 / 24.0;
    double tenmin = 10.0 / 24.0 / 60.0;
    DblObj dt1=new DblObj(), dt2=new DblObj();
    double dtdiv, dtstart;
    int iflag = SweConst.SEFLG_EQUATORIAL | SweConst.SEFLG_TOPOCTR | ifl;
    int iflagcart = iflag | SweConst.SEFLG_XYZ;
    sw.swe_set_topo(geopos[0], geopos[1], geopos[2]);
    K = (int) ((tjd_start - SwephData.J2000) / 365.2425 * 12.3685);
    if (backward!=0) {
      K++;
    } else {
      K--;
    }
//next_try:
    while (true) {
      T = K / 1236.85;
      T2 = T * T; T3 = T2 * T; T4 = T3 * T;
      Ff = F = sl.swe_degnorm(160.7108 + 390.67050274 * K
                   - 0.0016341 * T2
                   - 0.00000227 * T3
                   + 0.000000011 * T4);
      if (Ff > 180) {
        Ff -= 180;
      }
      if (Ff > 21 && Ff < 159) {         /* no eclipse possible */
        if (backward!=0) {
          K--;
        } else {
          K++;
        }
        continue;
      }
      /* approximate time of geocentric maximum eclipse.
       * formula from Meeus, German, p. 381 */
      tjd = 2451550.09765 + 29.530588853 * K
                          + 0.0001337 * T2
                          - 0.000000150 * T3
                          + 0.00000000073 * T4;
      M = sl.swe_degnorm(2.5534 + 29.10535669 * K
                          - 0.0000218 * T2
                          - 0.00000011 * T3);
      Mm = sl.swe_degnorm(201.5643 + 385.81693528 * K
                          + 0.1017438 * T2
                          + 0.00001239 * T3
                          + 0.000000058 * T4);
      Om = sl.swe_degnorm(124.7746 - 1.56375580 * K
                          + 0.0020691 * T2
                          + 0.00000215 * T3);
      E = 1 - 0.002516 * T - 0.0000074 * T2;
      A1 = sl.swe_degnorm(299.77 + 0.107408 * K - 0.009173 * T2);
      M *= SwissData.DEGTORAD;
      Mm *= SwissData.DEGTORAD;
      F *= SwissData.DEGTORAD;
      Om *= SwissData.DEGTORAD;
      A1 *= SwissData.DEGTORAD;
      tjd = tjd - 0.4075 * Math.sin(Mm)
                + 0.1721 * E * Math.sin(M);
      sw.swe_set_topo(geopos[0], geopos[1], geopos[2]);
      dtdiv = 2;
      dtstart = 0.5;
      if (tjd < 1900000) { /* because above formula is not good (delta t?) */
        dtstart = 2;
      }
      for (dt = dtstart;
           dt > 0.00001;
           dt /= dtdiv) {
        if (dt < 0.1) {
          dtdiv = 3;
        }
        for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
          /* this takes some time, but is necessary to avoid
           * missing an eclipse */
          if (sw.swe_calc(t, SweConst.SE_SUN, iflagcart, xs, serr) ==
                                                                SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_SUN, iflag, ls, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) ==
                                                                SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          dm = Math.sqrt(sl.square_sum(xm));
          ds = Math.sqrt(sl.square_sum(xs));
          for (k = 0; k < 3; k++) {
            x1[k] = xs[k] / ds /*ls[2]*/;
            x2[k] = xm[k] / dm /*lm[2]*/;
          }
          dc[i] = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
        }
        find_maximum(dc[0], dc[1], dc[2], dt, dtint, dctr);
        tjd += dtint.val + dt;
      }
      if (sw.swe_calc(tjd, SweConst.SE_SUN, iflagcart, xs, serr) ==
                                                                 SweConst.ERR) {
        return SweConst.ERR;
      }
      if (sw.swe_calc(tjd, SweConst.SE_SUN, iflag, ls, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
      if (sw.swe_calc(tjd, SweConst.SE_MOON, iflagcart, xm, serr) ==
                                                                 SweConst.ERR) {
        return SweConst.ERR;
      }
      if (sw.swe_calc(tjd, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
      dctr.val = Math.acos(sl.swi_dot_prod_unit(xs, xm)) * SwissData.RADTODEG;
      rmoon = Math.asin(RMOON / lm[2]) * SwissData.RADTODEG;
      rsun = Math.asin(RSUN / ls[2]) * SwissData.RADTODEG;
      rsplusrm = rsun + rmoon;
      rsminusrm = rsun - rmoon;
      if (dctr.val > rsplusrm) {
        if (backward!=0) {
          K--;
        } else {
          K++;
        }
        continue;
      }
      tret[0] = tjd - SweDate.getDeltaT(tjd);
      if ((backward!=0 && tret[0] >= tjd_start - 0.0001)
        || (backward==0 && tret[0] <= tjd_start + 0.0001)) {
        if (backward!=0) {
          K--;
        } else {
          K++;
        }
        continue;
      }
      if (dctr.val < rsminusrm) {
        retflag = SweConst.SE_ECL_ANNULAR;
      } else if (dctr.val < Math.abs(rsminusrm)) {
        retflag = SweConst.SE_ECL_TOTAL;
      } else if (dctr.val <= rsplusrm) {
        retflag = SweConst.SE_ECL_PARTIAL;
      }
      dctrmin = dctr.val;
      /* contacts 2 and 3 */
      if (dctr.val > Math.abs(rsminusrm)) {/* partial, no 2nd and 3rd contact */
        tret[2] = tret[3] = 0;
      } else {
        dc[1] = Math.abs(rsminusrm) - dctrmin;
        for (i = 0, t = tjd - twomin; i <= 2; i += 2, t = tjd + twomin) {
          if (sw.swe_calc(t, SweConst.SE_SUN, iflagcart, xs, serr) ==
                                                                 SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) ==
                                                                 SweConst.ERR) {
            return SweConst.ERR;
          }
          dm = Math.sqrt(sl.square_sum(xm));
          ds = Math.sqrt(sl.square_sum(xs));
          rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
          rsun = Math.asin(RSUN / ds) * SwissData.RADTODEG;
          rsminusrm = rsun - rmoon;
          for (k = 0; k < 3; k++) {
            x1[k] = xs[k] / ds /*ls[2]*/;
            x2[k] = xm[k] / dm /*lm[2]*/;
          }
          dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
          dc[i] = Math.abs(rsminusrm) - dctr.val;
        }
        find_zero(dc[0], dc[1], dc[2], twomin, dt1, dt2);
        tret[2] = tjd + dt1.val + twomin;
        tret[3] = tjd + dt2.val + twomin;
        for (m = 0, dt = tensec; m < 2; m++, dt /= 10) {
          for (j = 2; j <= 3; j++) {
            if (sw.swe_calc(tret[j], SweConst.SE_SUN,
                            iflagcart | SweConst.SEFLG_SPEED, xs, serr) ==
                                                                 SweConst.ERR) {
              return SweConst.ERR;
            }
            if (sw.swe_calc(tret[j], SweConst.SE_MOON,
                            iflagcart | SweConst.SEFLG_SPEED, xm, serr) ==
                                                                 SweConst.ERR) {
              return SweConst.ERR;
            }
            for (i = 0; i < 2; i++) {
              if (i == 1) {
                for(k = 0; k < 3; k++) {
                  xs[k] -= xs[k+3] * dt;
                  xm[k] -= xm[k+3] * dt;
                }
              }
              dm = Math.sqrt(sl.square_sum(xm));
              ds = Math.sqrt(sl.square_sum(xs));
              rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
              rsun = Math.asin(RSUN / ds) * SwissData.RADTODEG;
              rsminusrm = rsun - rmoon;
              for (k = 0; k < 3; k++) {
                x1[k] = xs[k] / ds /*ls[2]*/;
                x2[k] = xm[k] / dm /*lm[2]*/;
              }
              dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) *
                                                             SwissData.RADTODEG;
              dc[i] = Math.abs(rsminusrm) - dctr.val;
            }
            dt1.val = -dc[0] / ((dc[0] - dc[1]) / dt);
            tret[j] += dt1.val;
          }
        }
        tret[2] -= SweDate.getDeltaT(tret[2]);
        tret[3] -= SweDate.getDeltaT(tret[3]);
      }
      /* contacts 1 and 4 */
      dc[1] = rsplusrm - dctrmin;
      for (i = 0, t = tjd - twohr; i <= 2; i += 2, t = tjd + twohr) {
        if (sw.swe_calc(t, SweConst.SE_SUN, iflagcart, xs, serr) ==
                                                                 SweConst.ERR) {
          return SweConst.ERR;
        }
        if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) ==
                                                                 SweConst.ERR) {
          return SweConst.ERR;
        }
        dm = Math.sqrt(sl.square_sum(xm));
        ds = Math.sqrt(sl.square_sum(xs));
        rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
        rsun = Math.asin(RSUN / ds) * SwissData.RADTODEG;
        rsplusrm = rsun + rmoon;
        for (k = 0; k < 3; k++) {
          x1[k] = xs[k] / ds /*ls[2]*/;
          x2[k] = xm[k] / dm /*lm[2]*/;
        }
        dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
        dc[i] = rsplusrm - dctr.val;
      }
      find_zero(dc[0], dc[1], dc[2], twohr, dt1, dt2);
      tret[1] = tjd + dt1.val + twohr;
      tret[4] = tjd + dt2.val + twohr;
      for (m = 0, dt = tenmin; m < 3; m++, dt /= 10) {
        for (j = 1; j <= 4; j += 3) {
          if (sw.swe_calc(tret[j], SweConst.SE_SUN,
                          iflagcart | SweConst.SEFLG_SPEED, xs, serr) ==
                                                                 SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(tret[j], SweConst.SE_MOON,
                          iflagcart | SweConst.SEFLG_SPEED, xm, serr) ==
                                                                 SweConst.ERR) {
            return SweConst.ERR;
          }
          for (i = 0; i < 2; i++) {
            if (i == 1) {
              for(k = 0; k < 3; k++) {
                xs[k] -= xs[k+3] * dt;
                xm[k] -= xm[k+3] * dt;
              }
            }
            dm = Math.sqrt(sl.square_sum(xm));
            ds = Math.sqrt(sl.square_sum(xs));
            rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
            rsun = Math.asin(RSUN / ds) * SwissData.RADTODEG;
            rsplusrm = rsun + rmoon;
            for (k = 0; k < 3; k++) {
              x1[k] = xs[k] / ds /*ls[2]*/;
              x2[k] = xm[k] / dm /*lm[2]*/;
            }
            dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
            dc[i] = Math.abs(rsplusrm) - dctr.val;
          }
          dt1.val = -dc[0] / ((dc[0] - dc[1]) / dt);
          tret[j] += dt1.val;
        }
      }
      tret[1] -= SweDate.getDeltaT(tret[1]);
      tret[4] -= SweDate.getDeltaT(tret[4]);
      /*
       * visibility of eclipse phases
       */
      for (i = 4; i >= 0; i--) {        /* attr for i = 0 must be kept !!! */
        if (tret[i] == 0) {
          continue;
        }
        if (eclipse_how(tret[i], SweConst.SE_SUN, null, ifl, geopos[0], geopos[1], geopos[2],
                          attr, serr) == SweConst.ERR) {
          return SweConst.ERR;
        }
        /*if (retflag2 & SweConst.SE_ECL_VISIBLE) {} could be wrong for 1st/4th contact*/
        if (attr[5] > 0) {        /* this is save, sun above horizon */
          retflag |= SweConst.SE_ECL_VISIBLE;
          switch(i) {
          case 0: retflag |= SweConst.SE_ECL_MAX_VISIBLE; break;
          case 1: retflag |= SweConst.SE_ECL_1ST_VISIBLE; break;
          case 2: retflag |= SweConst.SE_ECL_2ND_VISIBLE; break;
          case 3: retflag |= SweConst.SE_ECL_3RD_VISIBLE; break;
          case 4: retflag |= SweConst.SE_ECL_4TH_VISIBLE; break;
          default:  break;
          }
        }
      }
      if ((retflag & SweConst.SE_ECL_VISIBLE)==0) {
        if (backward!=0) {
          K--;
        } else {
          K++;
        }
        continue;
      }
      break;
    } // while (true)
    return retflag;
  }

  private int occult_when_loc(double tjd_start, int ipl, StringBuffer starname,
      int ifl, double[] geopos, double[] tret, double[] attr,
      int backward, StringBuffer serr) {
    int i, j, k, m;
    int retflag = 0;
    double t, tjd, dt;
    DblObj dtint=new DblObj();
    double xs[]=new double[6], xm[]=new double[6], ls[]=new double[6], lm[]=new double[6], x1[]=new double[6], x2[]=new double[6], dm, ds;
    double rmoon, rsun, rsplusrm, rsminusrm;
    double dc[]=new double[20], dctrmin;
    DblObj dctr=new DblObj();
    double twomin = 2.0 / 24.0 / 60.0;
    double tensec = 10.0 / 24.0 / 60.0 / 60.0;
    double twohr = 2.0 / 24.0;
    double tenmin = 10.0 / 24.0 / 60.0;
    DblObj dt1=new DblObj(), dt2=new DblObj();
    double dtdiv, dtstart;
    double dadd2 = 6;
    int nstartpos = 10;
    double drad;
    int iflag = SweConst.SEFLG_TOPOCTR | ifl;
    int iflaggeo = iflag & ~SweConst.SEFLG_TOPOCTR;
    int iflagcart = iflag | SweConst.SEFLG_XYZ;
    int iflagcartgeo = iflaggeo | SweConst.SEFLG_XYZ;
    int direction = 1;
    int one_try = backward & SweConst.SE_ECL_ONE_TRY;
    boolean stop_after_this = false;
    backward &= 1L;
    retflag = 0;
    for (i = 0; i <= 9; i++)
      tret[i] = 0;
    if (backward!=0)
      direction = -1;
    t = tjd_start - direction * 0.1;
    tjd = tjd_start;
    while (true) {
//next_try:
      for (i = 0; i < nstartpos; i++, t += direction * dadd2) {
        if (calc_planet_star(t, ipl, starname, iflagcartgeo, xs, serr) == SweConst.ERR)
            return SweConst.ERR;
        if (sw.swe_calc(t, SweConst.SE_MOON, iflagcartgeo, xm, serr) == SweConst.ERR)
            return SweConst.ERR;
        dc[i] = Math.acos(sl.swi_dot_prod_unit(xs, xm)) * SwissData.RADTODEG;
        if (i > 1 && dc[i] > dc[i-1] && dc[i-2] > dc[i-1]) {
          tjd = t - direction*dadd2;
          break;
        } else if (i == nstartpos-1) {
          for (j = 0; j < nstartpos; j++)
              //DevNull.print(dc[j] + " ");
          DevNull.print("swe_lun_occult_when_loc(): problem planet\n");
          return SweConst.ERR;
        }
      }
      /*
       * radius of planet disk in AU
       */
      if (starname != null && starname.length() > 0)
        drad = 0;
      else if (ipl < SwephData.NDIAM)
        drad = SwephData.pla_diam[ipl] / 2 / SweConst.AUNIT;
      else if (ipl > SweConst.SE_AST_OFFSET)
        drad = swed.ast_diam / 2 * 1000 / SweConst.AUNIT; /* km -> m -> AU */
      else
        drad = 0;
      /* now find out, if there is an occultation at our geogr. location */
      dtdiv = 3;
      dtstart = dadd2; /* formerly 0.2 */
      for (dt = dtstart; 
           dt > 0.00001; 
           dt /= dtdiv) {
        if (dt < 0.01) 
          dtdiv = 3;
        for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
          /* this takes some time, but is necessary to avoid
           * missing an eclipse */
          if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (calc_planet_star(t, ipl, starname, iflag, ls, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (sw.swe_calc(t, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (dt < 1 && Math.abs(ls[1] - lm[1]) > 2) {
            if (one_try != 0) {
              stop_after_this = true;
            } else {
              t = tjd + direction * 2;
//goto next_try;
              continue;
            }
          }
          dc[i] = Math.acos(sl.swi_dot_prod_unit(xs, xm)) * SwissData.RADTODEG;
          rmoon = Math.asin(RMOON / lm[2]) * SwissData.RADTODEG;
          rsun = Math.asin(drad / ls[2]) * SwissData.RADTODEG;
          dc[i] -= (rmoon + rsun);
        }
        find_maximum(dc[0], dc[1], dc[2], dt, dtint, dctr);
        tjd += dtint.val + dt;
      }
      if (stop_after_this) { /* has one_try = TRUE */
        tret[0] = tjd;
        return 0;
      }
      if (calc_planet_star(tjd, ipl, starname, iflagcart, xs, serr) == SweConst.ERR)
        return SweConst.ERR;
      if (calc_planet_star(tjd, ipl, starname, iflag, ls, serr) == SweConst.ERR)
        return SweConst.ERR;
      if (sw.swe_calc(tjd, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR)
        return SweConst.ERR;
      if (sw.swe_calc(tjd, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR)
        return SweConst.ERR;
      dctr.val = Math.acos(sl.swi_dot_prod_unit(xs, xm)) * SwissData.RADTODEG;
      rmoon = Math.asin(RMOON / lm[2]) * SwissData.RADTODEG;
      rsun = Math.asin(drad / ls[2]) * SwissData.RADTODEG;
      rsplusrm = rsun + rmoon;
      rsminusrm = rsun - rmoon;
      if (dctr.val > rsplusrm) {
        if (one_try!=0) {
          tret[0] = tjd;
          return 0;
        }
        t = tjd + direction;
//    goto next_try;
        continue;
      }
      tret[0] = tjd - SweDate.getDeltaT(tjd);
      if ((backward!=0 && tret[0] >= tjd_start - 0.0001) 
        || (backward==0 && tret[0] <= tjd_start + 0.0001)) {
          t = tjd + direction;
//    goto next_try;
        continue;
      }
      if (dctr.val < rsminusrm)
        retflag = SweConst.SE_ECL_ANNULAR;
      else if (dctr.val < Math.abs(rsminusrm))
        retflag = SweConst.SE_ECL_TOTAL;
      else if (dctr.val <= rsplusrm)
        retflag = SweConst.SE_ECL_PARTIAL;
      dctrmin = dctr.val;
      /* contacts 2 and 3 */
      if (dctr.val > Math.abs(rsminusrm))  /* partial, no 2nd and 3rd contact */
        tret[2] = tret[3] = 0;
      else {
        dc[1] = Math.abs(rsminusrm) - dctrmin;
        for (i = 0, t = tjd - twomin; i <= 2; i += 2, t = tjd + twomin) {
          if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR)
            return SweConst.ERR;
          dm = Math.sqrt(sl.square_sum(xm));
          ds = Math.sqrt(sl.square_sum(xs));
          rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
          rsun = Math.asin(drad / ds) * SwissData.RADTODEG;
          rsminusrm = rsun - rmoon;
          for (k = 0; k < 3; k++) {
            x1[k] = xs[k] / ds /*ls[2]*/;
            x2[k] = xm[k] / dm /*lm[2]*/;
          }
          dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
          dc[i] = Math.abs(rsminusrm) - dctr.val;
        }
        find_zero(dc[0], dc[1], dc[2], twomin, dt1, dt2);
        tret[2] = tjd + dt1.val + twomin;
        tret[3] = tjd + dt2.val + twomin;
        for (m = 0, dt = tensec; m < 2; m++, dt /= 10) {
          for (j = 2; j <= 3; j++) {
            if (calc_planet_star(tret[j], ipl, starname, iflagcart | SweConst.SEFLG_SPEED, xs, serr) == SweConst.ERR)
              return SweConst.ERR;
            if (sw.swe_calc(tret[j], SweConst.SE_MOON, iflagcart | SweConst.SEFLG_SPEED, xm, serr) == SweConst.ERR)
              return SweConst.ERR;
            for (i = 0; i < 2; i++) {
              if (i == 1) {
                for(k = 0; k < 3; k++) {
                  xs[k] -= xs[k+3] * dt;
                  xm[k] -= xm[k+3] * dt;
                }
              }
              dm = Math.sqrt(sl.square_sum(xm));
              ds = Math.sqrt(sl.square_sum(xs));
              rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
              rsun = Math.asin(drad / ds) * SwissData.RADTODEG;
              rsminusrm = rsun - rmoon;
              for (k = 0; k < 3; k++) {
                x1[k] = xs[k] / ds /*ls[2]*/;
                x2[k] = xm[k] / dm /*lm[2]*/;
              }
              dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
              dc[i] = Math.abs(rsminusrm) - dctr.val;
            }
            dt1.val = -dc[0] / ((dc[0] - dc[1]) / dt);
            tret[j] += dt1.val;
          }
        }
        tret[2] -= SweDate.getDeltaT(tret[2]);
        tret[3] -= SweDate.getDeltaT(tret[3]);
      }
      /* contacts 1 and 4 */
      dc[1] = rsplusrm - dctrmin;
      for (i = 0, t = tjd - twohr; i <= 2; i += 2, t = tjd + twohr) {
        if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SweConst.ERR)
          return SweConst.ERR;
        if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR)
          return SweConst.ERR;
        dm = Math.sqrt(sl.square_sum(xm));
        ds = Math.sqrt(sl.square_sum(xs));
        rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
        rsun = Math.asin(drad / ds) * SwissData.RADTODEG;
        rsplusrm = rsun + rmoon;
        for (k = 0; k < 3; k++) {
          x1[k] = xs[k] / ds /*ls[2]*/;
          x2[k] = xm[k] / dm /*lm[2]*/;
        }
        dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
        dc[i] = rsplusrm - dctr.val;
      }
      find_zero(dc[0], dc[1], dc[2], twohr, dt1, dt2);
      tret[1] = tjd + dt1.val + twohr;
      tret[4] = tjd + dt2.val + twohr;
      for (m = 0, dt = tenmin; m < 3; m++, dt /= 10) {
        for (j = 1; j <= 4; j += 3) {
          if (calc_planet_star(tret[j], ipl, starname, iflagcart | SweConst.SEFLG_SPEED, xs, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (sw.swe_calc(tret[j], SweConst.SE_MOON, iflagcart | SweConst.SEFLG_SPEED, xm, serr) == SweConst.ERR)
            return SweConst.ERR;
          for (i = 0; i < 2; i++) {
            if (i == 1) {
              for(k = 0; k < 3; k++) {
                xs[k] -= xs[k+3] * dt;
                xm[k] -= xm[k+3] * dt;
              }
            }
            dm = Math.sqrt(sl.square_sum(xm));
            ds = Math.sqrt(sl.square_sum(xs));
            rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
            rsun = Math.asin(drad / ds) * SwissData.RADTODEG;
            rsplusrm = rsun + rmoon;
            for (k = 0; k < 3; k++) {
              x1[k] = xs[k] / ds /*ls[2]*/;
              x2[k] = xm[k] / dm /*lm[2]*/;
            }
            dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
            dc[i] = Math.abs(rsplusrm) - dctr.val;
          }
          dt1.val = -dc[0] / ((dc[0] - dc[1]) / dt);
          tret[j] += dt1.val;
        }
      }
      tret[1] -= SweDate.getDeltaT(tret[1]);
      tret[4] -= SweDate.getDeltaT(tret[4]);
      /*  
       * visibility of eclipse phases 
       */
      for (i = 4; i >= 0; i--) {	/* attr for i = 0 must be kept !!! */
        if (tret[i] == 0)
          continue;
        if (eclipse_how(tret[i], ipl, starname, ifl, geopos[0], geopos[1], geopos[2], 
    		attr, serr) == SweConst.ERR)
          return SweConst.ERR;
        /*if (retflag2 & SweConst.SE_ECL_VISIBLE) { could be wrong for 1st/4th contact } */
        if (attr[5] > 0) {	/* this is save, sun above horizon */
          retflag |= SweConst.SE_ECL_VISIBLE;
          switch(i) {
          case 0: retflag |= SweConst.SE_ECL_MAX_VISIBLE; break;
          case 1: retflag |= SweConst.SE_ECL_1ST_VISIBLE; break;
          case 2: retflag |= SweConst.SE_ECL_2ND_VISIBLE; break;
          case 3: retflag |= SweConst.SE_ECL_3RD_VISIBLE; break;
          case 4: retflag |= SweConst.SE_ECL_4TH_VISIBLE; break;
          default:  break;
          }
        }
      }
      if ((retflag & SweConst.SE_ECL_VISIBLE)==0) {
        t = tjd + direction;
//    goto next_try;
        continue;
      }
      break; // next_try
    } // while (true) .. [goto next_try]
    return retflag;
  }

  /*
   * swe_azalt()
   * Computes azimut and height, from either ecliptic or
   * equatorial coordinates
   *
   * input:
   *   tjd_ut
   *   iflag        either SE_ECL2HOR or SE_EQU2HOR
   *   geopos[3]    geograph. longitude, latitude, height above sea
   *   atpress      atmospheric pressure at geopos in millibars (hPa)
   *   attemp       atmospheric temperature in degrees C
   *   xin[2]       input coordinates polar, in degrees
   *
   * Horizontal coordinates are returned in
   *   xaz[3]       xaz[0] = azimuth
   *                xaz[1] = true altitude
   *                xaz[2] = apparent altitude
   *
   * If atpress is not given (= 0), the programm assumes 1013.25 mbar;
   * if a non-zero height above sea is given, atpress is estimated.
   *   geohgt       height of observer above sea (optional)
   */
  
  void swe_azalt(double tjd_ut,
                 int calc_flag,
                 double[] geopos,
                 double atpress,
                 double attemp,
                 double[] xin,
                 double[] xaz) {
    int i;
    double x[]=new double[6], xra[]=new double[3];
    double armc = sl.swe_degnorm(sl.swe_sidtime(tjd_ut) * 15 + geopos[0]);
    double mdd, eps_true, tjd_et;
    for (i = 0; i < 2; i++)
      xra[i] = xin[i];
    xra[2] = 1;
    if (calc_flag == SweConst.SE_ECL2HOR) {
          tjd_et = tjd_ut + SweDate.getDeltaT(tjd_ut);
      sw.swe_calc(tjd_et, SweConst.SE_ECL_NUT, 0, x, null);
      eps_true = x[0];
          sl.swe_cotrans(xra, 0, xra, 0, -eps_true);
    }
    mdd = sl.swe_degnorm(xra[0] - armc);
    x[0] = sl.swe_degnorm(mdd - 90);
    x[1] = xra[1];
    x[2] = 1;
    /* azimuth from east, counterclock */
    sl.swe_cotrans(x, 0, x, 0, 90 - geopos[1]);
    /* azimuth from south to west */
    x[0] = sl.swe_degnorm(x[0] + 90);
    xaz[0] = 360 - x[0];
    xaz[1] = x[1];                /* true height */
    if (atpress == 0) {
      /* estimate atmospheric pressure */
      atpress = 1013.25 * Math.pow(1 - 0.0065 * geopos[2] / 288, 5.255);
    }
    xaz[2] = swe_refrac(x[1], atpress, attemp, SweConst.SE_TRUE_TO_APP);
  }

  /*
   * swe_azalt_rev()
   * computes either ecliptical or equatorial coordinates from
   * azimuth and true altitude in degrees.
   * For conversion between true and apparent altitude, there is
   * the function swe_refrac().
   *
   * input:
   *   tjd_ut
   *   iflag        either SE_HOR2ECL or SE_HOR2EQU
   *   xin[2]       azimut and true altitude, in degrees
   */
  
  void swe_azalt_rev(double tjd_ut,
                     int calc_flag,
                     double[] geopos,
                     double[] xin,
                     double[] xout) {
    int i;
    double x[]=new double[6], xaz[]=new double[3];
    double geolon = geopos[0];
    double geolat = geopos[1];
    double armc = sl.swe_degnorm(sl.swe_sidtime(tjd_ut) * 15 + geolon);
    double eps_true, tjd_et;
    for (i = 0; i < 2; i++)
      xaz[i] = xin[i];
    xaz[2] = 1;
    /* azimuth is from south, clockwise.
     * we need it from east, counterclock */
    xaz[0] = 360 - xaz[0];
    xaz[0] = sl.swe_degnorm(xaz[0] - 90);
    /* equatorial positions */
    sl.swe_cotrans(xaz, 0, xaz, 0, geolat - 90);
    xaz[0] = sl.swe_degnorm(xaz[0] + armc + 90);
    xout[0] = xaz[0];
    xout[1] = xaz[1];
    /* ecliptic positions */
    if (calc_flag == SweConst.SE_HOR2ECL) {
      tjd_et = tjd_ut + SweDate.getDeltaT(tjd_ut);
      sw.swe_calc(tjd_et, SweConst.SE_ECL_NUT, 0, x, null);
      eps_true = x[0];
      sl.swe_cotrans(xaz, 0, x, 0, eps_true);
      xout[0] = x[0];
      xout[1] = x[1];
    }
  }

  /* swe_refrac()
   * Transforms apparent to true altitude and vice-versa.
   * These formulae do not handle the case when the
   * sun is visible below the geometrical horizon
   * (from a mountain top or an air plane)
   * input:
   * double inalt;        * altitude of object in degrees *
   * double atpress;      * millibars (hectopascal) *
   * double attemp;       * degrees C *
   * int32  calc_flag;    * either SE_CALC_APP_TO_TRUE or
   *                      *        SE_CALC_TRUE_TO_APP
   */
  
  double swe_refrac(double inalt, double atpress, double attemp,
                    int calc_flag) {
    double a, refr;
    double pt_factor = atpress / 1010.0 * 283.0 / (273.0 + attemp);
    double trualt, appalt;
    /* another algorithm, from Meeus, German, p. 114ff.
     */
    if (calc_flag == SweConst.SE_TRUE_TO_APP) {
      trualt = inalt;
      if (trualt > 15) {
        a = Math.tan((90 - trualt) * SwissData.DEGTORAD);
        refr = (58.276 * a - 0.0824 * a * a * a);
        refr *=  pt_factor / 3600.0;
      } else if (trualt > -5) {
        /* the following tan is not defined for a value
         * of trualt near -5.00158 and 89.89158 */
        a = trualt + 10.3 / (trualt + 5.11);
        if (a + 1e-10 >= 90) {
          refr = 0;
        } else {
          refr = 1.02 / Math.tan(a * SwissData.DEGTORAD);
        }
        refr *= pt_factor / 60.0;
      } else {
        refr = 0;
      }
      appalt = trualt;
      if (appalt + refr > 0) {
        appalt += refr;
      }
      return appalt;
    } else { // SE_TRUE_TO_APP
      appalt = inalt;
      if (appalt > 15) {
        a = Math.tan((90 - appalt) * SwissData.DEGTORAD);
        refr = (58.294 * a - 0.0668 * a * a * a);
        refr *=  pt_factor / 3600.0;
      } else {
        /* the following tan is not defined for a value
         * of inalt near -4.3285 and 89.9225 */
        a = appalt + 7.31 / (appalt + 4.4);
        if (a + 1e-10 >= 90) {
          refr = 0;
        } else {
          refr = 1.00 / Math.tan(a * SwissData.DEGTORAD);
          refr -= 0.06 * Math.sin(14.7 * refr + 13);
        }
        refr *= pt_factor / 60.0;
      }
      trualt = appalt;
      if (trualt - refr > 0) {
        trualt -= refr;
      }
      return trualt;
    }
  }

  /* Computes attributes of a lunar eclipse for given tjd and geopos
   *
   * retflag        SE_ECL_TOTAL or SE_ECL_PARTIAL
   *              SE_ECL_PENUMBRAL
   *              if 0, there is no eclipse
   *
   * attr[0]        umbral magnitude at tjd
   * attr[1]      penumbral magnitude
   * attr[7]        distance of moon from opposition in degrees
   *         declare as attr[20] at least !
   *
   */
  
  int swe_lun_eclipse_how(double tjd_ut,
                          int ifl,
                          double[] geopos,
                          double[] attr,
                          StringBuffer serr) {
    double dcore[]=new double[10];
    /* attention: geopos[] is not used so far; may be null */
    // geopos[0] = geopos[0]; /* to shut up mint */
    ifl = ifl & ~SweConst.SEFLG_TOPOCTR;
    return lun_eclipse_how(tjd_ut, ifl, attr, dcore, serr);
  }

  /*
   * attr[]:         see swe_lun_eclipse_how()
   *
   * dcore[0]:        distance of shadow axis from geocenter r0
   * dcore[1]:        diameter of core shadow on fundamental plane d0
   * dcore[2]:        diameter of half-shadow on fundamental plane D0
   */
  private int lun_eclipse_how(double tjd_ut,
                              int ifl,
                              double[] attr,
                              double[] dcore,
                              StringBuffer serr) {
    int i;
    int retc = 0;
    double e[]=new double[6], rm[]=new double[6], rs[]=new double[6];
    double dsm, d0, D0, s0, r0, ds, dm;
    double dctr, x1[]=new double[6], x2[]=new double[6];
    double f1, f2;
    double deltat, tjd;
    double cosf1, cosf2;
    int iflag;
    for (i = 0; i < 10; i++)
      dcore[i] = 0;
    for (i = 0; i < 20; i++)
      attr[i] = 0;
    /* nutation need not be in lunar and solar positions,
     * if mean sidereal time will be used */
    iflag = SweConst.SEFLG_SPEED | SweConst.SEFLG_EQUATORIAL | ifl;
    iflag  = iflag | SweConst.SEFLG_XYZ;
    deltat = SweDate.getDeltaT(tjd_ut);
    tjd = tjd_ut + deltat;
    /* moon in cartesian coordinates */
    if (sw.swe_calc(tjd, SweConst.SE_MOON, iflag, rm, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    /* distance of moon from geocenter */
    dm = Math.sqrt(sl.square_sum(rm));
    /* sun in cartesian coordinates */
    if (sw.swe_calc(tjd, SweConst.SE_SUN, iflag, rs, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    /* distance of sun from geocenter */
    ds = Math.sqrt(sl.square_sum(rs));
    for (i = 0; i < 3; i++) {
      x1[i] = rs[i] / ds;
      x2[i] = rm[i] / dm;
    }
    dctr = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
    /* selenocentric sun */
    for (i = 0; i <= 2; i++)
      rs[i] -= rm[i];
    /* selenocentric earth */
    for (i = 0; i <= 2; i++)
      rm[i] = -rm[i];
    /* sun - earth vector */
    for (i = 0; i <= 2; i++)
      e[i] = (rm[i] - rs[i]);
    /* distance sun - earth */
    dsm = Math.sqrt(sl.square_sum(e));
    /* sun - earth unit vector */
    for (i = 0; i <= 2; i++)
      e[i] /= dsm;
    f1 = ((RSUN - REARTH) / dsm);
    cosf1 = Math.sqrt(1 - f1 * f1);
    f2 = ((RSUN + REARTH) / dsm);
    cosf2 = Math.sqrt(1 - f2 * f2);
    /* distance of earth from fundamental plane */
    s0 = -sw.dot_prod(rm, e);
    /* distance of shadow axis from selenocenter */
    r0 = Math.sqrt(dm * dm - s0 * s0);
    /* diameter of core shadow on fundamental plane */
    d0 = Math.abs(s0 / dsm * (DSUN - DEARTH) - DEARTH) * (1 + 1.0 / 50) / cosf1;
           /* one 50th is added for effect of atmosphere, AA98, L4 */
    /* diameter of half-shadow on fundamental plane */
    D0 = (s0 / dsm * (DSUN + DEARTH) + DEARTH) * (1 + 1.0 / 50) / cosf2;
    d0 /= cosf1;
    D0 /= cosf2;
    dcore[0] = r0;
    dcore[1] = d0;
    dcore[2] = D0;
    dcore[3] = cosf1;
    dcore[4] = cosf2;
    
    retc = 0;
    if (d0 / 2 >= r0 + RMOON / cosf1) {
      retc = SweConst.SE_ECL_TOTAL;
      attr[0] = (d0 / 2 - r0 + RMOON) / DMOON;
    } else if (d0 / 2 >= r0 - RMOON / cosf1) {
      retc = SweConst.SE_ECL_PARTIAL;
      attr[0] = (d0 / 2 - r0 + RMOON) / DMOON;
    } else if (D0 / 2 >= r0 - RMOON / cosf2) {
      retc = SweConst.SE_ECL_PENUMBRAL;
      attr[0] = 0;
    } else {
      if (serr != null) {
        serr.setLength(0);
        serr.append("no lunar eclipse at tjd = "+tjd);
      }
    }
    
    attr[1] = (D0 / 2 - r0 + RMOON) / DMOON;
    if (retc != 0) {
      attr[7] = 180 - Math.abs(dctr);
    }
    return retc;
  }

  /* When is the next lunar eclipse?
   *
   * retflag        SE_ECL_TOTAL or SE_ECL_PENUMBRAL or SE_ECL_PARTIAL
   *
   * tret[0]        time of maximum eclipse
   * tret[1]
   * tret[2]        time of partial phase begin (indices consistent with solar eclipses)
   * tret[3]        time of partial phase end
   * tret[4]        time of totality begin
   * tret[5]        time of totality end
   * tret[6]        time of penumbral phase begin
   * tret[7]        time of penumbral phase end
   */
  
  int swe_lun_eclipse_when(double tjd_start, int ifl, int ifltype,
                           double[] tret, int backward,
                           StringBuffer serr) {
    int i, j, m, n, o, i1 = 0, i2 = 0;
    int retflag = 0, retflag2 = 0;
    double t, tjd, dt, dta, dtb;
    DblObj dtint=new DblObj();
    double T, T2, T3, T4, K, F, M, Mm;
    double E, Ff, F1, A1, Om;
    double xs[]=new double[6], xm[]=new double[6], dm, ds;
    double rsun, rearth, dcore[]=new double[10];
    double dc[]=new double[3];
    DblObj dctr=new DblObj();
    double twohr = 2.0 / 24.0;
    double tenmin = 10.0 / 24.0 / 60.0;
    DblObj dt1=new DblObj(), dt2=new DblObj();
    double kk;
    double attr[]=new double[20];
    double dtstart, dtdiv;
    double xa[]=new double[6], xb[]=new double[6];
    int direction = 1;
    int iflag;
    int iflagcart;
    ifl &= SweConst.SEFLG_EPHMASK;
    iflag = SweConst.SEFLG_EQUATORIAL | ifl;
    iflagcart = iflag | SweConst.SEFLG_XYZ;
    if (ifltype == 0) {
      ifltype = SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_PENUMBRAL |
                SweConst.SE_ECL_PARTIAL;
    }
    if (backward!=0) {
      direction = -1;
    }
    K = (int) ((tjd_start - SwephData.J2000) / 365.2425 * 12.3685);
    K -= direction;
//next_try:
    while (true) {
      retflag = 0;
      for (i = 0; i <= 9; i++)
        tret[i] = 0;
      kk = K + 0.5;
      T = kk / 1236.85;
      T2 = T * T; T3 = T2 * T; T4 = T3 * T;
      Ff = F = sl.swe_degnorm(160.7108 + 390.67050274 * kk
                   - 0.0016341 * T2
                   - 0.00000227 * T3
                   + 0.000000011 * T4);
      if (Ff > 180) {
        Ff -= 180;
      }
      if (Ff > 21 && Ff < 159) {         /* no eclipse possible */
        K += direction;
        continue;
      }
      /* approximate time of geocentric maximum eclipse
       * formula from Meeus, German, p. 381 */
      tjd = 2451550.09765 + 29.530588853 * kk
                          + 0.0001337 * T2
                          - 0.000000150 * T3
                          + 0.00000000073 * T4;
      M = sl.swe_degnorm(2.5534 + 29.10535669 * kk
                          - 0.0000218 * T2
                          - 0.00000011 * T3);
      Mm = sl.swe_degnorm(201.5643 + 385.81693528 * kk
                          + 0.1017438 * T2
                          + 0.00001239 * T3
                          + 0.000000058 * T4);
      Om = sl.swe_degnorm(124.7746 - 1.56375580 * kk
                          + 0.0020691 * T2
                          + 0.00000215 * T3);
      E = 1 - 0.002516 * T - 0.0000074 * T2;
      A1 = sl.swe_degnorm(299.77 + 0.107408 * kk - 0.009173 * T2);
      M *= SwissData.DEGTORAD;
      Mm *= SwissData.DEGTORAD;
      F *= SwissData.DEGTORAD;
      Om *= SwissData.DEGTORAD;
      F1 = F - 0.02665 * Math.sin(Om) * SwissData.DEGTORAD;
      A1 *= SwissData.DEGTORAD;
      tjd = tjd - 0.4075 * Math.sin(Mm)
                + 0.1721 * E * Math.sin(M)
                + 0.0161 * Math.sin(2 * Mm)
                - 0.0097 * Math.sin(2 * F1)
                + 0.0073 * E * Math.sin(Mm - M)
                - 0.0050 * E * Math.sin(Mm + M)
                - 0.0023 * Math.sin(Mm - 2 * F1)
                + 0.0021 * E * Math.sin(2 * M)
                + 0.0012 * Math.sin(Mm + 2 * F1)
                + 0.0006 * E * Math.sin(2 * Mm + M)
                - 0.0004 * Math.sin(3 * Mm)
                - 0.0003 * E * Math.sin(M + 2 * F1)
                + 0.0003 * Math.sin(A1)
                - 0.0002 * E * Math.sin(M - 2 * F1)
                - 0.0002 * E * Math.sin(2 * Mm - M)
                - 0.0002 * Math.sin(Om);
      /*
       * precise computation:
       * time of maximum eclipse (if eclipse) =
       * minimum selenocentric angle between sun and earth edges.
       * After this time has been determined, check
       * whether or not an eclipse is taking place with
       * the function lun_eclipse_how().
       */
      dtstart = 0.1;
      if (tjd < 2000000) {
        dtstart = 5;
      }
      dtdiv = 4;
      for (j = 0, dt = dtstart;
           dt > 0.001;
           j++, dt /= dtdiv) {
        for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
          if (sw.swe_calc(t, SweConst.SE_SUN, iflagcart, xs, serr) ==
                                                                 SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) ==
                                                                 SweConst.ERR) {
            return SweConst.ERR;
          }
          for (m = 0; m < 3; m++) {
            xs[m] -= xm[m];        /* selenocentric sun */
            xm[m] = -xm[m];        /* selenocentric earth */
          }
          ds = Math.sqrt(sl.square_sum(xs));
          dm = Math.sqrt(sl.square_sum(xm));
          for (m = 0; m < 3; m++) {
            xa[m] = xs[m] / ds;
            xb[m] = xm[m] / dm;
          }
          dc[i] = Math.acos(sl.swi_dot_prod_unit(xa, xb)) * SwissData.RADTODEG;
          rearth = Math.asin(REARTH / dm) * SwissData.RADTODEG;
          rsun = Math.asin(RSUN / ds) * SwissData.RADTODEG;
          dc[i] -= (rearth + rsun);
        }
        find_maximum(dc[0], dc[1], dc[2], dt, dtint, dctr);
        tjd += dtint.val + dt;
      }
      tjd = tjd - SweDate.getDeltaT(tjd);
      if ((retflag = swe_lun_eclipse_how(tjd, ifl, null, attr, serr)) ==
                                                                 SweConst.ERR) {
        return retflag;
      }
      if (retflag == 0) {
        K += direction;
        continue;
      }
      tret[0] = tjd;
      if ((backward!=0 && tret[0] >= tjd_start - 0.0001)
        || (backward==0 && tret[0] <= tjd_start + 0.0001)) {
        K += direction;
        continue;
      }
      /*
       * check whether or not eclipse type found is wanted
       */
      /* non penumbral eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_PENUMBRAL)==0 &&
          (retflag & SweConst.SE_ECL_PENUMBRAL)!=0) {
        K += direction;
        continue;
      }
      /* non partial eclipse is wanted: */
      if ((ifltype & SweConst.SE_ECL_PARTIAL)==0 &&
          (retflag & SweConst.SE_ECL_PARTIAL)!=0) {
        K += direction;
        continue;
      }
      /* annular-total eclipse will be discovered later */
      if ((ifltype & (SweConst.SE_ECL_TOTAL))==0 &&
          (retflag & SweConst.SE_ECL_TOTAL)!=0) {
        K += direction;
        continue;
      }
      /*
       * n = 0: times of eclipse begin and end
       * n = 1: times of totality begin and end
       * n = 2: times of center line begin and end
       */
      if ((retflag & SweConst.SE_ECL_PENUMBRAL)!=0) {
        o = 0;
      } else if ((retflag & SweConst.SE_ECL_PARTIAL)!=0) {
        o = 1;
      } else {
        o = 2;
      }
      dta = twohr;
      dtb = tenmin;
      for (n = 0; n <= o; n++) {
        if (n == 0) {
          i1 = 6; i2 = 7;
        } else if (n == 1) {
          i1 = 2; i2 = 3;
        } else if (n == 2) {
          i1 = 4; i2 = 5;
        }
        for (i = 0, t = tjd - dta; i <= 2; i += 1, t += dta) {
          if ((retflag2 = lun_eclipse_how(t, ifl, attr, dcore, serr)) ==
                                                                 SweConst.ERR) {
            return retflag2;
          }
          if (n == 0) {
            dc[i] = dcore[2] / 2 + RMOON / dcore[4] - dcore[0];
          } else if (n == 1) {
            dc[i] = dcore[1] / 2 + RMOON / dcore[3] - dcore[0];
          } else if (n == 2) {
            dc[i] = dcore[1] / 2 - RMOON / dcore[3] - dcore[0];
          }
        }
        find_zero(dc[0], dc[1], dc[2], dta, dt1, dt2);
        dtb = (dt1.val + dta) / 2;
        tret[i1] = tjd + dt1.val + dta;
        tret[i2] = tjd + dt2.val + dta;
        for (m = 0, dt = dtb / 2; m < 3; m++, dt /= 2) {
          for (j = i1; j <= i2; j += (i2 - i1)) {
            for (i = 0, t = tret[j] - dt; i < 2; i++, t += dt) {
              if ((retflag2 = lun_eclipse_how(t, ifl, attr, dcore, serr)) ==
                                                                 SweConst.ERR) {
                return retflag2;
              }
              if (n == 0) {
                dc[i] = dcore[2] / 2 + RMOON / dcore[4] - dcore[0];
              } else if (n == 1) {
                dc[i] = dcore[1] / 2 + RMOON / dcore[3] - dcore[0];
              } else if (n == 2) {
                dc[i] = dcore[1] / 2 - RMOON / dcore[3] - dcore[0];
              }
            }
            dt1.val = dc[1] / ((dc[1] - dc[0]) / dt);
            tret[j] -= dt1.val;
          }
        }
      }
      break;
    } // while (true)
    return retflag;
  }

  /*
   * function calculates planetary phenomena
   *
   * attr[0] = phase angle (earth-planet-sun)
   * attr[1] = phase (illumined fraction of disc)
   * attr[2] = elongation of planet
   * attr[3] = apparent diameter of disc
   * attr[4] = apparent magnitude
   *         declare as attr[20] at least !
   *
   * Note: the lunar magnitude is quite a complicated thing,
   * but our algorithm is very simple.
   * The phase of the moon, its distance from the earth and
   * the sun is considered, but no other factors.
   *
   */
  private static final double EULER=2.718281828459;
  private static final int NMAG_ELEM=SweConst.SE_VESTA + 1;

  private static final double mag_elem[][] = {
                  /* DTV-Atlas Astronomie, p. 32 */
                  {-26.86, 0, 0, 0},
                  {-12.55, 0, 0, 0},
                  /* IAU 1986 */
                  {-0.42, 3.80, -2.73, 2.00},
                  {-4.40, 0.09, 2.39, -0.65},
                  {- 1.52, 1.60, 0, 0},   /* Mars */
                  {- 9.40, 0.5, 0, 0},    /* Jupiter */
                  {- 8.88, -2.60, 1.25, 0.044},   /* Saturn */
                  {- 7.19, 0.0, 0, 0},    /* Uranus */
                  {- 6.87, 0.0, 0, 0},    /* Neptune */
                  {- 1.00, 0.0, 0, 0},    /* Pluto */
                  {99, 0, 0, 0},          /* nodes and apogees */
                  {99, 0, 0, 0},
                  {99, 0, 0, 0},
                  {99, 0, 0, 0},
                  {99, 0, 0, 0},          /* Earth */
                  /* from Bowell data base */
                  {6.5, 0.15, 0, 0},      /* Chiron */
                  {7.0, 0.15, 0, 0},      /* Pholus */
                  {3.34, 0.12, 0, 0},     /* Ceres */
                  {4.13, 0.11, 0, 0},     /* Pallas */
                  {5.33, 0.32, 0, 0},     /* Juno */
                  {3.20, 0.32, 0, 0},     /* Vesta */
                  };

  
  int swe_pheno(double tjd, int ipl, int iflag, double[] attr,
                StringBuffer serr) {
    int i;
    double xx[]=new double[6], xx2[]=new double[6], xxs[]=new double[6],
           lbr[]=new double[6], lbr2[]=new double[6], dt = 0, dsm, dd;
    double fac;
    double T, in, om, sinB, u1, u2, du;
    double ph1, ph2, me[]=new double[2];
    int iflagp;
    for (i = 0; i < 20; i++)
      attr[i] = 0;
    /* Ceres - Vesta must be SE_CERES etc., not 10001 etc. */
    if (ipl > SweConst.SE_AST_OFFSET && ipl <= SweConst.SE_AST_OFFSET + 4) {
      ipl = ipl - SweConst.SE_AST_OFFSET - 1 + SweConst.SE_CERES;
    }
    iflag = iflag & (SweConst.SEFLG_EPHMASK |
                     SweConst.SEFLG_TRUEPOS |
                     SweConst.SEFLG_J2000 |
                     SweConst.SEFLG_NONUT |
                     SweConst.SEFLG_NOGDEFL |
                     SweConst.SEFLG_NOABERR |
                     SweConst.SEFLG_TOPOCTR);
    iflagp = iflag & (SweConst.SEFLG_EPHMASK |
                     SweConst.SEFLG_TRUEPOS |
                     SweConst.SEFLG_J2000 |
                     SweConst.SEFLG_NONUT |
                     SweConst.SEFLG_NOABERR);
    iflagp |= SweConst.SEFLG_HELCTR;
    /*
     * geocentric planet
     */
    if (sw.swe_calc(tjd, ipl, iflag | SweConst.SEFLG_XYZ, xx, serr) ==
                                                                 SweConst.ERR) {
      return SweConst.ERR;
    }
    if (sw.swe_calc(tjd, ipl, iflag, lbr, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    /* if moon, we need sun as well, for magnitude */
    if (ipl == SweConst.SE_MOON) {
      if (sw.swe_calc(tjd, SweConst.SE_SUN, iflag | SweConst.SEFLG_XYZ,
                      xxs, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
    }
    if (ipl != SweConst.SE_SUN && ipl != SweConst.SE_EARTH &&
      ipl != SweConst.SE_MEAN_NODE && ipl != SweConst.SE_TRUE_NODE &&
      ipl != SweConst.SE_MEAN_APOG && ipl != SweConst.SE_OSCU_APOG) {
      /*
       * light time planet - earth
       */
      dt = lbr[2] * SweConst.AUNIT / SwephData.CLIGHT / 86400.0;
      if ((iflag & SweConst.SEFLG_TRUEPOS)!=0) {
        dt = 0;
      }
      /*
       * heliocentric planet at tjd - dt
       */
      if (sw.swe_calc(tjd - dt, ipl, iflagp | SweConst.SEFLG_XYZ, xx2, serr) ==
                                                                 SweConst.ERR) {
        return SweConst.ERR;
      }
      if (sw.swe_calc(tjd - dt, ipl, iflagp, lbr2, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
      /*
       * phase angle
       */
      attr[0] = Math.acos(sl.swi_dot_prod_unit(xx, xx2)) * SwissData.RADTODEG;
      /*
       * phase
       */
      attr[1] = (1 + Math.cos(attr[0] * SwissData.DEGTORAD)) / 2;
    }
    /*
     * apparent diameter of disk
     */
    if (ipl < SwephData.NDIAM) {
      dd = SwephData.pla_diam[ipl];
    } else if (ipl > SweConst.SE_AST_OFFSET) {
      dd = swed.ast_diam * 1000;        /* km -> m */
    } else {
      dd = 0;
    }
    if (lbr[2] < dd / 2 / SweConst.AUNIT) {
      attr[3] = 180;  /* assume position on surface of earth */
    } else {
      attr[3] = Math.asin(dd / 2 / SweConst.AUNIT / lbr[2]) * 2 * SwissData.RADTODEG;
    }
    /*
     * apparent magnitude
     */
    if (ipl > SweConst.SE_AST_OFFSET ||
        (ipl < NMAG_ELEM && mag_elem[ipl][0] < 99)) {
      if (ipl == SweConst.SE_SUN) {
        /* ratio apparent diameter : average diameter */
        fac = attr[3] / (Math.asin(SwephData.pla_diam[SweConst.SE_SUN] / 2.0 /
                                            SweConst.AUNIT) * 2 * SwissData.RADTODEG);
        fac *= fac;
        attr[4] = mag_elem[ipl][0] - 2.5 * log10(fac);
      } else if (ipl == SweConst.SE_MOON) {
        /* ratio apparent diameter : average diameter */
        fac = attr[3] / (Math.asin(SwephData.pla_diam[SweConst.SE_MOON] / 2.0 /
                                            384400000.0) * 2 * SwissData.RADTODEG);
        /* distance sun - moon */
        for (i = 0; i < 3; i++)
          xxs[i] -= xx[i];
        dsm = Math.sqrt(sl.square_sum(xxs));
        /* account for phase and distance of moon: */
        fac *= fac * attr[1];
        /* account for distance of sun from moon: */
        fac *= dsm * dsm;
        attr[4] = mag_elem[ipl][0] - 2.5 * log10(fac);
      } else if (ipl == SweConst.SE_SATURN) {
        /* rings are considered according to Meeus, German, p. 329ff. */
        T = (tjd - dt - SwephData.J2000) / 36525.0;
        in = (28.075216 - 0.012998 * T + 0.000004 * T * T) * SwissData.DEGTORAD;
        om = (169.508470 + 1.394681 * T + 0.000412 * T * T) * SwissData.DEGTORAD;
        sinB = Math.abs(Math.sin(in) * Math.cos(lbr[1] * SwissData.DEGTORAD)
                      * Math.sin(lbr[0] * SwissData.DEGTORAD - om)
                      - Math.cos(in) * Math.sin(lbr[1] * SwissData.DEGTORAD));
        u1 = Math.atan2(Math.sin(in) * Math.tan(lbr2[1] * SwissData.DEGTORAD)
                               + Math.cos(in) * Math.sin(lbr2[0] *
                                                          SwissData.DEGTORAD - om),
                          Math.cos(lbr2[0] * SwissData.DEGTORAD - om)) *
                                                                 SwissData.RADTODEG;
        u2 = Math.atan2(Math.sin(in) * Math.tan(lbr[1] * SwissData.DEGTORAD)
                        + Math.cos(in) * Math.sin(lbr[0] * SwissData.DEGTORAD - om),
                          Math.cos(lbr[0] * SwissData.DEGTORAD - om)) *
                                                                 SwissData.RADTODEG;
        du = sl.swe_degnorm(u1 - u2);
        if (du > 10) {
          du = 360 - du;
        }
        attr[4] = 5 * log10(lbr2[2] * lbr[2])
                    + mag_elem[ipl][1] * sinB
                    + mag_elem[ipl][2] * sinB * sinB
                    + mag_elem[ipl][3] * du
                    + mag_elem[ipl][0];
      } else if (ipl < SweConst.SE_CHIRON) {
        attr[4] = 5 * log10(lbr2[2] * lbr[2])
                    + mag_elem[ipl][1] * attr[0] /100.0
                    + mag_elem[ipl][2] * attr[0] * attr[0] / 10000.0
                    + mag_elem[ipl][3] * attr[0] * attr[0] * attr[0] / 1000000.0
                    + mag_elem[ipl][0];
      } else if (ipl < NMAG_ELEM || ipl > SweConst.SE_AST_OFFSET) {/*asteroids*/
        ph1 = Math.pow(EULER, -3.33 *
                        Math.pow(Math.tan(attr[0] * SwissData.DEGTORAD / 2), 0.63));
        ph2 = Math.pow(EULER, -1.87 *
                        Math.pow(Math.tan(attr[0] * SwissData.DEGTORAD / 2), 1.22));
        if (ipl < NMAG_ELEM) {    /* main asteroids */
          me[0] = mag_elem[ipl][0];
          me[1] = mag_elem[ipl][1];
        } else if (ipl == SweConst.SE_AST_OFFSET + 1566) {
                    /* Icarus has elements from JPL database */
                  me[0] = 16.9;
                  me[1] = 0.15;
        } else {      /* other asteroids */
          me[0] = swed.ast_H;
          me[1] = swed.ast_G;
        }
        attr[4] = 5 * log10(lbr2[2] * lbr[2])
            + me[0]
            - 2.5 * log10((1 - me[1]) * ph1 + me[1] * ph2);
      } else { /* ficticious bodies */
        attr[4] = 0;
      }
    }
    if (ipl != SweConst.SE_SUN && ipl != SweConst.SE_EARTH) {
      /*
       * elongation of planet
       */
      if (sw.swe_calc(tjd, SweConst.SE_SUN, iflag | SweConst.SEFLG_XYZ,
                      xx2, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
      if (sw.swe_calc(tjd, SweConst.SE_SUN, iflag, lbr2, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
      attr[2] = Math.acos(sl.swi_dot_prod_unit(xx, xx2)) * SwissData.RADTODEG;
    }
    return SweConst.OK;
  }

  
  int swe_pheno_ut(double tjd_ut, int ipl, int iflag, double[] attr,
                   StringBuffer serr) {
    return swe_pheno(tjd_ut + SweDate.getDeltaT(tjd_ut), ipl, iflag, attr, serr);
  }

  private int find_maximum(double y00, double y11, double y2, double dx,
                           DblObj dxret, DblObj yret) {
    double a, b, c, x, y;
    c = y11;
    b = (y2 - y00) / 2.0;
    a = (y2 + y00) / 2.0 - c;
    x = -b / 2 / a;
    y = (4 * a * c - b * b) / 4 / a;
    dxret.val = (x - 1) * dx;
    if (yret != null) {
      yret.val = y;
    }
    return SweConst.OK;
  }

  private int find_zero(double y00, double y11, double y2, double dx,
                        DblObj dxret, DblObj dxret2) {
    double a, b, c, x1, x2;
    c = y11;
    b = (y2 - y00) / 2.0;
    a = (y2 + y00) / 2.0 - c;
    if (b * b - 4 * a * c < 0) {
      return SweConst.ERR;
    }
    x1 = (-b + Math.sqrt(b * b - 4 * a * c)) / 2 / a;
    x2 = (-b - Math.sqrt(b * b - 4 * a * c)) / 2 / a;
      dxret.val = (x1 - 1) * dx;
      dxret2.val = (x2 - 1) * dx;
    return SweConst.OK;
  }

  /* rise, set, and meridian transits of sun, moon, planets, and stars
   *
   * tjd_ut       universal time from when on search ought to start
   * ipl          planet number, neglected, if Starname is given
   * starname     pointer to string. if a planet, not a star, is
   *              wanted, starname must be null or ""
   * epheflag     used for ephemeris only
   * rsmi         SE_CALC_RISE, SE_CALC_SET, SE_CALC_MTRANSIT, SE_CALC_ITRANSIT
   *              | SE_BIT_DISC_CENTER      for rises of disc center of body
   *              | SE_BIT_NO_REFRACTION    to neglect refraction
   * geopos       array of doubles for geogr. long., lat. and height above sea
   * atpress      atmospheric pressure
   * attemp       atmospheric temperature
   *
   * return variables:
   * tret         time of rise, set, meridian transits
   * serr[256]        error string
   * function return value -2 means that the body does not rise or set */
  
  int swe_rise_trans(double tjd_ut, int ipl, StringBuffer starname,
                     int epheflag, int rsmi, double[] geopos,
                     double atpress, double attemp,
                     DblObj tret, StringBuffer serr) {
    int i, j, k, ii, calc_culm, nculm = -1;
    double tjd_et = tjd_ut + SweDate.getDeltaT(tjd_ut);
    double xc[]=new double[6], xh[][]=new double[20][6], ah[]=new double[6],
           aha;
    double tculm[]=new double[4], tcu, tc[]=new double[20], h[]=new double[20],
           t2[]=new double[6], dc[]=new double[6];
    DblObj dtint=new DblObj();
    DblObj dx=new DblObj();
    double rdi, dd = 0;
    int iflag = epheflag;
    int jmax = 14;
    double t, te, tt, dt, twohrs = 1.0 / 12.0;
    boolean do_fixstar = (starname != null && starname.length() > 0);
    // xh[0][0] = 0; /* to shut up mint */
    iflag &= SweConst.SEFLG_EPHMASK;
    tret.val = 0;
    iflag |= (SweConst.SEFLG_EQUATORIAL | SweConst.SEFLG_TOPOCTR);
    sw.swe_set_topo(geopos[0], geopos[1], geopos[2]);
    if ((rsmi & (SweConst.SE_CALC_MTRANSIT | SweConst.SE_CALC_ITRANSIT))!=0) {
      return calc_mer_trans(tjd_ut, ipl, epheflag, rsmi,
                  geopos, starname,
                  tret, serr);
    }
    if ((rsmi & ( SweConst.SE_CALC_RISE | SweConst.SE_CALC_SET))==0) {
      rsmi |= SweConst.SE_CALC_RISE;
    }
    /* find culmination points within 28 hours from t0 - twohrs.
     * culminations are required in case there are maxima or minima
     * in height slightly above or below the horizon.
     * we do not use meridian transits, because in polar regions
     * the culmination points may considerably deviate from
     * transits. also, there are cases where the moon rises in the
     * western half of the sky for a short time.
     */
    if (do_fixstar) {
      if (sw.swe_fixstar(starname, tjd_et, iflag, xc, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
    }
    for (ii = 0, t = tjd_ut - twohrs; ii <= jmax; ii++, t += twohrs) {
      tc[ii] = t;
      if (!do_fixstar) {
        te = t + SweDate.getDeltaT(t);
        if (sw.swe_calc(te, ipl, iflag, xc, serr) == SweConst.ERR) {
          return SweConst.ERR;
        }
      }
      /* diameter of object in km */
      if (ii == 0) {
        if (do_fixstar) {
          dd = 0;
        } else
               if ((rsmi & SweConst.SE_BIT_DISC_CENTER)!=0) {
          dd = 0;
        } else if (ipl < SwephData.NDIAM) {
          dd = SwephData.pla_diam[ipl];
        } else if (ipl > SweConst.SE_AST_OFFSET) {
          dd = swed.ast_diam * 1000;        /* km -> m */
        } else {
          dd = 0;
        }
      }
      /* apparent radius of disc */
      rdi = Math.asin(dd / 2 / SweConst.AUNIT / xc[2]) * SwissData.RADTODEG;
      /* true height of center of body */
      swe_azalt(t, SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, xh[ii]);
      /* true height of uppermost point of body */
      xh[ii][1] += rdi;
      /* apparent height of uppermost point of body */
      if ((rsmi & SweConst.SE_BIT_NO_REFRACTION)!=0) {
        h[ii] = xh[ii][1];
      } else {
        swe_azalt_rev(t, SweConst.SE_HOR2EQU, geopos, xh[ii], xc);
        swe_azalt(t, SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, xh[ii]);
        h[ii] = xh[ii][2];
      }
      calc_culm = 0;
      if (ii > 1) {
        dc[0] = xh[ii-2][1];
        dc[1] = xh[ii-1][1];
        dc[2] = xh[ii][1];
        if (dc[1] > dc[0] && dc[1] > dc[2]) {
          calc_culm = 1;
        }
        if (dc[1] < dc[0] && dc[1] < dc[2]) {
          calc_culm = 2;
        }
      }
      if (calc_culm!=0) {
        dt = twohrs;
        tcu = t - dt;
        find_maximum(dc[0], dc[1], dc[2], dt, dtint, dx);
        tcu += dtint.val + dt;
        dt /= 3;
        for (; dt > 0.0001; dt /= 3) {
          for (i = 0, tt = tcu - dt; i < 3; tt += dt, i++) {
            te = tt + SweDate.getDeltaT(tt);
            if (!do_fixstar) {
              if (sw.swe_calc(te, ipl, iflag, xc, serr) == SweConst.ERR) {
                return SweConst.ERR;
              }
            }
            swe_azalt(tt, SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, ah);
            dc[i] = ah[1];
          }
          find_maximum(dc[0], dc[1], dc[2], dt, dtint, dx);
          tcu += dtint.val + dt;
        }
        nculm++;
        tculm[nculm] = tcu;
      }
    }
    /* note: there can be a rise or set on the poles, even if
     * there is no culmination. So, we must not leave here
     * in any case. */
    /* insert culminations into array of heights */
    for (i = 0; i <= nculm; i++) {
      for (j = 1; j <= jmax; j++) {
        if (tculm[i] < tc[j]) {
          for (k = jmax; k >= j; k--) {
            tc[k+1] = tc[k];
            h[k+1] = h[k];
          }
          tc[j] = tculm[i];
          if (!do_fixstar) {
            te = tc[j] + SweDate.getDeltaT(tc[j]);
            if (sw.swe_calc(te, ipl, iflag, xc, serr) == SweConst.ERR) {
              return SweConst.ERR;
            }
          }
          /* apparent radius of disc */
          rdi = Math.asin(dd / 2 / SweConst.AUNIT / xc[2]) * SwissData.RADTODEG;
          /* true height of center of body */
          swe_azalt(tc[j], SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, ah);
          /* true height of uppermost point of body */
          ah[1] += rdi;
          /* apparent height of uppermost point of body */
          if ((rsmi & SweConst.SE_BIT_NO_REFRACTION)!=0) {
            h[j] = ah[1];
          } else {
            swe_azalt_rev(tc[j], SweConst.SE_HOR2EQU, geopos, ah, xc);
            swe_azalt(tc[j], SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, ah);
            h[j] = ah[2];
          }
          jmax++;
          break;
        }
      }
    }
    tret.val = 0;
    /* find points with zero height.
     * binary search */
    for (ii = 1; ii <= jmax; ii++) {
      if (h[ii-1] * h[ii] >= 0) {
        continue;
      }
      if (h[ii-1] < h[ii] && ((rsmi & SweConst.SE_CALC_RISE) == 0)) {
        continue;
      }
      if (h[ii-1] > h[ii] && ((rsmi & SweConst.SE_CALC_SET) == 0)) {
        continue;
      }
      dc[0] = h[ii-1];
      dc[1] = h[ii];
      t2[0] = tc[ii-1];
      t2[1] = tc[ii];
      for (i = 0; i < 20; i++) {
        t = (t2[0] + t2[1]) / 2;
        if (!do_fixstar) {
          te = t + SweDate.getDeltaT(t);
          if (sw.swe_calc(te, ipl, iflag, xc, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
        }
        /* apparent radius of disc */
        rdi = Math.asin(dd / 2 / SweConst.AUNIT / xc[2]) * SwissData.RADTODEG;
        /* true height of center of body */
        swe_azalt(t, SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, ah);
        /* true height of uppermost point of body */
        ah[1] += rdi;
        /* apparent height of uppermost point of body */
        if ((rsmi & SweConst.SE_BIT_NO_REFRACTION)!=0) {
          aha = ah[1];
        } else {
          swe_azalt_rev(t, SweConst.SE_HOR2EQU, geopos, ah, xc);
          swe_azalt(t, SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, ah);
          aha = ah[2];
        }
        if (aha * dc[0] <= 0) {
          dc[1] = aha;
          t2[1] = t;
        } else {
          dc[0] = aha;
          t2[0] = t;
        }
      }
      if (t > tjd_ut) {
       tret.val = t;
       return SweConst.OK;
      }
    }
    if (serr!=null)
      serr.append("rise or set not found for planet ").append(ipl);
    return -2; /* no t of rise or set found */
  }

  private int calc_mer_trans(double tjd_ut, int ipl, int epheflag, int rsmi,
                             double[] geopos, StringBuffer starname,
                             DblObj tret, StringBuffer serr) {
    int i;
    double tjd_et = tjd_ut + SweDate.getDeltaT(tjd_ut);
    double armc, armc0, arxc, x0[]=new double[6], x[]=new double[6], t, te;
    double mdd;
    int iflag = epheflag;
    boolean do_fixstar = (starname != null && starname.length() > 0);
    iflag &= SweConst.SEFLG_EPHMASK;
    tret.val = 0;
    iflag |= (SweConst.SEFLG_EQUATORIAL | SweConst.SEFLG_TOPOCTR);
    armc0 = sl.swe_sidtime(tjd_ut) + geopos[0] / 15;
    if (armc0 >= 24) {
      armc0 -= 24;
    }
    if (armc0 < 0) {
      armc0 += 24;
    }
    armc0 *= 15;
    if (do_fixstar) {
      if (sw.swe_fixstar(starname, tjd_et, iflag, x0, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
    } else {
      if (sw.swe_calc(tjd_et, ipl, iflag, x0, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
    }
    /*
     * meridian transits
     */
      x[0] = x0[0];
      x[1] = x0[1];
      t = tjd_ut;
      arxc = armc0;
      if ((rsmi & SweConst.SE_CALC_ITRANSIT)!=0) {
        arxc = sl.swe_degnorm(arxc + 180);
      }
      for (i = 0; i < 4; i++) {
        mdd = sl.swe_degnorm(x[0] - arxc);
        if (i > 0 && mdd > 180) {
          mdd -= 360;
        }
        t += mdd / 361;
        armc = sl.swe_sidtime(t) + geopos[0] / 15;
        if (armc >= 24) {
          armc -= 24;
        }
        if (armc < 0) {
          armc += 24;
        }
        armc *= 15;
        arxc = armc;
        if ((rsmi & SweConst.SE_CALC_ITRANSIT)!=0) {
          arxc = sl.swe_degnorm(arxc + 180);
        }
        if (!do_fixstar) {
  //        te = t + swe_deltat(t);
          te = t + SweDate.getDeltaT(t);
          if (sw.swe_calc(te, ipl, iflag, x, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
        }
      }
    tret.val = t;
    return SweConst.OK;
  }

  /*
  Nodes and apsides of planets and moon

  Planetary nodes can be defined in three different ways:
  a) They can be understood as a direction or as an axis
    defined by the intersection line of two orbital planes.
    E.g., the nodes of Mars are defined by the intersection
    line of Mars' orbital plane with the ecliptic (= the
    Earths orbit heliocentrically or the solar orbit
    geocentrically). However, as Michael Erlewine points
    out in his elaborate web page on this topic
    (http://thenewage.com/resources/articles/interface.html),
    planetary nodes can be defined for any couple of
    planets. E.g. there is also an intersection line for the
    two orbital planes of Mars and Saturn.
    Because such lines are, in principle, infinite, the
    heliocentric and the geocentric positions of the
    planetary nodes will be the same. There are astrologers
    that use such heliocentric planetary nodes in geocentric
    charts.
    The ascending and the descending node will, in this
    case, be in precise opposition.

  b) The planetary nodes can also be understood in a
    different way, not as an axis, but as the two points on a
    planetary orbit that are located precisely on the
    intersection line of the two planes.
    This second definition makes no difference for the moon or
    for heliocentric positions of planets, but it does so for
    geocentric positions. There are two possibilities for
    geocentric planetary nodes based on this definition.
    1) The common solution is that the points on the
      planets orbit are transformed to the geocenter. The
      two points will not be in opposition anymore, or
      they will only roughly be so with the outer planets. The
      advantage of these nodes is that when a planet is in
      conjunction with its node, then its ecliptic latitude
      will be zero. This is not true when a planet is in
      geocentric conjunction with its heliocentric node.
      (And neither is it always true for the inner planets,
      i.e. Mercury and Venus.)
    2) The second possibility that nobody seems to have
      thought of so far: One may compute the points of
      the earth's orbit that lie exactly on another planet's
      orbital plane and transform it to the geocenter. The two
      points will always be in an approximate square.

  c) Third, the planetary nodes could be defined as the
    intersection points of the plane defined by their
    momentary geocentric position and motion with the
    plane of the ecliptic. Such points would move very fast
    around the planetary stations. Here again, as in b)1),
    the planet would cross the ecliptic and its ecliptic
    latitude would be 0 exactly when it were in
    conjunction with one of its nodes.

  The Swiss Ephemeris supports the solutions a) and b) 1).

  Possible definitions for apsides

  a) The planetary apsides can be defined as the perihelion and
    aphelion points on a planetary orbit. For a
    geocentric chart, these points could be transformed
    from the heliocenter to the geocenter.
  b) However, one might consider these points as
    astrologically relevant axes rather than as points on a
    planetary orbit. Again, this would allow heliocentric
    positions in a geocentric chart.

  Note: For the "Dark Moon" or "Lilith", which I usually
  define as the lunar apogee, some astrologers give a
  different definition. They understand it as the second focal
  point of the moon's orbital ellipse. This definition does not
  make a difference for geocentric positions, because the
  apogee and the second focus are in exactly the same geocentric
  direction. However, it makes a difference with topocentric
  positions, because the two points do not have same distance.
  Analogous "black planets" have been proposed: they would be the
  second focal points of the planets' orbital ellipses. The
  heliocentric positions of these "black planets" are identical
  with the heliocentric positions of the aphelia, but geocentric
  positions are not identical, because the focal points are
  much closer to the sun than the aphelia.

  The Swiss Ephemeris allows to compute the "black planets" as well.

  Mean positions

  Mean nodes and apsides can be computed for the Moon, the
  Earth and the planets Mercury - Neptune. They are taken
  from the planetary theory VSOP87. Mean points can not be
  calculated for Pluto and the asteroids, because there is no
  planetary theory for them.

  Osculating nodes and apsides

  Nodes and apsides can also be derived from the osculating
  orbital elements of a body, the paramaters that define an
  ideal unperturbed elliptic (two-body) orbit.
  For astrology, note that this is a simplification and
  idealization.
  Problem with Neptune: Neptune's orbit around the sun does not
  have much in common with an ellipse. There are often two
  perihelia and two aphelia within one revolution. As a result,
  there is a wild oscillation of the osculating perihelion (and
  aphelion).
  In actuality, Neptune's orbit is not heliocentric orbit at all.
  The twofold perihelia and aphelia are an effect of the motion of
  the sun about the solar system barycenter. This motion is
  much faster than the motion of Neptune, and Neptune
  cannot react on such fast displacements of the Sun. As a
  result, Neptune seems to move around the barycenter (or a
  mean sun) rather than around the true sun. In fact,
  Neptune's orbit around the barycenter is therefore closer to
  an ellipse than the his orbit around the sun. The same
  statement is also true for Saturn, Uranus and Pluto, but not
  for Jupiter and the inner planets.

  This fundamental problem about osculating ellipses of
  planetary orbits does of course not only affect the apsides
  but also the nodes.

  Two solutions can be thought of for this problem:
  1) The one would be to interpolate between actual
    passages of the planets through their nodes and
    apsides. However, this works only well with Mercury.
    With all other planets, the supporting points are too far
    apart as to make an accurate interpolation possible.
    This solution is not implemented, here.
  2) The other solution is to compute the apsides of the
    orbit around the barycenter rather than around the sun.
    This procedure makes sense for planets beyond Jupiter,
    it comes closer to the mean apsides and nodes for
    planets that have such points defined. For all other
    transsaturnian planets and asteroids, this solution yields
    a kind of "mean" nodes and apsides. On the other hand,
    the barycentric ellipse does not make any sense for
    inner planets and Jupiter.

  The Swiss Ephemeris supports solution 2) for planets and
  asteroids beyond Jupiter.

  Anyway, neither the heliocentric nor the barycentric ellipse
  is a perfect representation of the nature of a planetary orbit,
  and it will not yield the degree of precision that today's
  astrology is used to.
  The best choice of method will probably be:
  - For Mercury - Neptune: mean nodes and apsides
  - For asteroids that belong to the inner asteroid belt:
  osculating nodes/apsides from a heliocentric ellipse
  - For Pluto and outer asteroids: osculating nodes/apsides
  from a barycentric ellipse

  The Moon is a special case: A "lunar true node" makes
  more sense, because it can be defined without the idea of an
  ellipse, e.g. as the intersection axis of the momentary lunar
  orbital plane with the ecliptic. Or it can be said that the
  momentary motion of the moon points to one of the two
  ecliptic points that are called the "true nodes".  So, these
  points make sense. With planetary nodes, the situation is
  somewhat different, at least if we make a difference
  between heliocentric and geocentric positions. If so, the
  planetary nodes are points on a heliocentric orbital ellipse,
  which are transformed to the geocenter. An ellipse is
  required here, because a solar distance is required. In
  contrast to the planetary nodes, the lunar node does not
  require a distance, therefore manages without the idea of an
  ellipse and does not share its weaknesses.
  On the other hand, the lunar apsides DO require the idea of
  an ellipse. And because the lunar ellipse is actually
  extremely distorted, even more than any other celestial
  ellipse, the "true Lilith" (apogee), for which printed
  ephemerides are available, does not make any sense at all.
  (See the chapter on the lunar node and apogee.)

  Special case: the Earth

  The Earth is another special case. Instead of the motion of
  the Earth herself, the heliocentric motion of the Earth-
  Moon-Barycenter (EMB) is used to determine the
  osculating perihelion.
  There is no node of the earth orbit itself. However, there is
  an axis around which the earth's orbital plane slowly rotates
  due to planetary precession. The position points of this axis
  are not calculated by the Swiss Ephemeris.

  Special case: the Sun

  In addition to the Earth (EMB) apsides, the function
  computes so-to-say "apsides" of the sun, i.e. points on the
  orbit of the Sun where it is closest to and where it is farthest
  from the Earth. These points form an opposition and are
  used by some astrologers, e.g. by the Dutch astrologer
  George Bode or the Swiss astrologer Liduina Schmed. The
  perigee, located at about 13 Capricorn, is called the
  "Black Sun", the other one, in Cancer, the "Diamond".
  So, for a complete set of apsides, one ought to calculate
  them for the Sun and the Earth and all other planets.

  The modes of the Swiss Ephemeris function
  swe_nod_aps()

  The  function swe_nod_aps() can be run in the following
  modes:
  1) Mean positions are given for nodes and apsides of Sun,
    Moon, Earth, and the up to Neptune. Osculating
    positions are given with Pluto and all asteroids. This is
    the default mode.
  2) Osculating positions are returned for nodes and apsides
    of all planets.
  3) Same as 2), but for planets and asteroids beyond
    Jupiter, a barycentric ellipse is used.
  4) Same as 1), but for Pluto and asteroids beyond Jupiter,
    a barycentric ellipse is used.

  In all of these modes, the second focal point of the ellipse
  can be computed instead of the aphelion.
  Like the planetary function swe_calc(), swe_nod_aps() is
  able to return geocentric, topocentric, heliocentric, or
  barycentric position.
   *
   * tjd_ut         julian day, ephemeris time
   * ipl                 planet number
   * iflag         as usual, SEFLG_HELCTR, etc.
   * xnasc         an array of 6 doubles: ascending node
   * xndsc         an array of 6 doubles: ascending node
   * xperi         an array of 6 doubles: perihelion
   * xaphe         an array of 6 doubles: aphelion
   * method        see below
   * serr          error message
   *
   * method        can have the following values:
   *               - 0 or SE_NODBIT_MEAN. MEAN positions are given for
   *                 nodes and apsides of Sun, Moon, Earth, and the
   *                 planets up to Neptune. Osculating positions are
   *                 given with Pluto and all asteroids.
   *               - SE_NODBIT_OSCU. Osculating positions are given
   *                 for all nodes and apsides.
   *               - SE_NODBIT_OSCU_BAR. Osculating nodes and apsides
   *                 are computed from barycentric ellipses, for planets
   *                 beyond Jupiter, but from heliocentric ones for
   *                 ones for Jupiter and inner planets.
   *               - SE_NODBIT_MEAN and SE_NODBIT_OSCU_BAR can be combined.
   *                 The program behaves the same way as with simple
   *                 SE_NODBIT_MEAN, but uses barycentric ellipses for
   *                 planets beyond Neptune and asteroids beyond Jupiter.
   *               - SE_NODBIT_FOCAL can be combined with any of the other
   *                 bits. The second focal points of the ellipses will
   *                 be returned instead of the aphelia.
   */
  /* mean elements for Mercury - Neptune from VSOP87 (mean equinox of date) */
  private static final double el_node[][] = new double[][]
    {{ 48.330893,  1.1861890,  0.00017587,  0.000000211,}, /* Mercury */
    { 76.679920,  0.9011190,  0.00040665, -0.000000080,}, /* Venus   */
    {  0       ,  0        ,  0         ,  0          ,}, /* Earth   */
    { 49.558093,  0.7720923,  0.00001605,  0.000002325,}, /* Mars    */
    {100.464441,  1.0209550,  0.00040117,  0.000000569,}, /* Jupiter */
    {113.665524,  0.8770970, -0.00012067, -0.000002380,}, /* Saturn  */
    { 74.005947,  0.5211258,  0.00133982,  0.000018516,}, /* Uranus  */
    {131.784057,  1.1022057,  0.00026006, -0.000000636,}, /* Neptune */
    };
  private static final double el_peri[][] = new double[][]
    {{ 77.456119,  1.5564775,  0.00029589,  0.000000056,}, /* Mercury */
    {131.563707,  1.4022188, -0.00107337, -0.000005315,}, /* Venus   */
    {102.937348,  1.7195269,  0.00045962,  0.000000499,}, /* Earth   */
    {336.060234,  1.8410331,  0.00013515,  0.000000318,}, /* Mars    */
    { 14.331309,  1.6126668,  0.00103127, -0.000004569,}, /* Jupiter */
    { 93.056787,  1.9637694,  0.00083757,  0.000004899,}, /* Saturn  */
    {173.005159,  1.4863784,  0.00021450,  0.000000433,}, /* Uranus  */
    { 48.123691,  1.4262677,  0.00037918, -0.000000003,}, /* Neptune */
    };
  private static final double el_incl[][] = new double[][]
    {{  7.004986,  0.0018215, -0.00001809,  0.000000053,}, /* Mercury */
    {  3.394662,  0.0010037, -0.00000088, -0.000000007,}, /* Venus   */
    {  0,         0,          0,           0          ,}, /* Earth   */
    {  1.849726, -0.0006010,  0.00001276, -0.000000006,}, /* Mars    */
    {  1.303270, -0.0054966,  0.00000465, -0.000000004,}, /* Jupiter */
    {  2.488878, -0.0037363, -0.00001516,  0.000000089,}, /* Saturn  */
    {  0.773196,  0.0007744,  0.00003749, -0.000000092,}, /* Uranus  */
    {  1.769952, -0.0093082, -0.00000708,  0.000000028,}, /* Neptune */
    };
  private static final double el_ecce[][] = new double[][]
    {{  0.20563175,  0.000020406, -0.0000000284, -0.00000000017,}, /* Mercury */
    {  0.00677188, -0.000047766,  0.0000000975,  0.00000000044,}, /* Venus   */
    {  0.01670862, -0.000042037, -0.0000001236,  0.00000000004,}, /* Earth   */
    {  0.09340062,  0.000090483, -0.0000000806, -0.00000000035,}, /* Mars    */
    {  0.04849485,  0.000163244, -0.0000004719, -0.00000000197,}, /* Jupiter */
    {  0.05550862, -0.000346818, -0.0000006456,  0.00000000338,}, /* Saturn  */
    {  0.04629590, -0.000027337,  0.0000000790,  0.00000000025,}, /* Uranus  */
    {  0.00898809,  0.000006408, -0.0000000008, -0.00000000005,}, /* Neptune */
    };
  private static final double el_sema[][] = new double[][]
    {{  0.387098310,  0.0,  0.0,  0.0,}, /* Mercury */
    {  0.723329820,  0.0,  0.0,  0.0,}, /* Venus   */
    {  1.000001018,  0.0,  0.0,  0.0,}, /* Earth   */
    {  1.523679342,  0.0,  0.0,  0.0,}, /* Mars    */
    {  5.202603191,  0.0000001913,  0.0,  0.0,}, /* Jupiter */
    {  9.554909596,  0.0000021389,  0.0,  0.0,}, /* Saturn  */
    { 19.218446062, -0.0000000372,  0.00000000098,  0.0,}, /* Uranus  */
    { 30.110386869, -0.0000001663,  0.00000000069,  0.0,}, /* Neptune */
    };
  /* Ratios of mass of Sun to masses of the planets */
  private static final double plmass[] = new double[] {
      6023600,        /* Mercury */
       408523.5,      /* Venus */
       328900.5,      /* Earth and Moon */
      3098710,        /* Mars */
         1047.350,    /* Jupiter */
         3498.0,      /* Saturn */
        22960,        /* Uranus */
        19314,        /* Neptune */
    130000000,        /* Pluto */
  };
  private static final int ipl_to_elem[] = new int[]
                                {2, 0, 0, 1, 3, 4, 5, 6, 7, 0, 0, 0, 0, 0, 2,};

  
  int swe_nod_aps(double tjd_et, int ipl, int iflag,
                  int  method,
                  double[] xnasc, double[] xndsc,
                  double[] xperi, double[] xaphe,
                  StringBuffer serr) {
    int ij, i, j;
    int iplx;
    int ipli;
    int istart, iend;
    int iflJ2000;
    double plm;
    double t = (tjd_et - SwephData.J2000) / 36525, dt;
    double x[]=new double[6], xx[]=new double[24], xp[],
           xobs[]=new double[6], x2000[]=new double[6];
    int xpOffs=0;
    double xpos[][]=new double[3][6], xnorm[]=new double[6];
    double xposm[]=new double[6];
    double xn[][]=new double[3][6], xs[][]=new double[3][6];
    double xq[][]=new double[3][6], xa[][]=new double[3][6];
    double xobs2[]=new double[6], x2[]=new double[6];
    double[] xna, xnd, xpe, xap;
    final int xndOffs = 6, xpeOffs = 12, xapOffs = 18;
    double incl, sema, ecce, parg, ea, vincl, vsema, vecce, pargx, eax;
    PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
    PlanData psbdp = swed.pldat[SwephData.SEI_SUNBARY];
    PlanData pldat=new PlanData();
    double[] xsun = psbdp.x;
    double[] xear = pedp.x;
    double[] ep;
    double Gmsm, dzmin;
    double rxy, rxyz, fac, sgn;
    double sinnode, cosnode, sinincl, cosincl, sinu, cosu, sinE, cosE, cosE2;
    double uu, ny, ny2, c2, v2, pp, ro, ro2, rn, rn2;
    Epsilon oe;
    boolean is_true_nodaps = false;
    boolean do_aberr = (iflag &
                        (SweConst.SEFLG_TRUEPOS | SweConst.SEFLG_NOABERR))==0;
    boolean do_defl = (iflag & SweConst.SEFLG_TRUEPOS)==0 &&
                      (iflag & SweConst.SEFLG_NOGDEFL)==0;
    boolean do_focal_point = (method & SweConst.SE_NODBIT_FOPOINT) != 0;
    boolean ellipse_is_bary = false;
    int iflg0;
    xna = xx; 
    xnd = xx; // xndOffs = 6; 
    xpe = xx; // xpeOffs = 12; 
    xap = xx; // xapOffs = 18;
    // xpos[0][0] = 0; /* to shut up mint */
    /* to get control over the save area: */
    sw.swi_force_app_pos_etc();
    method %= SweConst.SE_NODBIT_FOPOINT;
    ipli = ipl;
    if (ipl == SweConst.SE_SUN) {
      ipli = SweConst.SE_EARTH;
    }
    if (ipl == SweConst.SE_MOON) {
      do_defl = false;
      if ((iflag & SweConst.SEFLG_HELCTR)==0) {
        do_aberr = false;
      }
    }
    iflg0 = (iflag & (SweConst.SEFLG_EPHMASK|SweConst.SEFLG_NONUT)) |
            SweConst.SEFLG_SPEED | SweConst.SEFLG_TRUEPOS;
    if (ipli != SweConst.SE_MOON) {
      iflg0 |= SweConst.SEFLG_HELCTR;
    }
    if (ipl == SweConst.SE_MEAN_NODE || ipl == SweConst.SE_TRUE_NODE ||
            ipl == SweConst.SE_MEAN_APOG || ipl == SweConst.SE_OSCU_APOG ||
            ipl < 0 ||
            (ipl >= SweConst.SE_NPLANETS && ipl <= SweConst.SE_AST_OFFSET)) {
           /*(ipl >= SE_FICT_OFFSET && ipl - SE_FICT_OFFSET < SE_NFICT_ELEM)) */
      if (serr != null) {
        serr.setLength(0);
        serr.append("nodes/apsides for planet "+ipl+
                    " are not implemented");
      }
      if (xnasc != null) {
        for (i = 0; i <= 5; i++)
          xnasc[i] = 0;
      }
      if (xndsc != null) {
        for (i = 0; i <= 5; i++)
          xndsc[i] = 0;
      }
      if (xaphe != null) {
        for (i = 0; i <= 5; i++)
          xaphe[i] = 0;
      }
      if (xperi != null) {
        for (i = 0; i <= 5; i++)
          xperi[i] = 0;
      }
      return SweConst.ERR;
    }
    for (i = 0; i < 24; i++)
      xx[i] = 0;
    
    /* mean points only for Sun - Neptune */
    if ((method == 0 || (method & SweConst.SE_NODBIT_MEAN)!=0) &&
          ((ipl >= SweConst.SE_SUN && ipl <= SweConst.SE_NEPTUNE) ||
                                                    ipl == SweConst.SE_EARTH)) {
      if (ipl == SweConst.SE_MOON) {
//      sm.swi_mean_lunar_elements(tjd_et, &xna[0], &xna[3], &xpe[0], &xpe[3]);
        DblObj xna0=new DblObj(); xna0.val=xna[0];
        DblObj xna3=new DblObj(); xna3.val=xna[3];
        DblObj xpe0=new DblObj(); xpe0.val=xpe[0+xpeOffs];
        DblObj xpe3=new DblObj(); xpe3.val=xpe[3+xpeOffs];
        sm.swi_mean_lunar_elements(tjd_et, xna0, xna3, xpe0, xpe3);
        xna[0]=xna0.val;
        xna[3]=xna3.val;
        xpe[0+xpeOffs]=xpe0.val;
        xpe[3+xpeOffs]=xpe3.val;
        incl = SwephData.MOON_MEAN_INCL;
        vincl = 0;
        ecce = SwephData.MOON_MEAN_ECC;
        vecce = 0;
        sema = SwephData.MOON_MEAN_DIST / SweConst.AUNIT;
        vsema = 0;
      } else {
        iplx = ipl_to_elem[ipl];
        ep = el_incl[iplx];
        incl = ep[0] + ep[1] * t + ep[2] * t * t + ep[3] * t * t * t;
        vincl = ep[1] / 36525;
        ep = el_sema[iplx];
        sema = ep[0] + ep[1] * t + ep[2] * t * t + ep[3] * t * t * t;
        vsema = ep[1] / 36525;
        ep = el_ecce[iplx];
        ecce = ep[0] + ep[1] * t + ep[2] * t * t + ep[3] * t * t * t;
        vecce = ep[1] / 36525;
        ep = el_node[iplx];
        /* ascending node */
        xna[0] = ep[0] + ep[1] * t + ep[2] * t * t + ep[3] * t * t * t;
        xna[3] = ep[1] / 36525;
        /* perihelion */
        ep = el_peri[iplx];
        xpe[0+xpeOffs] = ep[0] + ep[1] * t + ep[2] * t * t + ep[3] * t * t * t;
        xpe[3+xpeOffs] = ep[1] / 36525;
      }
      /* descending node */
      xnd[0+xndOffs] = sl.swe_degnorm(xna[0] + 180);
      xnd[3+xndOffs] = xna[3];
      /* angular distance of perihelion from node */
      parg = xpe[0+xpeOffs] = sl.swe_degnorm(xpe[0+xpeOffs] - xna[0]);
      pargx = xpe[3+xpeOffs] = sl.swe_degnorm(xpe[0+xpeOffs] + xpe[3+xpeOffs]  - xna[3]);
      /* transform from orbital plane to mean ecliptic of date */
      sl.swe_cotrans(xpe, xpeOffs, xpe, xpeOffs, -incl);
      /* xpe+3 is aux. position, not speed!!! */
      sl.swe_cotrans(xpe, 3+xpeOffs, xpe, 3+xpeOffs, -incl-vincl);
      /* add node again */
      xpe[0+xpeOffs] = sl.swe_degnorm(xpe[0+xpeOffs] + xna[0]);
      /* xpe+3 is aux. position, not speed!!! */
      xpe[3+xpeOffs] = sl.swe_degnorm(xpe[3+xpeOffs] + xna[0] + xna[3]);
      /* speed */
      xpe[3+xpeOffs] = sl.swe_degnorm(xpe[3+xpeOffs] - xpe[0+xpeOffs]);
      /* heliocentric distance of perihelion and aphelion */
      xpe[2+xpeOffs] = sema * (1 - ecce);
      xpe[5+xpeOffs] = (sema + vsema) * (1 - ecce - vecce) - xpe[2+xpeOffs];
      /* aphelion */
      xap[0+xapOffs] = sl.swe_degnorm(xpe[xpeOffs] + 180);
      xap[1+xapOffs] = -xpe[1+xpeOffs];
      xap[3+xapOffs] = xpe[3+xpeOffs];
      xap[4+xapOffs] = -xpe[4+xpeOffs];
      if (do_focal_point) {
        xap[2+xapOffs] = sema * ecce * 2;
        xap[5+xapOffs] = (sema + vsema) * (ecce + vecce) * 2 - xap[2+xapOffs];
      } else {
        xap[2+xapOffs] = sema * (1 + ecce);
        xap[5+xapOffs] = (sema + vsema) * (1 + ecce + vecce) - xap[2+xapOffs];
      }
      /* heliocentric distance of nodes */
      ea = Math.atan(Math.tan(-parg * SwissData.DEGTORAD / 2) *
                                              Math.sqrt((1-ecce)/(1+ecce))) * 2;
      eax = Math.atan(Math.tan(-pargx * SwissData.DEGTORAD / 2) *
                                  Math.sqrt((1-ecce-vecce)/(1+ecce+vecce))) * 2;
      xna[2] = sema * (Math.cos(ea) - ecce) / Math.cos(parg * SwissData.DEGTORAD);
      xna[5] = (sema+vsema) * (Math.cos(eax) - ecce - vecce) /
                                                Math.cos(pargx * SwissData.DEGTORAD);
      xna[5] -= xna[2];
      ea = Math.atan(Math.tan((180 - parg) * SwissData.DEGTORAD / 2) *
                                              Math.sqrt((1-ecce)/(1+ecce))) * 2;
      eax = Math.atan(Math.tan((180 - pargx) * SwissData.DEGTORAD / 2) *
                                  Math.sqrt((1-ecce-vecce)/(1+ecce+vecce))) * 2;
      xnd[2+xndOffs] = sema * (Math.cos(ea) - ecce) / Math.cos((180 - parg) * SwissData.DEGTORAD);
      xnd[5+xndOffs] = (sema+vsema) * (Math.cos(eax) - ecce - vecce) /
                                             Math.cos((180 - pargx) * SwissData.DEGTORAD);
      xnd[5+xndOffs] -= xnd[2+xndOffs];
      /* no light-time correction because speed is extremely small */
      for (i = 0, xp = xx, xpOffs = 0; i < 4; i++, xpOffs += 6) {
        /* to cartesian coordinates */
        xp[0+xpOffs] *= SwissData.DEGTORAD;
        xp[1+xpOffs] *= SwissData.DEGTORAD;
        xp[3+xpOffs] *= SwissData.DEGTORAD;
        xp[4+xpOffs] *= SwissData.DEGTORAD;
        sl.swi_polcart_sp(xp, xpOffs, xp, xpOffs);
      }
    
    } else {
      /* first, we need a heliocentric distance of the planet */
      if (sw.swe_calc(tjd_et, ipli, iflg0, x, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
      iflJ2000 = (iflag & SweConst.SEFLG_EPHMASK)|
                 SweConst.SEFLG_J2000|
                 SweConst.SEFLG_EQUATORIAL|
                 SweConst.SEFLG_XYZ|
                 SweConst.SEFLG_TRUEPOS|
                 SweConst.SEFLG_NONUT|
                 SweConst.SEFLG_SPEED;
      ellipse_is_bary = false;
      if (ipli != SweConst.SE_MOON) {
        if ((method & SweConst.SE_NODBIT_OSCU_BAR)!=0 && x[2] > 6) {
          iflJ2000 |= SweConst.SEFLG_BARYCTR; /* only planets beyond Jupiter */
          ellipse_is_bary = true;
        } else {
          iflJ2000 |= SweConst.SEFLG_HELCTR;
        }
      }
      /* we need three positions and three speeds
       * for three nodes/apsides. from the three node positions,
       * the speed of the node will be computed. */
      if (ipli == SweConst.SE_MOON) {
        dt = SwephData.NODE_CALC_INTV;
        dzmin = 1e-15;
        Gmsm = SwephData.GEOGCONST * (1 + 1 / SwephData.EARTH_MOON_MRAT) /
                            SweConst.AUNIT/SweConst.AUNIT/SweConst.AUNIT*86400.0*86400.0;
      } else {
        if ((ipli >= SweConst.SE_MERCURY && ipli <= SweConst.SE_PLUTO) ||
                                                   ipli == SweConst.SE_EARTH) {
          plm = 1 / plmass[ipl_to_elem[ipl]];
        } else {
          plm = 0;
        }
        dt = SwephData.NODE_CALC_INTV * 10 * x[2];
        dzmin = 1e-15 * dt / SwephData.NODE_CALC_INTV;
        Gmsm = SwephData.HELGRAVCONST * (1 + plm) /
                            SweConst.AUNIT/SweConst.AUNIT/SweConst.AUNIT*86400.0*86400.0;
      }
      if ((iflag & SweConst.SEFLG_SPEED)!=0) {
        istart = 0;
        iend = 2;
      } else {
        istart = iend = 0;
        dt = 0;
      }
      for (i = istart, t = tjd_et - dt; i <= iend; i++, t += dt) {
        if (istart == iend) {
          t = tjd_et;
        }
        if (sw.swe_calc(t, ipli, iflJ2000, xpos[i], serr) == SweConst.ERR) {
          return SweConst.ERR;
        }
        /* the EMB is used instead of the earth */
        if (ipli == SweConst.SE_EARTH) {
          if (sw.swe_calc(t,
                       SweConst.SE_MOON,
                       iflJ2000 & ~(SweConst.SEFLG_BARYCTR|SweConst.SEFLG_HELCTR),
                       xposm, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          for (j = 0; j <= 2; j++)
            xpos[i][j] += xposm[j] / (SwephData.EARTH_MOON_MRAT + 1.0);
        }
        sw.swi_plan_for_osc_elem(iflg0, t, xpos[i]);
      }
      for (i = istart; i <= iend; i++) {
        if (Math.abs(xpos[i][5]) < dzmin) {
          xpos[i][5] = dzmin;
        }
        fac = xpos[i][2] / xpos[i][5];
        sgn = xpos[i][5] / Math.abs(xpos[i][5]);
        for (j = 0; j <= 2; j++) {
          xn[i][j] = (xpos[i][j] - fac * xpos[i][j+3]) * sgn;
          xs[i][j] = -xn[i][j];
        }
      }
      for (i = istart; i <= iend; i++) {
        /* node */
        rxy =  Math.sqrt(xn[i][0] * xn[i][0] + xn[i][1] * xn[i][1]);
        cosnode = xn[i][0] / rxy;
        sinnode = xn[i][1] / rxy;
        /* inclination */
        sl.swi_cross_prod(xpos[i], 0, xpos[i], 3, xnorm, 0);
        rxy =  xnorm[0] * xnorm[0] + xnorm[1] * xnorm[1];
        c2 = (rxy + xnorm[2] * xnorm[2]);
        rxyz = Math.sqrt(c2);
        rxy = Math.sqrt(rxy);
        sinincl = rxy / rxyz;
        cosincl = Math.sqrt(1 - sinincl * sinincl);
        /* argument of latitude */
        cosu = xpos[i][0] * cosnode + xpos[i][1] * sinnode;
        sinu = xpos[i][2] / sinincl;
        uu = Math.atan2(sinu, cosu);
        /* semi-axis */
        rxyz = Math.sqrt(sl.square_sum(xpos[i]));
        v2 = sl.square_sum(xpos[i], 3);
        sema = 1 / (2 / rxyz - v2 / Gmsm);
        /* eccentricity */
        pp = c2 / Gmsm;
        ecce = Math.sqrt(1 - pp / sema);
        /* eccentric anomaly */
        cosE = 1 / ecce * (1 - rxyz / sema);
        sinE = 1 / ecce / Math.sqrt(sema * Gmsm) *
                                        sw.dot_prod(xpos[i], xpos[i], 3);
        /* true anomaly */
        ny = 2 * Math.atan(Math.sqrt((1+ecce)/(1-ecce)) * sinE / (1 + cosE));
        /* distance of perihelion from ascending node */
        xq[i][0] = sl.swi_mod2PI(uu - ny);
        xq[i][1] = 0;                        /* latitude */
        xq[i][2] = sema * (1 - ecce);        /* distance of perihelion */
        /* transformation to ecliptic coordinates */
        sl.swi_polcart(xq[i], xq[i]);
        sl.swi_coortrf2(xq[i], xq[i], -sinincl, cosincl);
        sl.swi_cartpol(xq[i], xq[i]);
        /* adding node, we get perihelion in ecl. coord. */
        xq[i][0] += Math.atan2(sinnode, cosnode);
        xa[i][0] = sl.swi_mod2PI(xq[i][0] + SwephData.PI);
        xa[i][1] = -xq[i][1];
        if (do_focal_point) {
          xa[i][2] = sema * ecce * 2;        /* distance of aphelion */
        } else {
          xa[i][2] = sema * (1 + ecce);        /* distance of aphelion */
        }
        sl.swi_polcart(xq[i], xq[i]);
        sl.swi_polcart(xa[i], xa[i]);
        /* new distance of node from orbital ellipse:
         * true anomaly of node: */
        ny = sl.swi_mod2PI(ny - uu);
        ny2 = sl.swi_mod2PI(ny + SwephData.PI);
        /* eccentric anomaly */
        cosE = Math.cos(2 * Math.atan(Math.tan(ny / 2) /
                                             Math.sqrt((1+ecce) / (1-ecce))));
        cosE2 = Math.cos(2 * Math.atan(Math.tan(ny2 / 2) /
                                             Math.sqrt((1+ecce) / (1-ecce))));
        /* new distance */
        rn = sema * (1 - ecce * cosE);
        rn2 = sema * (1 - ecce * cosE2);
        /* old node distance */
        ro = Math.sqrt(sl.square_sum(xn[i]));
        ro2 = Math.sqrt(sl.square_sum(xs[i]));
        /* correct length of position vector */
        for (j = 0; j <= 2; j++) {
          xn[i][j] *= rn / ro;
          xs[i][j] *= rn2 / ro2;
        }
      }
      for (i = 0; i <= 2; i++) {
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
          xpe[i+xpeOffs] = xq[1][i];
          xpe[i+3+xpeOffs] = (xq[2][i] - xq[0][i]) / dt / 2;
          xap[i+xapOffs] = xa[1][i];
          xap[i+3+xapOffs] = (xa[2][i] - xa[0][i]) / dt / 2;
          xna[i] = xn[1][i];
          xna[i+3] = (xn[2][i] - xn[0][i]) / dt / 2;
          xnd[i+xndOffs] = xs[1][i];
          xnd[i+3+xndOffs] = (xs[2][i] - xs[0][i]) / dt / 2;
        } else {
          xpe[i+xpeOffs] = xq[0][i];
          xpe[i+3+xpeOffs] = 0;
          xap[i+xapOffs] = xa[0][i];
          xap[i+3+xapOffs] = 0;
          xna[i] = xn[0][i];
          xna[i+3] = 0;
          xnd[i+xndOffs] = xs[0][i];
          xnd[i+3+xndOffs] = 0;
        }
      }
      is_true_nodaps = true;
    }
    /* to set the variables required in the save area,
     * i.e. ecliptic, nutation, barycentric sun, earth
     * we compute the planet */
    if (ipli == SweConst.SE_MOON &&
        (iflag & (SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR))!=0) {
      sw.swi_force_app_pos_etc();
      if (sw.swe_calc(tjd_et, SweConst.SE_SUN, iflg0, x, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
    } else {
      if (sw.swe_calc(tjd_et, ipli,
                   iflg0 | (iflag & SweConst.SEFLG_TOPOCTR), x, serr) ==
                                                                SweConst.ERR) {
        return SweConst.ERR;
      }
    }
    
    if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
      /* geocentric position of observer */
      if (sw.swi_get_observer(tjd_et, iflag, false, xobs, serr) != SweConst.OK) {
        return SweConst.ERR;
      }
      /*for (i = 0; i <= 5; i++)
        xobs[i] = swed.topd.xobs[i];*/
    } else {
      for (i = 0; i <= 5; i++)
        xobs[i] = 0;
    }
    if ((iflag & (SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR))!=0) {
      if ((iflag & SweConst.SEFLG_HELCTR)!=0 &&
          (iflag & SweConst.SEFLG_MOSEPH)==0) {
        for (i = 0; i <= 5; i++)
          xobs[i] = xsun[i];
      }
    } else if (ipl == SweConst.SE_SUN && (iflag & SweConst.SEFLG_MOSEPH)==0) {
      for (i = 0; i <= 5; i++)
        xobs[i] = xsun[i];
    } else {
      /* barycentric position of observer */
      for (i = 0; i <= 5; i++)
        xobs[i] += xear[i];
    }
    /* ecliptic obliqity */
    if ((iflag & SweConst.SEFLG_J2000)!=0) {
      oe = swed.oec2000;
    } else {
      oe = swed.oec;
    }
    
    for (ij = 0, xp = xx, xpOffs = 0; ij < 4; ij++, xpOffs += 6) {
      /* no nodes for earth */
      if (ipli == SweConst.SE_EARTH && ij <= 1) {
        for (i = 0; i <= 5; i++)
              xp[i+xpOffs] = 0;
        continue;
      }
      
      if (is_true_nodaps && (iflag & SweConst.SEFLG_NONUT)==0) {
        sl.swi_coortrf2(xp, xpOffs, xp, xpOffs, -swed.nut.snut, swed.nut.cnut);
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
          sl.swi_coortrf2(xp, 3+xpOffs, xp, 3+xpOffs, -swed.nut.snut, swed.nut.cnut);
        }
      }
      sl.swi_coortrf2(xp, xpOffs, xp, xpOffs, -oe.seps, oe.ceps);
      sl.swi_coortrf2(xp, 3+xpOffs, xp, 3+xpOffs, -oe.seps, oe.ceps);
      if (is_true_nodaps) {
        
        if ((iflag & SweConst.SEFLG_NONUT)==0) {
          sw.swi_nutate(xp, xpOffs, iflag, true);
        }
      }
      
      sl.swi_precess(xp, xpOffs, tjd_et, SwephData.J_TO_J2000);
      if ((iflag & SweConst.SEFLG_SPEED)!=0) {
        sw.swi_precess_speed(xp, xpOffs, tjd_et, SwephData.J_TO_J2000);
      }
      
      if (ipli == SweConst.SE_MOON) {
        for (i = 0; i <= 5; i++)
          xp[i+xpOffs] += xear[i];
      } else {
        if ((iflag & SweConst.SEFLG_MOSEPH)==0 && !ellipse_is_bary) {
          for (j = 0; j <= 5; j++)
            xp[j+xpOffs] += xsun[j];
        }
      }
      
      for (j = 0; j <= 5; j++)
        xp[j+xpOffs] -= xobs[j];
          /* geocentric perigee/apogee of sun */
      if (ipl == SweConst.SE_SUN &&
          (iflag & (SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR))==0) {
        for (j = 0; j <= 5; j++)
          xp[j+xpOffs] = -xp[j+xpOffs];
      }
      
      dt = Math.sqrt(sl.square_sum(xp, xpOffs)) * SweConst.AUNIT / SwephData.CLIGHT / 86400.0;
      if (do_defl) {
        sw.swi_deflect_light(xp, xpOffs, dt, iflag);
      }
      
      if (do_aberr) {
        sw.swi_aberr_light(xp, xpOffs, xobs, iflag);
        /*
         * Apparent speed is also influenced by
         * the difference of speed of the earth between t and t-dt.
         * Neglecting this would result in an error of several 0.1"
         */
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
          /* get barycentric sun and earth for t-dt into save area */
          if (sw.swe_calc(tjd_et - dt, ipli,
                       iflg0 | (iflag & SweConst.SEFLG_TOPOCTR), x2, serr) ==
                                                                SweConst.ERR) {
            return SweConst.ERR;
          }
          if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            /* geocentric position of observer */
            /* if (sw.swi_get_observer(tjd_et - dt, iflag, false, xobs, serr) != SweConst.OK)
              return SweConst.ERR;*/
            for (i = 0; i <= 5; i++)
              xobs2[i] = swed.topd.xobs[i];
          } else {
            for (i = 0; i <= 5; i++)
              xobs2[i] = 0;
          }
          if ((iflag & (SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR))!=0) {
            if ((iflag & SweConst.SEFLG_HELCTR)!=0 &&
                (iflag & SweConst.SEFLG_MOSEPH)==0) {
              for (i = 0; i <= 5; i++)
                xobs2[i] = xsun[i];
            }
          } else if (ipl == SweConst.SE_SUN && (iflag & SweConst.SEFLG_MOSEPH)==0) {
            for (i = 0; i <= 5; i++)
              xobs2[i] = xsun[i];
          } else {
            /* barycentric position of observer */
            for (i = 0; i <= 5; i++)
              xobs2[i] += xear[i];
          }
          for (i = 3; i <= 5; i++)
            xp[i+xpOffs] += xobs[i] - xobs2[i];
          /* The above call of swe_calc() has destroyed the
           * parts of the save area
           * (i.e. bary sun, earth nutation matrix!).
           * to restore it:
           */
          if (sw.swe_calc(tjd_et, SweConst.SE_SUN,
                       iflg0 | (iflag & SweConst.SEFLG_TOPOCTR), x2, serr) ==
                                                                SweConst.ERR) {
            return SweConst.ERR;
          }
        }
      }
      
      /* save J2000 coordinates; required for sidereal positions */
      for (j = 0; j <= 5; j++)
        x2000[j] = xp[j+xpOffs];
      if ((iflag & SweConst.SEFLG_J2000)==0) {
        sl.swi_precess(xp, xpOffs, tjd_et, SwephData.J2000_TO_J);
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
          sw.swi_precess_speed(xp, xpOffs, tjd_et, SwephData.J2000_TO_J);
        }
      }
      
      if ((iflag & SweConst.SEFLG_NONUT)==0) {
        sw.swi_nutate(xp, xpOffs, iflag, false);
      }
      /* now we have equatorial cartesian coordinates; keep them */
      for (j = 0; j <= 5; j++)
        pldat.xreturn[18+j] = xp[j+xpOffs];
      
      sl.swi_coortrf2(xp, xpOffs, xp, xpOffs, oe.seps, oe.ceps);
      if ((iflag & SweConst.SEFLG_SPEED)!=0) {
        sl.swi_coortrf2(xp, 3+xpOffs, xp, 3+xpOffs, oe.seps, oe.ceps);
      }
      if ((iflag & SweConst.SEFLG_NONUT)==0) {
        sl.swi_coortrf2(xp, xpOffs, xp, xpOffs, swed.nut.snut, swed.nut.cnut);
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
          sl.swi_coortrf2(xp, 3+xpOffs, xp, 3+xpOffs,
                          swed.nut.snut, swed.nut.cnut);
        }
      }
        /* now we have ecliptic cartesian coordinates */
        for (j = 0; j <= 5; j++)
          pldat.xreturn[6+j] = xp[j+xpOffs];
      
      if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
        /* project onto ecliptic t0 */
        if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0) {
          if (sw.swi_trop_ra2sid_lon(x2000, pldat.xreturn, 6, pldat.xreturn, 18, iflag, serr) != SweConst.OK) {
            return SweConst.ERR;
          }
        /* project onto solar system equator */
        } else if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
          if (sw.swi_trop_ra2sid_lon_sosy(x2000, pldat.xreturn, 6, pldat.xreturn, 18, iflag, serr) != SweConst.OK) {
            return SweConst.ERR;
        }
        } else {
        /* traditional algorithm */
        sl.swi_cartpol_sp(pldat.xreturn, 6, pldat.xreturn, 0);
        pldat.xreturn[0] -= sw.swe_get_ayanamsa(tjd_et) * SwissData.DEGTORAD;
        sl.swi_polcart_sp(pldat.xreturn, 0, pldat.xreturn, 6);
        }
      }
      if ((iflag & SweConst.SEFLG_XYZ)!=0 &&
          (iflag & SweConst.SEFLG_EQUATORIAL)!=0) {
        for (j = 0; j <= 5; j++)
          xp[j+xpOffs] = pldat.xreturn[18+j];
        continue;
      }
      if ((iflag & SweConst.SEFLG_XYZ)!=0) {
        for (j = 0; j <= 5; j++)
          xp[j+xpOffs] = pldat.xreturn[6+j];
        continue;
      }
      
      sl.swi_cartpol_sp(pldat.xreturn, 18, pldat.xreturn, 12);
      sl.swi_cartpol_sp(pldat.xreturn, 6, pldat.xreturn, 0);
      
      for (j = 0; j < 2; j++) {
        pldat.xreturn[j] *= SwissData.RADTODEG;                /* ecliptic */
        pldat.xreturn[j+3] *= SwissData.RADTODEG;
        pldat.xreturn[j+12] *= SwissData.RADTODEG;        /* equator */
        pldat.xreturn[j+15] *= SwissData.RADTODEG;
      }
      if ((iflag & SweConst.SEFLG_EQUATORIAL)!=0) {
        for (j = 0; j <= 5; j++)
          xp[j+xpOffs] = pldat.xreturn[12+j];
        continue;
      } else {
        for (j = 0; j <= 5; j++)
          xp[j+xpOffs] = pldat.xreturn[j];
        continue;
      }
    }
    for (i = 0; i <= 5; i++) {
      if (i > 2 && (iflag & SweConst.SEFLG_SPEED)==0) {
        xna[i] = xnd[i+xndOffs] = xpe[i+xpeOffs] = xap[i+xapOffs] = 0;
      }
      if (xnasc != null) {
        xnasc[i] = xna[i];
      }
      if (xndsc != null) {
        xndsc[i] = xnd[i+xndOffs];
      }
      if (xperi != null) {
        xperi[i] = xpe[i+xpeOffs];
      }
      if (xaphe != null) {
        xaphe[i] = xap[i+xapOffs];
      }
    }
    return SweConst.OK;
  }

  
  int swe_nod_aps_ut(double tjd_ut, int ipl, int iflag,
                     int  method,
                     double[] xnasc, double[] xndsc,
                     double[] xperi, double[] xaphe,
                     StringBuffer serr) {
    return swe_nod_aps(tjd_ut + SweDate.getDeltaT(tjd_ut),
                        ipl, iflag, method, xnasc, xndsc, xperi, xaphe,
                        serr);
  }


  /* function finds the gauquelin sector position of a planet or fixed star
   * 
   * if starname != NULL then a star is computed.
   * iflag: use the flags SE_SWIEPH, SE_JPLEPH, SE_MOSEPH, SEFLG_TOPOCTR.
   *
   * imeth defines method:
   *           imeth = 0                  sector from longitude and latitude
   *           imeth = 1                  sector from longitude, with lat = 0
   *           imeth = 2                  sector from rise and set
   *           imeth = 3                  sector from rise and set with refraction
   * rise and set are defined as appearance and disappearance of disc center.
   *
   * geopos is an array of 3 doubles for geo. longitude, geo. latitude, elevation.
   * atpress and attemp are only needed for imeth = 3. If imeth = 3,
   * If imeth=3 and atpress not given (= 0), the programm assumes 1013.25 mbar;
   * if a non-zero height above sea is given in geopos, atpress is estimated.
   * dgsect is return area (pointer to a double)
   * serr is pointer to error string, may be NULL
   */
  int swe_gauquelin_sector(double t_ut, int ipl, StringBuffer starname, int iflag, int imeth, double[] geopos, double atpress, double attemp, DblObj dgsect, StringBuffer serr) {
    DblObj dtmp=new DblObj();
    boolean rise_found = true;
    boolean set_found = true;
    int retval;
    double tret[]=new double[3];
    double t_et, t;
    double x0[]=new double[6];
    double eps, nutlo[]=new double[2], armc;
    int epheflag = iflag & SweConst.SEFLG_EPHMASK;
    boolean do_fixstar = (starname != null && starname.length() > 0);
    int risemeth = SweConst.SE_BIT_DISC_CENTER;
    boolean above_horizon = false;
    /* 
     * geometrically from ecl. longitude and latitude 
     */
    if ((imeth & 2)==0) {
      t_et = t_ut + SweDate.getDeltaT(t_ut);
      eps = sl.swi_epsiln(t_et) * SwissData.RADTODEG;
      sl.swi_nutation(t_et, nutlo);
      nutlo[0] *= SwissData.RADTODEG;
      nutlo[1] *= SwissData.RADTODEG;
      armc = sl.swe_degnorm(sl.swe_sidtime0(t_ut, eps + nutlo[1], nutlo[0]) * 15 + geopos[0]);
      if (do_fixstar) {
        if (sw.swe_fixstar(starname, t_et, iflag, x0, serr) == SweConst.ERR)
  	return SweConst.ERR;
      } else {
        if (sw.swe_calc(t_et, ipl, iflag, x0, serr) == SweConst.ERR)
  	return SweConst.ERR;
      }
      if ((imeth & 1)!=0) 
        x0[1] = 0;
      dgsect.val = sw.swe_house_pos(armc, geopos[1], eps + nutlo[1], 'G', x0, null);
      return SweConst.OK;
    }
    /* 
     * from rise and set times
     */
    if (imeth == 2) 
      risemeth |= SweConst.SE_BIT_NO_REFRACTION;
    /* find the next rising time of the planet or star */
    dtmp.val=tret[0];
    retval = swe_rise_trans(t_ut, ipl, starname, epheflag,
                            SweConst.SE_CALC_RISE|risemeth, geopos, atpress, attemp,
                            dtmp, serr);
    tret[0]=dtmp.val;
    if (retval == SweConst.ERR) {
      return SweConst.ERR; 
    } else if (retval == -2) {
      /* actually, we could return ERR here. However, we
       * keep this variable, in case we implement an algorithm
       * for Gauquelin sector positions of circumpolar bodies.
       * As with the Ludwig Otto procedure with Placidus, one 
       * could replace missing rises or sets by meridian transits,
       * although there are cases where even this is not possible.
       * Sometimes a body both appears and disappears on the western 
       * part of the horizon. Using true culminations rather than meridan
       * transits would not help in any case either, because there are
       * cases where a body does not have a culmination within days,
       * e.g. the sun near the poles.
       */
      rise_found = false;    
    }
    /* find the next setting time of the planet or star */
    dtmp.val=tret[1];
    retval = swe_rise_trans(t_ut, ipl, starname, epheflag,
                            SweConst.SE_CALC_SET|risemeth, geopos, atpress, attemp,
                            dtmp, serr);
    tret[1]=dtmp.val;
    if (retval == SweConst.ERR) {
      return SweConst.ERR; 
    } else if (retval == -2) {
      set_found = false;
    }
    if (tret[0] < tret[1] && rise_found == true) {
      above_horizon = false;
      /* find last set */
      t = t_ut - 1.2;
      if (set_found) t = tret[1] - 1.2;
      set_found = true;
      dtmp.val=tret[1];
      retval = swe_rise_trans(t, ipl, starname, epheflag,
                            SweConst.SE_CALC_SET|risemeth, geopos, atpress, attemp,
                            dtmp, serr);
      tret[1]=dtmp.val;
      if (retval == SweConst.ERR) {
        return SweConst.ERR; 
      } else if (retval == -2) {
        set_found = false;
      }
    } else if (tret[0] >= tret[1] && set_found == true) {
      above_horizon = true;
      /* find last rise */
      t = t_ut - 1.2;
      if (rise_found) t = tret[0] - 1.2;
      rise_found = true;
      dtmp.val=tret[0];
      retval = swe_rise_trans(t, ipl, starname, epheflag,
                            SweConst.SE_CALC_RISE|risemeth, geopos, atpress, attemp,
                            dtmp, serr);
      tret[0]=dtmp.val;
      if (retval == SweConst.ERR) {
        return SweConst.ERR; 
      } else if (retval == -2) {
        rise_found = false;
      }
    }
    if (rise_found && set_found) {
      if (above_horizon) {
        dgsect.val = (t_ut - tret[0]) / (tret[1] - tret[0]) * 18 + 1;
      } else {
        dgsect.val = (t_ut - tret[1]) / (tret[0] - tret[1]) * 18 + 19;
      }
      return SweConst.OK;
    } else {
      dgsect.val = 0;
      if (serr!=null)
        serr.append("rise or set not found for planet ").append(ipl);
      return SweConst.ERR;
    }
  }
} // End of class Swecl


class SweConst {

////////////////////////////////////////////////////////////////////////////////
//// sweodef.h: ////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
  
  public static final int OK=0;
  
  public static final int ERR=-1;

//////////////////////////////////////////////////////////////////////////////
// swephexp.h: ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
  /*
   * planet numbers for the ipl parameter in swe_calc()
   */
  
  public static final int SE_ECL_NUT=-1;

  
  public static final int SE_SUN=0;
  
  public static final int SE_MOON=1;
  
  public static final int SE_MERCURY=2;
  
  public static final int SE_VENUS=3;
  
  public static final int SE_MARS=4;
  
  public static final int SE_JUPITER=5;
  
  public static final int SE_SATURN=6;
  
  public static final int SE_URANUS=7;
  
  public static final int SE_NEPTUNE=8;
  
  public static final int SE_PLUTO=9;
  
  public static final int SE_MEAN_NODE=10;
  
  public static final int SE_TRUE_NODE=11;
  
  public static final int SE_MEAN_APOG=12;
  
  public static final int SE_OSCU_APOG=13;
  
  public static final int SE_EARTH=14;
  
  public static final int SE_CHIRON=15;
  
  public static final int SE_PHOLUS=16;
  
  public static final int SE_CERES=17;
  
  public static final int SE_PALLAS=18;
  
  public static final int SE_JUNO=19;
  
  public static final int SE_VESTA=20;
  
  public static final int SE_INTP_APOG=21;
  
  public static final int SE_INTP_PERG=22;

  
  static final int SE_NPLANETS=23;

  
  public static final int SE_AST_OFFSET=10000;
  public static final int SE_VARUNA  =(SE_AST_OFFSET + 20000);

  static final int SE_FICT_OFFSET=40;
  public static final int SE_FICT_OFFSET_1=39;
  static final int SE_FICT_MAX=999;
  static final int SE_NFICT_ELEM=15;

  static final int SE_COMET_OFFSET=2000;

  static final int SE_NALL_NAT_POINTS=(SE_NPLANETS + SE_NFICT_ELEM);

  /* Hamburger or Uranian "planets" */
  
  public static final int SE_CUPIDO=40;
  
  public static final int SE_HADES=41;
  
  public static final int SE_ZEUS=42;
  
  public static final int SE_KRONOS=43;
  
  public static final int SE_APOLLON=44;
  
  public static final int SE_ADMETOS=45;
  
  public static final int SE_VULKANUS=46;
  
  public static final int SE_POSEIDON=47;
  /* other fictitious bodies */
  
  public static final int SE_ISIS=48;
  
  public static final int SE_NIBIRU=49;
  
  public static final int SE_HARRINGTON=50;
  
  public static final int SE_NEPTUNE_LEVERRIER=51;
  
  public static final int SE_NEPTUNE_ADAMS=52;
  
  public static final int SE_PLUTO_LOWELL=53;
  
  public static final int SE_PLUTO_PICKERING=54;
  
  public static final int SE_VULCAN=55;
  
  public static final int SE_WHITE_MOON=56;
  
  public static final int SE_PROSERPINA=57;
  
  public static final int SE_WALDEMATH=58;

  public static final int SE_FIXSTAR=-10;

  
  static final int SE_ASC   =0;
  
  static final int SE_MC    =1;
  
  static final int SE_ARMC  =2;
  
  static final int SE_VERTEX=3;
  
  static final int SE_EQUASC=4;
  
  static final int SE_COASC1=5;
  
  static final int SE_COASC2=6;
  
  static final int SE_POLASC=7;
  
  static final int SE_NASCMC=8;

  /*
   * only used for experimenting with various JPL ephemeris files
   * which are available at Astrodienst's internal network
   */
  public static final String SE_FNAME_DE406="de406.eph";
  public static final String SE_FNAME_DE200="de200.eph";
  public static final String SE_FNAME_DFT=SE_FNAME_DE406;

  /*
   * flag bits for parameter iflag in function swe_calc()
   * The flag bits are defined in such a way that iflag = 0 delivers what one
   * usually wants:
   *    - the default ephemeris (SWISS EPHEMERIS) is used,
   *    - apparent geocentric positions referring to the true equinox of date
   *      are returned.
   * If not only coordinates, but also speed values are required, use
   * flag = SEFLG_SPEED.
   *
   * The 'L' behind the number indicates that 32-bit integers (Long) are used.
   */
  
  public static final int SEFLG_HELCTR=8;     // return heliocentric position
  
  public static final int SEFLG_TRUEPOS=16;   // return true positions, not apparent
  
  public static final int SEFLG_J2000=32;     // no precession, i.e. give J2000 equinox
  
  public static final int SEFLG_NONUT=64;     // no nutation, i.e. mean equinox of date
  
  public static final int SEFLG_SPEED3=128;   // speed from 3 positions (do not use
                                       // it, SEFLG_SPEED is faster and more
                                       // precise.)
  
  public static final int SEFLG_SPEED=256;    // high precision speed
  
  public static final int SEFLG_NOGDEFL=512;  // turn off gravitational deflection
  
  public static final int SEFLG_NOABERR=1024; // turn off 'annual' aberration of light
  
  public static final int SEFLG_EQUATORIAL=2*1024; // equatorial positions are wanted
  
  public static final int SEFLG_XYZ=4*1024;     // cartesian, not polar, coordinates
  
  public static final int SEFLG_RADIANS=8*1024; // coordinates in radians, not degrees
  
  public static final int SEFLG_BARYCTR=16*1024; // barycentric positions
  
  public static final int SEFLG_TOPOCTR=32*1024; // topocentric positions
  
  public static final int SEFLG_SIDEREAL=64*1024; // sidereal positions
  
  public static final int SEFLG_ICRS=128*1024; // ICRS (DE406 reference frame)

  
  public static final int SEFLG_TRANSIT_LONGITUDE =  128*1024;
  
  public static final int SEFLG_TRANSIT_LATITUDE  =  256*1024;
  
  public static final int SEFLG_TRANSIT_DISTANCE  =  512*1024;
  
  public static final int SEFLG_TRANSIT_SPEED     = 1024*1024;
  
  public static final int SEFLG_YOGA_TRANSIT      = 2048*1024;

  
  public static final int SEFLG_JPLEPH=1;
  
  public static final int SEFLG_SWIEPH=2;
  
  public static final int SEFLG_MOSEPH=4;
  
  public static final int SEFLG_DEFAULTEPH=SEFLG_SWIEPH;
  public static final int SEFLG_EPHMASK=SEFLG_JPLEPH|SEFLG_SWIEPH|SEFLG_MOSEPH;

  public static final int SE_SIDBITS             =256;
  /* for projection onto ecliptic of t0 */
  
  public static final int SE_SIDBIT_ECL_T0       =256;
  /* for projection onto solar system plane */
  
  public static final int SE_SIDBIT_SSY_PLANE    =512;

  /* sidereal modes (ayanamsas) */
  
  public static final int SE_SIDM_FAGAN_BRADLEY  = 0;
  
  public static final int SE_SIDM_LAHIRI         = 1;
  
  public static final int SE_SIDM_DELUCE         = 2;
  
  public static final int SE_SIDM_RAMAN          = 3;
  
  public static final int SE_SIDM_USHASHASHI     = 4;
  
  public static final int SE_SIDM_KRISHNAMURTI   = 5;
  
  public static final int SE_SIDM_DJWHAL_KHUL    = 6;
  
  public static final int SE_SIDM_YUKTESHWAR     = 7;
  
  public static final int SE_SIDM_JN_BHASIN      = 8;
  
  public static final int SE_SIDM_BABYL_KUGLER1  = 9;
  
  public static final int SE_SIDM_BABYL_KUGLER2  =10;
  
  public static final int SE_SIDM_BABYL_KUGLER3  =11;
  
  public static final int SE_SIDM_BABYL_HUBER    =12;
  
  public static final int SE_SIDM_BABYL_ETPSC    =13;
  
  public static final int SE_SIDM_ALDEBARAN_15TAU=14;
  
  public static final int SE_SIDM_HIPPARCHOS     =15;
  
  public static final int SE_SIDM_SASSANIAN      =16;
  
  public static final int SE_SIDM_GALCENT_0SAG   =17;
  
  public static final int SE_SIDM_J2000          =18;
  
  public static final int SE_SIDM_J1900          =19;
  
  public static final int SE_SIDM_B1950          =20;
  
  public static final int SE_SIDM_USER          =255;

  static final int SE_MAX_STNAME=20;    // maximum size of fixstar name;
                                        // the parameter star in swe_fixstar
					// must allow twice this space for
				        // the returned star name.



  /* used for swe_nod_aps(): */
  
  public static final int SE_NODBIT_MEAN    =1; // mean nodes/apsides
  
  public static final int SE_NODBIT_OSCU    =2; // osculating nodes/apsides
  
  public static final int SE_NODBIT_OSCU_BAR=4; // same, but motion about solar
                                             // system barycenter is considered
  
  public static final int SE_NODBIT_FOPOINT =256; // focal point of orbit
                                                  // instead of aphelion


  /* defines for function swe_split_deg() (in swephlib.c) */
  public static final int SE_SPLIT_DEG_ROUND_SEC =  1;
  public static final int SE_SPLIT_DEG_ROUND_MIN =  2;
  public static final int SE_SPLIT_DEG_ROUND_DEG =  4;
  public static final int SE_SPLIT_DEG_ZODIACAL  =  8;
  public static final int SE_SPLIT_DEG_KEEP_SIGN = 16;

  public static final int SE_SPLIT_DEG_KEEP_DEG  = 32;



  /*
   * ephemeris path
   * this defines where ephemeris files are expected if the function
   * swe_set_ephe_path() is not called by the application.
   * Normally, every application should make this call to define its
   * own place for the ephemeris files.
   */
  
  public static final String SE_EPHE_PATH=".:./ephe:/users/ephe2/:/users/ephe/";
//  public static final String SE_EPHE_PATH=".:./ephe:/users/ephe2/:/users/ephe/:c\\:\\\\ephe:d\\:\\\\ephe:http\\://www.th-mack.de/datafiles";
                        /* At Astrodienst, we maintain two ephemeris areas for
                           the thousands of asteroid files:
                           the short files in /users/ephe/ast*,
                           the long file in /users/ephe2/ast*. */

  static final String SE_STARFILE="fixstars.cat";
  static final String SE_ASTNAMFILE="seasnam.txt";
  
  static final String SE_FICTFILE="seorbel.txt";


  /* defines for eclipse computations */

  public static final int SE_ECL_CENTRAL=1;
  public static final int SE_ECL_NONCENTRAL=2;
  public static final int SE_ECL_TOTAL=4;
  
  public static final int SE_ECL_ANNULAR=8;
  public static final int SE_ECL_PARTIAL=16;
  public static final int SE_ECL_ANNULAR_TOTAL=32;
  public static final int SE_ECL_PENUMBRAL=64;
  public static final int SE_ECL_VISIBLE=128;
  public static final int SE_ECL_MAX_VISIBLE=256;
  
  public static final int SE_ECL_1ST_VISIBLE=512;
  
  public static final int SE_ECL_2ND_VISIBLE=1024;
  
  public static final int SE_ECL_3RD_VISIBLE=2048;
  
  public static final int SE_ECL_4TH_VISIBLE=4096;
  
  public static final int SE_ECL_ONE_TRY=32*1024;

  /* for swe_rise_transit() */
  
  public static final int SE_CALC_RISE          = 1;
  
  public static final int SE_CALC_SET           = 2;
  
  public static final int SE_CALC_MTRANSIT      = 4;
  
  public static final int SE_CALC_ITRANSIT      = 8;
  
  public static final int SE_BIT_DISC_CENTER   = 256;
                                    /* to be or'ed to SE_CALC_RISE/SET */
                                    /* if rise or set of disc center is */
                                    /* required */
  
  public static final int SE_BIT_NO_REFRACTION = 512;
                                    /* to be or'ed to SE_CALC_RISE/SET, */
                                    /* if refraction is not to be considered */

  /* for swe_azalt() and swe_azalt_rev() */
  
  public static final int SE_ECL2HOR            = 0;
  
  public static final int SE_EQU2HOR            = 1;
  
  public static final int SE_HOR2ECL            = 0;
  
  public static final int SE_HOR2EQU            = 1;

  /* for swe_refrac() */
  
  public static final int SE_TRUE_TO_APP =0;
  
  public static final int SE_APP_TO_TRUE =1;

//  static final int pnoext2int[] = {SwephData.SEI_SUN, SwephData.SEI_MOON,
//    SwephData.SEI_MERCURY, SwephData.SEI_VENUS, SwephData.SEI_MARS,
//    SwephData.SEI_JUPITER, SwephData.SEI_SATURN, SwephData.SEI_URANUS,
//    SwephData.SEI_NEPTUNE, SwephData.SEI_PLUTO, 0, 0, 0, 0, SwephData.SEI_EARTH,
//    SwephData.SEI_CHIRON, SwephData.SEI_PHOLUS, SwephData.SEI_CERES,
//    SwephData.SEI_PALLAS, SwephData.SEI_JUNO, SwephData.SEI_VESTA, };
//

// we always use Astronomical Almanac constants, if available
  public static final double AUNIT=1.4959787066e+11;        // au in meters,
                                                            // AA 1996 K6
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

  
  private SweConst() {
  }
}



class SweDate {

  private static SwissEph sw = new SwissEph();

  
  public static final int SUNDAY=0;
  
  public static final int MONDAY=1;
  
  public static final int TUESDAY=2;
  
  public static final int WEDNESDAY=3;
  
  public static final int THURSDAY=4;
  
  public static final int FRIDAY=5;
  
  public static final int SATURDAY=6;

  public static final boolean SE_JUL_CAL=false;
  public static final boolean SE_GREG_CAL=true;
  public static final boolean SE_KEEP_DATE=true;
  public static final boolean SE_KEEP_JD=false;


// for delta t: tidal acceleration in the mean motion of the moon

  
  public static final double SE_TIDAL_DE403=-25.8;
  
  public static final double SE_TIDAL_DE404=-25.8;
  
  public static final double SE_TIDAL_DE405=-25.7376;
  
  public static final double SE_TIDAL_DE406=-25.7376;
  
  public static final double SE_TIDAL_DE200=-23.8946;
  
  public static final double SE_TIDAL_26=-26.0;
  
  public static final double SE_TIDAL_DEFAULT=SE_TIDAL_DE406;



  
  public static final double JD0=2440587.5;          /* 1970 January 1.0 */

  private double tid_acc = SE_TIDAL_DEFAULT;
  private static boolean init_dt_done = false;
  private double jd;
  // JD for the start of the Gregorian calendar system (October 15, 1582):
  private double jdCO = 2299160.5;
  private boolean calType;
  private int year;
  private int month;
  private int day;
  private double hour;
  private double deltaT;
  private boolean deltatIsValid=false;


  //////////////////////////////////////////////////////////////////////////////
  // Constructors //////////////////////////////////////////////////////////////

  // The following constructors keep julian day in favor of date:
  
  public SweDate() {
    Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT+0"));
    setFields(cal.get(Calendar.YEAR),
          cal.get(Calendar.MONTH) + 1,
          cal.get(Calendar.DAY_OF_MONTH),
          cal.get(Calendar.HOUR_OF_DAY) +
                cal.get(Calendar.MINUTE)/60. +
                cal.get(Calendar.SECOND)/3600. +
                cal.get(Calendar.MILLISECOND)/3600000.,
          SE_GREG_CAL);
  }
  
  public SweDate(double jd) {
    initDateFromJD(jd, jdCO<=jd?SE_GREG_CAL:SE_JUL_CAL);
  }
  
  public SweDate(double jd, boolean calType) {
    initDateFromJD(jd, calType);
  }

  
  public SweDate(int year, int month, int day, double hour) {
    setFields(year, month, day, hour);
  }
  
  public SweDate(int year, int month, int day, double hour, boolean calType) {
     setFields(year, month, day, hour, calType);
   }
  // End of constructors
  //////////////////////////////////////////////////////////////////////////////


  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
  // Public methods: ///////////////////////////////////////////////////////////


  //////////////////////////////////////////////////////////////////////////////
  // Access to private variables ///////////////////////////////////////////////
  // Read access: //
  
  public double getJulDay() {
    return this.jd;
  }
  
  public static double getJulDay(int year, int month, int day, double hour) {
    double sjd = swe_julday(year, month, day, hour, SE_GREG_CAL);
    return sjd;
  }
  
  public static double getJulDay(int year, int month, int day, double hour,
                                 boolean calType) {
    double sjd = swe_julday(year, month, day, hour, calType);
    return sjd;
  }

  // 0=Sunday, 1=Monday etc.
  
  public int getDayOfWeekNr() {
    return ((int)(this.jd-5.5))%7;
  }
  
  public static synchronized int getDayOfWeekNr(double jd) {
    return ((int)(jd-5.5))%7;
  }
  
  public static int getDayOfWeekNr(int year, int month, int day) {
    int sdow = ((int)(swe_julday(year, month, day, 0.0, SE_GREG_CAL)-5.5))%7;
    return sdow;
  }

  
  public static int getDayOfWeekNr(int year, int month, int day,
                                   boolean calType) {
    int sdow = ((int)(swe_julday(year, month, day, 0.0, calType)-5.5))%7;
    return sdow;
  }

  
  public boolean getCalendarType() {
    return this.calType;
  }

  
  public int getYear() {
    return this.year;
  }
//  int getYear(double jd /*, boolean calType ?*/) { swe_revjul(jd,calType); }

  
  public int getMonth() {
    return this.month;
  }

  
  public int getDay() {
    return this.day;
  }

  
  public double getHour() {
    return this.hour;
  }

  
  public double getDeltaT() {
    if (deltatIsValid) { return this.deltaT; }
    this.deltaT=calc_deltaT(this.getJulDay());
    deltatIsValid=true;
    return this.deltaT;
  }

  
  static public double getDeltaT(double tjd) {
    double sdt = calc_deltaT(tjd, SE_TIDAL_DEFAULT);
    return sdt;
  }

  
  public Date getDate(long offset) {
    long millis=(long)((getJulDay()-JD0)*24L*3600L*1000L)+offset;
    return new Date(millis);
  }

  
  public static Date getDate(double jd) {
    long millis=(long)((jd-JD0)*24L*3600L*1000L);
    return new Date(millis);
  }
  // End of read access //


  // Write access: //
  
  public void setJulDay(double newJD) {
    this.jd=newJD;
    deltatIsValid=false;
    IDate dt=swe_revjul(newJD,this.calType);
    this.year=dt.year;
    this.month=dt.month;
    this.day=dt.day;
    this.hour=dt.hour;
  }

  
  public void setCalendarType(boolean newCalType, boolean keepDate) {
    if (this.calType != newCalType) {
      this.calType=newCalType;
      deltatIsValid=false;
      if (keepDate) {
        this.jd=swe_julday(this.year, this.month, this.day,
                           this.hour, this.calType);
      } else {
        IDate dt=swe_revjul(this.jd,newCalType);
        this.year=dt.year;
        this.month=dt.month;
        this.day=dt.day;
        this.hour=dt.hour;
      }
    }
  }

  
  public void updateCalendarType() {
    this.calType=(this.jdCO<=this.jd?SE_GREG_CAL:SE_JUL_CAL);;
  }


  // Date:
  
  public boolean setDate(int newYear, int newMonth, int newDay,
                         double newHour) {
    this.year=newYear;
    this.month=newMonth;
    this.day=newDay;
    this.hour=newHour;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    return true;
  }

  
  public boolean setDate(int newYear, int newMonth, int newDay, double newHour,
                         boolean check) {
    this.year=newYear;
    double oldMonth=this.month;
    double oldDay=this.day;
    this.month=newMonth;
    this.day=newDay;
    this.hour=newHour;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    if (check) {
      IDate dt=swe_revjul(this.jd,this.calType);  // -> erzeugt neues Datum
      this.year=dt.year;
      this.month=dt.month;
      this.day=dt.day;
      this.hour=dt.hour;
      return (this.year==newYear && this.month==oldMonth && this.day==oldDay);
    }
    return true;
  }


  // Year:
  
  public boolean setYear(int newYear) {
    this.year=newYear;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    return true;
  }

  
  public boolean setYear(int newYear, boolean check) {
    this.year=newYear;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    if (check) {
      double oldMonth=this.month;
      double oldDay=this.day;
      IDate dt=swe_revjul(this.jd,this.calType);  // -> erzeugt neues Datum
      this.year=dt.year;
      this.month=dt.month;
      this.day=dt.day;
      this.hour=dt.hour;
      return (this.year==newYear && this.month==oldMonth && this.day==oldDay);
    }
    return true;
  }


  
  // Monat:
  public boolean setMonth(int newMonth) {
    this.month=newMonth;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    return true;
  }

  
  public boolean setMonth(int newMonth, boolean check) {
    this.month=newMonth;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    if (check) {
      double oldYear=this.year;
      double oldDay=this.day;
      IDate dt=swe_revjul(this.jd,this.calType);  // -> erzeugt neues Datum
      this.year=dt.year;
      this.month=dt.month;
      this.day=dt.day;
      this.hour=dt.hour;
      return (this.year==oldYear && this.month==newMonth && this.day==oldDay);
    }
    return true;
  }


  // Tag:
  
  public boolean setDay(int newDay) {
    this.day=newDay;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);
    return true;
  }

  
  public boolean setDay(int newDay, boolean check) {
    this.day=newDay;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    if (check) {
      double oldYear=this.year;
      double oldMonth=this.month;
      IDate dt=swe_revjul(this.jd,this.calType);  // -> erzeugt neues Datum
      this.year=dt.year;
      this.month=dt.month;
      this.day=dt.day;
      this.hour=dt.hour;
      return (this.year==oldYear && this.month==oldMonth && this.day==newDay);
    }
    return true;
  }


  // Time:
  
  public boolean setHour(double newHour) {
    this.hour=newHour;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);
    return true;
  }


  // Datum ueberpruefen:
  
  public boolean checkDate() {
    boolean cd = checkDate(this.year, this.month, this.day, this.hour);
    return cd;
  }

  
  public boolean checkDate(int year, int month, int day) {
    boolean cd = checkDate(year, month, day, 0.0);
    return cd;
  }

  
  public boolean checkDate(int year, int month, int day, double hour) {
    double jd=swe_julday(year,month,day,hour,SE_GREG_CAL);
    IDate dt=swe_revjul(jd,SE_GREG_CAL);
    return (dt.year==year && dt.month==month && dt.day==day);
  }

  
  public void makeValidDate() {
    double jd=swe_julday(this.year,this.month,this.day,this.hour,SE_GREG_CAL);
    IDate dt=swe_revjul(jd,SE_GREG_CAL);
    this.year=dt.year;
    this.month=dt.month;
    this.day=dt.day;
    this.hour=dt.hour;
  }

  
  public double getGregorianChange() {
    return this.jdCO;
  }

  
  public void setGregorianChange(int year, int month, int day) {
    this.year = year;
    this.month = month;
    this.day = day;
    deltatIsValid = false;
    this.calType = SE_GREG_CAL;
    if (this.year < year ||
        (this.year == year && this.month < month) ||
        (this.year == year && this.month == month && this.day < day)) {
      this.calType = SE_JUL_CAL;
    }
    this.jdCO = swe_julday(year, month, day, 0., SE_GREG_CAL);
    this.jd = swe_julday(this.year, this.month, this.day, this.hour,
                         this.calType);
  }

  
  public void setGregorianChange(double newJDCO) {
    this.jdCO = newJDCO;
    this.calType = (this.jd>=this.jdCO?SE_GREG_CAL:SE_JUL_CAL);
    IDate dt = swe_revjul(this.jd,this.calType);
    this.year = dt.year;
    this.month = dt.month;
    this.day = dt.day;
    this.hour = dt.hour;
  }
  // End of access to private variables ////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  
  public double getTidalAcc() {
    return this.tid_acc;
  }

  
  public void setTidalAcc(double tid_acc) {
    this.tid_acc=tid_acc;
  }

  
  public String toString() {
    double hour = getHour();
    String h = (int)hour + ":";
    hour = 60 * (hour - (int)hour);
    h += (int)hour + ":";
    hour = 60 * (hour - (int)hour);
    h += hour ;
               
    return "(YYYY/MM/DD) " +
           getYear() + "/" +
           (getMonth()<10?"0":"") + getMonth() + "/" +
           (getDay()<10?"0":"") + getDay() + ", " +
           h + "h " +
           (getCalendarType()?"(greg)":"(jul)") + "\n" +
           "Jul. Day: " + getJulDay() + "; " +
           "DeltaT: " + getDeltaT();
  }

  // End of public methods /////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////////////
  // Private methods: //////////////////////////////////////////////////////////
  private static synchronized double swe_julday(int year, int month, int day,
                                                double hour, boolean calType) {
    double jd;
    double u,u0,u1,u2;
    u = year;
    if (month < 3) { u -=1; }
    u0 = u + 4712.0;
    u1 = month + 1.0;
    if (u1 < 4) { u1 += 12.0; }
    jd = Math.floor(u0*365.25)
       + Math.floor(30.6*u1+0.000001)
       + day + hour/24.0 - 63.5;
    if (calType == SE_GREG_CAL) {
      u2 = Math.floor(Math.abs(u) / 100) - Math.floor(Math.abs(u) / 400);
      if (u < 0.0) {
        u2 = -u2;
      }
      jd = jd - u2 + 2;
      if ((u < 0.0) && (u/100 == Math.floor(u/100)) &&
                          (u/400 != Math.floor(u/400))) {
        jd -=1;
      }
    }
    return jd;
  }


  //////////////////////////////////////////////////////////////////////
  // Erzeugt aus einem jd/calType Jahr, Monat, Tag und Stunde.        //
  // It does NOT change any global variables.                         //
  //////////////////////////////////////////////////////////////////////
  private synchronized IDate swe_revjul (double jd, boolean calType) {
    IDate dt=new IDate();
    double u0,u1,u2,u3,u4;

    u0 = jd + 32082.5;
    if (calType == SE_GREG_CAL) {
      u1 = u0 + Math.floor (u0/36525.0) - Math.floor (u0/146100.0) - 38.0;
      if (jd >= 1830691.5) {
        u1 +=1;
      }
      u0 = u0 + Math.floor (u1/36525.0) - Math.floor (u1/146100.0) - 38.0;
    }
    u2 = Math.floor (u0 + 123.0);
    u3 = Math.floor ( (u2 - 122.2) / 365.25);
    u4 = Math.floor ( (u2 - Math.floor (365.25 * u3) ) / 30.6001);
    dt.month = (int) (u4 - 1.0);
    if (dt.month > 12) {
      dt.month -= 12;
    }
    dt.day = (int) (u2 - Math.floor (365.25 * u3) - Math.floor (30.6001 * u4));
    dt.year = (int) (u3 + Math.floor ( (u4 - 2.0) / 12.0) - 4800);
    dt.hour = (jd - Math.floor (jd + 0.5) + 0.5) * 24.0;
    return dt;
  }

  ////////////////////////////////////////////////////////////////////////////
  /// deltaT:
  ////////////////////////////////////////////////////////////////////////////
  /* DeltaT = Ephemeris Time - Universal Time, in days.
   * 
   * 1620 - today + a couple of years:
   * ---------------------------------
   * The tabulated values of deltaT, in hundredths of a second,
   * were taken from The Astronomical Almanac 1997, page K8.  The program
   * adjusts for a value of secular tidal acceleration ndot = -25.7376.
   * arcsec per century squared, the value used in JPL's DE403 ephemeris.
   * ELP2000 (and DE200) used the value -23.8946.
   * To change ndot, one can
   * either redefine SE_TIDAL_DEFAULT in swephexp.h
   * or use the routine swe_set_tid_acc() before calling Swiss 
   * Ephemeris.
   * Bessel's interpolation formula is implemented to obtain fourth 
   * order interpolated values at intermediate times.
   *
   * -500 - 1620:
   * ---------------------------------
   * For dates between -500 and 1600, the table given by 
   * Stephenson (1997; p. 515) is used, with linear interpolation.
   * This table is based on an assumed value of ndot = -26.
   * The program adjusts for ndot = -25.7376.
   * For 1600 - 1620, a linear interpolation between the last value
   * of the latter and the first value of the former table is made.
   *
   * before -500:
   * ---------------------------------
   * For times before -600, a formula of Stephenson & Morrison (1995) 
   * (S. Stephenson 1997; p. 508) is used: 
   * dt = 35 * t * t - 20 sec, where t is centuries from 1735 AD.
   * For -600 to -500, a transition from this formula to the Stephenson
   * table has been implemented in order to avoid a jump.
   *
   * future:
   * ---------------------------------
   * For the time after the last tabulated value, we use the formula
   * of Stephenson (1997; p. 507), with a modification that avoids a jump
   * at the end of the tabulated period. A linear term is added that
   * makes a slow transition from the table to the formula over a period
   * of 100 years. (Need not be updated, when table will be enlarged.)
   *
   * References:
   *
   * Stephenson, F. R., and L. V. Morrison, "Long-term changes
   * in the rotation of the Earth: 700 B.C. to A.D. 1980,"
   * Philosophical Transactions of the Royal Society of London
   * Series A 313, 47-70 (1984)
   *
   * Borkowski, K. M., "ELP2000-85 and the Dynamical Time
   * - Universal Time relation," Astronomy and Astrophysics
   * 205, L8-L10 (1988)
   * Borkowski's formula is derived from partly doubtful eclipses 
   * going back to 2137 BC and uses lunar position based on tidal 
   * coefficient of -23.9 arcsec/cy^2.
   *
   * Chapront-Touze, Michelle, and Jean Chapront, _Lunar Tables
   * and Programs from 4000 B.C. to A.D. 8000_, Willmann-Bell 1991
   * Their table agrees with the one here, but the entries are
   * rounded to the nearest whole second.
   *
   * Stephenson, F. R., and M. A. Houlden, _Atlas of Historical
   * Eclipse Maps_, Cambridge U. Press (1986)
   *
   * Stephenson, F.R. & Morrison, L.V., "Long-Term Fluctuations in 
   * the Earth's Rotation: 700 BC to AD 1990", Philosophical 
   * Transactions of the Royal Society of London, 
   * Ser. A, 351 (1995), 165-202. 
   *
   * Stephenson, F. Richard, _Historical Eclipses and Earth's 
   * Rotation_, Cambridge U. Press (1997)
   * 
   * Table from AA for 1620 through today
   * Note, Stephenson and Morrison's table starts at the year 1630.
   * The Chapronts' table does not agree with the Almanac prior to 1630.
   * The actual accuracy decreases rapidly prior to 1780.
   *
   * Jean Meeus, Astronomical Algorithms, 2nd edition, 1998.
   * 
   * For a comprehensive collection of publications and formulae, see:
   * http://www.phys.uu.nl/~vgent/astro/deltatime.htm
   * 
   * For future values of delta t, the following data from the 
   * Earth Orientation Department of the US Naval Observatory can be used:
   * (TAI-UTC) from: ftp://maia.usno.navy.mil/ser7/tai-utc.dat
   * (UT1-UTC) from: ftp://maia.usno.navy.mil/ser7/finals.all
   * file description in: ftp://maia.usno.navy.mil/ser7/readme.finals
   * Delta T = TAI-UT1 + 32.184 sec = (TAI-UTC) - (UT1-UTC) + 32.184 sec
   *
   * Last update of table dt[]: Dieter Koch, 31 March 2005.
   * ATTENTION: Whenever updating this table, do not forget to adjust
   * the macros TABEND and TABSIZ !
   */

  private static final int TABSTART=1620;
  private static final int TABEND=2014;
  private static final int TABSIZ=TABEND-TABSTART+1;

  /* we make the table greater for additional values read from external file */
  private static final int TABSIZ_SPACE=TABSIZ+50;

  private static short dt[]=new short[] {
  /* 1620.0 thru 1659.0 */
  12400, 11900, 11500, 11000, 10600, 10200, 9800, 9500, 9100, 8800,
  8500, 8200, 7900, 7700, 7400, 7200, 7000, 6700, 6500, 6300,
  6200, 6000, 5800, 5700, 5500, 5400, 5300, 5100, 5000, 4900,
  4800, 4700, 4600, 4500, 4400, 4300, 4200, 4100, 4000, 3800,
  /* 1660.0 thru 1699.0 */
  3700, 3600, 3500, 3400, 3300, 3200, 3100, 3000, 2800, 2700,
  2600, 2500, 2400, 2300, 2200, 2100, 2000, 1900, 1800, 1700,
  1600, 1500, 1400, 1400, 1300, 1200, 1200, 1100, 1100, 1000,
  1000, 1000, 900, 900, 900, 900, 900, 900, 900, 900,
  /* 1700.0 thru 1739.0 */
  900, 900, 900, 900, 900, 900, 900, 900, 1000, 1000,
  1000, 1000, 1000, 1000, 1000, 1000, 1000, 1100, 1100, 1100,
  1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100,
  1100, 1100, 1100, 1100, 1200, 1200, 1200, 1200, 1200, 1200,
  /* 1740.0 thru 1779.0 */
  1200, 1200, 1200, 1200, 1300, 1300, 1300, 1300, 1300, 1300,
  1300, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1500, 1500,
  1500, 1500, 1500, 1500, 1500, 1600, 1600, 1600, 1600, 1600,
  1600, 1600, 1600, 1600, 1600, 1700, 1700, 1700, 1700, 1700,
  /* 1780.0 thru 1799.0 */
  1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700,
  1700, 1700, 1600, 1600, 1600, 1600, 1500, 1500, 1400, 1400,
  /* 1800.0 thru 1819.0 */
  1370, 1340, 1310, 1290, 1270, 1260, 1250, 1250, 1250, 1250,
  1250, 1250, 1250, 1250, 1250, 1250, 1250, 1240, 1230, 1220,
  /* 1820.0 thru 1859.0 */
  1200, 1170, 1140, 1110, 1060, 1020, 960, 910, 860, 800,
  750, 700, 660, 630, 600, 580, 570, 560, 560, 560,
  570, 580, 590, 610, 620, 630, 650, 660, 680, 690,
  710, 720, 730, 740, 750, 760, 770, 770, 780, 780,
  /* 1860.0 thru 1899.0 */
  788, 782, 754, 697, 640, 602, 541, 410, 292, 182,
  161, 10, -102, -128, -269, -324, -364, -454, -471, -511,
  -540, -542, -520, -546, -546, -579, -563, -564, -580, -566,
  -587, -601, -619, -664, -644, -647, -609, -576, -466, -374,
  /* 1900.0 thru 1939.0 */
  -272, -154, -2, 124, 264, 386, 537, 614, 775, 913,
  1046, 1153, 1336, 1465, 1601, 1720, 1824, 1906, 2025, 2095,
  2116, 2225, 2241, 2303, 2349, 2362, 2386, 2449, 2434, 2408,
  2402, 2400, 2387, 2395, 2386, 2393, 2373, 2392, 2396, 2402,
  /* 1940.0 thru 1979.0 */
   2433, 2483, 2530, 2570, 2624, 2677, 2728, 2778, 2825, 2871,
   2915, 2957, 2997, 3036, 3072, 3107, 3135, 3168, 3218, 3268,
   3315, 3359, 3400, 3447, 3503, 3573, 3654, 3743, 3829, 3920,
   4018, 4117, 4223, 4337, 4449, 4548, 4646, 4752, 4853, 4959,
  /* 1980.0 thru 1999.0 */
   5054, 5138, 5217, 5296, 5379, 5434, 5487, 5532, 5582, 5630,
   5686, 5757, 5831, 5912, 5998, 6078, 6163, 6230, 6297, 6347,
  /* 2000.0 thru 2005.0 */
   6383, 6409, 6430, 6447, 6457, 6469,       
  /* Extrapolated values, 2006 - 2014 */
                                       6481, 6500, 6520, 6550,
   6600, 6650, 6700, 6750, 6800,
  // Add 50 empty elements, see constant TABSIZ_SPACE above!
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  };
  /* Table for -500 through 1600, from Stephenson & Morrison (1995).
   *
   * The first value for -550 has been added from Borkowski
   * in order to make this table fit with the Borkowski formula
   * for times before -550.
   */
//C only://  private static final int TAB2_SIZ=43;
  private static final int TAB2_START=-500;
  private static final int TAB2_END=1600;
  private static short dt2[]=new short[] {
  /* -500  -450  -400  -350  -300  -250  -200  -150  -100   -50*/
    16800,16000,15300,14600,14000,13400,12800,12200,11600,11100,
  /*    0    50   100   150   200   250   300   350   400   450*/
    10600,10100, 9600, 9100, 8600, 8200, 7700, 7200, 6700, 6200,
  /*  500   550   600   650   700   750   800   850   900   950*/
     5700, 5200, 4700, 4300, 3800, 3400, 3000, 2600, 2200, 1900,
  /* 1000  1050  1100  1150  1200  1250  1300  1350  1400  1450*/
     1600, 1350, 1100,  900,  750,  600,  470,  380,  300,  230,
  /* 1500  1550  1600 */
      180,  140,  110,
  };
  /* returns DeltaT (ET - UT) in days
   * double tjd 	= 	julian day in UT
   */
  private synchronized double calc_deltaT(double tjd) {
    double sdt = calc_deltaT(tjd, this.tid_acc);
    return sdt;
  }
  private static synchronized double calc_deltaT(double tjd, double tid_acc) {
    double ans = 0., ans2, ans3;
    double p, B=0., Y=0., dd; // To remove Java warning of "maybe" not initialized
    int d[]=new int[6];
    int i, iy, k;
    /* read additional values from swedelta.txt */
    int tabsiz = init_dt();
    int tabend = TABSTART + tabsiz - 1;
    Y = 2000.0 + (tjd - SwephData.J2000)/365.25;
    /* before -500:
     * formula by Stephenson (1997; p. 508) but adjusted to fit the starting
     * point of table dt2 (Stephenson 1997). */
    if( Y < TAB2_START ) {
      B = (Y - 1735) * 0.01;
      ans = -20 + 35 * B * B;
      ans = adjust_for_tidacc(tid_acc, ans, Y);
      /* transition from formula to table over 100 years */
      if (Y >= TAB2_START - 100) {
        /* starting value of table dt2: */
        ans2 = adjust_for_tidacc(tid_acc, dt2[0], TAB2_START);
        /* value of formula at epoch TAB2_START */
        B = (TAB2_START - 1735) * 0.01;
        ans3 = -20 + 35 * B * B;
        ans3 = adjust_for_tidacc(tid_acc, ans3, Y);
        dd = ans3 - ans2;
        B = (Y - (TAB2_START - 100)) * 0.01;
        /* fit to starting point of table dt2. */
        ans = ans - dd * B;
      }
    }
    /* between -500 and 1600:
     * linear interpolation between values of table dt2 (Stephenson 1997) */
    if (Y >= TAB2_START && Y < TAB2_END) {
      p = Math.floor(Y);
      iy = (int) ((p - TAB2_START) / 50.0);
      dd = (Y - (TAB2_START + 50 * iy)) / 50.0;
      ans = dt2[iy] + (dt2[iy+1] - dt2[iy]) * dd;
      /* correction for tidal acceleration used by our ephemeris */
      ans = adjust_for_tidacc(tid_acc, ans, Y);
    }
    /* between 1600 and 1620:
     * linear interpolation between 
     * end of table dt2 and start of table dt */
    if (Y >= TAB2_END && Y < TABSTART) { 
      B = TABSTART - TAB2_END;
      iy = (TAB2_END - TAB2_START) / 50;
      dd = (Y - TAB2_END) / B;
      ans = dt2[iy] + dd * (dt[0] / 100.0 - dt2[iy]);
      ans = adjust_for_tidacc(tid_acc, ans, Y);
    }
    /* 1620 - today + a few years (tabend):
     * Besselian interpolation from tabulated values in table dt.
     * See AA page K11.
     */
    if (Y >= TABSTART && Y <= tabend) {
      /* Index into the table.
       */
      p = Math.floor(Y);
      iy = (int) (p - TABSTART);
      /* Zeroth order estimate is value at start of year
       */
      ans = dt[iy];
      k = iy + 1;
      if( k >= tabsiz )
        return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend); /* No data, can't go on. */
      /* The fraction of tabulation interval
       */
      p = Y - p;
      /* First order interpolated value
       */
      ans += p*(dt[k] - dt[iy]);
      if( (iy-1 < 0) || (iy+2 >= tabsiz) )
        return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend); /* can't do second differences */
      /* Make table of first differences
       */
      k = iy - 2;
      for( i=0; i<5; i++ ) {
        if( (k < 0) || (k+1 >= tabsiz) ) 
          d[i] = 0;
        else
          d[i] = dt[k+1] - dt[k];
        k += 1;
      }
      /* Compute second differences
       */
      for( i=0; i<4; i++ )
        d[i] = d[i+1] - d[i];
      B = 0.25*p*(p-1.0);
      ans += B*(d[1] + d[2]);
//    printf( "B %.4lf, ans %.4lf\n", B, ans );
      if( iy+2 >= tabsiz )
        return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend);
      /* Compute third differences
       */
      for( i=0; i<3; i++ )
        d[i] = d[i+1] - d[i];
      B = 2.0*B/3.0;
      ans += (p-0.5)*B*d[1];
//    printf( "B %.4lf, ans %.4lf\n", B*(p-0.5), ans );
      if( (iy-2 < 0) || (iy+3 > tabsiz) )
        return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend);
      /* Compute fourth differences
       */
      for( i=0; i<2; i++ )
        d[i] = d[i+1] - d[i];
      B = 0.125*B*(p+1.0)*(p-2.0);
      ans += B*(d[0] + d[1]);
//    printf( "B %.4lf, ans %.4lf\n", B, ans );
    }

    return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend);
  }

  private synchronized static double deltatIsDone(double ans, double Y,
                                                  double B, double tid_acc, int tabsiz, int tabend) {
// //#ifdef TRACE0
//     // Trace.level++; Don't increment here, as the calling method calc_deltat() does not decrement on return!
//     Trace.trace(Trace.level, "SweDate.deltatIsDone(double, double, double, double, int, int)");
// //#endif /* TRACE0 */
    double ans2, ans3, B2, dd;
    if (Y >= TABSTART && Y <= tabend) {
      ans *= 0.01;
      ans = adjust_for_tidacc(tid_acc, ans, Y);
    }
    /* today - :
     * Formula Stephenson (1997; p. 507),
     * with modification to avoid jump at end of AA table,
     * similar to what Meeus 1998 had suggested.
     * Slow transition within 100 years.
     */
    if (Y > tabend) {
      B = 0.01 * (Y - 1820);
      ans = -20 + 31 * B * B;
      /* slow transition from tabulated values to Stephenson formula: */
      if (Y <= tabend+100) {
        B2 = 0.01 * (tabend - 1820);
        ans2 = -20 + 31 * B2 * B2;
        ans3 = dt[tabsiz-1] * 0.01;
        dd = (ans2 - ans3);
        ans += dd * (Y - (tabend + 100)) * 0.01;
      }
    }
    return ans / 86400.0;
  }


  /* Read delta t values from external file.
   * record structure: year(whitespace)delta_t in 0.01 sec.
   */
  private static int init_dt() {
    FilePtr fp = null;
    int year;
    int tab_index;
    int tabsiz;
    int i;
    String s;
    if (!init_dt_done) {
      init_dt_done = true;
      /* no error message if file is missing */
      try {
        if ((fp = sw.swi_fopen(-1, "sedeltat.txt", sw.swed.ephepath, null)) == null) {
          return TABSIZ;  // I think, I could miss this one...
        }
      } catch (SwissephException se) {
        return TABSIZ;
      }
      try {
        while ((s=fp.readLine()) != null) {
          s.trim();
          if (s.length() == 0 || s.charAt(0) == '#') {
            continue;
          }
          year = SwissLib.atoi(s);
          tab_index = year - TABSTART;
          /* table space is limited. no error msg, if exceeded */
          if (tab_index >= TABSIZ_SPACE)
            continue;
          if (s.length() > 4) {
            s = s.substring(4).trim();
          }
          dt[tab_index] = (short)(SwissLib.atoi(s) * 100 + 0.5);
        }
      } catch (java.io.IOException e) {
      }
      try { fp.close(); } catch (java.io.IOException e) {}
    }
    /* find table size */
    tabsiz = 2001 - TABSTART + 1;
    for (i = tabsiz - 1; i < TABSIZ_SPACE; i++) {
      if (dt[i] == 0)
        break;
      else
        tabsiz++;
    }
    tabsiz--;
    return tabsiz;
  }
 
  /* Astronomical Almanac table is corrected by adding the expression
   *     -0.000091 (ndot + 26)(year-1955)^2  seconds
   * to entries prior to 1955 (AA page K8), where ndot is the secular
   * tidal term in the mean motion of the Moon.
   *
   * Entries after 1955 are referred to atomic time standards and
   * are not affected by errors in Lunar or planetary theory.
   */
  private static double adjust_for_tidacc(double tid_acc_local, double ans, double Y) {
    double B;
    if( Y < 1955.0 ) {
      B = (Y - 1955.0);
      ans += -0.000091 * (tid_acc_local + 26.0) * B * B;
    }
    return ans;
  }

  
  private void initDateFromJD(double jd, boolean calType) {
    this.jd=jd;
    this.calType=calType;
    IDate dt=swe_revjul(jd, calType);
    this.year=dt.year;
    this.month=dt.month;
    this.day=dt.day;
    this.hour=dt.hour;
  }

  
  private void setFields(int year, int month, int day, double hour) {
    // Get year, month, day of jdCO and compare to given date to
    // find out about the calendar system:
    IDate dt=swe_revjul(jdCO,SE_GREG_CAL);
    boolean calType = SE_GREG_CAL;
    if (dt.year > year ||
        (dt.year == year && dt.month > month) ||
        (dt.year == year && dt.month == month && dt.day > day)) {
      calType = SE_JUL_CAL;
    }
    setFields(year, month, day, hour, calType);
  }

  
  private void setFields(int year, int month, int day, double hour,
        boolean calType) {
    this.year=year;
    this.month=month;
    this.day=day;
    this.hour=hour;
    this.calType=calType;
    this.jd=swe_julday(year, month, day, hour, calType);
  }

} // end of class SweDate


class IDate {
  public int year;
  public int month;
  public int day;
  public double hour;
}



class SweHouse {

  static final double MILLIARCSEC=1.0 / 3600000.0;

  SwissLib sl=null;
  SwissEph sw=null;
  SwissData swed=null;

  
  SweHouse() {
    sl   = new SwissLib();
    sw   = new SwissEph();
    swed = new SwissData();
  }

  
  SweHouse(SwissLib sl, SwissEph sw, SwissData swed) {
    this.sl   = sl;
    this.sw   = sw;
    this.swed = swed;
    if (this.sl   ==null) { this.sl   =new SwissLib(); }
    if (this.sw   ==null) { this.sw   =new SwissEph(); }
    if (this.swed ==null) { this.swed =new SwissData(); }
  }


  static final double VERY_SMALL=1E-10;

// Hmmm? Never used anywhere...
//  public double degtocs(double x) {
//    return sl.swe_d2l((x) * SwissData.DEG);
//  }

// Hmmm? Never used anywhere...
//  public double cstodeg(double x) {
//    return (double)((x) * SwissData.CS2DEG);
//  }

  private double sind(double x) {
    return Math.sin(x * SwissData.DEGTORAD);
  }
  private double cosd(double x) {
    return Math.cos(x * SwissData.DEGTORAD);
  }
  private double tand(double x) {
    return Math.tan(x * SwissData.DEGTORAD);
  }
  private double asind(double x) {
    return (Math.asin(x) * SwissData.RADTODEG);
  }
//Never used anywhere//  private double acosd(double x) {
//Never used anywhere//    return (Math.acos(x) * SwissData.RADTODEG);
//Never used anywhere//  }
  private double atand(double x) {
    return (Math.atan(x) * SwissData.RADTODEG);
  }
//Never used anywhere//  private double atan2d(double y, double x) {
//Never used anywhere//    return (Math.atan2(y, x) * SwissData.RADTODEG);
//Never used anywhere//  }



  /* housasp.c
   * cusps are returned in double cusp[13],
   *                           or cusp[37] with house system 'G':
   * cusp[1...12]        houses 1 - 12
   * additional points are returned in ascmc[10].
   * ascmc[0] = ascendant
   * ascmc[1] = mc
   * ascmc[2] = armc
   * ascmc[3] = vertex
   * ascmc[4] = equasc            * "equatorial ascendant" *
   * ascmc[5] = coasc1            * "co-ascendant" (W. Koch) *
   * ascmc[6] = coasc2            * "co-ascendant" (M. Munkasey) *
   * ascmc[7] = polasc            * "polar ascendant" (M. Munkasey) *
   */
  
  int swe_houses(double tjd_ut,
                 int iflag,
                 double geolat,
                 double geolon,
                 int hsys,
                 double[] cusp,
                 double[] ascmc) {
    return swe_houses(tjd_ut, iflag, geolat, geolon, hsys, cusp, ascmc, 0);
  }
  int swe_houses(double tjd_ut,
                 int iflag,
                 double geolat,
                 double geolon,
                 int hsys,
                 double[] cusp,
                 double[] ascmc,
                 int aOffs) {
    int i, retc = 0;
    double armc, eps_mean, nutlo[]=new double[2];
    double tjde = tjd_ut + SweDate.getDeltaT(tjd_ut);
    SidData sip = swed.sidd;
    int ito;
    if (Character.toUpperCase((char)hsys) == 'G') {
      ito = 36;
    } else {
      ito = 12;
    }
    if ((iflag & SweConst.SEFLG_SIDEREAL)!=0 && !swed.ayana_is_set) {
      sw.swe_set_sid_mode(SweConst.SE_SIDM_FAGAN_BRADLEY, 0, 0);
    }
    eps_mean = sl.swi_epsiln(tjde) * SwissData.RADTODEG;
    sl.swi_nutation(tjde, nutlo);
    for (i = 0; i < 2; i++)
      nutlo[i] *= SwissData.RADTODEG;
      /*houses_to_sidereal(tjde, geolat, hsys, eps, cusp, ascmc, iflag);*/
    armc = sl.swe_degnorm(sl.swe_sidtime0(tjd_ut, eps_mean + nutlo[1], nutlo[0]) * 15 + geolon);
    if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
      if ((sip.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0) {
        retc = sidereal_houses_ecl_t0(tjde, armc, eps_mean + nutlo[1], nutlo, geolat, hsys, cusp, ascmc, aOffs);
      } else if ((sip.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
        retc = sidereal_houses_ssypl(tjde, armc, eps_mean + nutlo[1], nutlo, geolat, hsys, cusp, ascmc, aOffs);
      } else {
        retc = sidereal_houses_trad(tjde, armc, eps_mean + nutlo[1], nutlo[0], geolat, hsys, cusp, ascmc, aOffs);
      }
    } else {
      retc = swe_houses_armc(armc, geolat, eps_mean + nutlo[1], hsys, cusp, ascmc, aOffs);
    }
    if ((iflag & SweConst.SEFLG_RADIANS)!=0) {
      for (i = 1; i <= ito; i++)
        cusp[i] *= SwissData.DEGTORAD;
      for (i = 0; i < SweConst.SE_NASCMC; i++)
        ascmc[i+aOffs] *= SwissData.DEGTORAD;
    }
    return retc;
  }

  /*
   * houses to sidereal
   * ------------------
   * there are two methods:
   * a) the traditional one
   *    houses are computed tropically, then nutation and the ayanamsa
   *    are subtracted.
   * b) the projection on the ecliptic of t0
   *    The house computation is then as follows:
   *
   * Be t the birth date and t0 the epoch at which ayanamsa = 0.
   * 1. Compute the angle between the mean ecliptic at t0 and
   *    the true equator at t.
   *    The intersection point of these two circles we call the
   *    "auxiliary vernal point", and the angle between them the
   *    "auxiliary obliquity".
   * 2. Compute the distance of the auxiliary vernal point from the
   *    vernal point at t. (this is a section on the equator)
   * 3. subtract this value from the armc of t = aux. armc.
   * 4. Compute the axes and houses for this aux. armc and aux. obliquity.
   * 5. Compute the distance between the auxiliary vernal point and the
   *    vernal point at t0 (this is the ayanamsa at t, measured on the
   *    ecliptic of t0)
   * 6. subtract this distance from all house cusps.
   * 7. subtract ayanamsa_t0 from all house cusps.
   */
  private int sidereal_houses_ecl_t0(double tjde,
                                     double armc,
                                     double eps,
                                     double[] nutlo,
                                     double lat,
                                     int hsys,
                                     double[] cusp,
                                     double[] ascmc,
                                     int aOffs) {
    int i, j, retc = SweConst.OK;
    double x[]=new double[6], xvpx[]=new double[6], x2[]=new double[6], epst0,
           xnorm[]=new double[6];
    double rxy, rxyz, c2, epsx, sgn, fac, dvpx, dvpxe;
    double armcx;
    SidData sip = swed.sidd;
    int ito;
    if (Character.toUpperCase((char)hsys) == 'G') {
      ito = 36;
    } else {
      ito = 12;
    }
    /* epsilon at t0 */
    epst0 = sl.swi_epsiln(sip.t0);
    /* cartesian coordinates of an imaginary moving body on the
     * the mean ecliptic of t0; we take the vernal point: */
    x[0] = x[4] = 1;
    x[1] = x[2] = x[3] = x[5] = 0;
    /* to equator */
    sl.swi_coortrf(x, x, -epst0);
    sl.swi_coortrf(x, 3, x, 3, -epst0);
    /* to tjd_et */
    sl.swi_precess(x, sip.t0, SwephData.J_TO_J2000);
    sl.swi_precess(x, tjde, SwephData.J2000_TO_J);
    sl.swi_precess(x, 3, sip.t0, SwephData.J_TO_J2000);
    sl.swi_precess(x, 3, tjde, SwephData.J2000_TO_J);
    /* to true equator of tjd_et */
    sl.swi_coortrf(x, x, (eps - nutlo[1]) * SwissData.DEGTORAD);
    sl.swi_coortrf(x, 3, x, 3, (eps - nutlo[1]) * SwissData.DEGTORAD);
    sl.swi_cartpol_sp(x, 0, x, 0);
    x[0] += nutlo[0] * SwissData.DEGTORAD;
    sl.swi_polcart_sp(x, x);
    sl.swi_coortrf(x, x, -eps * SwissData.DEGTORAD);
    sl.swi_coortrf(x, 3, x, 3, -eps * SwissData.DEGTORAD);
    /* now, we have the moving point precessed to tjd_et.
     * next, we compute the auxiliary epsilon: */
    sl.swi_cross_prod(x, 0, x, 3, xnorm, 0);
    rxy =  xnorm[0] * xnorm[0] + xnorm[1] * xnorm[1];
    c2 = (rxy + xnorm[2] * xnorm[2]);
    rxyz = Math.sqrt(c2);
    rxy = Math.sqrt(rxy);
    epsx = Math.asin(rxy / rxyz) * SwissData.RADTODEG;           /* 1a */
    /* auxiliary vernal point */
    if (Math.abs(x[5]) < 1e-15) {
      x[5] = 1e-15;
    }
    fac = x[2] / x[5];
    sgn = x[5] / Math.abs(x[5]);
    for (j = 0; j <= 2; j++)
      xvpx[j] = (x[j] - fac * x[j+3]) * sgn;      /* 1b */
    /* distance of the auxiliary vernal point from
     * the zero point at tjd_et (a section on the equator): */
    sl.swi_cartpol(xvpx, x2);
    dvpx = x2[0] * SwissData.RADTODEG;                      /* 2 */
    /* auxiliary armc */
    armcx = sl.swe_degnorm(armc - dvpx);        /* 3 */
    /* compute axes and houses: */
    retc = swe_houses_armc(armcx, lat, epsx, hsys, cusp, ascmc, aOffs);  /* 4 */
    /* distance between auxiliary vernal point and
     * vernal point of t0 (a section on the sidereal plane) */
    dvpxe = Math.acos(sl.swi_dot_prod_unit(x, xvpx)) * SwissData.RADTODEG;  /* 5 */
    if (tjde < sip.t0) {
      dvpxe = -dvpxe;
    }
    for (i = 1; i <= ito; i++)                     /* 6, 7 */
      cusp[i] = sl.swe_degnorm(cusp[i] - dvpxe - sip.ayan_t0);
    for (i = 0; i <= SweConst.SE_NASCMC; i++)
      ascmc[aOffs+i] = sl.swe_degnorm(ascmc[aOffs+i] - dvpxe - sip.ayan_t0);
    return retc;
  }

  /*
   * Be t the birth date and t0 the epoch at which ayanamsa = 0.
   * 1. Compute the angle between the solar system rotation plane and
   *    the true equator at t.
   *    The intersection point of these two circles we call the
   *    "auxiliary vernal point", and the angle between them the
   *    "auxiliary obliquity".
   * 2. Compute the distance of the auxiliary vernal point from the
   *    zero point at t. (this is a section on the equator)
   * 3. subtract this value from the armc of t = aux. armc.
   * 4. Compute the axes and houses for this aux. armc and aux. obliquity.
   * 5. Compute the distance between the auxiliary vernal point at t
   *    and the zero point of the solar system plane J2000
   *    (a section measured on the solar system plane)
   * 6. subtract this distance from all house cusps.
   * 7. compute the ayanamsa of J2000 on the solar system plane,
   *    referred to t0
   * 8. subtract ayanamsa_t0 from all house cusps.
   * 9. subtract ayanamsa_2000 from all house cusps.
   */
  private int sidereal_houses_ssypl(double tjde,
                                    double armc,
                                    double eps,
                                    double[] nutlo,
                                    double lat,
                                    int hsys,
                                    double[] cusp,
                                    double[] ascmc,
                                    int aOffs) {
    int i, j, retc = SweConst.OK;
    double x[]=new double[6], x0[]=new double[6], xvpx[]=new double[6],
           x2[]=new double[6], epst0, xnorm[]=new double[6];
    double rxy, rxyz, c2, epsx, eps2000, sgn, fac, dvpx, dvpxe, x00;
    double armcx;
    SidData sip = swed.sidd;
    int ito;
    if (Character.toUpperCase((char)hsys) == 'G') {
      ito = 36;
    } else {
      ito = 12;
    }
    /* epsilon at t0 */
    epst0 = sl.swi_epsiln(sip.t0);
    eps2000 = sl.swi_epsiln(SwephData.J2000);
    /* cartesian coordinates of the zero point on the
     * the solar system rotation plane */
    x[0] = x[4] = 1;
    x[1] = x[2] = x[3] = x[5] = 0;
    /* to ecliptic 2000 */
    sl.swi_coortrf(x, x, -SwephData.SSY_PLANE_INCL);
    sl.swi_coortrf(x, 3, x, 3, -SwephData.SSY_PLANE_INCL);
    sl.swi_cartpol_sp(x, 0, x, 0);
    x[0] += SwephData.SSY_PLANE_NODE_E2000;
    sl.swi_polcart_sp(x, x);
    /* to equator 2000 */
    sl.swi_coortrf(x, x, -eps2000);
    sl.swi_coortrf(x, 3, x, 3, -eps2000);
    /* to mean equator of t */
    sl.swi_precess(x, tjde, SwephData.J2000_TO_J);
    sl.swi_precess(x, 3, tjde, SwephData.J2000_TO_J);
    /* to true equator of t */
    sl.swi_coortrf(x, x, (eps - nutlo[1]) * SwissData.DEGTORAD);
    sl.swi_coortrf(x, 3, x, 3, (eps - nutlo[1]) * SwissData.DEGTORAD);
    sl.swi_cartpol_sp(x, 0, x, 0);
    x[0] += nutlo[0] * SwissData.DEGTORAD;
    sl.swi_polcart_sp(x, x);
    sl.swi_coortrf(x, x, -eps * SwissData.DEGTORAD);
    sl.swi_coortrf(x, 3, x, 3, -eps * SwissData.DEGTORAD);
    /* now, we have the moving point precessed to tjd_et.
     * next, we compute the auxiliary epsilon: */
    sl.swi_cross_prod(x, 0, x, 3, xnorm, 0);
    rxy =  xnorm[0] * xnorm[0] + xnorm[1] * xnorm[1];
    c2 = (rxy + xnorm[2] * xnorm[2]);
    rxyz = Math.sqrt(c2);
    rxy = Math.sqrt(rxy);
    epsx = Math.asin(rxy / rxyz) * SwissData.RADTODEG;           /* 1a */
    /* auxiliary vernal point */
    if (Math.abs(x[5]) < 1e-15) {
      x[5] = 1e-15;
    }
    fac = x[2] / x[5];
    sgn = x[5] / Math.abs(x[5]);
    for (j = 0; j <= 2; j++)
      xvpx[j] = (x[j] - fac * x[j+3]) * sgn;      /* 1b */
    /* distance of the auxiliary vernal point from
     * mean vernal point at tjd_et (a section on the equator): */
    sl.swi_cartpol(xvpx, x2);
    dvpx = x2[0] * SwissData.RADTODEG;                      /* 2 */
    /* auxiliary armc */
    armcx = sl.swe_degnorm(armc - dvpx);        /* 3 */
    /* compute axes and houses: */
    retc = swe_houses_armc(armcx, lat, epsx, hsys, cusp, ascmc, aOffs);  /* 4 */
    /* distance between the auxiliary vernal point at t and
     * the sidereal zero point of 2000 at t
     * (a section on the sidereal plane).
     */
    dvpxe = Math.acos(sl.swi_dot_prod_unit(x, xvpx)) * SwissData.RADTODEG;  /* 5 */
                  /* (always positive for dates after 5400 bc) */
    dvpxe -= SwephData.SSY_PLANE_NODE * SwissData.RADTODEG;
    /* ayanamsa between t0 and J2000, measured on solar system plane: */
    /* position of zero point of t0 */
    x0[0] = 1;
    x0[1] = x0[2] = 0;
    /* zero point of t0 in J2000 system */
    if (sip.t0 != SwephData.J2000) {
      sl.swi_precess(x0, sip.t0, SwephData.J_TO_J2000);
    }
    /* zero point to ecliptic 2000 */
    sl.swi_coortrf(x0, x0, eps2000);
    /* to solar system plane */
    sl.swi_cartpol(x0, x0);
    x0[0] -= SwephData.SSY_PLANE_NODE_E2000;
    sl.swi_polcart(x0, x0);
    sl.swi_coortrf(x0, x0, SwephData.SSY_PLANE_INCL);
    sl.swi_cartpol(x0, x0);
    x0[0] += SwephData.SSY_PLANE_NODE;
    x00 = x0[0] * SwissData.RADTODEG;                       /* 7 */
    for (i = 1; i <= ito; i++)                     /* 6, 8, 9 */
      cusp[i] = sl.swe_degnorm(cusp[i] - dvpxe - sip.ayan_t0 - x00);
    for (i = 0; i <= SweConst.SE_NASCMC; i++)
      ascmc[aOffs+i] = sl.swe_degnorm(ascmc[aOffs+i] - dvpxe - sip.ayan_t0 - x00);
    return retc;
  }

  /* common simplified procedure */
  private int sidereal_houses_trad(double tjde,
                                   double armc,
                                   double eps,
                                   double nutl,
                                   double lat,
                                   int hsys,
                                   double[] cusp,
                                   double[] ascmc,
                                   int aOffs) {
    int i, retc = SweConst.OK;
    double ay;
    int ito;
    if (Character.toUpperCase((char)hsys) == 'G') {
      ito = 36;
    } else {
      ito = 12;
    }
    retc = swe_houses_armc(armc, lat, eps, hsys, cusp, ascmc, aOffs);
    ay = sw.swe_get_ayanamsa(tjde);
    for (i = 1; i <= ito; i++)
      cusp[i] = sl.swe_degnorm(cusp[i] - ay - nutl);
    for (i = 0; i < SweConst.SE_NASCMC; i++) {
      if (i == 2) /* armc */ {
        continue;
      }
      ascmc[aOffs+i] = sl.swe_degnorm(ascmc[aOffs+i] - ay - nutl);
    }
    return retc;
  }

  /*
   * this function is required for very special computations
   * where no date is given for house calculation,
   * e.g. for composite charts or progressive charts.
   * cusps are returned in double cusp[13],
   *                           or cusp[37] with house system 'G'.
   * cusp[1...12] houses 1 - 12
   * additional points are returned in ascmc[10].
   * ascmc[0] = ascendant
   * ascmc[1] = mc
   * ascmc[2] = armc
   * ascmc[3] = vertex
   * ascmc[4] = equasc            * "equatorial ascendant" *
   * ascmc[5] = coasc1            * "co-ascendant" (Walter Koch) *
   * ascmc[6] = coasc2            * "co-ascendant" (Michael Munkasey) *
   * ascmc[7] = polasc            * "polar ascendant" (Michael Munkasey) *
   */
  
  int swe_houses_armc(double armc,
                      double geolat,
                      double eps,
                      int hsys,
                      double cusp[],
                      double ascmc[],
                      int aOffs) {
    Houses h=new Houses();
    int i, retc = 0;
    int ito;
    if (Character.toUpperCase((char)hsys) == 'G') {
      ito = 36;
    } else {
      ito = 12;
    }
    armc = sl.swe_degnorm(armc);
    retc = CalcH(armc,
                 geolat,
                 eps,
                 (char)hsys, 2, h);
    cusp[0] = 0;
    for (i = 1; i <= ito; i++) {
      cusp[i] = h.cusp[i];
    }
    ascmc[aOffs+0] = h.ac;        /* Asc */
    ascmc[aOffs+1] = h.mc;        /* Mid */
    ascmc[aOffs+2] = armc;
    ascmc[aOffs+3] = h.vertex;
    ascmc[aOffs+4] = h.equasc;
    ascmc[aOffs+5] = h.coasc1;  /* "co-ascendant" (Walter Koch) */
    ascmc[aOffs+6] = h.coasc2;  /* "co-ascendant" (Michael Munkasey) */
    ascmc[aOffs+7] = h.polasc;  /* "polar ascendant" (Michael Munkasey) */
    for (i = SweConst.SE_NASCMC; i < 10; i++)
      ascmc[aOffs+i] = 0;
    return retc;
  }

  private int CalcH(double th, double fi, double ekl, char hsy,
                    int iteration_count, Houses hsp )
  /* *********************************************************
   *  Arguments: th = sidereal time (angle 0..360 degrees
   *             hsy = letter code for house system;
   *                   A  equal
   *                   E  equal
   *                   B  Alcabitius
   *                   C  Campanus
   *                   H  horizon / azimut
   *                   K  Koch
   *                   O  Porphyry
   *                   P  Placidus
   *                   R  Regiomontanus
   *                   V  equal Vehlow
   *                   X  axial rotation system/ Meridian houses
   *                   G  36 Gauquelin sectors
   *                   U  Krusinski
   *             fi = geographic latitude
   *             ekl = obliquity of the ecliptic
   *             iteration_count = number of iterations in
   *             Placidus calculation; can be 1 or 2.
   * *********************************************************
   *  Koch and Placidus don't work in the polar circle.
   *  We swap MC/IC so that MC is always before AC in the zodiac
   *  We than divide the quadrants into 3 equal parts.
   * *********************************************************
   *  All angles are expressed in degrees.
   *  Special trigonometric functions sind, cosd etc. are
   *  implemented for arguments in degrees.
   ***********************************************************/
  {
    double tane, tanfi, cosfi, tant, sina, cosa, th2;
    double a, c, f, fh1, fh2, xh1, xh2, rectasc, ad3, acmc, vemc;
    int i, ih, ih2, retc = SweConst.OK;
    double sine, cose;
    double x[] = new double[3], krHorizonLon; /* BK 14.02.2006 */
    cose  = cosd(ekl);
    sine  = sind(ekl);
    tane  = tand(ekl);
    /* north and south poles */
    if (Math.abs(Math.abs(fi) - 90) < VERY_SMALL) {
      if (fi < 0) {
        fi = -90 + VERY_SMALL;
      } else {
        fi = 90 - VERY_SMALL;
      }
    }
    tanfi = tand(fi);
    /* mc */
    if (Math.abs(th - 90) > VERY_SMALL
      && Math.abs(th - 270) > VERY_SMALL) {
      tant = tand(th);
      hsp.mc = atand(tant / cose);
      if (th > 90 && th <= 270) {
        hsp.mc = sl.swe_degnorm(hsp.mc + 180);
      }
    } else {
      if (Math.abs(th - 90) <= VERY_SMALL) {
        hsp.mc = 90;
      } else {
        hsp.mc = 270;
      }
    } /*  if */
    hsp.mc = sl.swe_degnorm(hsp.mc);
    /* ascendant */
    hsp.ac = Asc1 (th + 90, fi, sine, cose);
    hsp.cusp[1] = hsp.ac;
    hsp.cusp[10] = hsp.mc;
    hsy=Character.toUpperCase(hsy);
    switch (hsy) {
      case (int)'A':   /* equal houses */
      case (int)'E':
        /*
         * within polar circle we swap AC/DC if AC is on wrong side
         */
        acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
        if (acmc < 0) {
          hsp.ac = sl.swe_degnorm(hsp.ac + 180);
          hsp.cusp[1] = hsp.ac;
        }
        for (i = 2; i <=12; i++)
          hsp.cusp [i] = sl.swe_degnorm(hsp.cusp [1] + (i-1) * 30);
        break;
      case 'C': /* Campanus houses and Horizon or Azimut system */
      case 'H':
        if (hsy == 'H') {
          if (fi > 0) {
            fi = 90 - fi;
          } else {
            fi = -90 - fi;
          }
          /* equator */
          if (Math.abs(Math.abs(fi) - 90) < VERY_SMALL) {
            if (fi < 0) {
              fi = -90 + VERY_SMALL;
            } else {
              fi = 90 - VERY_SMALL;
            }
          }
          th = sl.swe_degnorm(th + 180);
        }
        fh1 = asind(sind (fi) / 2);
        fh2 = asind(Math.sqrt (3.0) / 2 * sind(fi));
        cosfi = cosd(fi);
        if (Math.abs(cosfi) == 0) {        /* '==' should be save! */
          if (fi > 0) {
            xh1 = xh2 = 90; /* cosfi = VERY_SMALL; */
          } else {
            xh1 = xh2 = 270; /* cosfi = -VERY_SMALL; */
          }
        } else {
          xh1 = atand(Math.sqrt (3.0) / cosfi);
          xh2 = atand(1 / Math.sqrt (3.0) / cosfi);
        }
        hsp.cusp [11] = Asc1 (th + 90 - xh1, fh1, sine, cose);
        hsp.cusp [12] = Asc1 (th + 90 - xh2, fh2, sine, cose);
        if (hsy == 'H') {
          hsp.cusp [1] = Asc1 (th + 90, fi, sine, cose);
        }
        hsp.cusp [2] = Asc1 (th + 90 + xh2, fh2, sine, cose);
        hsp.cusp [3] = Asc1 (th + 90 + xh1, fh1, sine, cose);
        /* within polar circle, when mc sinks below horizon and
         * ascendant changes to western hemisphere, all cusps
         * must be added 180 degrees.
         * houses will be in clockwise direction */
        if (Math.abs(fi) >= 90 - ekl) {  /* within polar circle */
          acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
          if (acmc < 0) {
            hsp.ac = sl.swe_degnorm(hsp.ac + 180);
            hsp.mc = sl.swe_degnorm(hsp.mc + 180);
            for (i = 1; i <= 12; i++)
              hsp.cusp[i] = sl.swe_degnorm(hsp.cusp[i] + 180);
          }
        }
        if (hsy == 'H') {
          for (i = 1; i <= 3; i++)
            hsp.cusp[i] = sl.swe_degnorm(hsp.cusp[i] + 180);
          for (i = 11; i <= 12; i++)
            hsp.cusp[i] = sl.swe_degnorm(hsp.cusp[i] + 180);
          /* restore fi and th */
          if (fi > 0) {
            fi = 90 - fi;
          } else {
            fi = -90 - fi;
          }
          th = sl.swe_degnorm(th + 180);
        }
        break;
      case (int)'K': /* Koch houses */
        if (Math.abs(fi) >= 90 - ekl) {  /* within polar circle */
          retc = SweConst.ERR;
//          goto porphyry;
          makePorphyry(hsp);
          break;
        }
        sina = sind(hsp.mc) * sine / cosd(fi);      /* always << 1,
                                          because fi < polar circle */
        cosa = Math.sqrt(1 - sina * sina);          /* always >> 0 */
        c = atand(tanfi / cosa);
        ad3 = asind(sind(c) * sina) / 3.0;
        hsp.cusp [11] = Asc1 (th + 30 - 2 * ad3, fi, sine, cose);
        hsp.cusp [12] = Asc1 (th + 60 - ad3, fi, sine, cose);
        hsp.cusp [2] = Asc1 (th + 120 + ad3, fi, sine, cose);
        hsp.cusp [3] = Asc1 (th + 150 + 2 * ad3, fi, sine, cose);
        break;
      case (int)'O':   /* Porphyry houses */
//porphyry:
        makePorphyry(hsp);
        break;
      case (int)'R':   /* Regiomontanus houses */
        fh1 = atand (tanfi * 0.5);
        fh2 = atand (tanfi * cosd(30));
        hsp.cusp [11] =  Asc1 (30 + th, fh1, sine, cose);
        hsp.cusp [12] =  Asc1 (60 + th, fh2, sine, cose);
        hsp.cusp [2] =  Asc1 (120 + th, fh2, sine, cose);
        hsp.cusp [3] =  Asc1 (150 + th, fh1, sine, cose);
        /* within polar circle, when mc sinks below horizon and
         * ascendant changes to western hemisphere, all cusps
         * must be added 180 degrees.
         * houses will be in clockwise direction */
        if (Math.abs(fi) >= 90 - ekl) {  /* within polar circle */
          acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
          if (acmc < 0) {
            hsp.ac = sl.swe_degnorm(hsp.ac + 180);
            hsp.mc = sl.swe_degnorm(hsp.mc + 180);
            for (i = 1; i <= 12; i++)
              hsp.cusp[i] = sl.swe_degnorm(hsp.cusp[i] + 180);
          }
        }
        break;
      case (int)'T':   /* 'topocentric' houses */
        fh1 = atand (tanfi / 3.0);
        fh2 = atand (tanfi * 2.0 / 3.0);
        hsp.cusp [11] =  Asc1 (30 + th, fh1, sine, cose);
        hsp.cusp [12] =  Asc1 (60 + th, fh2, sine, cose);
        hsp.cusp [2] =  Asc1 (120 + th, fh2, sine, cose);
        hsp.cusp [3] =  Asc1 (150 + th, fh1, sine, cose);
        /* within polar circle, when mc sinks below horizon and
         * ascendant changes to western hemisphere, all cusps
         * must be added 180 degrees.
         * houses will be in clockwise direction */
        if (Math.abs(fi) >= 90 - ekl) {  /* within polar circle */
          acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
          if (acmc < 0) {
            hsp.ac = sl.swe_degnorm(hsp.ac + 180);
            hsp.mc = sl.swe_degnorm(hsp.mc + 180);
            for (i = 1; i <= 12; i++)
              hsp.cusp[i] = sl.swe_degnorm(hsp.cusp[i] + 180);
          }
        }
        break;
      case 'V':   /* equal houses after Vehlow */
        /*
         * within polar circle we swap AC/DC if AC is on wrong side
         */
        acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
        if (acmc < 0) {
          hsp.ac = sl.swe_degnorm(hsp.ac + 180);
          hsp.cusp[1] = hsp.ac;
        }
        hsp.cusp [1] = sl.swe_degnorm(hsp.ac - 15);
        for (i = 2; i <=12; i++)
          hsp.cusp [i] = sl.swe_degnorm(hsp.cusp [1] + (i-1) * 30);
        break;
      case (int)'X': {
        /*
         * Meridian or axial rotation system:
         * ecliptic points whose rectascensions
         * are armc + n * 30
         */
        int j;
        double a2 = th;
        for (i = 1; i <= 12; i++) {
          j = i + 10;
          if (j > 12) {
            j -= 12;
          }
          a2 = sl.swe_degnorm(a2 + 30);
          if (Math.abs(a2 - 90) > VERY_SMALL
            && Math.abs(a2 - 270) > VERY_SMALL) {
            tant = tand(a2);
            hsp.cusp[j] = atand(tant / cose);
            if (a2 > 90 && a2 <= 270) {
              hsp.cusp[j] = sl.swe_degnorm(hsp.cusp[j] + 180);
            }
          } else {
            if (Math.abs(a2 - 90) <= VERY_SMALL) {
              hsp.cusp[j] = 90;
            } else {
              hsp.cusp[j] = 270;
            }
          } /*  if */
          hsp.cusp[j] = sl.swe_degnorm(hsp.cusp[j]);
        }
        break;
        }
      case (int)'M': {
        /*
         * Morinus
         * points of the equator (armc + n * 30) are transformed
         * into the ecliptic coordinate system
         */
        int j;
        double am = th;
        double xm[] = new double[3];
        for (i = 1; i <= 12; i++) {
          j = i + 10;
          if (j > 12) j -= 12;
          am = sl.swe_degnorm(am + 30);
          xm[0] = am;
          xm[1] = 0;
          sl.swe_cotrans(xm, 0, xm, 0, ekl);
          hsp.cusp[j] = xm[0];
        }
        break;
        }
      case (int)'B': { /* Alcabitius */
        /* created by Alois 17-sep-2000, followed example in Matrix
           electrical library. The code reproduces the example!
           See http://www.astro.com/cgi/adict.cgi query: alcabitius
           in the resuotl page, see program code example.
           I think the Alcabitius code in Walter Pullen's Astrolog 5.40
           is wrong, because he remains in RA and forgets the transform to
           the ecliptic. */
        double dek, r, sna, sda, sn3, sd3;
        acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
        if (acmc < 0) {
          hsp.ac = sl.swe_degnorm(hsp.ac + 180);
          hsp.cusp[1] = hsp.ac;
          acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
        }
        dek = asind(sind(hsp.ac) * sine);        /* declination of Ascendant */
        /* must treat the case fi == 90 or -90 */
        r = -tanfi * tand(dek);
        /* must treat the case of abs(r) > 1; probably does not happen
         * because dek becomes smaller when fi is large, as ac is close to
         * zero Aries/Libra in that case.
         */
        sda = Math.acos(r) * SwissData.RADTODEG; /* semidiurnal arc, measured on equator */
        sna = 180 - sda;          /* complement, seminocturnal arc */
        sd3 = sda / 3;
        sn3 = sna / 3;
        rectasc = sl.swe_degnorm(th + sd3);            /* cusp 11 */
        /* project rectasc onto eclipitic with pole height 0, i.e. along the
        declination circle */
        hsp.cusp [11] = Asc1 (rectasc, 0, sine, cose);
        rectasc = sl.swe_degnorm(th + 2 * sd3);        /* cusp 12 */
        hsp.cusp [12] = Asc1 (rectasc, 0, sine, cose);
        rectasc = sl.swe_degnorm(th + 180 - 2 * sn3);  /* cusp 2 */
        hsp.cusp [2] = Asc1 (rectasc, 0, sine, cose);
        rectasc = sl.swe_degnorm(th + 180 -  sn3);     /* cusp 3 */
        hsp.cusp [3] = Asc1 (rectasc, 0, sine, cose);
        }
        break;
      case (int)'G': {   /* 36 Gauquelin sectors */
        for (i = 1; i <= 36; i++) {
          hsp.cusp[i] = 0;
        }
        if (Math.abs(fi) >= 90 - ekl) {  /* within polar circle */
          retc = SweConst.ERR;
          // goto porphyry;
          makePorphyry(hsp);
        }
        
        /* note: Gauquelin sectors are counted in clockwise direction */
        a = asind(tand(fi) * tane);
        for (ih = 2; ih <= 9; ih++) {
          ih2 = 10 - ih;
          fh1 = atand(sind(a * ih2 / 9) / tane);
          rectasc = sl.swe_degnorm((90 / 9) * ih2 + th);
          tant = tand(asind(sine * sind(Asc1 (rectasc, fh1, sine, cose))));
          if (Math.abs(tant) < VERY_SMALL) {
            hsp.cusp[ih] = rectasc;
          } else {
            /* pole height */
            f = atand(sind(asind(tanfi * tant) * ih2 / 9)  /tant);
            hsp.cusp [ih] = Asc1 (rectasc, f, sine, cose);
            for (i = 1; i <= iteration_count; i++) {
            tant = tand(asind(sine * sind(hsp.cusp[ih])));
            if (Math.abs(tant) < VERY_SMALL) {
              hsp.cusp[ih] = rectasc;
              break;
            }
            /* pole height */
            f = atand(sind(asind(tanfi * tant) * ih2 / 9) / tant);
            hsp.cusp[ih] = Asc1 (rectasc, f, sine, cose);
            }
          }
          hsp.cusp[ih+18] = sl.swe_degnorm(hsp.cusp[ih] + 180);
        }
        
        for (ih = 29; ih <= 36; ih++) {
          ih2 = ih - 28;
          fh1 = atand(sind(a * ih2 / 9) / tane);
          rectasc = sl.swe_degnorm(180 - ih2 * 90 / 9 + th);
          tant = tand(asind(sine * sind(Asc1 (rectasc, fh1, sine, cose))));
          if (Math.abs(tant) < VERY_SMALL) {
            hsp.cusp[ih] = rectasc;
          } else {
            f = atand(sind(asind(tanfi * tant) * ih2 / 9) / tant);
            /*  pole height */
            hsp.cusp[ih] = Asc1 (rectasc, f, sine, cose);
            for (i = 1; i <= iteration_count; i++) {
            tant = tand(asind(sine * sind(hsp.cusp[ih])));
            if (Math.abs(tant) < VERY_SMALL) {
              hsp.cusp[ih] = rectasc;
              break;
            }
            f = atand(sind(asind(tanfi * tant) * ih2 / 9) / tant);
            /*  pole height */
            hsp.cusp[ih] = Asc1 (rectasc, f, sine, cose);
            }
          }
          hsp.cusp[ih-18] = sl.swe_degnorm(hsp.cusp[ih] + 180);
        }
        hsp.cusp[1] = hsp.ac;
        hsp.cusp[10] = hsp.mc;
        hsp.cusp[19] = sl.swe_degnorm(hsp.ac + 180);
        hsp.cusp[28] = sl.swe_degnorm(hsp.mc + 180);
        break;
        }
      case 'U': /* Krusinski */
        /*
         * The following code was written by Bogdan Krusinski in 2006.
         * bogdan@astrologia.pl
         *
         * Definition:
         * "Krusinski - house system based on the great circle passing through 
         * ascendant and zenith. This circle is divided into 12 equal parts 
         * (1st cusp is ascendent, 10th cusp is zenith), then the resulting 
         * points are projected onto the ecliptic through meridian circles.
         * The house cusps in space are half-circles perpendicular to the equator
         * and running from the north to the south celestial pole through the
         * resulting cusp points on the house circle. The points where they 
         * cross the ecliptic mark the ecliptic house cusps."
         *
         * Description of the algorithm:
         * Transform into great circle running through Asc and zenit (where arc 
         * between Asc and zenith is always 90 deg), and then return with 
         * house cusps into ecliptic. Eg. solve trigonometrical triangle 
         * with three transformations and two rotations starting from ecliptic. 
         * House cusps in space are meridian circles. 
         *
         * Notes:
         * 1. In this definition we assume MC on ecliptic as point where
         *    half-meridian (from north to south pole) cuts ecliptic,
         *    so MC may be below horizon in arctic regions.
         * 2. Houses could be calculated in all latitudes except the poles 
         *    themselves (-90,90) and points on arctic circle in cases where 
         *    ecliptic is equal to horizon and then ascendant is undefined. 
         *    But ascendant when 'horizon=ecliptic' could be deduced as limes 
         *    from both sides of that point and houses with that provision can 
         *    be computed also there.
         *
         * Starting values for calculations:
         *	   - Asc ecliptic longitude
         *	   - right ascension of MC (RAMC)
         *	   - geographic latitude.
         */
        /*
         * within polar circle we swap AC/DC if AC is on wrong side
         */
        acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
        if (acmc < 0) {
          hsp.ac = sl.swe_degnorm(hsp.ac + 180);
        }
        /* A0. Start point - ecliptic coords of ascendant */
        x[0] = hsp.ac; /* Asc longitude   */
        x[1] = 0.0;     /* Asc declination */
        x[2] = 1.0;     /* Radius to test validity of subsequent transformations. */
        sl.swe_cotrans(x, x, -ekl);      /* A1. Transform into equatorial coords */
        x[0] = x[0] - (th-90);        /* A2. Rotate                           */
        sl.swe_cotrans(x, x, -(90-fi));  /* A3. Transform into horizontal coords */
        krHorizonLon = x[0];          /* ...save asc lon on horizon to get back later with house cusp */
        x[0] = x[0] - x[0];           /* A4. Rotate                           */
        sl.swe_cotrans(x, x, -90);       /* A5. Transform into this house system great circle (asc-zenith) */
        /* As it is house circle now, simple add 30 deg increments... */
        for(i = 0; i < 6; i++) {
          /* B0. Set 'n-th' house cusp. 
           *     Note that IC/MC are also calculated here to check 
           *     if really this is the asc-zenith great circle. */
          x[0] = 30.0*i;
          x[1] = 0.0;
          sl.swe_cotrans(x, x, 90);                 /* B1. Transform back into horizontal coords */
          x[0] = x[0] + krHorizonLon;            /* B2. Rotate back.                          */
          sl.swe_cotrans(x, x, 90-fi);              /* B3. Transform back into equatorial coords */
          x[0] = sl.swe_degnorm(x[0] + (th-90));    /* B4. Rotate back -> RA of house cusp as result. */
          /* B5. Where's this house cusp on ecliptic? */
          /* ... so last but not least - get ecliptic longitude of house cusp: */
          hsp.cusp[i+1] = atand(tand(x[0])/cosd(ekl));
          if (x[0] > 90 && x[0] <= 270)
            hsp.cusp[i+1] = sl.swe_degnorm(hsp.cusp[i+1] + 180);
          hsp.cusp[i+1] = sl.swe_degnorm(hsp.cusp[i+1]);
          hsp.cusp[i+7] = sl.swe_degnorm(hsp.cusp[i+1]+180);
        }
        break;
      default:    /* Placidus houses */
        if (hsy != 'P') {
          System.err.println("swe_houses: make Placidus, unknown key "+hsy);
        }
        if (Math.abs(fi) >= 90 - ekl) {  /* within polar circle */
          retc = SweConst.ERR;
//          goto porphyry;
          makePorphyry(hsp);
          break;
        }
        a = asind(tand(fi) * tane);
        fh1 = atand(sind(a / 3) / tane);
        fh2 = atand(sind(a * 2 / 3) / tane);
        /* ************  house 11 ******************** */
        rectasc = sl.swe_degnorm(30 + th);
        tant = tand(asind(sine * sind(Asc1 (rectasc, fh1, sine, cose))));
        if (Math.abs(tant) < VERY_SMALL) {
          hsp.cusp [11] = rectasc;
        } else {
          /* pole height */
          f = atand(sind(asind(tanfi * tant) / 3)  /tant);
          hsp.cusp [11] = Asc1 (rectasc, f, sine, cose);
          for (i = 1; i <= iteration_count; i++) {
            tant = tand(asind(sine * sind(hsp.cusp [11])));
            if (Math.abs(tant) < VERY_SMALL) {
              hsp.cusp [11] = rectasc;
              break;
            }
            /* pole height */
            f = atand(sind(asind(tanfi * tant) / 3) / tant);
            hsp.cusp [11] = Asc1 (rectasc, f, sine, cose);
          }
        }
        /* ************  house 12 ******************** */
        rectasc = sl.swe_degnorm(60 + th);
        tant = tand(asind(sine*sind(Asc1 (rectasc,  fh2, sine, cose))));
        if (Math.abs(tant) < VERY_SMALL) {
          hsp.cusp [12] = rectasc;
        } else {
          f = atand(sind(asind(tanfi * tant) / 1.5) / tant);
          /*  pole height */
          hsp.cusp [12] = Asc1 (rectasc, f, sine, cose);
          for (i = 1; i <= iteration_count; i++) {
            tant = tand(asind(sine * sind(hsp.cusp [12])));
            if (Math.abs(tant) < VERY_SMALL) {
              hsp.cusp [12] = rectasc;
              break;
            }
            f = atand(sind(asind(tanfi * tant) / 1.5) / tant);
            /*  pole height */
            hsp.cusp [12] = Asc1 (rectasc, f, sine, cose);
          }
        }
        /* ************  house  2 ******************** */
        rectasc = sl.swe_degnorm(120 + th);
        tant = tand(asind(sine * sind(Asc1 (rectasc, fh2, sine, cose))));
        if (Math.abs(tant) < VERY_SMALL) {
          hsp.cusp [2] = rectasc;
        } else {
          f = atand(sind(asind(tanfi * tant) / 1.5) / tant);
          /*  pole height */
          hsp.cusp [2] = Asc1 (rectasc, f, sine, cose);
          for (i = 1; i <= iteration_count; i++) {
            tant = tand(asind(sine * sind(hsp.cusp [2])));
            if (Math.abs(tant) < VERY_SMALL) {
              hsp.cusp [2] = rectasc;
              break;
            }
            f = atand(sind(asind(tanfi * tant) / 1.5) / tant);
            /*  pole height */
            hsp.cusp [2] = Asc1 (rectasc, f, sine, cose);
          }
        }
        /* ************  house  3 ******************** */
        rectasc = sl.swe_degnorm(150 + th);
        tant = tand(asind(sine * sind(Asc1 (rectasc, fh1, sine, cose))));
        if (Math.abs(tant) < VERY_SMALL) {
          hsp.cusp [3] = rectasc;
        } else {
          f = atand(sind(asind(tanfi * tant) / 3) / tant);
          /*  pole height */
          hsp.cusp [3] = Asc1(rectasc, f, sine, cose);
          for (i = 1; i <= iteration_count; i++) {
            tant = tand(asind(sine * sind(hsp.cusp [3])));
            if (Math.abs(tant) < VERY_SMALL) {
              hsp.cusp [3] = rectasc;
              break;
            }
            f = atand(sind(asind(tanfi * tant) / 3) / tant);
            /*  pole height */
            hsp.cusp [3] = Asc1 (rectasc, f, sine, cose);
          }
        }
        break;
    } /* end switch */
    if (hsy != 'G') {
      hsp.cusp [4] = sl.swe_degnorm(hsp.cusp [10] + 180);
      hsp.cusp [5] = sl.swe_degnorm(hsp.cusp [11] + 180);
      hsp.cusp [6] = sl.swe_degnorm(hsp.cusp [12] + 180);
      hsp.cusp [7] = sl.swe_degnorm(hsp.cusp [1] + 180);
      hsp.cusp [8] = sl.swe_degnorm(hsp.cusp [2] + 180);
      hsp.cusp [9] = sl.swe_degnorm(hsp.cusp [3] + 180);
    }
    /* vertex */
    if (fi >= 0) {
      f = 90 - fi;
    } else {
      f = -90 - fi;
    }
    hsp.vertex = Asc1 (th - 90, f, sine, cose);
    /* with tropical latitudes, the vertex behaves strange,
     * in a similar way as the ascendant within the polar
     * circle. we keep it always on the western hemisphere.*/
    if (Math.abs(fi) <= ekl) {
      vemc = sl.swe_difdeg2n(hsp.vertex, hsp.mc);
      if (vemc > 0) {
        hsp.vertex = sl.swe_degnorm(hsp.vertex + 180);
      }
    }
    /*
     * some strange points:
     */
    /* equasc (equatorial ascendant) */
    th2 = sl.swe_degnorm(th + 90);
    if (Math.abs(th2 - 90) > VERY_SMALL
      && Math.abs(th2 - 270) > VERY_SMALL) {
      tant = tand(th2);
      hsp.equasc = atand(tant / cose);
      if (th2 > 90 && th2 <= 270) {
        hsp.equasc = sl.swe_degnorm(hsp.equasc + 180);
      }
    } else {
      if (Math.abs(th2 - 90) <= VERY_SMALL) {
        hsp.equasc = 90;
      } else {
        hsp.equasc = 270;
      }
    } /*  if */
    hsp.equasc = sl.swe_degnorm(hsp.equasc);
    /* "co-ascendant" W. Koch */
    hsp.coasc1 = sl.swe_degnorm(Asc1 (th - 90, fi, sine, cose) + 180);
    /* "co-ascendant" M. Munkasey */
    if (fi >= 0) {
      hsp.coasc2 = Asc1 (th + 90, 90 - fi, sine, cose);
    } else /* southern hemisphere */ {
      hsp.coasc2 = Asc1 (th + 90, -90 - fi, sine, cose);
    }
    /* "polar ascendant" M. Munkasey */
    hsp.polasc = Asc1 (th - 90, fi, sine, cose);
    return retc;
  } /* procedure houses */

  
  private void makePorphyry(Houses hsp) {
    /*
     * within polar circle we swap AC/DC if AC is on wrong side
     */
    double acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
    if (acmc < 0) {
      hsp.ac = sl.swe_degnorm(hsp.ac + 180);
      hsp.cusp[1] = hsp.ac;
      acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
    }
    hsp.cusp [2] = sl.swe_degnorm(hsp.ac + (180 - acmc) / 3);
    hsp.cusp [3] = sl.swe_degnorm(hsp.ac + (180 - acmc) / 3 * 2);
    hsp.cusp [11] = sl.swe_degnorm(hsp.mc + acmc / 3);
    hsp.cusp [12] = sl.swe_degnorm(hsp.mc + acmc / 3 * 2);
  }

  
  private double Asc1 (double x1, double f, double sine, double cose) {
    int n;
    double ass;
    x1 = sl.swe_degnorm(x1);
    n  = (int) ((x1 / 90) + 1);
    if (n == 1) {
      ass = ( Asc2 (x1, f, sine, cose));
    } else if (n == 2) {
      ass = (180 - Asc2 (180 - x1, - f, sine, cose));
    } else if (n == 3) {
      ass = (180 + Asc2 (x1 - 180, - f, sine, cose));
    } else {
      ass = (360 - Asc2 (360- x1,  f, sine, cose));
    }
    ass = sl.swe_degnorm(ass);
    if (Math.abs(ass - 90) < VERY_SMALL)        /* rounding, e.g.: if */ {
      ass = 90;                           /* fi = 0 & st = 0, ac = 89.999... */
    }
    if (Math.abs(ass - 180) < VERY_SMALL) {
      ass = 180;
    }
    if (Math.abs(ass - 270) < VERY_SMALL)        /* rounding, e.g.: if */ {
      ass = 270;                          /* fi = 0 & st = 0, ac = 89.999... */
    }
    if (Math.abs(ass - 360) < VERY_SMALL) {
      ass = 0;
    }
    return ass;
  }  /* Asc1 */

  private double Asc2 (double x, double f, double sine, double cose) {
    int n;
    double ass, sinx;
    ass = - tand(f) * sine + cose * cosd(x);
    if (Math.abs(ass) < VERY_SMALL) {
      ass = 0;
    }
    sinx = sind(x);
    if (Math.abs(sinx) < VERY_SMALL) {
      sinx = 0;
    }
    if (sinx == 0) {
      if (ass < 0) {
        ass = -VERY_SMALL;
      } else {
        ass = VERY_SMALL;
      }
    } else if (ass == 0) {
      if (sinx < 0) {
        ass = -90;
      } else {
        ass = 90;
      }
    } else {
      ass = atand(sinx / ass);
    }
    if (ass < 0) {
      ass = 180 + ass;
    }
    return (ass);
  } /* Asc2 */


  /* computes the house position of a planet or another point,
   * in degrees: 0 - 30 = 1st house, 30 - 60 = 2nd house, etc.
   * armc         sidereal time in degrees
   * geolat       geographic latitude
   * eps          true ecliptic obliquity
   * hsys         house system character
   * xpin         array of 6 doubles:
   *              only the first two of them are used: ecl. long., lat.
   * serr         error message area
   *
   * house position is returned by function.
   *
   * sidereal house positions:
   *
   * tropical and sidereal house positions of planets are always identical
   * if the traditional method of computing sidereal positions (subtracting
   * the ayanamsha from tropical in order to get sidereal positions) is used.
   *
   * if the sidereal plane is not identical to the ecliptic of date,
   * sidereal and tropical house positions are identical with
   * house systems that are independent on the ecliptic such as:
   * - Campanus
   * - Regiomontanus
   * - Placidus
   * - Azimuth/Horizon
   * - Axial rotation system
   * - "topocentric" system
   *
   * in all these cases call swe_house_pos() with TROPICAL planetary positions.
   *
   * but there are different house positions for ecliptic-dependent systems
   * such as:
   * - equal
   * - Porphyry
   * - Koch
<  * - Krusinski
   *
   * for these cases there is no function.
   */
  
  double swe_house_pos(double armc, double geolat, double eps,
                       int hsys, double xpin[], StringBuffer serr) {
    double xp[]=new double[6], xeq[]=new double[6], ra, de, mdd, mdn, sad, san;
    double hpos, sinad, ad, a, admc, adp, samc, demc, asc, mc, acmc, tant;
    double fh, ra0, tanfi, fac;
    double x[] = new double[3], xasc[] = new double[3], raep, raaz, oblaz, xtemp; /* BK 21.02.2006 */
    double sine = sind(eps);
    double cose = cosd(eps);
    boolean is_above_hor = false;
    if (serr != null) { serr.setLength(0); }
    hsys = Character.toUpperCase((char)hsys);
    xeq[0] = xpin[0];
    xeq[1] = xpin[1];
    xeq[2] = 1;
    sl.swe_cotrans(xpin, 0, xeq, 0, -eps);
    ra = xeq[0];
    de = xeq[1];
    mdd = sl.swe_degnorm(ra - armc);
    mdn = sl.swe_degnorm(mdd + 180);
    if (mdd >= 180) {
      mdd -= 360;
    }
    if (mdn >= 180) {
      mdn -= 360;
    }
    /* xp[0] will contain the house position, a value between 0 and 360 */
    switch(hsys) {
      case (int)'A':
      case (int)'E':
      case (int)'V':
        asc = Asc1 (sl.swe_degnorm(armc + 90), geolat, sine, cose);
        demc = atand(sind(armc) * tand(eps));
        if (geolat >= 0 && 90 - geolat + demc < 0) {
          asc = sl.swe_degnorm(asc + 180);
        }
        if (geolat < 0 && -90 - geolat + demc > 0) {
          asc = sl.swe_degnorm(asc + 180);
        }
        xp[0] = sl.swe_degnorm(xpin[0] - asc);
        if (hsys == 'V') {
          xp[0] = sl.swe_degnorm(xp[0] + 15);
        }
        /* to make sure that a call with a house cusp position returns
         * a value within the house, 0.001" is added */
        xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        hpos = xp[0] / 30.0 + 1;
      break;
      case 'O':
        asc = Asc1 (sl.swe_degnorm(armc + 90), geolat, sine, cose);
        demc = atand(sind(armc) * tand(eps));
        /* mc */
        if (Math.abs(armc - 90) > VERY_SMALL
                && Math.abs(armc - 270) > VERY_SMALL) {
          tant = tand(armc);
          mc = sl.swe_degnorm(atand(tant / cose));
          if (armc > 90 && armc <= 270) {
            mc = sl.swe_degnorm(mc + 180);
          }
        } else {
          if (Math.abs(armc - 90) <= VERY_SMALL) {
            mc = 90;
          } else {
            mc = 270;
          }
        }
        /* while MC is always south,
         * Asc must always be in eastern hemisphere */
        if (geolat >= 0 && 90 - geolat + demc < 0) {
          asc = sl.swe_degnorm(asc + 180);
        }
        if (geolat < 0 && -90 - geolat + demc > 0) {
          asc = sl.swe_degnorm(asc + 180);
        }
        xp[0] = sl.swe_degnorm(xpin[0] - asc);
        /* to make sure that a call with a house cusp position returns
         * a value within the house, 0.001" is added */
        xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        if (xp[0] < 180) {
          hpos = 1;
        } else {
          hpos = 7;
          xp[0] -= 180;
        }
        acmc = sl.swe_difdeg2n(asc, mc);
        if (xp[0] < 180 - acmc) {
          hpos += xp[0] * 3 / (180 - acmc);
        } else {
          hpos += 3 + (xp[0] - 180 + acmc) * 3 / acmc;
        }
      break;
      case 'X': /* Merdidian or axial rotation system */
        hpos = sl.swe_degnorm(mdd - 90) / 30.0 + 1;
      break;
      case (int)'M': { /* Morinus */
        double am = xpin[0];
        if (Math.abs(am - 90) > VERY_SMALL
          && Math.abs(am - 270) > VERY_SMALL) {
          tant = tand(am);
          hpos = atand(tant / cose);
          if (am > 90 && am <= 270) {
            hpos = sl.swe_degnorm(hpos + 180);
          }
        } else {
          if (Math.abs(am - 90) <= VERY_SMALL) {
            hpos = 90;
          } else {
            hpos = 270;
          }
        } /*  if */
        hpos = sl.swe_degnorm(hpos - armc - 90);
        hpos = hpos / 30.0 + 1;
      }
      break;
      case (int)'K':
       demc = atand(sind(armc) * tand(eps));
       /* if body is within circumpolar region, error */
       if (90 - Math.abs(geolat) <= Math.abs(de)) {
         if (serr != null) {
           serr.append("no Koch house position, because planet is circumpolar.");
         }
         xp[0] = 0;
         hpos = 0;        /* Error */
       } else if (90 - Math.abs(geolat) <= Math.abs(demc)) {
         if (serr != null) {
           serr.append("no Koch house position, because mc is circumpolar.");
         }
         xp[0] = 0;
         hpos = 0;        /* Error */
        } else {
          admc = asind(tand(eps) * tand(geolat) * sind(armc));
          adp = asind(tand(geolat) * tand(de));
            samc = 90 + admc;
          if (mdd >= 0) {        /* east */
            xp[0] = sl.swe_degnorm(((mdd - adp + admc) / samc - 1) * 90);
          } else {
            xp[0] = sl.swe_degnorm(((mdd + 180 + adp + admc) / samc + 1) * 90);
          }
          /* to make sure that a call with a house cusp position returns
           * a value within the house, 0.001" is added */
          xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
          hpos = xp[0] / 30.0 + 1;
        }
        break;
      case (int)'C':
        xeq[0] = sl.swe_degnorm(mdd - 90);
        sl.swe_cotrans(xeq, 0, xp, 0, -geolat);
        /* to make sure that a call with a house cusp position returns
         * a value within the house, 0.001" is added */
        xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        hpos = xp[0] / 30.0 + 1;
        break;
      case 'U': /* Krusinski */
        /* Purpose: find point where planet's house circle (meridian)
         * cuts house plane, giving exact planet's house position.
         * Input data: ramc, geolat, asc.
         */
        asc = Asc1 (sl.swe_degnorm(armc + 90), geolat, sine, cose);
        demc = atand(sind(armc) * tand(eps));
        /* while MC is always south, 
         * Asc must always be in eastern hemisphere */
        if (geolat >= 0 && 90 - geolat + demc < 0) {
          asc = sl.swe_degnorm(asc + 180);
        }
        if (geolat < 0 && -90 - geolat + demc > 0) {
          asc = sl.swe_degnorm(asc + 180);
        }
        /*
         * Descr: find the house plane 'asc-zenith' - where it intersects 
         * with equator and at what angle, and then simple find arc 
         * from asc on that plane to planet's meridian intersection 
         * with this plane.
         */
        /* I. find plane of 'asc-zenith' great circle relative to equator: 
         *   solve spherical triangle 'EP-asc-intersection of house circle with equator' */
        /* Ia. Find intersection of house plane with equator: */
        x[0] = asc; x[1] = 0.0; x[2] = 1.0;          /* 1. Start with ascendent on ecliptic     */
        sl.swe_cotrans(x, x, -eps);                     /* 2. Transform asc into equatorial coords */
        raep = sl.swe_degnorm(armc + 90);               /* 3. RA of east point                     */
        x[0] = sl.swe_degnorm(raep - x[0]);             /* 4. Rotation - found arc raas-raep      */
        sl.swe_cotrans(x, x, -(90-geolat));             /* 5. Transform into horizontal coords - arc EP-asc on horizon */
        xtemp = atand(tand(x[0])/cosd((90-geolat))); /* 6. Rotation from horizon on circle perpendicular to equator */
        if (x[0] > 90 && x[0] <= 270)
        xtemp = sl.swe_degnorm(xtemp + 180);
        x[0] = sl.swe_degnorm(xtemp);        
        raaz = sl.swe_degnorm(raep - x[0]); /* result: RA of intersection 'asc-zenith' great circle with equator */
        /* Ib. Find obliquity to equator of 'asc-zenith' house plane: */
        x[0] = raaz; x[1] = 0.0; 
        x[0] = sl.swe_degnorm(raep - x[0]);  /* 1. Rotate start point relative to EP   */
        sl.swe_cotrans(x, x, -(90-geolat));  /* 2. Transform into horizontal coords    */
        x[1] = x[1] + 90;                 /* 3. Add 90 deg do decl - so get the point on house plane most distant from equ. */
        sl.swe_cotrans(x, x, 90-geolat);     /* 4. Rotate back to equator              */
        oblaz = x[1];                     /* 5. Obliquity of house plane to equator */
        /* II. Next find asc and planet position on house plane, 
         *     so to find relative distance of planet from 
         *     coords beginning. */
        /* IIa. Asc on house plane relative to intersection 
         *      of equator with 'asc-zenith' plane. */
        xasc[0] = asc; xasc[1] = 0.0; xasc[2] = 1.0;
        sl.swe_cotrans(xasc, xasc, -eps);
        xasc[0] = sl.swe_degnorm(xasc[0] - raaz);
        xtemp = atand(tand(xasc[0])/cosd(oblaz));
        if (xasc[0] > 90 && xasc[0] <= 270)
        xtemp = sl.swe_degnorm(xtemp + 180);
        xasc[0] = sl.swe_degnorm(xtemp);
        /* IIb. Planet on house plane relative to intersection 
         *      of equator with 'asc-zenith' plane */
        xp[0] = sl.swe_degnorm(xeq[0] - raaz);        /* Rotate on equator  */
        xtemp = atand(tand(xp[0])/cosd(oblaz));    /* Find arc on house plane from equator */
        if (xp[0] > 90 && xp[0] <= 270)
          xtemp = sl.swe_degnorm(xtemp + 180);
        xp[0] = sl.swe_degnorm(xtemp);
        xp[0] = sl.swe_degnorm(xp[0]-xasc[0]); /* find arc between asc and planet, and get planet house position  */
        /* IIc. Distance from planet to house plane on declination circle: */
        x[0] = xeq[0];
        x[1] = xeq[1];
        sl.swe_cotrans(x, x, oblaz);
        xp[1] = xeq[1] - x[1]; /* How many degrees is the point on declination circle from house circle */
        /* to make sure that a call with a house cusp position returns
         * a value within the house, 0.001" is added */
        xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        hpos = xp[0] / 30.0 + 1;
        break;
      case (int)'H':
        xeq[0] = sl.swe_degnorm(mdd - 90);
        sl.swe_cotrans(xeq, 0, xp, 0, 90 - geolat);
        /* to make sure that a call with a house cusp position returns
         * a value within the house, 0.001" is added */
        xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        hpos = xp[0] / 30.0 + 1;
        break;
      case (int)'R':
        if (Math.abs(mdd) < VERY_SMALL) {
          xp[0] = 270;
        } else if (180 - Math.abs(mdd) < VERY_SMALL) {
          xp[0] = 90;
        } else {
          if (90 - Math.abs(geolat) < VERY_SMALL) {
            if (geolat > 0) {
              geolat = 90 - VERY_SMALL;
            } else {
              geolat = -90 + VERY_SMALL;
            }
          }
          if (90 - Math.abs(de) < VERY_SMALL) {
            if (de > 0) {
              de = 90 - VERY_SMALL;
            } else {
              de = -90 + VERY_SMALL;
            }
          }
          a = tand(geolat) * tand(de) + cosd(mdd);
          xp[0] = sl.swe_degnorm(atand(-a / sind(mdd)));
          if (mdd < 0) {
            xp[0] += 180;
          }
          xp[0] = sl.swe_degnorm(xp[0]);
          /* to make sure that a call with a house cusp position returns
           * a value within the house, 0.001" is added */
          xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        }
        hpos = xp[0] / 30.0 + 1;
        break;
      case (int)'T':
        mdd = sl.swe_degnorm(mdd);
        if (de > 90 - VERY_SMALL) {
          de = 90 - VERY_SMALL;
        }
        if (de < -90 + VERY_SMALL) {
          de = -90 + VERY_SMALL;
        }
        sinad = tand(de) * tand(geolat);
        ad = asind(sinad);
        a = sinad + cosd(mdd);
        if (a >= 0) {
          is_above_hor = true;
        }
        /* mirror everything below the horizon to the opposite point
         * above the horizon */
        if (!is_above_hor) {
          ra = sl.swe_degnorm(ra + 180);
          de = -de;
          mdd = sl.swe_degnorm(mdd + 180);
        }
        /* mirror everything on western hemisphere to eastern hemisphere */
        if (mdd > 180) {
          ra = sl.swe_degnorm(armc - mdd);
        }
        /* binary search for "topocentric" position line of body */
        tanfi = tand(geolat);
        fh = geolat;
        ra0 = sl.swe_degnorm(armc + 90);
        xp[1] = 1;
        xeq[1] = de;
        fac = 2;
        while (Math.abs(xp[1]) > 0.000001) {
          if (xp[1] > 0) {
            fh = atand(tand(fh) - tanfi / fac);
            ra0 -= 90 / fac;
          } else {
            fh = atand(tand(fh) + tanfi / fac);
            ra0 += 90 / fac;
          }
          xeq[0] = sl.swe_degnorm(ra - ra0);
          sl.swe_cotrans(xeq, 0, xp, 0, 90 - fh);
          fac *= 2;
        }
        hpos = sl.swe_degnorm(ra0 - armc);
        /* mirror back to west */
        if (mdd > 180) {
          hpos = sl.swe_degnorm(-hpos);
        }
        /* mirror back to below horizon */
        if (!is_above_hor) {
          hpos = sl.swe_degnorm(hpos + 180);
        }
        hpos = sl.swe_degnorm(hpos - 90) / 30 + 1;
        break;
      case (int)'P':
      case (int)'G':
      default:
         /* circumpolar region */
        if (90 - Math.abs(de) <= Math.abs(geolat)) {
          if (de * geolat < 0) {
            xp[0] = sl.swe_degnorm(90 + mdn / 2);
          } else {
            xp[0] = sl.swe_degnorm(270 + mdd / 2);
          }
          if (serr != null) {
            serr.append("Otto Ludwig procedure within circumpolar regions.");
          }
        } else {
          sinad = tand(de) * tand(geolat);
          ad = asind(sinad);
          a = sinad + cosd(mdd);
          if (a >= 0) {
            is_above_hor = true;
          }
          sad = 90 + ad;
          san = 90 - ad;
          if (is_above_hor) {
            xp[0] =  (mdd / sad + 3) * 90;
          } else {
            xp[0] = (mdn / san + 1) * 90;
          }
          /* to make sure that a call with a house cusp position returns
           * a value within the house, 0.001" is added */
          xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        }
        if ((char)hsys == 'G') {
          xp[0] = 360 - xp[0]; /* Gauquelin sectors are in clockwise direction */
          hpos = xp[0] / 10.0 + 1;
        } else {
          hpos = xp[0] / 30.0 + 1;
        }
      break;
    }
    return hpos;
  }
}




class Swemmoon {

 /*
 * Expansions for the geocentric ecliptic longitude,
 * latitude, and distance of the Moon referred to the mean equinox
 * and ecliptic of date.
 *
 * This version of cmoon.c adjusts the ELP2000-85 analytical Lunar
 * theory of Chapront-Touze and Chapront to fit the Jet Propulsion
 * Laboratory's DE404 long ephemeris on the interval from 3000 B.C.
 * to 3000 A.D.
 *
 * The fit is much better in the remote past and future if
 * secular terms are included in the arguments of the oscillatory
 * perturbations.  Such adjustments cannot easily be incorporated
 * into the 1991 lunar tables.  In this program the traditional
 * literal arguments are used instead, with mean elements adjusted
 * for a best fit to the reference ephemeris.
 *
 * This program omits many oscillatory terms from the analytical
 * theory which, if they were included, would yield a much higher
 * accuracy for modern dates.  Detailed statistics of the precision
 * are given in the table below.  Comparing at 64-day intervals
 * over the period -3000 to +3000, the maximum discrepancies noted
 * were 7" longitude, 5" latitude, and 5 x 10^-8 au radius.
 * The expressions used for precession in this comparision were
 * those of Simon et al (1994).
 *
 * The adjusted coefficients were found by an unweighted least squares
 * fit to the numerical ephemeris in the mentioned test interval.
 * The approximation error increases rapidly outside this interval.
 * J. Chapront (1994) has described the basic fitting procedure.
 *
 * A major change from DE200 to DE404 is in the coefficient
 * of tidal acceleration of the Moon, which causes the Moon's
 * longitude to depart by about -0.9" per century squared
 * from DE200.  Uncertainty in this quantity continues to
 * be the limiting factor in long term projections of the Moon's
 * ephemeris.
 *
 * Since the Lunar theory is cast in the ecliptic of date, it makes
 * some difference what formula you use for precession.  The adjustment
 * to DE404 was carried out relative to the mean equinox and ecliptic
 * of date as defined in Williams (1994).  An earlier version of this
 * program used the precession given by Simon et al (1994).  The difference
 * between these two precession formulas amounts to about 12" in Lunar
 * longitude at 3000 B.C.
 *
 *    Maximum deviations between DE404 and this program
 *    in a set of 34274 samples spaced 64 days apart
 *
 *   Interval     Longitude  Latitude  Radius
 *   Julian Year   arc sec   arc sec   10^-8 au
 * -3000 to -2500    5.66      4.66     4.93
 * -2500 to -2000    5.49      3.98     4.56
 * -2000 to -1500    6.98      4.17     4.81
 * -1500 to -1000    5.74      3.53     4.87
 * -1000 to -500     5.95      3.42     4.67
 * -500 to     0     4.94      3.07     4.04
 *    0 to   500     4.42      2.65     4.55
 *  500 to  1000     5.68      3.30     3.99
 * 1000 to  1500     4.32      3.21     3.83
 * 1500 to  2000     2.70      2.69     3.71
 * 2000 to  2500     3.35      2.32     3.85
 * 2500 to  3000     4.62      2.39     4.11
 *
 *
 *
 * References:
 *
 *   James G. Williams, "Contributions to the Earth's obliquity rate,
 *   precession, and nutation,"  Astron. J. 108, 711-724 (1994)
 *
 *   DE403 and DE404 ephemerides by E. M. Standish, X. X. Newhall, and
 *   J. G. Williams are at the JPL computer site navigator.jpl.nasa.gov.
 *
 *   J. L. Simon, P. Bretagnon, J. Chapront, M. Chapront-Touze', G. Francou,
 *   and J. Laskar, "Numerical Expressions for precession formulae and
 *   mean elements for the Moon and the planets," Astronomy and Astrophysics
 *   282, 663-683 (1994)
 *
 *   P. Bretagnon and Francou, G., "Planetary theories in rectangular
 *   and spherical variables. VSOP87 solutions," Astronomy and
 *   Astrophysics 202, 309-315 (1988)
 *
 *   M. Chapront-Touze' and J. Chapront, "ELP2000-85: a semi-analytical
 *   lunar ephemeris adequate for historical times," Astronomy and
 *   Astrophysics 190, 342-352 (1988).
 *
 *   M. Chapront-Touze' and J. Chapront, _Lunar Tables and
 *   Programs from 4000 B.C. to A.D. 8000_, Willmann-Bell (1991)
 *
 *   J. Laskar, "Secular terms of classical planetary theories
 *   using the results of general theory," Astronomy and Astrophysics
 *   157, 59070 (1986)
 *
 *   S. L. Moshier, "Comparison of a 7000-year lunar ephemeris
 *   with analytical theory," Astronomy and Astrophysics 262,
 *   613-616 (1992)
 *
 *   J. Chapront, "Representation of planetary ephemerides by frequency
 *   analysis.  Application to the five outer planets,"  Astronomy and
 *   Astrophysics Suppl. Ser. 109, 181-192 (1994)
 *
 *
 * Entry swi_moshmoon2() returns the geometric position of the Moon
 * relative to the Earth.  Its calling procedure is as follows:
 *
 * double JD;       input Julian Ephemeris Date
 * double pol[3];   output ecliptic polar coordinatees in radians and au
 *                  pol[0] longitude, pol[1] latitude, pol[2] radius
 * swi_moshmoon2( JD, pol );
 *
 * - S. L. Moshier, August, 1991
 * DE200 fit: July, 1992
 * DE404 fit: October, 1995
 *
 * Dieter Koch: adaptation to SWISSEPH, April 1996
 * 18-feb-2006  replaced LP by SWELP because of name collision
 */

  SwissData swed;
  SwissLib sl;

  Swemmoon() {
    this(null,null);
// //#ifdef TRACE0
//     DevNull.println(System.currentTimeMillis()+" Swemmoon()");
// //#endif /* TRACE0 */
  }

  Swemmoon(SwissData swed, SwissLib sl) {
    this.swed=swed;
    this.sl=sl;
    if (this.swed ==null) { this.swed =new SwissData(); }
    if (this.sl   ==null) { this.sl   =new SwissLib(); }
  }


  /* The following coefficients were calculated by a simultaneous least
   * squares fit between the analytical theory and DE404 on the finite
   * interval from -3000 to +3000.
   * The coefficients were estimated from 34,247 Lunar positions.
   */
  static final double z[] = {
    /* The following are scaled in arc seconds, time in Julian centuries.
       They replace the corresponding terms in the mean elements.  */
    -1.312045233711e+01, /* F, t^2 */
    -1.138215912580e-03, /* F, t^3 */
    -9.646018347184e-06, /* F, t^4 */
     3.146734198839e+01, /* l, t^2 */
     4.768357585780e-02, /* l, t^3 */
    -3.421689790404e-04, /* l, t^4 */
    -6.847070905410e+00, /* D, t^2 */
    -5.834100476561e-03, /* D, t^3 */
    -2.905334122698e-04, /* D, t^4 */
    -5.663161722088e+00, /* L, t^2 */
     5.722859298199e-03, /* L, t^3 */
    -8.466472828815e-05, /* L, t^4 */
    /* The following longitude terms are in arc seconds times 10^5.  */
    -8.429817796435e+01, /* t^2 Math.cos(18V - 16E - l) */
    -2.072552484689e+02, /* t^2 Math.sin(18V - 16E - l) */
     7.876842214863e+00, /* t^2 Math.cos(10V - 3E - l) */
     1.836463749022e+00, /* t^2 Math.sin(10V - 3E - l) */
    -1.557471855361e+01, /* t^2 Math.cos(8V - 13E) */
    -2.006969124724e+01, /* t^2 Math.sin(8V - 13E) */
     2.152670284757e+01, /* t^2 Math.cos(4E - 8M + 3J) */
    -6.179946916139e+00, /* t^2 Math.sin(4E - 8M + 3J) */
    -9.070028191196e-01, /* t^2 Math.cos(18V - 16E) */
    -1.270848233038e+01, /* t^2 Math.sin(18V - 16E) */
    -2.145589319058e+00, /* t^2 Math.cos(2J - 5S) */
     1.381936399935e+01, /* t^2 Math.sin(2J - 5S) */
    -1.999840061168e+00, /* t^3 Math.sin(l') */
  };


  /* Perturbation tables
   */
  static final int NLR=118;
  static final short LR[]={
  /*
                 Longitude    Radius
   D  l' l  F    1"  .0001"  1km  .0001km */

   0, 0, 1, 0, 22639, 5858,-20905,-3550,
   2, 0,-1, 0,  4586, 4383, -3699,-1109,
   2, 0, 0, 0,  2369, 9139, -2955,-9676,
   0, 0, 2, 0,   769,  257,  -569,-9251,
   0, 1, 0, 0,  -666,-4171,    48, 8883,
   0, 0, 0, 2,  -411,-5957,    -3,-1483,
   2, 0,-2, 0,   211, 6556,   246, 1585,
   2,-1,-1, 0,   205, 4358,  -152,-1377,
   2, 0, 1, 0,   191, 9562,  -170,-7331,
   2,-1, 0, 0,   164, 7285,  -204,-5860,
   0, 1,-1, 0,  -147,-3213,  -129,-6201,
   1, 0, 0, 0,  -124,-9881,   108, 7427,
   0, 1, 1, 0,  -109,-3803,   104, 7552,
   2, 0, 0,-2,    55, 1771,    10, 3211,
   0, 0, 1, 2,   -45, -996,     0,    0,
   0, 0, 1,-2,    39, 5333,    79, 6606,
   4, 0,-1, 0,    38, 4298,   -34,-7825,
   0, 0, 3, 0,    36, 1238,   -23,-2104,
   4, 0,-2, 0,    30, 7726,   -21,-6363,
   2, 1,-1, 0,   -28,-3971,    24, 2085,
   2, 1, 0, 0,   -24,-3582,    30, 8238,
   1, 0,-1, 0,   -18,-5847,    -8,-3791,
   1, 1, 0, 0,    17, 9545,   -16,-6747,
   2,-1, 1, 0,    14, 5303,   -12,-8314,
   2, 0, 2, 0,    14, 3797,   -10,-4448,
   4, 0, 0, 0,    13, 8991,   -11,-6500,
   2, 0,-3, 0,    13, 1941,    14, 4027,
   0, 1,-2, 0,    -9,-6791,    -7,  -27,
   2, 0,-1, 2,    -9,-3659,     0, 7740,
   2,-1,-2, 0,     8, 6055,    10,  562,
   1, 0, 1, 0,    -8,-4531,     6, 3220,
   2,-2, 0, 0,     8,  502,    -9,-8845,
   0, 1, 2, 0,    -7,-6302,     5, 7509,
   0, 2, 0, 0,    -7,-4475,     1,  657,
   2,-2,-1, 0,     7, 3712,    -4,-9501,
   2, 0, 1,-2,    -6,-3832,     4, 1311,
   2, 0, 0, 2,    -5,-7416,     0,    0,
   4,-1,-1, 0,     4, 3740,    -3,-9580,
   0, 0, 2, 2,    -3,-9976,     0,    0,
   3, 0,-1, 0,    -3,-2097,     3, 2582,
   2, 1, 1, 0,    -2,-9145,     2, 6164,
   4,-1,-2, 0,     2, 7319,    -1,-8970,
   0, 2,-1, 0,    -2,-5679,    -2,-1171,
   2, 2,-1, 0,    -2,-5212,     2, 3536,
   2, 1,-2, 0,     2, 4889,     0, 1437,
   2,-1, 0,-2,     2, 1461,     0, 6571,
   4, 0, 1, 0,     1, 9777,    -1,-4226,
   0, 0, 4, 0,     1, 9337,    -1,-1169,
   4,-1, 0, 0,     1, 8708,    -1,-5714,
   1, 0,-2, 0,    -1,-7530,    -1,-7385,
   2, 1, 0,-2,    -1,-4372,     0,-1357,
   0, 0, 2,-2,    -1,-3726,    -4,-4212,
   1, 1, 1, 0,     1, 2618,     0,-9333,
   3, 0,-2, 0,    -1,-2241,     0, 8624,
   4, 0,-3, 0,     1, 1868,     0,-5142,
   2,-1, 2, 0,     1, 1770,     0,-8488,
   0, 2, 1, 0,    -1,-1617,     1, 1655,
   1, 1,-1, 0,     1,  777,     0, 8512,
   2, 0, 3, 0,     1,  595,     0,-6697,
   2, 0, 1, 2,     0,-9902,     0,    0,
   2, 0,-4, 0,     0, 9483,     0, 7785,
   2,-2, 1, 0,     0, 7517,     0,-6575,
   0, 1,-3, 0,     0,-6694,     0,-4224,
   4, 1,-1, 0,     0,-6352,     0, 5788,
   1, 0, 2, 0,     0,-5840,     0, 3785,
   1, 0, 0,-2,     0,-5833,     0,-7956,
   6, 0,-2, 0,     0, 5716,     0,-4225,
   2, 0,-2,-2,     0,-5606,     0, 4726,
   1,-1, 0, 0,     0,-5569,     0, 4976,
   0, 1, 3, 0,     0,-5459,     0, 3551,
   2, 0,-2, 2,     0,-5357,     0, 7740,
   2, 0,-1,-2,     0, 1790,     8, 7516,
   3, 0, 0, 0,     0, 4042,    -1,-4189,
   2,-1,-3, 0,     0, 4784,     0, 4950,
   2,-1, 3, 0,     0,  932,     0, -585,
   2, 0, 2,-2,     0,-4538,     0, 2840,
   2,-1,-1, 2,     0,-4262,     0,  373,
   0, 0, 0, 4,     0, 4203,     0,    0,
   0, 1, 0, 2,     0, 4134,     0,-1580,
   6, 0,-1, 0,     0, 3945,     0,-2866,
   2,-1, 0, 2,     0,-3821,     0,    0,
   2,-1, 1,-2,     0,-3745,     0, 2094,
   4, 1,-2, 0,     0,-3576,     0, 2370,
   1, 1,-2, 0,     0, 3497,     0, 3323,
   2,-3, 0, 0,     0, 3398,     0,-4107,
   0, 0, 3, 2,     0,-3286,     0,    0,
   4,-2,-1, 0,     0,-3087,     0,-2790,
   0, 1,-1,-2,     0, 3015,     0,    0,
   4, 0,-1,-2,     0, 3009,     0,-3218,
   2,-2,-2, 0,     0, 2942,     0, 3430,
   6, 0,-3, 0,     0, 2925,     0,-1832,
   2, 1, 2, 0,     0,-2902,     0, 2125,
   4, 1, 0, 0,     0,-2891,     0, 2445,
   4,-1, 1, 0,     0, 2825,     0,-2029,
   3, 1,-1, 0,     0, 2737,     0,-2126,
   0, 1, 1, 2,     0, 2634,     0,    0,
   1, 0, 0, 2,     0, 2543,     0,    0,
   3, 0, 0,-2,     0,-2530,     0, 2010,
   2, 2,-2, 0,     0,-2499,     0,-1089,
   2,-3,-1, 0,     0, 2469,     0,-1481,
   3,-1,-1, 0,     0,-2314,     0, 2556,
   4, 0, 2, 0,     0, 2185,     0,-1392,
   4, 0,-1, 2,     0,-2013,     0, 0,
   0, 2,-2, 0,     0,-1931,     0, 0,
   2, 2, 0, 0,     0,-1858,     0, 0,
   2, 1,-3, 0,     0, 1762,     0, 0,
   4, 0,-2, 2,     0,-1698,     0, 0,
   4,-2,-2, 0,     0, 1578,     0,-1083,
   4,-2, 0, 0,     0, 1522,     0,-1281,
   3, 1, 0, 0,     0, 1499,     0,-1077,
   1,-1,-1, 0,     0,-1364,     0, 1141,
   1,-3, 0, 0,     0,-1281,     0, 0,
   6, 0, 0, 0,     0, 1261,     0, -859,
   2, 0, 2, 2,     0,-1239,     0, 0,
   1,-1, 1, 0,     0,-1207,     0, 1100,
   0, 0, 5, 0,     0, 1110,     0, -589,
   0, 3, 0, 0,     0,-1013,     0,  213,
   4,-1,-3, 0,     0,  998,     0, 0,
  };


  static final int NMB=77;
  static final short MB[]={
  /*
                 Latitude
   D  l' l  F    1"  .0001" */

   0, 0, 0, 1,18461, 2387,
   0, 0, 1, 1, 1010, 1671,
   0, 0, 1,-1,  999, 6936,
   2, 0, 0,-1,  623, 6524,
   2, 0,-1, 1,  199, 4837,
   2, 0,-1,-1,  166, 5741,
   2, 0, 0, 1,  117, 2607,
   0, 0, 2, 1,   61, 9120,
   2, 0, 1,-1,   33, 3572,
   0, 0, 2,-1,   31, 7597,
   2,-1, 0,-1,   29, 5766,
   2, 0,-2,-1,   15, 5663,
   2, 0, 1, 1,   15, 1216,
   2, 1, 0,-1,  -12, -941,
   2,-1,-1, 1,    8, 8681,
   2,-1, 0, 1,    7, 9586,
   2,-1,-1,-1,    7, 4346,
   0, 1,-1,-1,   -6,-7314,
   4, 0,-1,-1,    6, 5796,
   0, 1, 0, 1,   -6,-4601,
   0, 0, 0, 3,   -6,-2965,
   0, 1,-1, 1,   -5,-6324,
   1, 0, 0, 1,   -5,-3684,
   0, 1, 1, 1,   -5,-3113,
   0, 1, 1,-1,   -5, -759,
   0, 1, 0,-1,   -4,-8396,
   1, 0, 0,-1,   -4,-8057,
   0, 0, 3, 1,    3, 9841,
   4, 0, 0,-1,    3, 6745,
   4, 0,-1, 1,    2, 9985,
   0, 0, 1,-3,    2, 7986,
   4, 0,-2, 1,    2, 4139,
   2, 0, 0,-3,    2, 1863,
   2, 0, 2,-1,    2, 1462,
   2,-1, 1,-1,    1, 7660,
   2, 0,-2, 1,   -1,-6244,
   0, 0, 3,-1,    1, 5813,
   2, 0, 2, 1,    1, 5198,
   2, 0,-3,-1,    1, 5156,
   2, 1,-1, 1,   -1,-3178,
   2, 1, 0, 1,   -1,-2643,
   4, 0, 0, 1,    1, 1919,
   2,-1, 1, 1,    1, 1346,
   2,-2, 0,-1,    1,  859,
   0, 0, 1, 3,   -1, -194,
   2, 1, 1,-1,    0,-8227,
   1, 1, 0,-1,    0, 8042,
   1, 1, 0, 1,    0, 8026,
   0, 1,-2,-1,    0,-7932,
   2, 1,-1,-1,    0,-7910,
   1, 0, 1, 1,    0,-6674,
   2,-1,-2,-1,    0, 6502,
   0, 1, 2, 1,    0,-6388,
   4, 0,-2,-1,    0, 6337,
   4,-1,-1,-1,    0, 5958,
   1, 0, 1,-1,    0,-5889,
   4, 0, 1,-1,    0, 4734,
   1, 0,-1,-1,    0,-4299,
   4,-1, 0,-1,    0, 4149,
   2,-2, 0, 1,    0, 3835,
   3, 0, 0,-1,    0,-3518,
   4,-1,-1, 1,    0, 3388,
   2, 0,-1,-3,    0, 3291,
   2,-2,-1, 1,    0, 3147,
   0, 1, 2,-1,    0,-3129,
   3, 0,-1,-1,    0,-3052,
   0, 1,-2, 1,    0,-3013,
   2, 0, 1,-3,    0,-2912,
   2,-2,-1,-1,    0, 2686,
   0, 0, 4, 1,    0, 2633,
   2, 0,-3, 1,    0, 2541,
   2, 0,-1, 3,    0,-2448,
   2, 1, 1, 1,    0,-2370,
   4,-1,-2, 1,    0, 2138,
   4, 0, 1, 1,    0, 2126,
   3, 0,-1, 1,    0,-2059,
   4, 1,-1,-1,    0,-1719,
  };

  static final int NLRT=38;
  static final short LRT[]={
  /*
  Multiply by T
                 Longitude    Radius
   D  l' l  F   .1"  .00001" .1km  .00001km */

   0, 1, 0, 0,    16, 7680,    -1,-2302,
   2,-1,-1, 0,    -5,-1642,     3, 8245,
   2,-1, 0, 0,    -4,-1383,     5, 1395,
   0, 1,-1, 0,     3, 7115,     3, 2654,
   0, 1, 1, 0,     2, 7560,    -2,-6396,
   2, 1,-1, 0,     0, 7118,     0,-6068,
   2, 1, 0, 0,     0, 6128,     0,-7754,
   1, 1, 0, 0,     0,-4516,     0, 4194,
   2,-2, 0, 0,     0,-4048,     0, 4970,
   0, 2, 0, 0,     0, 3747,     0, -540,
   2,-2,-1, 0,     0,-3707,     0, 2490,
   2,-1, 1, 0,     0,-3649,     0, 3222,
   0, 1,-2, 0,     0, 2438,     0, 1760,
   2,-1,-2, 0,     0,-2165,     0,-2530,
   0, 1, 2, 0,     0, 1923,     0,-1450,
   0, 2,-1, 0,     0, 1292,     0, 1070,
   2, 2,-1, 0,     0, 1271,     0,-6070,
   4,-1,-1, 0,     0,-1098,     0,  990,
   2, 0, 0, 0,     0, 1073,     0,-1360,
   2, 0,-1, 0,     0,  839,     0, -630,
   2, 1, 1, 0,     0,  734,     0, -660,
   4,-1,-2, 0,     0, -688,     0,  480,
   2, 1,-2, 0,     0, -630,     0,    0,
   0, 2, 1, 0,     0,  587,     0, -590,
   2,-1, 0,-2,     0, -540,     0, -170,
   4,-1, 0, 0,     0, -468,     0,  390,
   2,-2, 1, 0,     0, -378,     0,  330,
   2, 1, 0,-2,     0,  364,     0,    0,
   1, 1, 1, 0,     0, -317,     0,  240,
   2,-1, 2, 0,     0, -295,     0,  210,
   1, 1,-1, 0,     0, -270,     0, -210,
   2,-3, 0, 0,     0, -256,     0,  310,
   2,-3,-1, 0,     0, -187,     0,  110,
   0, 1,-3, 0,     0,  169,     0,  110,
   4, 1,-1, 0,     0,  158,     0, -150,
   4,-2,-1, 0,     0, -155,     0,  140,
   0, 0, 1, 0,     0,  155,     0, -250,
   2,-2,-2, 0,     0, -148,     0, -170,
  };

  static final int NBT=16;
  static final short BT[]={
  /*
  Multiply by T
               Latitude
   D  l' l  F  .00001"  */

   2,-1, 0,-1, -7430,
   2, 1, 0,-1,  3043,
   2,-1,-1, 1, -2229,
   2,-1, 0, 1, -1999,
   2,-1,-1,-1, -1869,
   0, 1,-1,-1,  1696,
   0, 1, 0, 1,  1623,
   0, 1,-1, 1,  1418,
   0, 1, 1, 1,  1339,
   0, 1, 1,-1,  1278,
   0, 1, 0,-1,  1217,
   2,-2, 0,-1,  -547,
   2,-1, 1,-1,  -443,
   2, 1,-1, 1,   331,
   2, 1, 0, 1,   317,
   2, 0, 0,-1,   295,
  };

  static final int NLRT2=25;
  static final short LRT2[]={
  /*
  Multiply by T^2
             Longitude    Radius
   D  l' l  F  .00001" .00001km   */

   0, 1, 0, 0,  487,   -36,
   2,-1,-1, 0, -150,   111,
   2,-1, 0, 0, -120,   149,
   0, 1,-1, 0,  108,    95,
   0, 1, 1, 0,   80,   -77,
   2, 1,-1, 0,   21,   -18,
   2, 1, 0, 0,   20,   -23,
   1, 1, 0, 0,  -13,    12,
   2,-2, 0, 0,  -12,    14,
   2,-1, 1, 0,  -11,     9,
   2,-2,-1, 0,  -11,     7,
   0, 2, 0, 0,   11,     0,
   2,-1,-2, 0,   -6,    -7,
   0, 1,-2, 0,    7,     5,
   0, 1, 2, 0,    6,    -4,
   2, 2,-1, 0,    5,    -3,
   0, 2,-1, 0,    5,     3,
   4,-1,-1, 0,   -3,     3,
   2, 0, 0, 0,    3,    -4,
   4,-1,-2, 0,   -2,     0,
   2, 1,-2, 0,   -2,     0,
   2,-1, 0,-2,   -2,     0,
   2, 1, 1, 0,    2,    -2,
   2, 0,-1, 0,    2,     0,
   0, 2, 1, 0,    2,     0,
  };

  static final int NBT2=12;
  static final short BT2[]={
  /*
  Multiply by T^2
             Latitiude
   D  l' l  F  .00001" */

   2,-1, 0,-1,  -22,
   2, 1, 0,-1,    9,
   2,-1, 0, 1,   -6,
   2,-1,-1, 1,   -6,
   2,-1,-1,-1,   -5,
   0, 1, 0, 1,    5,
   0, 1,-1,-1,    5,
   0, 1, 1, 1,    4,
   0, 1, 1,-1,    4,
   0, 1, 0,-1,    4,
   0, 1,-1, 1,    4,
   2,-2, 0,-1,   -2,
  };

  /* The following times are set up by update() and refer
   * to the same instant.  The distinction between them
   * is required by altaz().
   */
  double ss[][]=new double[5][8];
  double cc[][]=new double[5][8];

  double l;                /* Moon's ecliptic longitude */
  double B;                /* Ecliptic latitude */

  double moonpol[]=new double[3];

  /* Orbit calculation begins.
   */
  double SWELP;
  double M;
  double MP;
  double D;
  double NF;
  double T;
  double T2;

  static double T3;
  static double T4;
  static double f;
  static double g;
  static double Ve;
  static double Ea;
  static double Ma;
  static double Ju;
  static double Sa;
  static double cg;
  static double sg;
  static double l1;
  static double l2;
  static double l3;
  static double l4;

  /* Calculate geometric coordinates of Moon
   * without light time or nutation correction.
   */
  int swi_moshmoon2(double J, double[] pol) {
    int i;
    T = (J-SwephData.J2000)/36525.0;
    T2 = T*T;
    mean_elements();
    mean_elements_pl();
    moon1();
    moon2();
    moon3();
    moon4();
    for( i=0; i<3; i++ )
      pol[i] = moonpol[i];
    return(0);
  }

  /* Moshier's moom
   * tjd          julian day
   * xpm          array of 6 doubles for moon's position and speed vectors
   * serr         pointer to error string
   */
  int swi_moshmoon(double tjd, boolean do_save, double[] xpmret,
                   StringBuffer serr) {
    int i;
    double a, b, x1[]=new double[6], x2[]=new double[6], t;
    double xx[]=new double[6], xpm[];
    PlanData pdp = swed.pldat[SwephData.SEI_MOON];
    String s;
    if (do_save) {
      xpm = pdp.x;
    } else {
      xpm = xx;
    }
    /* allow 0.2 day tolerance so that true node interval fits in */
    if (tjd < SwephData.MOSHLUEPH_START - 0.2 || tjd > SwephData.MOSHLUEPH_END + 0.2) {
      if (serr != null) {
        s="jd "+tjd+" outside Moshier's Moon range "+
          SwephData.MOSHLUEPH_START+" .. "+
          SwephData.MOSHLUEPH_END+" ";
        if (serr.length() + s.length() < SwissData.AS_MAXCH) {
          serr.append(s);
        }
      }
      return(SweConst.ERR);
    }
    /* if moon has already been computed */
    if (tjd == pdp.teval && pdp.iephe == SweConst.SEFLG_MOSEPH) {
      if (xpmret != null) {
        for (i = 0; i <= 5; i++) {
          xpmret[i] = pdp.x[i];
        }
      }
      return(SweConst.OK);
    }
    /* else compute moon */
    swi_moshmoon2(tjd, xpm);
    if (do_save) {
      pdp.teval = tjd;
      pdp.xflgs = -1;
      pdp.iephe = SweConst.SEFLG_MOSEPH;
    }
    /* Moshier moon is referred to ecliptic of date. But we need
     * equatorial positions for several reasons.
     * e.g. computation of earth from emb and moon
     *                  of heliocentric moon
     * Besides, this helps to keep the program structure simpler
     */
    ecldat_equ2000(tjd, xpm);
    /* speed */
    /* from 2 other positions. */
    /* one would be good enough for computation of osculating node,
     * but not for osculating apogee */
    t = tjd + SwephData.MOON_SPEED_INTV;
    swi_moshmoon2(t, x1);
    ecldat_equ2000(t, x1);
    t = tjd - SwephData.MOON_SPEED_INTV;
    swi_moshmoon2(t, x2);
    ecldat_equ2000(t, x2);
    for (i = 0; i <= 2; i++) {
      b = (x1[i] - x2[i]) / 2;
      a = (x1[i] + x2[i]) / 2 - xpm[i];
      xpm[i+3] = (2 * a + b) / SwephData.MOON_SPEED_INTV;
    }
    if (xpmret != null) {
      for (i = 0; i <= 5; i++) {
        xpmret[i] = xpm[i];
      }
    }
    return(SweConst.OK);
  }


  private void moon1() {
    double a;

    sscc( 0, SwephData.STR*D, 6 );
    sscc( 1, SwephData.STR*M,  4 );
    sscc( 2, SwephData.STR*MP, 4 );
    sscc( 3, SwephData.STR*NF, 4 );
    moonpol[0] = 0.0;
    moonpol[1] = 0.0;
    moonpol[2] = 0.0;
    /* terms in T^2, scale 1.0 = 10^-5" */
    chewm( LRT2, NLRT2, 4, 2, moonpol );
    chewm( BT2, NBT2, 4, 4, moonpol );
    f = 18 * Ve - 16 * Ea;
    g = SwephData.STR*(f - MP );  /* 18V - 16E - l */
    cg = Math.cos(g);
    sg = Math.sin(g);
    l = 6.367278 * cg + 12.747036 * sg;  /* t^0 */
    l1 = 23123.70 * cg - 10570.02 * sg;  /* t^1 */
    l2 = z[12] * cg + z[13] * sg;        /* t^2 */
    moonpol[2] += 5.01 * cg + 2.72 * sg;
    g = SwephData.STR * (10.*Ve - 3.*Ea - MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.253102 * cg + 0.503359 * sg;
    l1 += 1258.46 * cg + 707.29 * sg;
    l2 += z[14] * cg + z[15] * sg;
    g = SwephData.STR*(8.*Ve - 13.*Ea);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.187231 * cg - 0.127481 * sg;
    l1 += -319.87 * cg - 18.34 * sg;
    l2 += z[16] * cg + z[17] * sg;
    a = 4.0*Ea - 8.0*Ma + 3.0*Ju;
    g = SwephData.STR * a;
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.866287 * cg + 0.248192 * sg;
    l1 += 41.87 * cg + 1053.97 * sg;
    l2 += z[18] * cg + z[19] * sg;
    g = SwephData.STR*(a - MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.165009 * cg + 0.044176 * sg;
    l1 += 4.67 * cg + 201.55 * sg;
    g = SwephData.STR*f;  /* 18V - 16E */
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.330401 * cg + 0.661362 * sg;
    l1 += 1202.67 * cg - 555.59 * sg;
    l2 += z[20] * cg + z[21] * sg;
    g = SwephData.STR*(f - 2.0*MP );  /* 18V - 16E - 2l */
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.352185 * cg + 0.705041 * sg;
    l1 += 1283.59 * cg - 586.43 * sg;
    g = SwephData.STR * (2.0*Ju - 5.0*Sa);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.034700 * cg + 0.160041 * sg;
    l2 += z[22] * cg + z[23] * sg;
    g = SwephData.STR * (SWELP - NF);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.000116 * cg + 7.063040 * sg;
    l1 +=  298.8 * sg;
    /* T^3 terms */
    sg = Math.sin( SwephData.STR * M );
    /* l3 +=  z[24] * sg;                   moshier! l3 not initialized! */
    l3 =  z[24] * sg;
    l4 = 0;
    g = SwephData.STR * (2.0*D - M);
    sg = Math.sin(g);
    cg = Math.cos(g);
    moonpol[2] +=  -0.2655 * cg * T;
    g = SwephData.STR * (M - MP);
    moonpol[2] +=  -0.1568 * Math.cos( g ) * T;
    g = SwephData.STR * (M + MP);
    moonpol[2] +=  0.1309 * Math.cos( g ) * T;
    g = SwephData.STR * (2.0*(D + M) - MP);
    sg = Math.sin(g);
    cg = Math.cos(g);
    moonpol[2] +=   0.5568 * cg * T;
    l2 += moonpol[0];
    g = SwephData.STR*(2.0*D - M - MP);
    moonpol[2] +=  -0.1910 * Math.cos( g ) * T;
    moonpol[1] *= T;
    moonpol[2] *= T;
    /* terms in T */
    moonpol[0] = 0.0;
    chewm( BT, NBT, 4, 4, moonpol );
    chewm( LRT, NLRT, 4, 1, moonpol );
    g = SwephData.STR*(f - MP - NF - 2355767.6); /* 18V - 16E - l - F */
    moonpol[1] +=  -1127. * Math.sin(g);
    g = SwephData.STR*(f - MP + NF - 235353.6); /* 18V - 16E - l + F */
    moonpol[1] +=  -1123. * Math.sin(g);
    g = SwephData.STR*(Ea + D + 51987.6);
    moonpol[1] +=  1303. * Math.sin(g);
    g = SwephData.STR*SWELP;
    moonpol[1] +=  342. * Math.sin(g);
    g = SwephData.STR*(2.*Ve - 3.*Ea);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l +=  -0.343550 * cg - 0.000276 * sg;
    l1 +=  105.90 * cg + 336.53 * sg;
    g = SwephData.STR*(f - 2.*D); /* 18V - 16E - 2D */
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.074668 * cg + 0.149501 * sg;
    l1 += 271.77 * cg - 124.20 * sg;
    g = SwephData.STR*(f - 2.*D - MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.073444 * cg + 0.147094 * sg;
    l1 += 265.24 * cg - 121.16 * sg;
    g = SwephData.STR*(f + 2.*D - MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.072844 * cg + 0.145829 * sg;
    l1 += 265.18 * cg - 121.29 * sg;
    g = SwephData.STR*(f + 2.*(D - MP));
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.070201 * cg + 0.140542 * sg;
    l1 += 255.36 * cg - 116.79 * sg;
    g = SwephData.STR*(Ea + D - NF);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.288209 * cg - 0.025901 * sg;
    l1 += -63.51 * cg - 240.14 * sg;
    g = SwephData.STR*(2.*Ea - 3.*Ju + 2.*D - MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.077865 * cg + 0.438460 * sg;
    l1 += 210.57 * cg + 124.84 * sg;
    g = SwephData.STR*(Ea - 2.*Ma);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.216579 * cg + 0.241702 * sg;
    l1 += 197.67 * cg + 125.23 * sg;
    g = SwephData.STR*(a + MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.165009 * cg + 0.044176 * sg;
    l1 += 4.67 * cg + 201.55 * sg;
    g = SwephData.STR*(a + 2.*D - MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.133533 * cg + 0.041116 * sg;
    l1 +=  6.95 * cg + 187.07 * sg;
    g = SwephData.STR*(a - 2.*D + MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.133430 * cg + 0.041079 * sg;
    l1 +=  6.28 * cg + 169.08 * sg;
    g = SwephData.STR*(3.*Ve - 4.*Ea);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.175074 * cg + 0.003035 * sg;
    l1 +=  49.17 * cg + 150.57 * sg;
    g = SwephData.STR*(2.*(Ea + D - MP) - 3.*Ju + 213534.);
    l1 +=  158.4 * Math.sin(g);
    l1 += moonpol[0];
    a = 0.1 * T; /* set amplitude scale of 1.0 = 10^-4 arcsec */
    moonpol[1] *= a;
    moonpol[2] *= a;
  }

  void moon2() {
    /* terms in T^0 */
    g = SwephData.STR*(2*(Ea-Ju+D)-MP+648431.172);
    l += 1.14307 * Math.sin(g);
    g = SwephData.STR*(Ve-Ea+648035.568);
    l += 0.82155 * Math.sin(g);
    g = SwephData.STR*(3*(Ve-Ea)+2*D-MP+647933.184);
    l += 0.64371 * Math.sin(g);
    g = SwephData.STR*(Ea-Ju+4424.04);
    l += 0.63880 * Math.sin(g);
    g = SwephData.STR*(SWELP + MP - NF + 4.68);
    l += 0.49331 * Math.sin(g);
    g = SwephData.STR*(SWELP - MP - NF + 4.68);
    l += 0.4914 * Math.sin(g);
    g = SwephData.STR*(SWELP+NF+2.52);
    l += 0.36061 * Math.sin(g);
    g = SwephData.STR*(2.*Ve - 2.*Ea + 736.2);
    l += 0.30154 * Math.sin(g);
    g = SwephData.STR*(2.*Ea - 3.*Ju + 2.*D - 2.*MP + 36138.2);
    l += 0.28282 * Math.sin(g);
    g = SwephData.STR*(2.*Ea - 2.*Ju + 2.*D - 2.*MP + 311.0);
    l += 0.24516 * Math.sin(g);
    g = SwephData.STR*(Ea - Ju - 2.*D + MP + 6275.88);
    l += 0.21117 * Math.sin(g);
    g = SwephData.STR*(2.*(Ea - Ma) - 846.36);
    l += 0.19444 * Math.sin(g);
    g = SwephData.STR*(2.*(Ea - Ju) + 1569.96);
    l -= 0.18457 * Math.sin(g);
    g = SwephData.STR*(2.*(Ea - Ju) - MP - 55.8);
    l += 0.18256 * Math.sin(g);
    g = SwephData.STR*(Ea - Ju - 2.*D + 6490.08);
    l += 0.16499 * Math.sin(g);
    g = SwephData.STR*(Ea - 2.*Ju - 212378.4);
    l += 0.16427 * Math.sin(g);
    g = SwephData.STR*(2.*(Ve - Ea - D) + MP + 1122.48);
    l += 0.16088 * Math.sin(g);
    g = SwephData.STR*(Ve - Ea - MP + 32.04);
    l -= 0.15350 * Math.sin(g);
    g = SwephData.STR*(Ea - Ju - MP + 4488.88);
    l += 0.14346 * Math.sin(g);
    g = SwephData.STR*(2.*(Ve - Ea + D) - MP - 8.64);
    l += 0.13594 * Math.sin(g);
    g = SwephData.STR*(2.*(Ve - Ea - D) + 1319.76);
    l += 0.13432 * Math.sin(g);
    g = SwephData.STR*(Ve - Ea - 2.*D + MP - 56.16);
    l -= 0.13122 * Math.sin(g);
    g = SwephData.STR*(Ve - Ea + MP + 54.36);
    l -= 0.12722 * Math.sin(g);
    g = SwephData.STR*(3.*(Ve - Ea) - MP + 433.8);
    l += 0.12539 * Math.sin(g);
    g = SwephData.STR*(Ea - Ju + MP + 4002.12);
    l += 0.10994 * Math.sin(g);
    g = SwephData.STR*(20.*Ve - 21.*Ea - 2.*D + MP - 317511.72);
    l += 0.10652 * Math.sin(g);
    g = SwephData.STR*(26.*Ve - 29.*Ea - MP + 270002.52);
    l += 0.10490 * Math.sin(g);
    g = SwephData.STR*(3.*Ve - 4.*Ea + D - MP - 322765.56);
    l += 0.10386 * Math.sin(g);
    g = SwephData.STR*(SWELP+648002.556);
    B =  8.04508 * Math.sin(g);
    g = SwephData.STR*(Ea+D+996048.252);
    B += 1.51021 * Math.sin(g);
    g = SwephData.STR*(f - MP + NF + 95554.332);
    B += 0.63037 * Math.sin(g);
    g = SwephData.STR*(f - MP - NF + 95553.792);
    B += 0.63014 * Math.sin(g);
    g = SwephData.STR*(SWELP - MP + 2.9);
    B +=  0.45587 * Math.sin(g);
    g = SwephData.STR*(SWELP + MP + 2.5);
    B +=  -0.41573 * Math.sin(g);
    g = SwephData.STR*(SWELP - 2.0*NF + 3.2);
    B +=  0.32623 * Math.sin(g);
    g = SwephData.STR*(SWELP - 2.0*D + 2.5);
    B +=  0.29855 * Math.sin(g);
  }

  void moon3() {
    /* terms in T^0 */
    moonpol[0] = 0.0;
    chewm( LR, NLR, 4, 1, moonpol );
    chewm( MB, NMB, 4, 3, moonpol );
    l += (((l4 * T + l3) * T + l2) * T + l1) * T * 1.0e-5;
    moonpol[0] = SWELP + l + 1.0e-4 * moonpol[0];
    moonpol[1] = 1.0e-4 * moonpol[1] + B;
    moonpol[2] = 1.0e-4 * moonpol[2] + 385000.52899; /* kilometers */
  }


  /* Compute final ecliptic polar coordinates
   */
  void moon4() {
    moonpol[2] /= SweConst.AUNIT / 1000;
    moonpol[0] = SwephData.STR * mods3600( moonpol[0] );
    moonpol[1] = SwephData.STR * moonpol[1];
    B = moonpol[1];
  }

  /* mean lunar node
   * J            julian day
   * pol          return array for position and velocity
   *              (polar coordinates of ecliptic of date)
   */
  int swi_mean_node(double J, double pol[], StringBuffer serr) {
    return swi_mean_node(J, pol, 0, serr);
  }
  int swi_mean_node(double J, double pol[], int offs, StringBuffer serr) {
    String s;
    T = (J-SwephData.J2000)/36525.0;
    T2 = T*T;
    T3 = T*T2;
    T4 = T2*T2;
    /* with elements from swi_moshmoon2(), which are fitted to jpl-ephemeris */
    if (J < SwephData.MOSHNDEPH_START || J > SwephData.MOSHNDEPH_END) {
      if (serr != null) {
        s="jd "+J+" outside mean node range "+
                SwephData.MOSHNDEPH_START+" .. "+
                SwephData.MOSHNDEPH_END+" ";
        serr.append(s);
      }
      return SweConst.ERR;
    }
    mean_elements();
    /* longitude */
    pol[offs] = sl.swi_mod2PI((SWELP - NF) * SwephData.STR);
    /* latitude */
    pol[offs+1] = 0.0;
    /* distance */
    pol[offs+2] = SwephData.MOON_MEAN_DIST / SweConst.AUNIT; /* or should it be derived from mean
                                      * orbital ellipse? */
    return SweConst.OK;
  }

  /* mean lunar apogee ('dark moon', 'lilith')
   * J            julian day
   * pol          return array for position
   *              (polar coordinates of ecliptic of date)
   * serr         error return string
   */
  int swi_mean_apog(double J, double pol[], StringBuffer serr) {
    return swi_mean_apog(J, pol, 0, serr);
  }
  int swi_mean_apog(double J, double pol[], int offs, StringBuffer serr) {
    double node;
    String s;
    T = (J-SwephData.J2000)/36525.0;
    T2 = T*T;
    T3 = T*T2;
    T4 = T2*T2;
    /* with elements from swi_moshmoon2(), which are fitted to jpl-ephemeris */
    if (J < SwephData.MOSHNDEPH_START || J > SwephData.MOSHNDEPH_END) {
      if (serr != null) {
        s="jd "+J+" outside mean apogee range "+
                SwephData.MOSHNDEPH_START+" .. "+
                SwephData.MOSHNDEPH_END+" ";
        if (serr.length()+s.length() < SwissData.AS_MAXCH) {
          serr.append(s);
        }
      }
      return SweConst.ERR;
    }
    mean_elements();
    pol[offs] = sl.swi_mod2PI((SWELP - MP) * SwephData.STR + SwephData.PI);
    pol[offs+1] = 0;
    pol[offs+2] = SwephData.MOON_MEAN_DIST * (1 + SwephData.MOON_MEAN_ECC) /
                                                 SweConst.AUNIT; /* apogee */
    /* Lilith or Dark Moon is either the empty focal point of the mean
     * lunar ellipse or, for some people, its apogee ("aphelion").
     * This is 180 degrees from the perigee.
     *
     * Since the lunar orbit is not in the ecliptic, the apogee must be
     * projected onto the ecliptic.
     * Joelle de Gravelaine has in her book "Lilith der schwarze Mond"
     * (Astrodata, 1990) an ephemeris which gives noon (12.00) positions
     * but does not project them onto the ecliptic.
     * This results in a mistake of several arc minutes.
     *
     * There is also another problem. The other focal point doesn't
     * coincide with the geocenter but with the barycenter of the
     * earth-moon-system. The difference is about 4700 km. If one
     * took this into account, it would result in an oscillation
     * of the Black Moon. If defined as the apogee, this oscillation
     * would be about +/- 40 arcmin.
     * If defined as the second focus, the effect is very large:
     * +/- 6 deg!
     * We neglect this influence.
     */
    /* apogee is now projected onto ecliptic */
    node = (SWELP - NF) * SwephData.STR;
    pol[offs] = sl.swi_mod2PI(pol[offs] - node);
    sl.swi_polcart(pol, offs, pol, offs);
    sl.swi_coortrf(pol, offs, pol, offs, -SwephData.MOON_MEAN_INCL * SwissData.DEGTORAD);
    sl.swi_cartpol(pol, offs, pol, offs);
    pol[offs] = sl.swi_mod2PI(pol[offs] + node);
    return SweConst.OK;
  }

  /* Program to step through the perturbation table
   */
  void chewm(short[] pt, int nlines, int nangles, int typflg, double[] ans ) {
    int npt=0;
    int i, j, k, k1, m;
    double cu, su, cv, sv, ff;
    for( i=0; i<nlines; i++ ) {
      k1 = 0;
      sv = 0.0;
      cv = 0.0;
      for( m=0; m<nangles; m++ ) {
        j = pt[npt++]; /* multiple angle factor */
        if( j!=0 ) {
          k = j;
          if( j < 0 ) {
            k = -k; /* make angle factor > 0 */
          }
          /* sin, cos (k*angle) from lookup table */
          su = ss[m][k-1];
          cu = cc[m][k-1];
          if( j < 0 ) {
            su = -su; /* negative angle factor */
          }
          if( k1 == 0 ) {
            /* Set sin, cos of first angle. */
            sv = su;
            cv = cu;
            k1 = 1;
          }
          else {
            /* Combine angles by trigonometry. */
            ff =  su*cv + cu*sv;
            cv = cu*cv - su*sv;
            sv = ff;
          }
        }
      }
      /* Accumulate
       */
      switch( typflg ) {
      /* large longitude and radius */
      case 1:
        j = pt[npt++];
        k = pt[npt++];
        ans[0] += (10000.0 * j  + k) * sv;
        j = pt[npt++];
        k = pt[npt++];
        if( k!=0 ) {
          ans[2] += (10000.0 * j  + k) * cv;
        }
        break;
      /* longitude and radius */
      case 2:
        j = pt[npt++];
        k = pt[npt++];
        ans[0] += j * sv;
        ans[2] += k * cv;
        break;
      /* large latitude */
      case 3:
        j = pt[npt++];
        k = pt[npt++];
        ans[1] += ( 10000.0*j + k)*sv;
        break;
      /* latitude */
      case 4:
        j = pt[npt++];
        ans[1] += j * sv;
        break;
      }
    }
  }

  /* Prepare lookup table of sin and cos ( i*Lj )
   * for required multiple angles
   */
  void sscc(int k, double arg, int n ) {
    double cu, su, cv, sv, s;
    int i;
    su = Math.sin(arg);
    cu = Math.cos(arg);
    ss[k][0] = su;                        /* sin(L) */
    cc[k][0] = cu;                        /* cos(L) */
    sv = 2.0*su*cu;
    cv = cu*cu - su*su;
    ss[k][1] = sv;                        /* sin(2L) */
    cc[k][1] = cv;
    for( i=2; i<n; i++ ) {
      s =  su*cv + cu*sv;
      cv = cu*cv - su*sv;
      sv = s;
      ss[k][i] = sv;              /* sin( i+1 L ) */
      cc[k][i] = cv;
    }
  }

  /* converts from polar coordinates of ecliptic of date
   *          to   cartesian coordinates of equator 2000
   * tjd          date
   * x            array of position
   */
  void ecldat_equ2000(double tjd, double[] xpm) {
    /* cartesian */
    sl.swi_polcart(xpm, xpm);
    /* equatorial */
    sl.swi_coortrf2(xpm, xpm, -swed.oec.seps, swed.oec.ceps);
    /* j2000 */
    sl.swi_precess(xpm, tjd, SwephData.J_TO_J2000);
  }

  /* Reduce arc seconds modulo 360 degrees
   * answer in arc seconds
   */
  double mods3600(double x) {
    double lx;
    lx = x;
    lx = lx - 1296000.0 * Math.floor( lx/1296000.0 );
    return( lx );
  }


  void swi_mean_lunar_elements(double tjd,
                               DblObj node, DblObj dnode,
                               DblObj peri, DblObj dperi) {
    T = (tjd - SwephData.J2000) / 36525.0;
    T2 = T*T;
    mean_elements();
    node.val = sl.swe_degnorm((SWELP - NF) * SwephData.STR * SwissData.RADTODEG);
    peri.val = sl.swe_degnorm((SWELP - MP) * SwephData.STR * SwissData.RADTODEG);
    T -= 1.0 / 36525;
    mean_elements();
    dnode.val = sl.swe_degnorm(node.val - (SWELP-NF) * SwephData.STR * SwissData.RADTODEG);
    dnode.val -= 360;
    dperi.val = sl.swe_degnorm(peri.val - (SWELP-MP) * SwephData.STR * SwissData.RADTODEG);
  }

  void mean_elements() {
    double fracT = T%1.;
    /* Mean anomaly of sun = l' (J. Laskar) */
    M =  mods3600(129600000.0 * fracT - 3418.961646 * T +  1287104.76154);
    M += ((((((((
      1.62e-20 * T
    - 1.0390e-17 ) * T
    - 3.83508e-15 ) * T
    + 4.237343e-13 ) * T
    + 8.8555011e-11 ) * T
    - 4.77258489e-8 ) * T
    - 1.1297037031e-5 ) * T
    + 1.4732069041e-4 ) * T
    - 0.552891801772 ) * T2;
    /* Mean distance of moon from its ascending node = F */
    /*NF = mods3600((1739527263.0983 - 2.079419901760e-01) * T +335779.55755);*/
    NF = mods3600(1739232000.0 * fracT + 295263.0983 * T -
                  2.079419901760e-01 * T + 335779.55755);
    /* Mean anomaly of moon = l */
    MP = mods3600(1717200000.0 * fracT + 715923.4728 * T -
                  2.035946368532e-01 * T + 485868.28096);
    /* Mean elongation of moon = D */
    D = mods3600(1601856000.0 * fracT + 1105601.4603 * T +
                 3.962893294503e-01 * T + 1072260.73512);
    /* Mean longitude of moon, referred to the mean ecliptic and equinox of date */
    SWELP = mods3600(1731456000.0 * fracT + 1108372.83264 * T - 6.784914260953e-01 * T +  785939.95571);
    /* Higher degree secular terms found by least squares fit */
    NF += ((z[2]*T + z[1])*T + z[0])*T2;
    MP += ((z[5]*T + z[4])*T + z[3])*T2;
    D  += ((z[8]*T + z[7])*T + z[6])*T2;
    SWELP += ((z[11]*T + z[10])*T + z[9])*T2;
    /* sensitivity of mean elements
     *    delta argument = scale factor times delta amplitude (arcsec)
     * cos l  9.0019 = mean eccentricity
     * cos 2D 43.6
     * cos F  11.2 (latitude term)
     */
  }
  
  void mean_elements_pl() {
    /* Mean longitudes of planets (Laskar, Bretagnon) */
    Ve = mods3600( 210664136.4335482 * T + 655127.283046 );
    Ve += ((((((((
      -9.36e-023 * T
     - 1.95e-20 ) * T
     + 6.097e-18 ) * T
     + 4.43201e-15 ) * T
     + 2.509418e-13 ) * T
     - 3.0622898e-10 ) * T
     - 2.26602516e-9 ) * T
     - 1.4244812531e-5 ) * T
     + 0.005871373088 ) * T2;
    Ea = mods3600( 129597742.26669231  * T +  361679.214649 );
    Ea += (((((((( -1.16e-22 * T
     + 2.976e-19 ) * T
     + 2.8460e-17 ) * T
     - 1.08402e-14 ) * T
     - 1.226182e-12 ) * T
     + 1.7228268e-10 ) * T
     + 1.515912254e-7 ) * T
     + 8.863982531e-6 ) * T
     - 2.0199859001e-2 ) * T2;
    Ma = mods3600(  68905077.59284 * T + 1279559.78866 );
    Ma += (-1.043e-5*T + 9.38012e-3)*T2;
    Ju = mods3600( 10925660.428608 * T +  123665.342120 );
    Ju += (1.543273e-5*T - 3.06037836351e-1)*T2;
    Sa = mods3600( 4399609.65932 * T + 180278.89694 );
    Sa += (( 4.475946e-8*T - 6.874806E-5 ) * T + 7.56161437443E-1)*T2;
  }
  
  /* Calculate geometric coordinates of true interpolated Moon apsides
   */
  int swi_intp_apsides(double J, double[] pol, int ipli) {
    double dd;
    double rsv[] = new double[3];
    double sNF, sD, sLP, sMP, sM, sVe, sEa, sMa, sJu, sSa, fM, fVe, fEa, fMa, fJu, fSa, cMP, zMP, fNF, fD, fLP;
    double dMP, mLP, mNF, mD, mMP;
    int i, ii, iii, niter = 4;    /* niter: silence compiler warning */
    ii=1;
    zMP=27.55454988;
    fNF = 27.212220817/zMP;
    fD  = 29.530588835/zMP;
    fLP = 27.321582/zMP;
    fM  = 365.2596359/zMP;
    fVe = 224.7008001/zMP;
    fEa = 365.2563629/zMP;
    fMa = 686.9798519/zMP;
    fJu = 4332.589348/zMP;
    fSa = 10759.22722/zMP;
    T = (J-SwephData.J2000)/36525.0;
    T2 = T*T;
    T4 = T2*T2;
    mean_elements();
    mean_elements_pl();
    sNF = NF;
    sD  = D;
    sLP = SWELP;
    sMP = MP;
    sM  = M ;
    sVe = Ve;
    sEa = Ea;
    sMa = Ma;
    sJu = Ju;
    sSa = Sa;
    sNF = mods3600(NF);
    sD  = mods3600(D);
    sLP = mods3600(SWELP);
    sMP = mods3600(MP);
    if (ipli == SwephData.SEI_INTP_PERG) {MP = 0.0; niter = 5;}
    if (ipli == SwephData.SEI_INTP_APOG) {MP = 648000.0; niter = 4;}
    cMP = 0;
    dd = 18000.0;
    for (iii= 0; iii<=niter; iii++) {
      dMP = sMP - MP;
      mLP = sLP - dMP;
      mNF = sNF - dMP;
      mD  = sD  - dMP;
      mMP = sMP - dMP;
      for (ii = 0; ii <=2; ii++) {
        MP = mMP + (ii-1)*dd;       
        NF = mNF + (ii-1)*dd/fNF;
        D  = mD  + (ii-1)*dd/fD;
        SWELP = mLP + (ii-1)*dd/fLP;
        M  = sM  + (ii-1)*dd/fM ;
        Ve = sVe + (ii-1)*dd/fVe;
        Ea = sEa + (ii-1)*dd/fEa;
        Ma = sMa + (ii-1)*dd/fMa;
        Ju = sJu + (ii-1)*dd/fJu;
        Sa = sSa + (ii-1)*dd/fSa;
        moon1();
        moon2();
        moon3();
        moon4();
        if (ii==1) {
          for( i=0; i<3; i++ ) pol[i] = moonpol[i];
        }
        rsv[ii] = moonpol[2];
      }
      cMP = (1.5*rsv[0] - 2*rsv[1] + 0.5*rsv[2]) / (rsv[0] + rsv[2] - 2*rsv[1]);
      cMP *= dd;
      cMP = cMP - dd;
      mMP += cMP;
      MP = mMP;
      dd /= 10;
    }
    return(0);
  }

} // End of class Swemmoon

class SwemptabEar {
  /*
  First date in file = 1228000.50
  Number of records = 264850.0
  Days per record = 6.0
        Julian Years      Lon    Lat    Rad
   -1349.9 to  -1000.0:   0.13   0.06   0.07
   -1000.0 to   -500.0:   0.12   0.06   0.06
    -500.0 to      0.0:   0.12   0.06   0.08
       0.0 to    500.0:   0.12   0.05   0.06
     500.0 to   1000.0:   0.12   0.05   0.07
    1000.0 to   1500.0:   0.11   0.05   0.07
    1500.0 to   2000.0:   0.11   0.05   0.06
    2000.0 to   2500.0:   0.11   0.05   0.06
    2500.0 to   3000.0:   0.14   0.06   0.07
    3000.0 to   3000.8:  0.074  0.048  0.044
  */

  static final double eartabl[] = {
         -65.54655,        -232.74963, 12959774227.57587,      361678.59587,

           2.52679,          -4.93511,           2.46852,          -8.88928,
           6.66257,          -1.94502,

           0.66887,          -0.06141,           0.08893,           0.18971,

           0.00068,          -0.00307,

           0.03092,           0.03214,          -0.14321,           0.22548,

           0.00314,          -0.00221,

           8.98017,           7.25747,          -1.06655,           1.19671,
          -2.42276,           0.29621,           1.55635,           0.99167,

          -0.00026,           0.00187,

           0.00189,           0.02742,

           0.00158,           0.01475,

           0.00353,          -0.02048,

          -0.01775,          -0.01023,           0.01927,          -0.03122,

          -1.55440,          -4.97423,           2.14765,          -2.77045,
           1.02707,           0.55507,          -0.08066,           0.18479,

           0.00750,           0.00583,

          -0.16977,           0.35555,           0.32036,           0.01309,

           0.54625,           0.08167,           0.10681,           0.17231,
          -0.02287,           0.01631,

          -0.00866,          -0.00190,

           0.00016,          -0.01514,

          -0.00073,           0.04205,

          -0.00072,           0.01490,

          -0.38831,           0.41043,          -1.11857,          -0.84329,
           1.15123,          -1.34167,

           0.01026,          -0.00432,

          -0.02833,          -0.00705,          -0.00285,           0.01645,

          -0.01234,           0.05609,          -0.01893,          -0.00171,

          -0.30527,           0.45390,           0.56713,           0.70030,
           1.27125,          -0.76481,           0.34857,          -2.60318,

          -0.00160,           0.00643,

           0.28492,          -0.37998,           0.23347,           0.00540,
           0.00342,           0.04406,

           0.00037,          -0.02449,

           0.01469,           1.59358,           0.24956,           0.71066,
           0.25477,          -0.98371,

          -0.69412,           0.19687,          -0.44423,          -0.83331,
           0.49647,          -0.31021,

           0.05696,          -0.00802,          -0.14423,          -0.04719,

           0.16762,          -0.01234,           0.02481,           0.03465,

           0.01091,           0.02123,

           0.08212,          -0.07375,           0.01524,          -0.07388,

           0.06673,          -0.22486,           0.10026,          -0.00559,

           0.14711,          -0.11680,           0.05460,           0.02749,

          -1.04467,           0.34273,          -0.67582,          -2.15117,
           2.47372,          -0.04332,

           0.05016,          -0.03991,           0.01908,           0.00943,

           0.07321,          -0.23637,           0.10564,          -0.00446,

          -0.09523,          -0.30710,           0.17400,          -0.10681,

           0.05104,          -0.14078,           0.01390,           0.07288,

          -0.26308,          -0.20717,           0.20773,          -0.37096,

          -0.00205,          -0.27274,

          -0.00792,          -0.00183,

           0.02985,           0.04895,           0.03785,          -0.14731,

           0.02976,          -0.02495,          -0.02644,          -0.04085,

          -0.00843,           0.00027,

           0.00090,           0.00611,

           0.00040,           4.83425,

           0.01692,          -0.01335,

           0.04482,          -0.03602,           0.01672,           0.00838,

           0.03682,          -0.11206,           0.05163,          -0.00219,

          -0.08381,          -0.20911,           0.16400,          -0.13325,

          -0.05945,           0.02114,          -0.00710,          -0.04695,

          -0.01657,          -0.00513,

          -0.06999,          -0.23054,           0.13128,          -0.07975,

           0.00054,          -0.00699,

          -0.01253,          -0.04007,           0.00658,          -0.00607,

          -0.48696,           0.31859,          -0.84292,          -0.87950,
           1.30507,          -0.94042,

          -0.00234,           0.00339,

          -0.30647,          -0.24605,           0.24948,          -0.43369,

          -0.64033,           0.20754,          -0.43829,          -1.31801,
           1.55412,          -0.02893,

          -0.02323,           0.02181,          -0.00398,          -0.01548,

          -0.08005,          -0.01537,          -0.00362,          -0.02033,

           0.00028,          -0.03732,          -0.14083,          -7.21175,

          -0.07430,           0.01886,          -0.00223,           0.01915,

          -0.02270,          -0.03702,           0.10167,          -0.02917,

           0.00879,          -2.04198,

          -0.00433,          -0.41764,

           0.00671,          -0.00030,

           0.00070,          -0.01066,

           0.01144,          -0.03190,

          -0.29653,           0.38638,          -0.16611,          -0.07661,

           0.22071,           0.14665,           0.02487,           0.13524,

        -275.60942,        -335.52251,        -413.89009,         359.65390,
        1396.49813,        1118.56095,        2559.41622,       -3393.39088,
       -6717.66079,       -1543.17403,

          -1.90405,          -0.22958,          -0.57989,          -0.36584,
          -0.04547,          -0.14164,

           0.00749,          -0.03973,

           0.00033,           0.01842,

          -0.08301,          -0.03523,          -0.00408,          -0.02008,

           0.00008,           0.00778,

          -0.00046,           0.02760,

          -0.03135,           0.07710,           0.06130,           0.04003,

          -0.04703,           0.00671,          -0.00754,          -0.01000,

          -0.01902,          -0.00125,

          -0.00264,          -0.00903,

          -0.02672,           0.12765,

          -0.03872,           0.03532,          -0.01534,          -0.00710,

          -0.01087,           0.01124,

          -0.01664,           0.06304,          -0.02779,           0.00214,

          -0.01279,          -5.51814,

           0.05847,          -0.02093,           0.03950,           0.06696,
          -0.04064,           0.02687,

           0.01478,          -0.02169,           0.05821,           0.03301,
          -0.03861,           0.07535,

           0.00290,          -0.00644,

           0.00631,           0.12905,

           0.02400,           0.13194,          -0.14339,           0.00529,

           0.00343,           0.00819,

           0.02692,          -0.03332,          -0.07284,          -0.02064,

           0.07038,           0.03999,           0.02759,           0.07599,

           0.00033,           0.00641,

           0.00128,           0.02032,          -0.00852,           0.00680,

           0.23019,           0.17100,           0.09861,           0.55013,

          -0.00192,           0.00953,

          -0.00943,           0.01783,

           0.05975,           0.01486,           0.00160,           0.01558,

          -0.01629,          -0.02035,           0.01533,           2.73176,

           0.05858,          -0.01327,           0.00209,          -0.01506,

           0.00755,           0.03300,

          -0.00796,          -0.65270,

           0.02305,           0.00165,

          -0.02512,           0.06560,           0.16108,          -0.02087,

           0.00016,           0.10729,

           0.04175,           0.00559,

           0.01176,           0.00110,

          15.15730,          -0.52460,         -37.16535,         -25.85564,
         -60.94577,           4.29961,          57.11617,          67.96463,
          31.41414,         -64.75731,

           0.00848,           0.02971,          -0.03690,          -0.00010,

          -0.03568,           0.06325,           0.11311,           0.02431,

          -0.00383,           0.00421,

          -0.00140,           0.00680,

           0.00069,          -0.21036,

           0.00386,           0.04210,

          -0.01324,           0.16454,

          -0.01398,          -0.00109,

           0.02548,          -0.03842,          -0.06504,          -0.02204,

           0.01359,           0.00232,

           0.07634,          -1.64648,          -1.73103,           0.89176,
           0.81398,           0.65209,

           0.00021,          -0.08441,

          -0.00012,           0.01262,

          -0.00666,          -0.00050,

          -0.00130,           0.01596,

          -0.00485,          -0.00213,

           0.00009,          -0.03941,

          -0.02266,          -0.04421,          -0.01341,           0.01083,

          -0.00011,           0.00004,           0.00003,          -0.02017,

           0.00003,          -0.01096,

           0.00002,          -0.00623,

  };
  static final double eartabb[] = {
         -41.97860,         -48.43539,          74.72897,           0.00075,

          -0.12774,          -0.10188,          -0.00943,          -0.04574,
           0.00265,          -0.00217,

           0.00254,           0.00168,           0.00008,           0.00026,

          -0.00000,          -0.00000,

           0.00004,          -0.00003,           0.00001,          -0.00003,

          -0.00002,          -0.00006,

           0.03351,          -0.02699,           0.00896,          -0.01315,
          -0.00019,          -0.00054,          -0.00020,          -0.00003,

           0.00002,           0.00001,

          -0.00000,           0.00000,

          -0.00002,          -0.00001,

          -0.00001,           0.00003,

           0.00017,          -0.00008,           0.00000,          -0.00003,

           0.00501,          -0.00083,           0.00414,           0.00202,
           0.00051,           0.00060,           0.00002,           0.00000,

          -0.00002,           0.00002,

          -0.00016,          -0.00443,          -0.00083,          -0.00031,

          -0.00394,           0.00148,          -0.00035,           0.00099,
           0.00005,           0.00009,

           0.00004,          -0.00002,

          -0.00001,          -0.00002,

           0.00012,          -0.00005,

           0.00001,           0.00001,

          -0.00577,          -0.00631,          -0.00017,           0.01993,
          -0.00234,          -0.00218,

          -0.00001,           0.00002,

          -0.00101,          -0.00044,          -0.00036,           0.00041,

           0.00294,          -0.00109,           0.00043,          -0.00006,

           0.09650,           0.15003,           0.01087,           0.04905,
           0.00093,          -0.06986,          -0.01471,          -0.00221,

          -0.00002,          -0.00003,

           0.00440,          -0.00083,           0.00102,          -0.00024,
           0.00005,          -0.00002,

          -0.00004,           0.00001,

           0.00505,           0.00930,          -0.01609,          -0.00183,
          -0.00113,           0.00214,

           0.00439,          -0.00295,          -0.00280,           0.00402,
          -0.00047,          -0.00145,

          -0.00114,          -0.00178,           0.00097,           0.00022,

           0.00019,           0.00002,           0.00009,          -0.00005,

          -0.00002,           0.00006,

          -0.01618,          -0.01033,          -0.00372,           0.00301,

          -0.00199,           0.00003,           0.00012,          -0.00068,

          -0.00027,          -0.00011,           0.00009,          -0.00020,

          -0.00618,           0.00129,           0.00452,           0.00620,
          -0.06411,          -0.01524,

          -0.00207,          -0.00140,           0.00005,          -0.00036,

          -0.00009,           0.00005,           0.00012,          -0.00053,

           0.00050,          -0.00068,          -0.00059,          -0.00132,

           0.00719,          -0.13368,          -0.08789,          -0.02072,

           0.00031,          -0.00360,          -0.00241,          -0.00182,

           0.00284,           0.00196,

           0.00083,           0.00008,

           0.00203,          -0.00097,          -0.00120,           0.00748,

           0.00326,          -0.00145,          -0.00276,           0.00236,

          -0.00048,          -0.00258,

           0.00011,           0.00001,

          -0.00284,           0.00795,

          -0.00156,           0.00106,

          -0.00040,          -0.00069,           0.00026,          -0.00039,

          -0.00102,          -0.00098,           0.00017,          -0.00125,

          -0.00180,          -0.01103,          -0.01854,           0.00742,

          -0.02751,          -0.00773,          -0.00263,           0.01059,

           0.00152,           0.00047,

          -0.00106,          -0.00034,          -0.00126,          -0.00291,

          -0.00014,           0.00006,

           0.00069,           0.00316,          -0.00087,           0.00022,

           0.05381,           0.03791,           0.05011,          -0.15168,
          -0.16315,           0.03037,

           0.00068,          -0.00067,

          -0.00457,          -0.00146,          -0.00643,          -0.00451,

           0.07806,           0.00729,           0.03356,          -0.16465,
          -0.20388,          -0.04854,

          -0.00163,          -0.00178,           0.00185,           0.00405,

          -0.00009,           0.00068,          -0.00003,           0.00005,

          -0.01186,           0.00347,          -0.01776,           0.00258,

           0.00081,          -0.00014,           0.00003,          -0.00021,

          -0.01218,          -0.03048,          -0.03109,           0.01387,

          -0.00740,          -0.00113,

          -0.00155,           0.00679,

          -0.00053,          -0.00007,

          -0.00004,          -0.00002,

           0.00248,           0.00127,

          -0.00386,           0.00394,           0.01213,           0.00748,

          -0.04669,          -0.00319,           0.00315,           0.00010,

          85.02966,         -55.85765,         215.62111,         519.00334,
       -1941.10461,         508.68393,        -419.80123,       -4679.60117,
          -0.00916,           0.00204,

          -0.13900,          -0.08473,          -0.07614,          -0.03445,
           0.00359,          -0.00136,

          -0.00111,           0.01028,

           0.00021,          -0.00002,

           0.00039,           0.00246,          -0.00084,          -0.00007,

          -0.00191,           0.00491,

           0.00474,          -0.00676,

          -0.00549,           0.02234,           0.02087,           0.00575,

          -0.00011,           0.00079,          -0.00060,           0.00029,

          -0.00239,          -0.00257,

           0.00020,           0.00163,

           0.00301,          -0.01723,

           0.00049,           0.00086,          -0.00046,           0.00057,

          -0.00049,           0.00024,

           0.00103,          -0.00072,          -0.00005,           0.00095,

           0.00598,          -0.01127,

          -0.00538,           0.00317,          -0.00178,          -0.00010,
           0.00061,           0.00132,

          -0.00001,           0.00318,          -0.00206,           0.00113,
           0.00153,           0.00097,

           0.00161,          -0.00363,

           0.00142,          -0.00047,

          -0.00281,           0.03085,           0.02895,           0.00688,

           0.00025,          -0.00016,

          -0.00197,          -0.08112,           0.02859,          -0.00683,

           0.00004,           0.00016,           0.00158,          -0.00065,

           0.00004,          -0.00001,

           0.00002,          -0.00008,           0.00019,           0.00039,

          -0.00344,           0.00364,           0.00579,          -0.00144,

           0.00031,          -0.00190,

           0.00066,           0.00025,

           0.00011,          -0.00069,           0.00001,          -0.00011,

          -0.01202,           0.00842,           0.00067,          -0.00297,

          -0.00000,           0.00008,           0.00005,           0.00000,

           0.00086,          -0.00057,

           0.00354,          -0.00548,

           0.00009,          -0.00003,

           0.00179,           0.07922,           0.00490,           0.00065,

          -0.00005,          -0.00059,

           0.00061,          -0.00319,

           0.00007,          -0.00048,

           3.49661,          -1.52414,          -6.26431,          -1.76193,
         -26.45666,           7.62583,          77.77395,          10.67040,
           0.00032,           0.00090,

          -0.00026,           0.00680,           0.00827,           0.00199,

          -0.00271,           0.04278,           0.02257,          -0.00532,

           0.00006,           0.00011,

           0.00006,           0.00010,

          -0.00017,          -0.00081,

           0.00050,           0.00001,

           0.00012,           0.00082,

           0.00326,           0.00040,

          -0.00003,          -0.03209,           0.00042,           0.00008,

           0.01059,          -0.00218,

          -0.87557,          -1.06369,          -0.52928,           1.38498,
           0.00082,          -0.00040,

           0.00009,          -0.00047,

           0.00007,           0.00007,

           0.00155,           0.00019,

           0.00002,           0.00008,

           0.00001,           0.00023,

           0.00010,          -0.00029,

          -0.03336,          -0.00987,           0.00012,          -0.00006,

          -0.00198,           0.00333,          -0.00004,           0.00026,

           0.00042,           0.00006,

           0.00025,           0.00021,

  };
  static final double eartabr[] = {
           0.64577,          -2.90183,         -14.50280,          28.85196,

           0.08672,          -0.05643,           0.02353,          -0.00404,
           0.00019,          -0.00137,

           0.00128,          -0.00310,           0.00143,           0.00050,

           0.00000,           0.00000,

          -0.00023,          -0.00003,          -0.00057,          -0.00032,

          -0.00002,           0.00009,

          -0.09716,           0.04111,          -0.03108,           0.00633,
          -0.00220,          -0.00595,          -0.00279,           0.00491,

          -0.00004,          -0.00003,

          -0.00010,          -0.00004,

          -0.00013,          -0.00010,

           0.00017,          -0.00010,

          -0.00075,           0.00002,          -0.00054,          -0.00025,

           0.12572,           0.00948,           0.05937,           0.04900,
          -0.00785,           0.01815,          -0.00303,          -0.00120,

          -0.00010,           0.00010,

          -0.00317,          -0.00143,           0.00068,           0.00213,

          -0.00043,          -0.00420,           0.00406,          -0.00041,
           0.00048,           0.00062,

          -0.00005,           0.00029,

           0.00043,          -0.00002,

          -0.00126,          -0.00009,

          -0.00040,           0.00000,

           0.03557,           0.02143,          -0.02196,           0.04671,
          -0.05571,          -0.03425,

           0.00016,           0.00031,

           0.00020,          -0.00153,          -0.00142,          -0.00051,

          -0.00214,           0.00001,           0.00002,          -0.00061,

          -0.06824,           0.00030,          -0.05717,           0.04196,
           0.05887,           0.07531,           0.12313,          -0.04113,

           0.00025,           0.00021,

           0.02218,           0.01747,           0.00011,           0.01367,
          -0.00247,           0.00029,

           0.00120,          -0.00003,

           0.13373,          -0.02072,           0.06706,          -0.01009,
          -0.09515,          -0.01901,

           0.01767,           0.06939,          -0.06702,           0.04159,
          -0.02809,          -0.03968,

           0.00257,           0.00553,           0.00411,          -0.01309,

           0.00139,           0.01591,          -0.00322,           0.00245,

          -0.00202,           0.00093,

           0.01845,          -0.00018,          -0.00247,          -0.00771,

          -0.02834,          -0.00691,          -0.00154,          -0.01244,

           0.01512,           0.01884,          -0.00359,           0.00731,

          -0.05395,          -0.18108,           0.36303,          -0.12751,
           0.01877,           0.43653,

          -0.00725,          -0.00692,           0.00115,          -0.00327,

           0.04030,           0.01171,           0.00107,           0.01793,

           0.06335,          -0.02171,           0.02229,           0.03533,

          -0.06038,          -0.00356,           0.01325,          -0.03798,

           0.04963,          -0.06258,           0.08931,           0.04904,

           0.07115,          -0.00073,

          -0.00104,           0.00354,

          -0.01549,           0.00647,           0.04418,           0.01061,

           0.00568,           0.00957,           0.01102,          -0.00819,

          -0.00089,           0.00368,

          -0.00214,           0.00031,

          -1.11935,          -0.00029,

           0.00457,           0.00550,

           0.01409,           0.01664,          -0.00306,           0.00629,

           0.04531,           0.01460,           0.00092,           0.02074,

           0.07900,          -0.03241,           0.05122,           0.06151,

           0.01319,           0.03075,          -0.02814,           0.00329,

           0.00208,          -0.00681,

           0.09887,          -0.02956,           0.03410,           0.05617,

           0.00295,           0.00022,

           0.01727,          -0.00666,           0.00255,           0.00256,

          -0.14161,          -0.20656,           0.36936,          -0.35793,
           0.40122,           0.54675,

          -0.00109,          -0.00135,

           0.11179,          -0.13803,           0.19591,           0.11327,

          -0.08785,          -0.29929,           0.60319,          -0.20484,
           0.01418,           0.71392,

          -0.01039,          -0.01041,           0.00694,          -0.00183,

           0.00707,          -0.03745,           0.00943,          -0.00174,

           0.01781,           0.00069,           3.35806,          -0.06731,

          -0.01015,          -0.03402,          -0.00913,          -0.00094,

           0.01682,          -0.01066,           0.01361,           0.04752,

           0.97349,           0.00504,

           0.20303,          -0.00206,

           0.00012,           0.00327,

           0.00504,           0.00040,

          -0.01599,          -0.00570,

          -0.19375,          -0.14714,           0.03820,          -0.08283,

          -0.07716,           0.10543,          -0.06772,           0.01131,

         163.23023,        -126.90743,        -183.43441,        -201.49515,
        -559.82622,         698.28238,        1696.58461,        1279.45831,
         771.51923,       -3358.57619,

          -0.05911,           0.89279,          -0.15861,           0.28577,
          -0.06958,           0.02406,

           0.01999,           0.00382,

          -0.00934,           0.00014,

           0.01792,          -0.04249,           0.01019,          -0.00210,

          -0.00386,           0.00009,

          -0.01353,           0.00101,

          -0.03828,          -0.01677,          -0.02026,           0.03079,

          -0.00285,          -0.02484,           0.00537,          -0.00397,

          -0.00064,           0.00906,

          -0.00411,           0.00100,

          -0.06940,          -0.01482,

          -0.01966,          -0.02171,           0.00388,          -0.00840,

          -0.00621,          -0.00597,

          -0.03690,          -0.00959,          -0.00115,          -0.01557,

           3.24906,          -0.00580,

           0.00745,           0.03347,          -0.04023,           0.02174,
          -0.01544,          -0.02389,

           0.00935,          -0.00141,          -0.02018,           0.03258,
          -0.04479,          -0.02360,

          -0.00542,          -0.00194,

          -0.07906,           0.00273,

          -0.08439,           0.01534,          -0.00264,          -0.09205,

          -0.00539,           0.00220,

           0.01263,           0.01593,           0.01103,          -0.03324,

          -0.02720,           0.04749,          -0.05099,           0.01807,

          -0.00443,           0.00024,

          -0.01386,           0.00029,          -0.00443,          -0.00591,

          -0.11899,           0.15817,          -0.37728,           0.06552,

          -0.00669,          -0.00140,

          -0.01168,          -0.00690,

          -0.01032,           0.04315,          -0.01082,           0.00123,

           0.01192,          -0.01071,          -1.90746,           0.00700,

           0.00779,           0.04261,           0.01052,           0.00173,

          -0.02138,           0.00307,

           0.50118,          -0.00330,

          -0.00111,           0.01624,

          -0.02601,           0.00305,           0.02348,           0.07058,

          -0.07622,           0.00006,

          -0.00183,           0.01636,

          -0.00037,           0.00564,

           4.72127,           3.53639,          13.37363,          -6.68745,
         -12.29946,         -22.51893,         -27.18616,          22.85033,
          25.89912,          12.56594,

          -0.02566,           0.00307,          -0.00064,          -0.02727,

          -0.02634,          -0.01101,          -0.01029,           0.04755,

          -0.00372,          -0.00292,

          -0.00582,          -0.00053,

           0.17840,           0.00027,

          -0.03400,           0.00357,

          -0.13428,          -0.00611,

           0.00099,          -0.01169,

           0.01909,           0.01338,           0.01302,          -0.03071,

          -0.00051,           0.00577,

           0.61945,          -0.32627,          -0.30811,          -0.60197,
          -0.22597,           0.28183,

           0.07739,           0.00011,

           0.01336,          -0.00010,

           0.00049,          -0.00592,

          -0.01407,          -0.00081,

           0.00146,          -0.00280,

           0.03795,           0.00003,

           0.01173,          -0.00655,          -0.00344,          -0.00403,

           0.00036,          -0.00047,           0.02000,           0.00001,

           0.01105,           0.00002,

           0.00620,          -0.00052,

  };

  static final byte earargs[] = {
  (byte)0,  (byte)3,
  (byte)3,  (byte)4,  (byte)3, (byte)-8,  (byte)4,  (byte)3,  (byte)5,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)3,  (byte)2,  (byte)2,  (byte)1,  (byte)3, (byte)-8,  (byte)4,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-7,  (byte)3,  (byte)4,  (byte)4,  (byte)1,
  (byte)3,  (byte)7,  (byte)3,(byte)-13,  (byte)4, (byte)-1,  (byte)5,  (byte)0,
  (byte)2,  (byte)8,  (byte)2,(byte)-13,  (byte)3,  (byte)3,
  (byte)3,  (byte)1,  (byte)2, (byte)-8,  (byte)3, (byte)12,  (byte)4,  (byte)0,
  (byte)1,  (byte)1,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)3,  (byte)3,  (byte)3, (byte)-6,  (byte)4,  (byte)2,  (byte)5,  (byte)1,
  (byte)2,  (byte)8,  (byte)3,(byte)-15,  (byte)4,  (byte)3,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)0,
  (byte)1,  (byte)1,  (byte)6,  (byte)1,
  (byte)2,  (byte)9,  (byte)3,(byte)-17,  (byte)4,  (byte)2,
  (byte)3,  (byte)3,  (byte)2, (byte)-5,  (byte)3,  (byte)1,  (byte)5,  (byte)0,
  (byte)3,  (byte)2,  (byte)3, (byte)-4,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-5,  (byte)3,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-2,  (byte)4,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)1,  (byte)1,  (byte)5,  (byte)3,
  (byte)2,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)3,(byte)-13,  (byte)4,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-5,  (byte)3,  (byte)2,
  (byte)2,  (byte)2,  (byte)3, (byte)-4,  (byte)4,  (byte)2,
  (byte)2,  (byte)5,  (byte)2, (byte)-8,  (byte)3,  (byte)1,
  (byte)2,  (byte)6,  (byte)3,(byte)-11,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)1, (byte)-4,  (byte)3,  (byte)0,
  (byte)1,  (byte)2,  (byte)5,  (byte)1,
  (byte)2,  (byte)3,  (byte)3, (byte)-6,  (byte)4,  (byte)1,
  (byte)2,  (byte)5,  (byte)3, (byte)-9,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)2, (byte)-3,  (byte)3,  (byte)2,
  (byte)2,  (byte)4,  (byte)3, (byte)-8,  (byte)4,  (byte)1,
  (byte)2,  (byte)4,  (byte)3, (byte)-7,  (byte)4,  (byte)1,
  (byte)2,  (byte)3,  (byte)3, (byte)-5,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)2, (byte)-2,  (byte)3,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-3,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-6,  (byte)3,  (byte)1,
  (byte)1,  (byte)1,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-3,  (byte)4,  (byte)0,
  (byte)2,  (byte)7,  (byte)3,(byte)-12,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-1,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)6,  (byte)3,(byte)-10,  (byte)4,  (byte)1,
  (byte)2,  (byte)5,  (byte)3, (byte)-8,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-3,  (byte)5,  (byte)1,
  (byte)2,  (byte)2,  (byte)2, (byte)-4,  (byte)3,  (byte)1,
  (byte)2,  (byte)6,  (byte)2, (byte)-9,  (byte)3,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-6,  (byte)4,  (byte)1,
  (byte)3,  (byte)1,  (byte)3, (byte)-3,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-5,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-2,  (byte)5,  (byte)2,
  (byte)3,  (byte)1,  (byte)3, (byte)-4,  (byte)5,  (byte)5,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-4,  (byte)4,  (byte)1,
  (byte)2,  (byte)3,  (byte)2, (byte)-4,  (byte)3,  (byte)2,
  (byte)2,  (byte)1,  (byte)3, (byte)-3,  (byte)6,  (byte)1,
  (byte)3,  (byte)1,  (byte)3,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)5,  (byte)1,
  (byte)3,  (byte)1,  (byte)3, (byte)-3,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-2,  (byte)6,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)7,  (byte)0,
  (byte)2,  (byte)8,  (byte)2,(byte)-14,  (byte)3,  (byte)0,
  (byte)3,  (byte)1,  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)3,  (byte)5,  (byte)3, (byte)-8,  (byte)4,  (byte)3,  (byte)5,  (byte)1,
  (byte)1,  (byte)1,  (byte)3,  (byte)4,
  (byte)3,  (byte)3,  (byte)3, (byte)-8,  (byte)4,  (byte)3,  (byte)5,  (byte)2,
  (byte)2,  (byte)8,  (byte)2,(byte)-12,  (byte)3,  (byte)0,
  (byte)3,  (byte)1,  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)9,  (byte)3,(byte)-15,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)3,  (byte)1,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)3,  (byte)1,  (byte)5,  (byte)1,
  (byte)2,  (byte)8,  (byte)3,(byte)-13,  (byte)4,  (byte)1,
  (byte)2,  (byte)3,  (byte)2, (byte)-6,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)5,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)7,  (byte)3,(byte)-11,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)1, (byte)-3,  (byte)3,  (byte)0,
  (byte)2,  (byte)6,  (byte)3, (byte)-9,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)2, (byte)-2,  (byte)3,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-7,  (byte)4,  (byte)2,
  (byte)2,  (byte)4,  (byte)3, (byte)-5,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)2, (byte)-3,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-3,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-5,  (byte)3,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-5,  (byte)5,  (byte)0,
  (byte)1,  (byte)1,  (byte)2,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-4,  (byte)5,  (byte)1,
  (byte)3,  (byte)2,  (byte)3, (byte)-4,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)3, (byte)-8,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-3,  (byte)5,  (byte)1,
  (byte)2,  (byte)6,  (byte)2, (byte)-8,  (byte)3,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-6,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-5,  (byte)6,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-2,  (byte)5,  (byte)1,
  (byte)3,  (byte)2,  (byte)3, (byte)-4,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)2,  (byte)4,  (byte)3, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-3,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-1,  (byte)5,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-1,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)3,  (byte)4,
  (byte)2,  (byte)5,  (byte)2, (byte)-6,  (byte)3,  (byte)1,
  (byte)2,  (byte)2,  (byte)2, (byte)-1,  (byte)3,  (byte)1,
  (byte)2,  (byte)6,  (byte)3, (byte)-7,  (byte)4,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-5,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-4,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-3,  (byte)5,  (byte)0,
  (byte)2,  (byte)6,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-2,  (byte)5,  (byte)1,
  (byte)2,  (byte)3,  (byte)2, (byte)-2,  (byte)3,  (byte)0,
  (byte)1,  (byte)3,  (byte)3,  (byte)2,
  (byte)2,  (byte)5,  (byte)2, (byte)-5,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)1, (byte)-1,  (byte)3,  (byte)0,
  (byte)2,  (byte)7,  (byte)2, (byte)-8,  (byte)3,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-3,  (byte)5,  (byte)0,
  (byte)2,  (byte)6,  (byte)2, (byte)-6,  (byte)3,  (byte)0,
  (byte)1,  (byte)4,  (byte)3,  (byte)1,
  (byte)2,  (byte)7,  (byte)2, (byte)-7,  (byte)3,  (byte)1,
  (byte)2,  (byte)8,  (byte)2, (byte)-8,  (byte)3,  (byte)0,
  (byte)2,  (byte)9,  (byte)2, (byte)-9,  (byte)3,  (byte)0,
 (byte)-1
  };
  /* Total terms = 135, small = 134 */
  static Plantbl ear404 = new Plantbl(
                               new short[]{1,  9, 14, 17,  5,  5,  2,  1,  0},
                               (short)4,
                               earargs,
                               eartabl,
                               eartabb,
                               eartabr,
                               1.0
                              );

  /*
  First date in file = 1228000.50
  Number of records = 397276.0
  Days per record = 4.0
        Julian Years      Lon    Lat    Rad
   -1349.9 to  -1000.0:   0.42   0.18   0.25
   -1000.0 to   -500.0:   0.45   0.14   0.21
    -500.0 to      0.0:   0.37   0.10   0.20
       0.0 to    500.0:   0.33   0.09   0.22
     500.0 to   1000.0:   0.48   0.07   0.22
    1000.0 to   1500.0:   0.40   0.07   0.19
    1500.0 to   2000.0:   0.36   0.11   0.19
    2000.0 to   2500.0:   0.38   0.14   0.20
    2500.0 to   3000.0:   0.45   0.15   0.24
    3000.0 to   3000.8:  0.182  0.125  0.087
  */
}


class SwemptabJup {
  /*
  First date in file = 625296.50
  Number of records = 16731.0
  Days per record = 131.0
        Julian Years      Lon    Lat    Rad
   -3000.0 to  -2499.7:   0.64   0.09   0.40
   -2499.7 to  -1999.7:   0.70   0.09   0.45
   -1999.7 to  -1499.7:   0.44   0.08   0.32
   -1499.7 to   -999.8:   0.42   0.07   0.32
    -999.8 to   -499.8:   0.55   0.06   0.34
    -499.8 to      0.2:   0.43   0.06   0.31
       0.2 to    500.2:   0.56   0.07   0.32
     500.2 to   1000.1:   0.49   0.06   0.41
    1000.1 to   1500.1:   0.48   0.06   0.38
    1500.1 to   2000.1:   0.56   0.06   0.38
    2000.1 to   2500.0:   0.63   0.08   0.33
    2500.0 to   3000.0:   0.70   0.09   0.36
    3000.0 to   3000.4:  0.526  0.023  0.190
  */
  static final double juptabl[] = {
      153429.13855,      130818.16897,       18120.42948,       -8463.12663,
       -5058.91447,  1092566021.02148,      123671.25097,

          -5.43364,          12.06012,

       30428.31077,      -74667.61443,       46848.16236,      -66373.44474,
       24312.54264,      -26045.64766,       18353.92564,       -4022.13679,
        4037.97936,       10059.82468,       -4622.55896,        1383.21617,
        -187.25468,       -1171.66028,

          -0.00062,          -0.21713,

       -1198.83945,        1178.62445,       -1492.07393,         153.07155,
        -245.57966,        -391.94010,          82.26400,         -40.92104,
           3.72520,          10.57242,

          -0.04720,          -0.04448,          -0.04329,          -0.06043,

          -0.03905,           0.15712,

          -0.05644,          -0.00129,

          -0.00342,           0.02473,

           0.00434,          -0.01862,

           0.00431,          -0.03993,

          -0.03159,          -0.15982,

          -0.09928,           0.04430,          -0.00357,           0.31312,

          -0.01346,          -0.00180,

          -0.09107,           0.01215,

           0.02485,           0.01024,

          27.29869,           2.70896,          12.91956,          19.21726,
          -6.91384,           5.12954,          -1.07533,          -1.71691,

          -0.01423,           0.03121,

         -32.48652,         -26.13483,          46.78162,         -62.02701,
          94.96809,          81.73791,         -20.13673,         131.05065,

          -0.00798,           0.01786,

          13.99591,          16.87756,          -8.51726,          21.59490,
         -14.28833,          -9.45530,           7.73954,          -6.53078,

           0.03175,          -0.04295,

           3.06742,          -0.11838,           1.03630,           0.94004,
          -0.14085,           0.14434,

          -0.03363,           0.00993,

          -0.00007,          -0.02748,

          26.01507,          -7.37178,          16.96955,           6.24203,
          -0.40481,           3.72456,          -0.53597,          -0.14938,

          37.82081,          26.15887,          -2.82115,          78.26478,
         -63.39155,          -5.52419,          13.11482,         -43.54977,
          15.64940,           6.67505,

         -10.25616,          -7.39672,         -12.37441,          12.24417,
           8.54922,           9.68451,

          -0.03658,          -0.00963,

           1.65523,           0.43093,           0.32023,           0.71365,
          -0.12226,           0.03759,

           0.10388,           0.47212,          -0.02791,           0.09929,

          -0.04116,          -0.03125,

          -0.10240,          -0.23199,          -0.03524,          -0.13625,

           7.52726,           6.86314,           0.01239,          13.46530,
          -5.22256,           1.56116,          -0.15925,          -1.19571,

           3.26302,           0.06097,          -0.14444,          -0.20301,
           1.93822,         -80.12566,

           0.98665,          -7.52986,           3.86703,          -2.43028,
           0.64180,           0.78351,

           0.00190,          -0.00633,

          -0.00321,          -0.04403,

           0.19018,           0.14335,           0.10315,           0.53154,

          -0.00062,          -0.00464,

          -0.00109,           0.02150,

           1.19993,          47.21638,         -24.56067,          25.06332,
          -7.50751,          -6.36250,           1.39443,          -1.23806,

           0.04951,           0.02176,

           0.02802,          -0.01665,

          -0.10698,          -0.13635,

          73.54797,         -52.34968,          74.98754,          86.56283,
         -69.01463,          44.56866,

           0.04387,          -0.05925,

          -0.03732,          -0.03264,

           0.00967,           0.02143,

          10.59429,          26.48226,          34.03470,           3.96160,
           4.15919,         -20.22616,          -5.25903,          -3.40177,

           0.05111,          -0.06788,

           0.06497,           1.21024,          -0.29607,           0.49991,
          -0.06055,          -0.03464,

           0.02950,           0.16429,

           0.00722,          -0.90806,

          -0.02161,           0.00902,

          -0.00261,           0.00077,

           0.00434,          -0.29231,

           0.00456,           0.04781,

           1.33214,          -2.62015,           0.79761,          -0.81850,
           0.06371,           0.00119,

           0.03049,          -0.03553,           0.02373,          -0.01411,

        -189.06132,        -169.17940,           5.27464,        -227.72664,
          83.72511,         -12.04794,           0.23965,          23.75496,
          -3.43532,          -0.34276,

          -1.35880,           0.45053,          -0.34298,          -0.11441,

          -0.16328,           0.07423,

         481.48150,          79.82461,         453.82764,         941.94205,
        -635.83924,         397.29087,         -81.54066,        -417.22420,
         149.91822,          10.53490,

          -0.13210,           0.36740,

           0.33777,           0.15893,

       -2562.04968,        2442.77844,       -2602.66709,        2838.87348,
         723.50715,       -1284.58208,       -4557.23362,       -4514.61100,
       -8960.81693,        4663.55087,       -4947.61530,       19377.42027,

          -0.16786,          -0.19514,

           0.32100,           0.91502,

           4.96600,          -1.11836,

         307.38057,         175.14618,          16.02093,         444.42376,
        -219.80047,          62.39286,         -18.14266,         -52.23698,

           0.02111,           0.00469,

         -20.97409,         -34.48296,          -2.03906,         -27.07560,
           3.73818,          -3.00599,           0.24112,           0.41430,

          -0.03552,           0.00394,

          -0.00217,           0.02307,

           0.03686,           0.00510,

          34.46537,          10.23293,           9.99520,          28.88781,
         -11.31210,           3.52646,          -0.48062,          -2.93641,

          -0.00987,          -0.05310,

         -38.39539,           0.04568,         -31.73684,          -1.83151,
         -24.97332,          -1.71244,           0.33498,           7.03899,
          -4.15247,         200.43434,

          -0.00800,           0.04462,

          37.83113,         -13.40661,           9.49434,         -35.41588,
         -14.72767,          -3.84674,          -0.31412,           3.97734,

           0.02908,          -0.00353,

           1.89935,         -14.31774,           7.77051,          -7.08945,
           1.90915,           1.78908,          -0.41445,           0.30506,

         -14.43121,           7.30707,         -11.97842,         -17.64121,
          13.38962,          -7.20982,

          -5.23362,           2.11364,          -0.45605,           4.08835,
           1.42683,           0.24838,

          -0.00605,           0.03199,

          -0.17609,          -1.43091,           0.32444,          -0.51371,
           0.06182,           0.03733,

           0.00696,          -0.13438,

           4.67581,           4.42379,          -1.52602,           4.20659,
          -1.31757,          -0.72910,

           1.29012,           0.97780,           2.25895,          -0.85306,
           1.74120,          -5.09507,

           0.28107,          -0.05040,           0.05508,          -0.06349,

          -0.00061,           0.48249,

          -2.37749,           1.78180,          -1.67423,          -0.35618,
           0.05789,          -0.35287,

           0.56252,          -0.66584,           0.61979,           4.84016,
          -4.64462,          17.48002,

           0.40982,          -4.19214,          -1.55252,          -1.87505,
          -0.31070,           0.15554,

          -0.00034,           0.11102,

           0.01116,          -0.04166,

           9.27689,          -4.32090,           6.84888,           1.78741,
          -0.09306,           1.68391,          -0.27482,          -0.04197,

          -7.83068,          37.71086,         -37.53346,           7.18559,
           0.74427,         -24.29751,          10.87837,           1.35503,

           0.00998,          -0.03395,

        -133.52206,        -150.11329,           4.27494,        -173.79469,
         150.87961,        -356.29181,        -330.17873,        -426.29809,
        -607.98186,         126.35464,        -299.69623,         556.41055,

          -0.00342,           0.04411,

          44.65946,          42.07312,          85.71397,           5.95130,
          24.98064,         -41.20026,         -14.05970,         -10.46101,
          -2.24038,           2.89211,

           0.06175,           0.08128,           0.00705,           0.01939,

          -1.08361,          -0.08213,          -0.20868,          -0.36268,

          -4.96489,          -2.05966,          -6.16586,           3.65514,
          -3.12555,          12.20821,

          -1.11236,          -1.73772,          -1.34045,          -0.22774,
          -0.08639,           0.27355,

          -0.07700,           1.06260,          -0.46013,           0.31916,
          -0.04969,          -0.09488,

          -1.54000,           0.04949,          -0.07616,          -0.95933,
           0.93303,           3.43183,

          -0.82917,          -0.82042,          -0.68158,           0.17083,
           0.06942,           0.17491,

          -0.02699,          -0.01051,

           0.00657,           0.03063,

          -0.52595,           0.84035,          -0.88323,          -0.70188,
           0.60928,          -0.48179,

           0.38290,           0.04482,           0.26456,          -0.32369,

          -0.00615,           0.03218,

          -0.32943,           0.14675,          -0.10782,          -0.09036,

          -0.58003,           0.72888,          -0.46654,           1.17977,

           0.00222,           0.01541,

          -0.19226,          -0.07770,          -0.01829,          -0.05070,

          -1.75385,          -1.32969,           0.52361,          -1.36036,
           0.67222,           1.34612,

           6.96841,         -29.24025,         -23.76900,         -39.91647,
         -41.01215,          -2.23638,         -18.81024,          20.77095,

          -0.68592,          -2.26212,          -1.14065,          -0.76493,
          -0.18044,           0.15193,

          -0.20669,          -0.44387,           0.25697,          -0.17880,

          -0.53097,           0.43181,          -0.35187,           0.71934,

          -0.14962,           0.09220,          -0.05031,          -0.03924,

           0.06571,           0.29487,

           0.05170,           0.36847,

           0.02754,          -0.00411,

          -0.08313,          -0.16907,           0.10273,          -0.07315,

          -0.02312,           0.04912,

          -0.01062,          -0.02713,

           0.03806,           0.13401,

          -1.79865,          -2.04540,          -2.69965,          -0.65706,
          -1.17916,           0.79292,

           0.02415,           0.14001,

          -0.01767,           0.04209,

           0.05212,          -0.01795,

           0.01285,           0.04028,

           0.01075,           0.05533,

           0.02323,          -0.00864,

          -0.04691,           0.03128,

           0.00548,           0.02254,

           0.00011,           0.12033,

  };
  static final double juptabb[] = {
         548.59659,         594.29629,         219.97664,          59.71822,
          23.62157,          40.77732,         227.07380,

           0.00293,          -0.00745,

        -307.33226,        -347.92807,        -309.49383,        -428.18929,
         -96.59506,        -191.36254,           2.11014,         -34.44145,
           2.23085,           6.77110,          -5.43468,          -0.28391,
           0.28355,          -1.81690,

           0.00036,           0.00078,

          -1.83259,           1.17464,          -2.66976,          -0.92339,
          -0.23645,          -1.20623,           0.25248,          -0.04958,
           0.00064,           0.03599,

          -0.00079,           0.00004,          -0.00005,          -0.00010,

          -0.00024,           0.00051,

           0.00001,           0.00005,

           0.00015,           0.00010,

           0.00017,          -0.00004,

           0.00113,          -0.00011,

           0.00021,           0.00087,

           0.00120,          -0.00114,          -0.00881,          -0.00020,

          -0.00005,           0.00009,

           0.00005,           0.00007,

           0.00002,          -0.00033,

          -0.00554,          -0.32274,           0.23695,          -0.11184,
           0.04050,           0.09929,          -0.02189,           0.00305,

          -0.00142,          -0.00055,

           0.66623,           0.34590,           0.74913,          -0.23202,
          -1.08316,          -1.40407,           1.72287,          -0.07604,

           0.00024,           0.00004,

           0.03592,           0.91143,          -1.11848,          -0.17473,
           0.91500,          -1.34912,           0.85229,           0.69029,

          -0.00019,           0.00075,

           0.03615,           0.30768,          -0.08733,           0.12016,
          -0.01716,          -0.01138,

           0.00021,           0.00004,

           0.00531,           0.00098,

          -0.14354,          -0.02364,          -0.05559,          -0.07561,
           0.01419,          -0.01141,           0.00014,           0.00218,

          -0.36564,           0.13498,          -0.13283,          -0.11462,
           0.23741,           0.14960,          -0.23173,           0.25148,
           0.00763,          -0.05987,

          -0.00857,           0.20312,          -0.29399,           0.34831,
          -1.33166,          -0.46808,

          -0.00027,           0.00046,

           0.15729,           0.01367,           0.04093,           0.07447,
          -0.01598,           0.00785,

           0.00583,           0.00324,           0.00053,           0.00160,

          -0.00030,           0.00043,

          -0.00208,           0.00334,          -0.00316,           0.00136,

           0.23086,           0.05711,           0.19558,           0.05897,
           0.01070,           0.05021,          -0.00818,          -0.02242,

           0.06301,          -0.26483,           0.66177,           0.02125,
           0.13477,           0.19376,

          -0.36520,           0.83588,          -0.69848,          -0.00877,
           0.01626,          -0.23878,

          -0.00373,           0.00044,

           0.00008,          -0.00004,

          -0.00374,          -0.00283,           0.01104,          -0.00619,

           0.00004,           0.00015,

           0.00026,           0.00013,

           0.04630,          -0.11815,           0.00773,           0.03796,
          -0.05172,           0.00149,           0.00444,          -0.01493,

          -0.00064,          -0.00044,

          -0.00033,           0.00002,

          -0.00012,           0.00284,

          -0.15622,          -0.92158,          -0.82690,          -1.52101,
          -0.55934,           0.69375,

          -0.00171,           0.00031,

           0.00129,          -0.00013,

          -0.00024,          -0.00083,

           0.66101,          -0.21764,          -0.43967,           0.30157,
           0.53389,           1.59141,           1.94286,           0.14146,

          -0.00064,          -0.00006,

           0.21850,          -0.02912,           0.08594,           0.08734,
          -0.01678,           0.01629,

           0.00133,           0.00562,

           0.00128,          -0.00025,

          -0.00005,           0.00027,

           0.00032,           0.00001,

           0.00037,           0.00042,

           0.00070,           0.00003,

           0.00275,          -0.13096,           0.02329,          -0.05582,
           0.00405,          -0.00251,

           0.01316,          -0.01165,           0.00279,          -0.00374,

         -39.62783,          20.91467,         -28.97236,           3.77560,
          -3.30029,           0.11472,          -0.48216,           1.05814,
          -0.21607,          -0.03055,

          -0.64162,          -0.57355,          -0.05861,          -0.18592,

          -0.12207,          -0.06279,

         -38.55325,        -125.74207,         -47.22357,          41.75842,
        -119.38841,          18.88515,         -11.04830,         -50.98851,
          16.64895,           1.76553,

           0.09474,           0.03714,

           0.02593,           0.07967,

       -1187.61854,       -1094.91786,       -1011.21939,       -1102.25998,
        -575.88672,        -107.84860,        -890.58889,        -807.06589,
         971.78461,       -1287.24560,       -4601.44669,        -849.54329,

          -0.00904,           0.06233,

          -0.19456,          -0.05521,

          -0.36915,           1.15363,

          32.64763,         -85.19705,         114.34437,         -13.37747,
          15.92865,          55.84857,         -13.10538,           3.07629,

          -0.00327,           0.00104,

          -7.81035,           6.19960,          -6.36096,           1.00493,
          -0.66971,          -0.84572,           0.09943,          -0.04583,

           0.00200,          -0.00032,

          -0.00265,           0.00047,

          -0.00053,           0.00046,

          -0.24396,           0.20664,          -0.30820,          -0.04917,
           0.06184,          -0.12642,           0.03053,           0.05054,

           0.00035,           0.00012,

           0.42063,          -0.58254,           0.90517,          -0.66276,
           0.64765,           0.39338,          -1.40645,           0.33017,
          -1.43377,          -0.67089,

          -0.00045,          -0.00036,

           0.23690,           0.07185,           0.28386,          -0.04397,
           0.02836,          -0.13082,          -0.00978,           0.00108,

           0.00046,           0.00083,

          -0.01665,           0.32499,          -0.09980,           0.18611,
          -0.02561,           0.00239,          -0.00084,          -0.00110,

           0.46854,          -0.35113,           0.69908,           0.53244,
           0.12875,           0.01115,

           0.13930,           0.02747,          -0.10587,          -0.17759,
          -0.26850,           0.04400,

           0.00010,          -0.00015,

           0.00164,          -0.01308,           0.00488,          -0.01046,
           0.00170,           0.00024,

           0.00084,           0.00014,

          -0.08481,          -0.02547,          -0.02290,          -0.02281,
          -0.03946,          -0.02810,

           0.01298,           0.08658,           0.05575,          -0.01081,
           1.09695,           0.35441,

          -0.03127,           0.07946,           0.01245,           0.02578,

          -0.00524,          -0.00027,

           0.08217,          -0.31742,           0.15273,          -0.07804,
           0.01197,           0.03053,

           0.81596,           0.38640,          -0.89777,           0.59499,
          -0.39581,          -0.87375,

           0.02096,           0.49772,           0.29986,           0.24210,
           0.14038,          -0.03016,

          -0.00208,           0.00045,

           0.01024,           0.00114,

           1.23010,           1.75663,          -0.12741,           1.44996,
          -0.31607,           0.03151,           0.00259,          -0.04741,

         -11.57091,           8.00331,          -9.24028,          -6.36906,
           4.71248,          -2.43695,           0.38630,           1.90625,

           0.01401,           0.00114,

          33.56690,         -55.17784,          33.21425,         -52.57002,
          27.04138,          13.78610,          69.60307,         -81.16312,
          27.53960,        -158.28336,        -205.94418,         -95.08051,

          -0.01407,          -0.00364,

         -18.56128,           6.02270,         -10.11059,          24.69471,
          12.31878,           9.94393,           3.81994,          -4.84109,
          -1.08440,          -0.72136,

           0.03731,          -0.02094,           0.00789,          -0.00176,

           0.09673,          -0.11181,           0.03112,          -0.00065,

          -0.29167,          -0.82083,           0.40866,          -0.77487,
          -2.23349,          -0.46973,

           0.41024,          -0.14274,           0.07755,          -0.24895,
          -0.04965,          -0.01197,

          -0.02264,           0.05917,          -0.02817,           0.01242,
          -0.00250,          -0.00247,

          -0.14414,          -0.03739,           0.14708,          -0.07908,
           0.05843,           0.15173,

          -0.01601,          -0.07844,          -0.05957,          -0.03143,
          -0.01830,           0.01257,

          -0.00109,          -0.00000,

           0.00174,           0.00050,

          -0.02119,           0.06918,          -0.02470,           0.00185,
           0.02372,          -0.02417,

           0.01081,           0.05222,           0.09820,           0.05931,

          -0.00588,          -0.00086,

           0.01688,          -0.00133,          -0.00073,           0.00041,

          -0.02280,          -0.05706,          -0.17694,          -0.12027,

           0.00196,          -0.00060,

           0.00051,          -0.02426,           0.00314,          -0.00302,

           0.17923,          -0.78343,           0.52073,          -0.02398,
          -0.03978,           0.20841,

           6.51325,           3.37139,          12.88844,          -6.72098,
           3.40949,         -14.34313,          -9.68278,          -7.85143,

           1.06886,          -0.21727,           0.36675,          -0.49815,
          -0.07289,          -0.07537,

           0.01107,          -0.00644,           0.01013,          -0.00306,

          -0.00708,          -0.13488,          -0.23041,          -0.10698,

          -0.00049,          -0.00692,          -0.00142,          -0.00211,

          -0.04021,           0.01805,

           0.00479,           0.00620,

           0.00739,           0.00566,

          -0.00101,          -0.00022,           0.00261,          -0.00188,

          -0.01812,          -0.01205,

          -0.00061,          -0.00061,

          -0.02479,           0.01157,

           0.91642,          -0.65781,           0.39969,          -1.13699,
          -0.43337,          -0.57828,

           0.00145,           0.00281,

          -0.01675,          -0.00975,

           0.00119,          -0.00074,

          -0.00343,           0.00139,

           0.00061,           0.00086,

           0.00054,          -0.00046,

          -0.01996,          -0.02689,

           0.00034,           0.00037,

          -0.00006,           0.00001,

  };
  static final double juptabr[] = {
        -734.58857,       -1081.04460,        -551.65750,        -148.79782,
         -25.23171,         164.64781,         248.64813,

          -0.05163,          -0.02413,

       -1306.61004,         560.02437,       -1622.58047,         589.92513,
        -812.39674,         166.85340,        -157.92826,        -107.14755,
          68.98900,         -18.95875,          -0.16183,          36.24345,
          -9.19972,          -2.29315,

          -0.00316,           0.00222,

          10.95234,          21.37177,          -6.29550,          21.83656,
          -7.70755,           1.38228,          -0.21770,          -1.49525,
           0.17951,           0.01043,

           0.00062,           0.00208,          -0.00066,           0.00050,

           0.00313,           0.00187,

           0.00010,           0.00131,

           0.00102,           0.00047,

           0.00102,           0.00012,

           0.00012,          -0.00037,

           0.00808,           0.00027,

          -0.01219,          -0.00961,          -0.04166,          -0.00327,

          -0.00001,          -0.00146,

          -0.00092,          -0.00989,

          -0.00135,           0.00196,

           0.19216,           2.48442,          -1.43599,           1.39651,
          -0.48549,          -0.53272,           0.14066,          -0.10352,

           0.00141,           0.00066,

           2.96838,          -3.09575,           6.27741,           5.24306,
          -8.77080,           9.03247,         -10.98350,          -3.58579,

          -0.00168,          -0.00100,

           0.20234,          -0.75737,           0.36838,          -0.58241,
           0.41430,          -0.35784,           0.47038,          -0.10586,

           0.00539,           0.00490,

          -0.01375,          -0.01950,           0.00145,           0.00723,
          -0.00391,           0.00391,

          -0.00131,          -0.00568,

           0.01317,           0.00319,

           1.31006,           5.89394,          -1.61753,           3.68814,
          -0.80644,          -0.14747,           0.04481,          -0.11361,

          -4.36130,           7.92488,         -16.29047,          -1.52163,
           2.14492,         -14.38028,           9.65573,           3.56881,
          -1.87208,           3.36213,

           1.84499,          -2.41575,          -2.77076,          -3.23915,
          -3.34573,           1.40979,

           0.00217,          -0.00841,

           0.29313,          -0.36246,           0.22043,           0.02328,
          -0.01182,           0.04074,

          -0.15728,           0.02468,          -0.03185,          -0.01099,

           0.01059,          -0.01274,

           0.07362,          -0.02642,           0.04035,          -0.00968,

          -2.14457,           2.53297,          -4.34196,          -0.11421,
          -0.38757,          -1.73872,           0.39784,          -0.01397,

          -0.03311,           0.97723,           0.16060,          -0.07486,
          25.96413,           0.75088,

          -3.04736,           0.30340,          -1.43451,          -1.35136,
           0.26526,          -0.40247,

          -0.00460,          -0.00056,

           0.01633,          -0.00128,

          -0.05197,           0.07002,          -0.19450,           0.03737,

           0.00188,          -0.00037,

          -0.00903,          -0.00059,

         -19.73809,           0.58424,         -10.42034,         -10.14579,
           2.65990,          -3.07889,           0.50884,           0.58508,

          -0.00970,           0.02099,

           0.00716,           0.01161,

           0.05751,          -0.04515,

          22.08042,          30.82415,         -36.27430,          31.40265,
         -18.30150,         -29.16403,

           0.02454,           0.01834,

          -0.01312,           0.01576,

          -0.00928,           0.00330,

         -11.78094,           4.06738,          -2.51590,          15.05277,
           9.12747,           2.88088,           2.32916,          -2.08271,

           0.02872,           0.02194,

           0.60494,          -0.04597,           0.24749,           0.15971,
          -0.02185,           0.03384,

          -0.07075,           0.01287,

           0.40201,           0.00347,

          -0.00410,          -0.00998,

          -0.00005,          -0.00121,

           0.13770,           0.00186,

          -0.02268,           0.00210,

           1.26291,           0.65546,           0.38885,           0.38880,
          -0.00184,           0.03067,

           0.01273,           0.01136,           0.00557,           0.01117,

          94.13171,         -88.37882,         120.53292,           8.32903,
           7.77313,          43.46523,         -11.66698,           0.44639,
           0.15092,          -1.68367,

          -0.30833,          -0.49030,           0.01971,          -0.14144,

          -0.04019,          -0.05110,

         -39.70024,         272.91667,        -468.46263,         256.77696,
        -200.63130,        -307.98554,         206.56301,         -41.76039,
          -4.74242,          74.19909,

           0.18474,           0.05547,

          -0.06732,           0.16515,

       -1156.31285,       -1102.97666,       -1346.99288,       -1121.01090,
         666.84550,         421.92305,        2259.49740,       -2268.69758,
       -2325.87639,       -4476.46256,       -9683.77583,       -2472.92565,

          -0.10400,           0.08075,

          -0.45225,           0.16621,

           0.57789,           2.43804,

          85.21675,        -154.17208,         219.91042,          -9.71116,
          31.13240,         108.60117,         -25.85622,           8.98402,

          -0.00233,           0.01030,

         -17.01324,          10.41588,         -13.34449,           1.08782,
          -1.48199,          -1.81734,           0.20334,          -0.11734,

          -0.00230,          -0.01869,

          -0.01182,          -0.00129,

          -0.00281,           0.02021,

          -5.75973,          19.13309,         -16.13690,           5.53382,
          -1.96585,          -6.29211,           1.63105,          -0.26089,

           0.02935,          -0.00555,

           0.30700,         -19.96182,           0.99825,         -16.32664,
           0.83052,         -13.76201,          -3.15609,           0.17360,
        -111.81423,          -2.05419,

          -0.02455,          -0.00478,

           7.45114,          21.53296,          19.90263,           5.69420,
           2.31253,          -8.15116,          -2.17440,          -0.23014,

           0.00168,           0.01590,

           8.78005,           0.71418,           4.48561,           4.50680,
          -1.05713,           1.17880,          -0.19327,          -0.24877,

          -5.00870,          -8.66354,          10.51902,          -7.71011,
           4.65486,           8.05673,

          -1.39635,          -3.07669,          -2.40347,          -0.11167,
          -0.04064,           0.83512,

          -0.02041,          -0.00351,

           0.97375,          -0.15795,           0.36361,           0.19913,
          -0.02142,           0.04193,

           0.08801,           0.00475,

          -2.81010,           3.11341,          -2.79191,          -0.93313,
           0.44570,          -0.88287,

          -0.51815,           0.54776,           0.29736,           0.99779,
           2.28957,           0.82183,

           0.03386,           0.12855,           0.03124,           0.02454,

          -0.31958,           0.00070,

          -1.48184,          -1.28195,           0.03965,          -1.12026,
           0.23910,           0.01293,

           0.36146,          -0.64483,          -1.88470,           0.21469,
         -11.79819,          -1.87287,

           2.65699,          -0.36287,           0.88148,          -1.26883,
          -0.19657,          -0.14279,

          -0.07536,          -0.00004,

           0.01496,           0.00537,

           2.48352,           3.75581,          -0.34909,           3.26696,
          -0.82105,           0.11287,          -0.00755,          -0.13764,

         -15.34429,          -2.79957,          -3.22976,         -15.46084,
          10.66793,          -0.26054,          -0.12188,           5.06211,

           0.01313,           0.00424,

          84.34332,         -57.05646,          92.68150,          -0.02024,
         149.62698,          59.14407,         174.04569,        -129.26785,
         -55.99789,        -238.01484,        -212.51618,        -115.94914,

          -0.01720,          -0.00158,

         -13.65602,          17.47396,           0.16714,          32.66367,
          16.30095,           9.18345,           3.98555,          -5.39985,
          -1.09958,          -0.86072,

           0.02752,          -0.02474,           0.00671,          -0.00278,

          -0.21030,          -0.73658,           0.20708,          -0.21378,

           0.78462,          -2.14051,          -1.60070,          -2.60915,
          -5.02441,          -1.19246,

           0.67622,          -0.41889,           0.07430,          -0.53204,
          -0.11214,          -0.03417,

          -0.72636,          -0.15535,          -0.16815,          -0.35603,
           0.07530,          -0.02521,

          -0.01261,          -0.94883,           0.39930,          -0.05370,
          -2.77309,           0.38431,

           0.72127,          -0.52030,          -0.01804,          -0.51188,
          -0.11993,           0.02189,

           0.00928,          -0.02129,

          -0.02760,           0.00441,

          -0.56832,          -0.48114,           0.64192,          -0.65656,
           0.37483,           0.51883,

          -0.08474,           0.20324,           0.12783,           0.13041,

          -0.01545,          -0.00282,

          -0.16196,          -0.26980,           0.06584,          -0.09987,

          -0.36305,          -0.27610,          -0.57074,          -0.13607,

          -0.00824,           0.00369,

           0.06094,          -0.12214,           0.03581,          -0.00876,

           0.49346,          -0.74596,           0.47814,           0.18201,
          -1.00640,           0.24465,

          10.09808,           2.30496,          13.63359,          -7.94007,
           0.29792,         -13.55724,          -6.48556,          -5.99581,

           0.69686,          -0.22434,           0.23198,          -0.35579,
          -0.04736,          -0.05683,

           0.36710,          -0.16571,           0.14876,           0.21824,

          -0.18940,          -0.15063,          -0.23692,          -0.09990,

          -0.08923,          -0.12222,           0.02998,          -0.04560,

          -0.16229,           0.04552,

          -0.33051,           0.02585,

          -0.00622,           0.01583,

           0.15436,          -0.07109,           0.06429,           0.09218,

          -0.01277,          -0.00019,

           0.02345,          -0.01057,

          -0.07294,           0.02506,

           0.62063,          -0.52533,           0.16814,          -0.77168,
          -0.20614,          -0.31828,

          -0.12856,           0.01316,

          -0.01522,          -0.00126,

           0.01558,           0.04765,

          -0.02776,           0.01166,

          -0.05185,           0.00674,

           0.00754,           0.02183,

          -0.00645,          -0.01050,

          -0.02155,           0.00375,

           0.12040,          -0.00004,

  };

  static byte jupargs[] = {
  (byte)0,  (byte)6,
  (byte)3,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)6,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)5,(byte)-10,  (byte)6,  (byte)4,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)3,  (byte)3,  (byte)5,(byte)-10,  (byte)6,  (byte)7,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)5,(byte)-15,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)4,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)1,  (byte)1,  (byte)7,  (byte)1,
  (byte)2,  (byte)5,  (byte)5,(byte)-12,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)7,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-7,  (byte)6,  (byte)3,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)3,
  (byte)3,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)3,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)2,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)1,  (byte)2,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-9,  (byte)6,  (byte)3,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)4,
  (byte)1,  (byte)1,  (byte)6,  (byte)2,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)2,
  (byte)2,  (byte)5,  (byte)5,(byte)-11,  (byte)6,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-3,  (byte)7,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-6,  (byte)6,  (byte)3,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)2,
  (byte)2,  (byte)3,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)7,  (byte)1,
  (byte)2,  (byte)6,  (byte)5,(byte)-13,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-2,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-8,  (byte)6,  (byte)3,
  (byte)2,  (byte)3,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)6,  (byte)5,(byte)-14,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)2,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)7,  (byte)5,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)4,  (byte)5, (byte)-9,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-6,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)3,  (byte)4,  (byte)5, (byte)-8,  (byte)6,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)7,  (byte)5,(byte)-15,  (byte)6,  (byte)2,
  (byte)3,  (byte)3,  (byte)5, (byte)-4,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)2,  (byte)5,  (byte)5,(byte)-10,  (byte)6,  (byte)4,
  (byte)3,  (byte)1,  (byte)5,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)3,  (byte)7,  (byte)5,(byte)-16,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-5,  (byte)6,  (byte)4,
  (byte)3,  (byte)1,  (byte)5, (byte)-6,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)5,  (byte)5,(byte)-11,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)1,  (byte)1,  (byte)5,  (byte)5,
  (byte)3,  (byte)3,  (byte)5,(byte)-11,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-6,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-7,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)3,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5,(byte)-10,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5,  (byte)1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-7,  (byte)6,  (byte)3,
  (byte)2,  (byte)4,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)6,  (byte)4,
  (byte)3,  (byte)4,  (byte)5, (byte)-8,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)1,  (byte)3,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-9,  (byte)6,  (byte)3,
  (byte)2,  (byte)3,  (byte)5, (byte)-4,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)5,  (byte)1,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)5,(byte)-11,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-6,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-1,  (byte)6,  (byte)2,
  (byte)1,  (byte)4,  (byte)6,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-8,  (byte)6,  (byte)2,
  (byte)2,  (byte)3,  (byte)5, (byte)-3,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)5,  (byte)2,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-1,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)5,(byte)-10,  (byte)6,  (byte)3,
  (byte)2,  (byte)4,  (byte)5, (byte)-5,  (byte)6,  (byte)3,
  (byte)2,  (byte)6,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)1,  (byte)2,  (byte)5,  (byte)5,
  (byte)3,  (byte)4,  (byte)5, (byte)-6,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)1,  (byte)5,  (byte)6,  (byte)4,
  (byte)2,  (byte)2,  (byte)5,(byte)-10,  (byte)6,  (byte)1,
  (byte)2,  (byte)5,  (byte)5, (byte)-7,  (byte)6,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-2,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)5,  (byte)3,  (byte)6,  (byte)2,
  (byte)2,  (byte)6,  (byte)5, (byte)-9,  (byte)6,  (byte)2,
  (byte)2,  (byte)4,  (byte)5, (byte)-4,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5,  (byte)1,  (byte)6,  (byte)2,
  (byte)2,  (byte)7,  (byte)5,(byte)-11,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-6,  (byte)6,  (byte)2,
  (byte)2,  (byte)3,  (byte)5, (byte)-1,  (byte)6,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-8,  (byte)6,  (byte)1,
  (byte)2,  (byte)4,  (byte)5, (byte)-3,  (byte)6,  (byte)1,
  (byte)2,  (byte)2,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)5,(byte)-10,  (byte)6,  (byte)1,
  (byte)2,  (byte)5,  (byte)5, (byte)-5,  (byte)6,  (byte)2,
  (byte)1,  (byte)3,  (byte)5,  (byte)3,
  (byte)2,  (byte)1,  (byte)5,  (byte)5,  (byte)6,  (byte)2,
  (byte)2,  (byte)6,  (byte)5, (byte)-7,  (byte)6,  (byte)1,
  (byte)2,  (byte)4,  (byte)5, (byte)-2,  (byte)6,  (byte)1,
  (byte)2,  (byte)7,  (byte)5, (byte)-9,  (byte)6,  (byte)1,
  (byte)2,  (byte)5,  (byte)5, (byte)-4,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-6,  (byte)6,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-1,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)5, (byte)-8,  (byte)6,  (byte)1,
  (byte)2,  (byte)5,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)8,  (byte)5,(byte)-10,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)1,  (byte)4,  (byte)5,  (byte)2,
  (byte)2,  (byte)7,  (byte)5, (byte)-7,  (byte)6,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)8,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)5, (byte)-6,  (byte)6,  (byte)0,
  (byte)2,  (byte)8,  (byte)5, (byte)-8,  (byte)6,  (byte)0,
  (byte)2,  (byte)9,  (byte)5,(byte)-10,  (byte)6,  (byte)0,
  (byte)1,  (byte)5,  (byte)5,  (byte)0,
  (byte)2,  (byte)9,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)5,  (byte)0,
 (byte)-1
  };
  /* Total terms = 142, small = 140 */
  static Plantbl jup404 = new Plantbl(
                               new short[]{0,  0,  1,  0,  9, 16,  7,  5,  0},
                               (short)6,
                               jupargs,
                               juptabl,
                               juptabb,
                               juptabr,
                               5.2026032092000003e+00
  );
}

class SwemptabMar {
  /*
  First date in file = 1228000.50
  Number of records = 397276.0
  Days per record = 4.0
        Julian Years      Lon    Lat    Rad
   -1349.9 to  -1000.0:   0.42   0.18   0.25
   -1000.0 to   -500.0:   0.45   0.14   0.21
    -500.0 to      0.0:   0.37   0.10   0.20
       0.0 to    500.0:   0.33   0.09   0.22
     500.0 to   1000.0:   0.48   0.07   0.22
    1000.0 to   1500.0:   0.40   0.07   0.19
    1500.0 to   2000.0:   0.36   0.11   0.19
    2000.0 to   2500.0:   0.38   0.14   0.20
    2500.0 to   3000.0:   0.45   0.15   0.24
    3000.0 to   3000.8:  0.182  0.125  0.087
  */

  static final double martabl[] = {
       43471.66140,       21291.11063,        2033.37848,  6890507597.78366,
     1279543.73631,

         317.74183,         730.69258,         -15.26502,         277.56960,
         -62.96711,          20.96285,

           1.01857,          -2.19395,

           3.75708,           3.65854,           0.01049,           1.09183,

          -0.00605,          -0.04769,

           0.41839,           0.10091,           0.03887,           0.11666,

          -0.03301,           0.02664,

           0.38777,          -0.56974,

           0.02974,          -0.15041,           0.02179,          -0.00808,

           0.08594,           0.09773,

          -0.00902,          -0.04597,           0.00762,          -0.03858,

          -0.00139,           0.01562,

           0.02019,           0.01878,

          -0.01244,           0.00795,

           0.00815,           0.03501,

          -0.00335,          -0.02970,

          -0.00518,          -0.01763,

           0.17257,           0.14698,          -0.14417,           0.26028,

           0.00062,          -0.00180,

          13.35262,          39.38771,         -15.49558,          22.00150,
          -7.71321,          -4.20035,           0.62074,          -1.42376,

           0.07043,          -0.06670,           0.16960,          -0.06859,
           0.07787,           0.01845,

          -0.01608,          -0.00914,

           5.60438,          -3.44436,           5.88876,           6.77238,
          -5.29704,           3.48944,

           0.01291,           0.01280,

          -0.53532,           0.86584,           0.79604,           0.31635,

          -3.92977,          -0.94829,          -0.74254,          -1.37947,
           0.17871,          -0.12477,

           0.00171,           0.11537,

           0.02281,          -0.03922,

          -0.00165,           0.02965,

           1.59773,           1.24565,          -0.35802,           1.37272,
          -0.44811,          -0.08611,

           3.04184,          -3.39729,           8.86270,           6.65967,
          -9.10580,          10.66103,

           0.02015,          -0.00902,

          -0.01166,          -0.23957,          -0.12128,          -0.04640,

          -0.07114,           0.14053,          -0.04966,          -0.01665,

           0.28411,          -0.37754,          -1.26265,           1.01377,
           3.70433,          -0.21025,

          -0.00972,           0.00350,

           0.00997,           0.00450,

          -2.15305,           3.18147,          -1.81957,          -0.02321,
          -0.02560,          -0.35188,

           0.00003,          -0.01110,

           0.00244,          -0.05083,

          -0.00216,          -0.02026,

           0.05179,           0.04188,

           5.92031,          -1.61316,           3.72001,           6.98783,
          -4.17690,           2.61250,

           0.04157,           2.76453,          -1.34043,           0.74586,
          -0.20258,          -0.30467,

           0.00733,           0.00376,

           1.72800,           0.76593,           1.26577,          -2.02682,
          -1.14637,          -0.91894,

          -0.00002,           0.00036,

           2.54213,           0.89533,          -0.04166,           2.36838,
          -0.97069,           0.05486,

           0.46927,           0.04500,           0.23388,           0.35005,

           1.61402,           2.30209,          -0.99859,           1.63349,
          -0.51490,          -0.26112,

           0.27848,          -0.26100,          -0.07645,          -0.22001,

           0.92901,           1.12627,          -0.39829,           0.77120,
          -0.23716,          -0.11245,

          -0.02387,           0.03960,

          -0.00802,           0.02179,

           2.86448,           1.00246,          -0.14647,           2.80278,
          -1.14143,           0.05177,

           1.68671,          -1.23451,           3.16285,           0.70070,
           0.25817,           3.17416,

           0.07447,          -0.08116,          -0.03029,          -0.02795,

           0.00816,           0.01023,

           0.00685,          -0.01075,

          -0.34268,           0.03680,          -0.05488,          -0.07430,

          -0.00041,          -0.02968,

           3.13228,          -0.83209,           1.95765,           3.78394,
          -2.26196,           1.38520,

          -0.00401,          -0.01397,

           1.01604,          -0.99485,           0.62465,           0.22431,
          -0.05076,           0.12025,

           4.35229,          -5.04483,          14.87533,           9.00826,
         -10.37595,          19.26596,

           0.40352,           0.19895,           0.09463,          -0.10774,

          -0.17809,          -0.08979,          -0.00796,          -0.04313,

           0.01520,          -0.03538,

           1.53301,          -1.75553,           4.87236,           3.23662,
          -3.62305,           6.42351,

          -0.00439,          -0.01305,

           0.17194,          -0.64003,           0.26609,           0.06600,

           0.01767,          -0.00251,

          -0.08871,          -0.15523,           0.01201,          -0.03408,

          -0.29126,          -0.07093,          -0.00998,          -0.07876,

           1.05932,         -25.38650,

          -0.29354,           0.04179,          -0.01726,           0.07473,

          -0.07607,          -0.08859,           0.00842,          -0.02359,

           0.47858,          -0.39809,           1.25061,           0.87017,
          -0.82453,           1.56864,

          -0.00463,           0.02385,

          -0.29070,           8.56535,

          -0.12495,           0.06580,          -0.03395,          -0.02465,

          -1.06759,           0.47004,          -0.40281,          -0.23957,
           0.03572,          -0.07012,

           0.00571,          -0.00731,

           0.18601,          -1.34068,

           0.03798,          -0.00532,           0.00448,          -0.01147,

           1.41208,          -0.00668,           0.25883,           1.23788,
          -0.57774,           0.09166,

          -2.49664,          -0.25235,          -0.53582,          -0.80126,
           0.10827,          -0.08861,

          -0.03577,           0.06825,

          -0.00143,           0.04633,

           0.01586,          -0.01056,

          -0.02106,           0.03804,

          -0.00088,          -0.03458,

          -0.00033,          -0.01079,

           0.05821,          -0.02445,

           0.00602,           0.00721,

          -0.00315,          -0.01021,

          -0.65454,           1.08478,          -0.44593,          -0.21492,

          -1.35004,           4.47299,          -4.19170,           3.51236,

        1946.04629,       13960.88247,         576.24572,        8023.81797,
        2402.48512,        -753.87007,       -6376.99217,      -10278.88014,
      -25743.89874,       15506.87748,       15609.59853,       35173.63133,

          -3.70370,           6.29538,          -4.84183,          -0.76942,

          -0.02465,          -0.03840,

           0.00565,          -0.06071,

           0.01174,           0.00253,

          -0.00230,           0.05252,

          -0.02813,           0.01359,

           0.23208,           0.03393,           0.01734,           0.04838,

          -0.46340,          -0.18941,           0.25428,          -0.56925,

           0.05213,           0.24704,           0.12922,          -0.01531,

           0.06885,          -0.08510,           0.01853,          -0.00390,

           0.01196,          -0.30530,           0.13117,          -0.03533,

           1.79597,          -0.42743,           0.98545,           2.13503,
          -1.32942,           0.68005,

          -0.01226,           0.00571,

           0.31081,           0.34932,           0.34531,          -0.32947,

          -0.00548,           0.00186,          -0.00157,          -0.00065,

           0.30877,          -0.03864,           0.04921,           0.06693,

           0.01761,          -0.04119,

           1.28318,           0.38546,           0.06462,           1.18337,
          -0.48698,           0.07086,

           0.26031,          -0.22813,           0.10272,           0.04737,

          -0.04506,          -0.38581,          -0.16624,          -0.04588,

           0.00992,           0.00722,

          -0.21041,           0.20560,          -0.09267,          -0.03438,

           0.32264,          -0.07383,

           0.09553,          -0.38730,           0.17109,          -0.01342,

          -0.02336,          -0.01286,

           0.00230,           0.04626,

           0.01176,           0.01868,

          -0.15411,          -0.32799,           0.22083,          -0.14077,

           1.98392,           1.68058,

          -0.02526,          -0.13164,          -0.04447,          -0.00153,

           0.01277,           0.00553,

          -0.26035,          -0.11362,           0.14672,          -0.32242,

           0.16686,          -0.69957,           0.40091,          -0.06721,
           0.00837,           0.09635,

          -0.08545,           0.25178,          -0.22486,          16.03256,

           0.34130,          -0.06313,           0.01469,          -0.09012,

          -0.00744,          -0.02510,

          -0.08492,          -0.13733,

          -0.07620,          -0.15329,           0.13716,          -0.03769,

           2.01176,          -1.35991,          -1.04319,          -2.97226,

          -0.01433,           0.61219,

          -0.55522,           0.38579,           0.31831,           0.81843,

          -0.04583,          -0.14585,

          -0.10218,           0.16039,          -0.06552,          -0.01802,

           0.06480,          -0.06641,           0.01672,          -0.00287,

           0.00308,           0.09982,          -0.05679,          -0.00249,

          -0.36034,           0.52385,          -0.29759,           0.59539,

          -3.59641,          -1.02499,

        -547.53774,         734.11470,         441.86760,        -626.68255,
       -2255.81376,       -1309.01028,       -2025.69590,        2774.69901,
        1711.21478,        1509.99797,

          -0.99274,           0.61858,          -0.47634,          -0.33034,

           0.00261,           0.01183,

          -0.00038,           0.11687,

           0.00994,          -0.01122,

           0.03482,          -0.01942,

          -0.11557,           0.38237,          -0.17826,           0.00830,

           0.01193,          -0.05469,

           0.01557,           0.01747,

           0.02730,          -0.01182,

          -0.11284,           0.12939,          -0.05621,          -0.01615,

           0.04258,           0.01058,

          -0.01723,           0.00963,

           0.20666,           0.11742,

           0.07830,          -0.02922,

          -0.10659,          -0.05407,           0.07254,          -0.13005,

          -0.02365,           0.24583,           0.31915,           1.27060,

           0.00009,          -0.21541,

          -0.55324,          -0.45999,          -1.45885,           0.86530,
           0.85932,           1.92999,

          -0.00755,          -0.00715,

          -0.02004,          -0.00788,

           0.01539,           0.00837,

           0.27652,          -0.50297,          -0.26703,          -0.28159,

           0.03950,           0.07182,

          -0.07177,           0.14140,           0.07693,           0.07564,

          -0.01316,          -0.01259,

           0.01529,           0.07773,

         -90.74225,        -378.15784,        -510.30190,         -52.35396,
         -89.15267,         415.56828,         181.52119,          54.01570,

          -0.01093,          -0.05931,

          -0.01344,          -0.02390,

           0.01432,          -0.02470,

          -0.01509,          -0.01346,

           0.03352,           0.02248,

           0.02588,          -0.00948,

           0.03610,           0.17238,

           0.02909,          -0.04065,

           0.00155,          -0.07025,

          -0.09508,           0.14487,           0.12441,           0.16451,

           0.00001,          -0.00005,

          -0.00982,          -0.01895,

          -0.16968,           0.36565,           0.20234,           0.17789,

          -0.04519,          -0.00588,

           0.01268,           0.00107,

         -56.32137,         -58.22145,         -80.55270,          28.14532,
          11.43301,          52.05752,          17.79480,          -2.61997,

          -0.00005,          -0.02629,

           0.01080,          -0.00390,

           0.00744,           0.03132,

           0.01156,          -0.01621,

           0.02162,           0.02552,

           0.00075,          -0.02497,

           0.02495,           0.00830,

           0.03230,           0.00103,

         -14.84965,          -4.50200,          -9.73043,           9.40426,
           4.08054,           5.38571,           1.53731,          -1.01288,

           0.21076,           1.74227,           0.79760,           0.39583,
           0.09879,          -0.16736,

          -0.00723,          -0.01536,

  };
  static final double martabb[] = {
        -364.49380,         -47.17612,        -554.97858,        -430.63121,
         596.44312,

          -3.94434,          -7.43169,          -0.06665,          -2.23987,
           0.10366,          -0.05567,

          -0.01463,           0.01908,

          -0.02611,          -0.00350,          -0.01057,          -0.00610,

          -0.00015,           0.00002,

           0.00010,           0.00033,           0.00007,          -0.00000,

          -0.00010,          -0.00004,

           0.00012,           0.00002,

          -0.00014,          -0.00048,          -0.00003,          -0.00007,

           0.00008,          -0.00005,

          -0.00043,          -0.00003,          -0.00010,          -0.00004,

           0.00001,           0.00001,

          -0.00003,          -0.00003,

           0.00004,           0.00007,

          -0.00041,           0.00031,

           0.00076,           0.00062,

           0.00001,          -0.00002,

           0.00035,           0.00053,           0.00026,           0.00019,

           0.00020,           0.00010,

           0.02936,           0.09624,          -0.01153,           0.01386,
           0.00551,          -0.00690,           0.00196,           0.00148,

          -0.00408,          -0.00673,          -0.00067,          -0.00152,
          -0.00014,          -0.00005,

           0.00000,           0.00005,

          -0.00116,           0.00276,          -0.00391,           0.00983,
          -0.01327,          -0.01986,

          -0.00003,           0.00001,

           0.01104,           0.00631,          -0.01364,           0.01152,

          -0.00439,           0.01103,          -0.00546,           0.00181,
          -0.00039,          -0.00083,

           0.00007,           0.00002,

          -0.00010,          -0.00008,

           0.00005,           0.00002,

          -0.00584,           0.00512,          -0.00722,          -0.00174,
           0.00101,          -0.00316,

          -0.02229,          -0.02797,          -0.10718,           0.05741,
           0.11403,           0.10033,

           0.00036,          -0.00022,

           0.00787,           0.01191,           0.01756,          -0.02121,

          -0.00169,          -0.00364,           0.00070,          -0.00051,

           0.01850,          -0.06836,           0.21471,           0.00162,
          -0.29165,           0.16799,

          -0.00002,           0.00011,

          -0.00075,          -0.00077,

          -0.00675,          -0.00814,           0.00029,          -0.00599,
           0.00107,           0.00013,

           0.00010,          -0.00002,

           0.00005,           0.00020,

           0.00355,           0.00306,

          -0.00013,          -0.00061,

          -0.02950,          -0.00847,           0.01037,          -0.04783,
           0.04237,           0.11662,

          -0.00331,           0.00207,          -0.00107,          -0.00264,
           0.00072,          -0.00023,

          -0.00151,           0.00146,

          -0.12847,           0.02294,           0.03611,           0.19705,
           0.16855,          -0.28279,

          -0.00000,          -0.00002,

          -0.00525,          -0.03619,           0.05048,          -0.00481,
          -0.00745,           0.04618,

           0.00286,           0.00443,           0.00521,          -0.00351,

           0.00200,           0.00474,          -0.00149,           0.00031,
          -0.00003,           0.00029,

           0.00686,           0.02467,           0.04275,          -0.02223,

           0.02282,          -0.04228,           0.03312,           0.01847,
          -0.01253,           0.01601,

           0.00076,           0.00091,

           0.00045,           0.00035,

           0.00658,           0.01586,          -0.00310,           0.00628,
          -0.00045,           0.00316,

          -0.01602,          -0.00340,          -0.01744,           0.04907,
           0.06426,           0.02275,

          -0.00217,          -0.00377,          -0.00091,           0.00037,

           0.00040,          -0.00003,

          -0.00017,          -0.00027,

           0.00366,           0.02693,          -0.00934,           0.00386,

           0.00616,          -0.00037,

           0.02028,           0.02120,          -0.01768,           0.02421,
           0.00102,           0.00877,

           0.00012,           0.00030,

          -0.00019,          -0.02165,           0.01245,          -0.00742,
           0.00172,           0.00320,

          -0.17117,          -0.12908,          -0.43134,           0.15617,
           0.21216,           0.56432,

           0.01139,          -0.00937,          -0.00058,          -0.00337,

          -0.00999,           0.01862,          -0.00621,          -0.00080,

          -0.00025,          -0.00140,

           0.09250,           0.01173,          -0.03549,           0.14651,
          -0.01784,           0.00945,

           0.00000,          -0.00006,

          -0.00500,           0.00086,           0.01079,          -0.00002,

          -0.00012,          -0.00029,

          -0.02661,           0.00140,          -0.00524,          -0.00460,

          -0.00352,          -0.00563,          -0.00277,          -0.00052,

          -0.10171,          -0.02001,

           0.00045,           0.00265,          -0.00082,           0.00160,

          -0.00302,          -0.00434,          -0.00022,          -0.00134,

           0.03285,           0.02964,          -0.05612,          -0.00668,
          -0.01821,           0.06590,

           0.00039,           0.00061,

          -0.13531,          -0.03831,

           0.02553,           0.02130,          -0.00336,           0.00468,

          -0.04522,          -0.05540,           0.00129,          -0.01767,
           0.00181,           0.00031,

          -0.00011,          -0.00034,

          -0.00146,           0.01101,

          -0.00030,           0.00240,          -0.00039,           0.00072,

          -0.01954,          -0.03822,           0.09682,          -0.04541,
          -0.01567,           0.09617,

          -0.03371,           0.33028,          -0.12102,           0.05874,
          -0.00990,          -0.02236,

           0.00109,           0.00158,

          -0.00482,           0.00019,

          -0.00036,           0.00004,

           0.00024,           0.00201,

           0.00017,           0.00011,

          -0.00012,           0.00002,

          -0.00323,          -0.01062,

          -0.00130,           0.00091,

           0.00056,          -0.00017,

           0.00774,           0.00601,           0.02550,           0.01700,

          -0.84327,           0.77533,          -0.71414,          -0.50643,

        -473.30877,       -1504.79179,        -458.52274,        -865.82237,
        -417.34994,        -681.03976,         765.50697,       -1653.67165,
        4427.33176,         710.53895,       -5016.39367,        4280.60361,

           0.33957,           0.38390,          -0.38631,           0.81193,

           0.00154,          -0.00043,

           0.01103,          -0.00017,

          -0.00046,           0.00221,

           0.00059,           0.00014,

           0.00160,           0.00475,

           0.06191,          -0.13289,           0.02884,          -0.00566,

          -0.01572,           0.23780,          -0.05140,          -0.03228,

          -0.00716,          -0.00978,          -0.01048,           0.01317,

          -0.01267,          -0.01198,           0.00037,          -0.00330,

          -0.02305,           0.00355,          -0.00121,          -0.00496,

          -0.04369,          -0.01343,           0.05347,          -0.12433,
           0.02090,           0.17683,

           0.00028,          -0.00490,

          -0.02778,          -0.05587,          -0.01658,           0.05655,

           0.00204,          -0.00092,           0.00020,           0.00014,

          -0.00603,          -0.03829,           0.00778,          -0.00588,

          -0.00266,           0.00097,

          -0.02158,          -0.07742,           0.09306,          -0.01827,
          -0.01048,           0.07885,

          -0.02485,          -0.02505,           0.00471,          -0.01026,

           0.06663,           0.01110,           0.00469,          -0.05347,

          -0.00016,          -0.00013,

           0.02622,           0.02273,          -0.01009,           0.01391,

          -0.01042,          -0.00444,

          -0.04293,          -0.00767,          -0.00154,          -0.01739,

           0.00353,          -0.00763,

          -0.00060,           0.00010,

          -0.00053,          -0.00146,

          -0.05317,           0.05760,          -0.01801,          -0.02099,

          -0.02611,          -0.01836,

          -0.00256,           0.00812,          -0.00145,           0.00054,

          -0.00008,           0.00015,

          -0.04087,           0.08860,          -0.05385,          -0.02134,

           0.02771,           0.02441,          -0.00234,           0.01571,
          -0.00260,           0.00097,

           0.10151,           0.49378,          -0.28555,           0.11428,

          -0.00286,           0.01224,           0.00160,           0.00069,

           0.00000,          -0.00040,

          -0.13286,           0.00448,

           0.01225,          -0.00568,           0.00341,           0.00224,

          -0.23483,          -0.07859,           0.30733,          -0.21548,

          -0.02608,           0.00756,

           0.09789,           0.02878,          -0.11968,           0.08981,

           0.02046,          -0.00888,

           0.02955,           0.01486,          -0.00981,           0.01542,

          -0.01674,          -0.01540,           0.00019,          -0.00449,

          -0.02140,           0.00638,           0.00112,          -0.00730,

          -0.08571,           0.13811,          -0.16951,          -0.02917,

          -0.03931,          -0.32643,

         -68.64541,         -81.00521,         -47.97737,          15.75290,
         181.76392,         -36.00647,         -48.32098,        -259.02226,
        -265.57466,         554.05904,

           0.09017,           0.18803,          -0.12459,           0.10852,

           0.00211,           0.00002,

           0.00304,          -0.00370,

           0.00174,           0.00279,

           0.00139,           0.00095,

           0.04881,           0.00262,          -0.01020,           0.03762,

           0.00987,           0.00612,

           0.00054,          -0.00036,

           0.00009,          -0.00094,

           0.02279,           0.01785,          -0.00778,           0.01263,

           0.00040,          -0.00112,

          -0.00452,          -0.00662,

           0.00483,          -0.00030,

          -0.00054,          -0.00205,

          -0.00052,          -0.00362,          -0.00215,          -0.00247,

           0.02893,          -0.01965,          -0.00004,           0.04114,

          -0.00284,          -0.00103,

           0.01827,          -0.07822,           0.18010,           0.04805,
          -0.21702,           0.18808,

           0.00095,          -0.00132,

          -0.01488,           0.00746,

           0.00198,           0.00190,

           0.01032,           0.03392,           0.04318,          -0.07332,

          -0.01004,           0.00787,

          -0.00308,          -0.01177,          -0.01431,           0.02659,

           0.00273,          -0.00374,

          -0.02545,           0.00644,

          28.68376,          13.74978,          29.60401,         -47.98255,
         -65.91944,         -18.48404,          -1.73580,          64.67487,

          -0.02492,           0.00104,

          -0.00829,          -0.00134,

           0.00077,           0.00005,

          -0.00513,           0.00403,

           0.00071,          -0.00047,

          -0.00023,          -0.00063,

           0.00120,           0.00370,

          -0.00038,          -0.00037,

           0.00080,          -0.00018,

           0.00866,           0.00156,          -0.01064,           0.02131,

           0.00000,          -0.00001,

           0.00038,          -0.00068,

          -0.00909,          -0.02187,          -0.02599,           0.05507,

          -0.00022,          -0.01468,

           0.00032,           0.00500,

           9.86233,          -2.85314,          -2.25791,         -13.83444,
         -12.38794,           3.79861,           2.76343,           6.63505,

           0.00066,           0.00007,

          -0.00016,          -0.00039,

           0.00014,           0.00059,

          -0.00031,          -0.00024,

          -0.00168,           0.00259,

           0.00007,          -0.00005,

          -0.00052,           0.00558,

           0.00110,           0.01037,

           1.59224,          -2.37284,          -2.00023,          -2.28280,
          -1.49571,           1.48293,           0.60041,           0.56376,

          -0.54386,           0.03568,          -0.10392,           0.31005,
           0.09104,           0.03015,

           0.00826,          -0.00524,

  };
  static final double martabr[] = {
        -816.07287,        -381.41365,         -33.69436,         177.22955,
           0.18630,

          -8.29605,         -11.15519,          -0.57407,          -3.53642,
           0.16663,          -0.06334,

          -0.03056,           0.02767,

          -0.04161,           0.03917,          -0.02425,           0.00204,

          -0.00034,           0.00023,

           0.00058,          -0.00111,           0.00039,          -0.00015,

           0.00006,          -0.00023,

           0.00237,           0.00191,

           0.00154,          -0.00029,           0.00009,           0.00011,

          -0.00041,           0.00037,

          -0.00010,          -0.00064,           0.00015,          -0.00005,

           0.00012,          -0.00003,

          -0.00034,           0.00026,

           0.00011,          -0.00007,

          -0.00158,           0.00087,

           0.00278,           0.00137,

           0.00024,          -0.00020,

           0.00530,          -0.00448,           0.00780,           0.00408,

           0.00062,           0.00035,

          -1.35261,           0.79891,          -0.81597,          -0.43774,
           0.14713,          -0.27415,           0.05298,           0.02230,

          -0.02089,          -0.01070,          -0.00374,           0.00342,
          -0.00142,           0.00270,

          -0.00039,           0.00063,

           0.16024,           0.27088,          -0.32127,           0.27467,
          -0.16615,          -0.24460,

          -0.00073,           0.00032,

          -0.05710,          -0.05265,          -0.06025,           0.05120,

          -0.05295,           0.23477,          -0.08211,           0.04575,
          -0.00769,          -0.01067,

          -0.00570,           0.00015,

          -0.00251,          -0.00140,

          -0.00131,          -0.00018,

          -0.12246,           0.15836,          -0.13065,          -0.03222,
           0.00795,          -0.04232,

          -0.36585,          -0.31154,           0.68504,          -0.96006,
           1.19304,           0.88631,

           0.00132,           0.00046,

           0.13105,           0.04252,           0.05164,          -0.06837,

          -0.01351,          -0.01458,           0.00376,          -0.00557,

           0.28532,          -0.17290,          -0.53946,          -0.79365,
          -0.95246,           0.74984,

           0.00019,           0.00132,

          -0.00163,          -0.00295,

          -0.40106,          -0.26573,          -0.00155,          -0.22655,
           0.04349,          -0.00376,

           0.00149,          -0.00001,

           0.00523,           0.00078,

           0.01203,           0.00558,

          -0.00708,           0.00520,

          -0.36428,          -1.28827,           1.50845,          -0.83063,
           0.58802,           0.89998,

          -0.55256,           0.01255,          -0.15169,          -0.26715,
           0.06061,          -0.04122,

          -0.00397,           0.00534,

          -0.52576,           1.22031,           1.44098,           0.92406,
           0.67214,          -0.85486,

          -0.00010,           0.00001,

           0.28820,          -0.84198,           0.78291,           0.00251,
           0.02398,           0.32093,

          -0.02331,           0.10109,          -0.07555,           0.03557,

          -0.61580,           0.43399,          -0.43779,          -0.26390,
           0.06885,          -0.13803,

           0.17694,           0.19245,           0.15119,          -0.05100,

           0.49469,          -0.45028,           0.33590,           0.15677,
          -0.04702,           0.10265,

          -0.00942,          -0.00580,

          -0.00555,          -0.00252,

          -0.32933,           0.92539,          -0.91004,          -0.04490,
          -0.01812,          -0.37121,

           0.34695,           0.50855,          -0.24721,           0.86063,
          -0.84747,           0.01983,

           0.01948,           0.02039,           0.00748,          -0.00727,

          -0.00271,           0.00220,

           0.00309,           0.00196,

           0.02030,           0.17201,          -0.03716,           0.02801,

           0.01871,           0.00002,

           0.31736,           1.17319,          -1.42245,           0.73416,
          -0.52302,          -0.85056,

           0.00522,          -0.00126,

           0.33571,           0.34594,          -0.07709,           0.21114,
          -0.04066,          -0.01742,

           1.72228,           1.46934,          -3.06437,           5.06723,
          -6.53800,          -3.55839,

          -0.06933,           0.13815,           0.03684,           0.03284,

          -0.04841,           0.09571,          -0.02350,           0.00418,

           0.01302,           0.00579,

           0.73408,           0.64718,          -1.37437,           2.04816,
          -2.70756,          -1.52808,

           0.00523,          -0.00166,

           0.25915,           0.06900,          -0.02758,           0.10707,

           0.00062,           0.00744,

          -0.08117,           0.04840,          -0.01806,          -0.00637,

           0.03034,          -0.12414,           0.03419,          -0.00388,

          10.92603,           0.48169,

          -0.01753,          -0.12853,          -0.03207,          -0.00801,

           0.03904,          -0.03326,           0.01033,           0.00366,

           0.17249,           0.20846,          -0.38157,           0.54639,
          -0.68518,          -0.36121,

          -0.01043,          -0.00186,

          -3.33843,          -0.16353,

           0.03462,           0.06669,          -0.01305,           0.01803,

          -0.22703,          -0.52219,           0.11709,          -0.19628,
           0.03410,           0.01741,

           0.00338,           0.00265,

           0.63213,           0.08944,

           0.00236,           0.01829,           0.00546,           0.00218,

           0.00073,          -0.72570,           0.63698,          -0.13340,
           0.04698,           0.29716,

          -0.13126,           1.27705,          -0.40980,           0.27400,
          -0.04525,          -0.05529,

          -0.03249,          -0.01696,

          -0.02314,          -0.00076,

           0.00510,           0.00764,

          -0.01847,          -0.01021,

           0.01688,          -0.00044,

           0.00531,          -0.00016,

          -0.01219,          -0.02903,

          -0.00361,           0.00299,

           0.00504,          -0.00153,

          -0.53625,          -0.32460,           0.10642,          -0.22070,

          -2.21651,          -0.66036,          -1.74652,          -2.08198,

       -6810.78679,         967.02869,       -3915.97140,         291.65905,
         372.99563,        1196.01966,        5108.01033,       -3172.64698,
       -7685.78246,      -12789.43898,      -17474.50562,        7757.84703,

           3.13224,           1.84743,          -0.38257,           2.40590,

           0.01860,          -0.01217,

           0.03004,           0.00278,

          -0.00125,           0.00579,

          -0.02673,          -0.00112,

           0.00662,           0.01374,

          -0.02729,           0.13109,          -0.02836,           0.00877,

           0.12171,          -0.27475,           0.34765,           0.15882,

          -0.12548,           0.02603,           0.00710,           0.06538,

          -0.04039,          -0.03257,          -0.00186,          -0.00880,

           0.16643,           0.00707,           0.01918,           0.07156,

          -0.20459,          -0.85107,           1.01832,          -0.47158,
           0.32582,           0.63002,

          -0.00282,          -0.00711,

          -0.19695,           0.15053,           0.15676,           0.17847,

           0.00071,           0.00286,          -0.00039,           0.00083,

           0.02009,           0.17859,          -0.03894,           0.02805,

           0.02379,           0.00752,

           0.17529,          -0.57783,           0.53257,          -0.02829,
           0.03211,           0.21777,

           0.13813,           0.16305,          -0.02996,           0.06303,

           0.21058,          -0.02659,           0.02596,          -0.08808,

          -0.00389,           0.00586,

           0.08986,           0.09204,          -0.01480,           0.04031,

           0.06115,           0.18366,

           0.25636,           0.06905,           0.00719,           0.11391,

           0.00636,          -0.01113,

          -0.02808,           0.00150,

          -0.01219,           0.00832,

           0.28626,          -0.09573,           0.10481,           0.16559,

          -0.94578,           1.26394,

           0.08846,          -0.01623,           0.00082,          -0.02640,

          -0.00347,           0.00798,

           0.12873,          -0.21248,           0.27999,           0.14348,

           0.44082,           0.10453,           0.04362,           0.25332,
          -0.06077,           0.00555,

          -0.06947,          -0.05511,         -10.08703,          -0.10614,

           0.04059,           0.21355,           0.05632,           0.00871,

           0.01599,          -0.00531,

           0.36835,          -0.03530,

           0.09519,          -0.04961,           0.02568,           0.08613,

           0.57033,           0.84599,           1.27123,          -0.41266,

          -0.36937,          -0.00655,

          -0.16547,          -0.24000,          -0.35213,           0.13345,

           0.05870,          -0.01524,

           0.06419,           0.04136,          -0.00681,           0.02606,

          -0.02519,          -0.02732,          -0.00105,          -0.00677,

          -0.03891,           0.00106,           0.00087,          -0.02256,

          -0.20834,          -0.14624,          -0.23178,          -0.11786,

           0.32479,          -1.41222,

        -303.74549,        -202.79324,         260.20290,         184.84320,
         536.68016,        -881.56427,       -1125.64824,        -791.09928,
        -596.61162,         659.35664,

           0.24561,           0.39519,          -0.12601,           0.18709,

          -0.00700,           0.00136,

           0.30750,           0.00009,

           0.00443,           0.00384,

           0.01170,           0.02078,

           0.15043,           0.04802,           0.00386,           0.06942,

           0.02107,           0.00495,

          -0.01067,           0.00951,

           0.00937,           0.01996,

           0.04922,           0.04337,          -0.00583,           0.02110,

          -0.00691,           0.02793,

          -0.00364,          -0.00682,

          -0.09143,           0.15369,

           0.02043,           0.05451,

           0.04053,          -0.08179,           0.09645,           0.05330,

          -0.10149,          -0.01594,          -0.96773,           0.13660,

           0.17326,           0.00013,

           0.20990,          -0.23184,          -0.38407,          -0.64733,
          -0.84754,           0.38889,

           0.00310,          -0.00340,

           0.00970,          -0.00788,

          -0.01111,           0.00677,

           0.18147,           0.09968,           0.10170,          -0.09233,

          -0.03165,           0.01790,

          -0.04727,          -0.02364,          -0.02546,           0.02451,

           0.00442,          -0.00426,

          -0.02540,           0.00471,

         130.42585,         -31.30051,          17.99957,        -174.75585,
        -142.96798,         -27.89752,         -19.42122,          59.14872,

          -0.01899,           0.00388,

          -0.01265,           0.00694,

           0.01966,           0.01140,

          -0.00439,           0.00503,

          -0.01867,           0.02826,

           0.00752,           0.02012,

          -0.14734,           0.01909,

           0.03312,           0.02327,

           0.05843,           0.00061,

          -0.06958,          -0.05798,          -0.09174,           0.06242,

           0.00003,           0.00001,

           0.00670,          -0.00305,

          -0.13637,          -0.06058,          -0.06372,           0.07257,

           0.00209,          -0.01369,

          -0.00044,           0.00355,

          17.90079,         -17.48270,          -8.77915,         -24.54483,
         -15.67123,           3.62668,           0.52038,           5.13220,

           0.02574,           0.00003,

           0.00339,           0.00919,

          -0.02778,           0.00464,

           0.01429,           0.01003,

          -0.01661,           0.01327,

           0.02216,           0.00034,

          -0.00389,           0.01076,

          -0.00035,           0.00983,

           1.23731,          -4.18017,          -2.61932,          -2.66346,
          -1.45540,           1.10310,           0.23322,           0.40775,

          -0.43623,           0.06212,          -0.09900,           0.19456,
           0.03639,           0.02566,

           0.00309,          -0.00116,

  };

  static final byte marargs[] = {
  (byte)0,  (byte)4,
  (byte)3,  (byte)4,  (byte)3, (byte)-8,  (byte)4,  (byte)3,  (byte)5,  (byte)2,
  (byte)3,  (byte)5,  (byte)2, (byte)-6,  (byte)3, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)3, (byte)12,  (byte)3,(byte)-24,  (byte)4,  (byte)9,  (byte)5,  (byte)0,
  (byte)3,  (byte)2,  (byte)2,  (byte)1,  (byte)3, (byte)-8,  (byte)4,  (byte)1,
  (byte)3, (byte)11,  (byte)3,(byte)-21,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-7,  (byte)3,  (byte)4,  (byte)4,  (byte)0,
  (byte)3,  (byte)7,  (byte)3,(byte)-13,  (byte)4, (byte)-1,  (byte)5,  (byte)1,
  (byte)3,  (byte)1,  (byte)3, (byte)-2,  (byte)4,  (byte)2,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)2, (byte)-8,  (byte)3, (byte)12,  (byte)4,  (byte)1,
  (byte)3,  (byte)1,  (byte)4, (byte)-8,  (byte)5,  (byte)4,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)4, (byte)-7,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)4, (byte)-9,  (byte)5,  (byte)7,  (byte)6,  (byte)0,
  (byte)1,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)3, (byte)-2,  (byte)4,  (byte)1,  (byte)5,  (byte)0,
  (byte)3,  (byte)3,  (byte)3, (byte)-6,  (byte)4,  (byte)2,  (byte)5,  (byte)1,
  (byte)3, (byte)12,  (byte)3,(byte)-23,  (byte)4,  (byte)3,  (byte)5,  (byte)0,
  (byte)2,  (byte)8,  (byte)3,(byte)-15,  (byte)4,  (byte)3,
  (byte)2,  (byte)1,  (byte)4, (byte)-6,  (byte)5,  (byte)2,
  (byte)3,  (byte)2,  (byte)2, (byte)-7,  (byte)3,  (byte)7,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-3,  (byte)4,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)0,
  (byte)1,  (byte)1,  (byte)6,  (byte)1,
  (byte)2,  (byte)9,  (byte)3,(byte)-17,  (byte)4,  (byte)2,
  (byte)3,  (byte)2,  (byte)3, (byte)-4,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)3,  (byte)2,  (byte)3, (byte)-4,  (byte)4,  (byte)1,  (byte)5,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-6,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)3, (byte)-2,  (byte)4,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)1,  (byte)1,  (byte)5,  (byte)2,
  (byte)3,  (byte)4,  (byte)3, (byte)-8,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)3,(byte)-13,  (byte)4,  (byte)2,
  (byte)2,  (byte)3,  (byte)2, (byte)-9,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)1,  (byte)3,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-5,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-4,  (byte)4,  (byte)2,
  (byte)2,  (byte)6,  (byte)3,(byte)-11,  (byte)4,  (byte)2,
  (byte)2,  (byte)4,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)5,  (byte)2,
  (byte)3,  (byte)1,  (byte)4, (byte)-3,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-6,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)4, (byte)-4,  (byte)5,  (byte)1,
  (byte)2,  (byte)5,  (byte)3, (byte)-9,  (byte)4,  (byte)2,
  (byte)1,  (byte)3,  (byte)5,  (byte)1,
  (byte)2,  (byte)4,  (byte)3, (byte)-8,  (byte)4,  (byte)2,
  (byte)3,  (byte)1,  (byte)4, (byte)-4,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)4, (byte)-1,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-7,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)4, (byte)-3,  (byte)5,  (byte)2,
  (byte)3,  (byte)1,  (byte)4, (byte)-5,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)3,  (byte)1,  (byte)4, (byte)-4,  (byte)5,  (byte)3,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)4, (byte)-3,  (byte)5,  (byte)1,  (byte)6,  (byte)0,
  (byte)2,  (byte)5,  (byte)3,(byte)-10,  (byte)4,  (byte)1,
  (byte)1,  (byte)4,  (byte)5,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-5,  (byte)4,  (byte)2,
  (byte)3,  (byte)1,  (byte)4, (byte)-3,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-5,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)4, (byte)-2,  (byte)5,  (byte)2,
  (byte)3,  (byte)1,  (byte)4, (byte)-4,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)2,  (byte)6,  (byte)3,(byte)-12,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)4, (byte)-4,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-3,  (byte)4,  (byte)2,
  (byte)2, (byte)10,  (byte)3,(byte)-18,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-3,  (byte)6,  (byte)1,
  (byte)3,  (byte)1,  (byte)4, (byte)-2,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)3,(byte)-14,  (byte)4,  (byte)1,
  (byte)3,  (byte)1,  (byte)4,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)4, (byte)-1,  (byte)5,  (byte)0,
  (byte)3,  (byte)1,  (byte)4, (byte)-3,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)3,  (byte)1,  (byte)4,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)4, (byte)-2,  (byte)6,  (byte)2,
  (byte)3,  (byte)1,  (byte)4, (byte)-2,  (byte)5,  (byte)3,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-7,  (byte)4,  (byte)1,
  (byte)2,  (byte)9,  (byte)3,(byte)-16,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)4, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-1,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)4, (byte)-2,  (byte)5,  (byte)4,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)2, (byte)-4,  (byte)4,  (byte)2,
  (byte)2,  (byte)8,  (byte)3,(byte)-16,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)4, (byte)-2,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)3, (byte)-5,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)3,  (byte)1,  (byte)4,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-1,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-1,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-7,  (byte)3,  (byte)3,  (byte)4,  (byte)0,
  (byte)3,  (byte)2,  (byte)2,  (byte)1,  (byte)3, (byte)-7,  (byte)4,  (byte)0,
  (byte)3,  (byte)1,  (byte)4,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)4,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)3,  (byte)4,  (byte)3, (byte)-7,  (byte)4,  (byte)3,  (byte)5,  (byte)1,
  (byte)1,  (byte)1,  (byte)4,  (byte)5,
  (byte)3,  (byte)4,  (byte)3, (byte)-9,  (byte)4,  (byte)3,  (byte)5,  (byte)1,
  (byte)3,  (byte)1,  (byte)4, (byte)-2,  (byte)5,  (byte)5,  (byte)6,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-7,  (byte)3,  (byte)5,  (byte)4,  (byte)0,
  (byte)3,  (byte)1,  (byte)3, (byte)-1,  (byte)4,  (byte)2,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)4,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)3,  (byte)3,  (byte)3, (byte)-7,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)8,  (byte)3,(byte)-14,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)2, (byte)-2,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)4,  (byte)1,  (byte)6,  (byte)1,
  (byte)2,  (byte)9,  (byte)3,(byte)-18,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)2, (byte)-5,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-3,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)4,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)4,  (byte)1,  (byte)5,  (byte)1,
  (byte)3,  (byte)4,  (byte)3, (byte)-9,  (byte)4,  (byte)2,  (byte)5,  (byte)1,
  (byte)2,  (byte)7,  (byte)3,(byte)-12,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-5,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-5,  (byte)4,  (byte)2,
  (byte)2,  (byte)6,  (byte)3,(byte)-10,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)4,  (byte)2,  (byte)5,  (byte)1,
  (byte)3,  (byte)2,  (byte)4, (byte)-5,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-7,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-8,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)4,  (byte)3,  (byte)5,  (byte)0,
  (byte)3,  (byte)2,  (byte)4, (byte)-4,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)4, (byte)-1,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-6,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-3,  (byte)5,  (byte)0,
  (byte)3,  (byte)2,  (byte)4, (byte)-5,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)3,  (byte)2,  (byte)4, (byte)-4,  (byte)5,  (byte)3,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-4,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-5,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)4, (byte)-2,  (byte)5,  (byte)1,
  (byte)3,  (byte)2,  (byte)4, (byte)-4,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-4,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)4, (byte)-3,  (byte)6,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-1,  (byte)5,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-2,  (byte)6,  (byte)0,
  (byte)1,  (byte)1,  (byte)3,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-1,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-5,  (byte)4,  (byte)1,
  (byte)2,  (byte)8,  (byte)3,(byte)-17,  (byte)4,  (byte)1,
  (byte)3,  (byte)2,  (byte)4,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)3,  (byte)4,  (byte)3, (byte)-6,  (byte)4,  (byte)3,  (byte)5,  (byte)1,
  (byte)3, (byte)10,  (byte)3,(byte)-17,  (byte)4,  (byte)3,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)4,  (byte)4,
  (byte)3,  (byte)4,  (byte)3,(byte)-10,  (byte)4,  (byte)3,  (byte)5,  (byte)1,
  (byte)2,  (byte)8,  (byte)3,(byte)-13,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-1,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)4,  (byte)1,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-4,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)4,  (byte)1,  (byte)5,  (byte)0,
  (byte)2,  (byte)7,  (byte)3,(byte)-11,  (byte)4,  (byte)0,
  (byte)2,  (byte)3,  (byte)4, (byte)-5,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-6,  (byte)4,  (byte)1,
  (byte)2,  (byte)6,  (byte)3, (byte)-9,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)3,  (byte)4, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-7,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-5,  (byte)4,  (byte)1,
  (byte)2,  (byte)3,  (byte)4, (byte)-3,  (byte)5,  (byte)1,
  (byte)2,  (byte)3,  (byte)3, (byte)-3,  (byte)4,  (byte)0,
  (byte)2,  (byte)3,  (byte)4, (byte)-2,  (byte)5,  (byte)2,
  (byte)3,  (byte)3,  (byte)4, (byte)-4,  (byte)5,  (byte)5,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-1,  (byte)4,  (byte)0,
  (byte)2,  (byte)3,  (byte)4, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)4, (byte)-1,  (byte)5,  (byte)1,
  (byte)2,  (byte)3,  (byte)4, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3,  (byte)1,  (byte)4,  (byte)1,
  (byte)2,  (byte)3,  (byte)4, (byte)-1,  (byte)6,  (byte)0,
  (byte)3,  (byte)4,  (byte)3, (byte)-5,  (byte)4,  (byte)3,  (byte)5,  (byte)0,
  (byte)1,  (byte)3,  (byte)4,  (byte)3,
  (byte)3,  (byte)4,  (byte)3,(byte)-11,  (byte)4,  (byte)3,  (byte)5,  (byte)0,
  (byte)1,  (byte)1,  (byte)2,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-3,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-5,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)4, (byte)-5,  (byte)5,  (byte)0,
  (byte)2,  (byte)6,  (byte)3, (byte)-8,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)4, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-6,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)4, (byte)-3,  (byte)5,  (byte)1,
  (byte)3,  (byte)6,  (byte)3, (byte)-8,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)4, (byte)-2,  (byte)5,  (byte)1,
  (byte)2,  (byte)4,  (byte)4, (byte)-1,  (byte)5,  (byte)0,
  (byte)2,  (byte)1,  (byte)3,  (byte)2,  (byte)4,  (byte)0,
  (byte)1,  (byte)4,  (byte)4,  (byte)3,
  (byte)2,  (byte)2,  (byte)2, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)7,  (byte)3, (byte)-9,  (byte)4,  (byte)0,
  (byte)2,  (byte)5,  (byte)4, (byte)-5,  (byte)5,  (byte)0,
  (byte)2,  (byte)6,  (byte)3, (byte)-7,  (byte)4,  (byte)0,
  (byte)2,  (byte)5,  (byte)4, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-5,  (byte)4,  (byte)0,
  (byte)2,  (byte)5,  (byte)4, (byte)-3,  (byte)5,  (byte)0,
  (byte)2,  (byte)5,  (byte)4, (byte)-2,  (byte)5,  (byte)0,
  (byte)1,  (byte)5,  (byte)4,  (byte)3,
  (byte)1,  (byte)6,  (byte)4,  (byte)2,
  (byte)1,  (byte)7,  (byte)4,  (byte)0,
 (byte)-1
  };
  /* Total terms = 201, small = 199 */
  static Plantbl mar404 = new Plantbl(
                               new short[]{0,  5, 12, 24,  9,  7,  3,  2,  0},
                               (short)5,
                               marargs,
                               martabl,
                               martabb,
                               martabr,
                               1.5303348827100001e+00
                              );
}


class SwemptabMer {
  /*
  First date in file = 1228000.50
  Number of records = 397276.0
  Days per record = 4.0
        Julian Years      Lon    Lat    Rad
   -1349.9 to  -1000.0:   0.42   0.18   0.16
   -1000.0 to   -500.0:   0.37   0.19   0.13
    -500.0 to      0.0:   0.35   0.17   0.12
       0.0 to    500.0:   0.34   0.15   0.10
     500.0 to   1000.0:   0.28   0.14   0.09
    1000.0 to   1500.0:   0.34   0.14   0.09
    1500.0 to   2000.0:   0.35   0.13   0.09
    2000.0 to   2500.0:   0.38   0.12   0.12
    2500.0 to   3000.0:   0.42   0.13   0.16
    3000.0 to   3000.8:  0.252  0.087  0.115
  */
  static final double mertabl[] = {
          35.85255,        -163.26379, 53810162857.56026,      908082.18475,

           0.05214,          -0.07712,

           1.07258,           0.04008,           0.49259,           0.00230,
           0.02324,           0.05869,

           0.24516,           0.22898,          -0.06037,           0.13023,

           0.00331,          -0.03576,

           0.06464,           0.00089,

           0.03103,           0.05078,

          -0.01133,           0.01520,

           0.14654,           0.07538,           0.25112,          -0.24473,
          -0.17928,          -0.53366,

          -0.06367,           0.20458,          -0.42985,           0.14848,
          -0.35317,          -0.61364,

           0.00325,          -0.08617,          -0.23180,           0.08576,
           0.22995,           0.43569,

           1.92114,           2.89319,          -5.55637,           4.70329,
          -4.91411,          -5.45521,

           0.02607,           0.04468,

          -0.05439,           0.13476,          -0.07329,          -0.00985,

          -0.00278,           0.05377,

           0.07474,          -0.09658,           0.29818,           0.20422,
          -0.29074,           0.44962,

          -0.15411,          -0.04287,           0.29907,          -1.02948,
           3.62183,           0.84869,

          -0.08157,           0.02754,

          -0.03610,          -0.12909,           0.09195,          -0.04424,

          -0.08845,           0.09347,

          -0.27140,           0.08185,

           0.24783,           0.19543,          -0.25154,           0.41371,

          -0.00046,           0.01524,

           0.04127,           0.06663,

           0.43023,           0.11790,

           0.04427,           0.05329,

           0.00411,          -0.71074,

          -0.07111,          -0.09824,

           0.01264,          -0.02075,

          -0.00068,          -0.01678,

           0.01186,           0.00181,

           0.00302,          -0.21963,

          -0.06412,          -0.10155,          -0.36856,           0.20240,
           0.32282,           0.65133,

          -0.07178,          -0.01876,           0.13399,          -0.39522,
           1.28413,           0.33790,

           0.05040,          -0.01679,

          -0.00794,           0.01117,

           0.02630,           0.00575,

          -0.07113,          -0.11414,           0.16422,          -0.23060,
           0.35198,           0.05409,

           1.11486,          -0.35833,           0.87313,           1.66304,
          -1.28434,           0.72067,

           0.01400,           0.00971,

           0.21044,          -0.87385,           3.20820,           0.67957,

          -0.01716,           0.00111,

          -0.13776,          -0.02650,

          -0.06778,           0.00908,           0.00616,          -0.04520,

          -0.31625,          -0.61913,

           0.36184,           0.09373,

           0.00984,          -0.03292,

           0.01944,           0.00530,

           0.00243,          -0.00123,

           0.01589,           0.02223,

          -0.02992,          -0.01086,

        4356.04809,       -5859.86328,        2918.27323,       -4796.67315,
         510.24783,       -1220.02233,         127.48927,         250.10654,
        3250.43013,        -904.27614,       -5667.40042,      -22634.00922,
      -82471.79425,       18615.92342,

           0.01941,           0.00372,

           0.01830,          -0.00652,

          -0.02548,          -0.01157,

           0.00635,           0.02343,

          -0.00980,           0.00961,

           0.12137,           0.10068,           0.16676,          -0.07257,

          -0.07267,          -0.13761,           0.25305,          -0.28112,

          -0.07974,           0.07866,

          -0.41726,           0.49991,          -1.55187,          -1.14150,
           1.54754,          -2.35141,

          -0.00862,           0.00808,

           0.00218,          -0.03726,

           0.06914,          -0.08986,

          -0.00501,           2.09577,

          -0.01409,          -0.01842,

           0.04138,           0.05961,

          -0.12276,          -0.04929,

          -0.03963,          -0.06080,

          -0.27697,          -0.09329,

          -0.01011,           0.00295,

          -0.01374,           0.01328,

          -0.00171,           0.25815,

           0.01446,           0.00782,

           0.17909,          -0.04683,

           0.03765,          -0.04990,

           0.00036,           0.00528,

           0.05508,          -0.01369,

          -0.11751,          -0.10624,          -0.14448,           0.10522,

          -0.00884,           0.43006,

           0.01162,           0.01659,

          -0.00076,           0.10143,

           0.55779,           0.05510,           0.12350,          -0.34025,

           0.01320,           0.92985,
          -0.00026,          -0.03426,

           0.01305,           0.00041,

           0.13187,          -0.11903,

           0.00058,           0.09877,

         -33.10230,         -41.96782,        -268.28908,         174.29259,
         731.20089,        1508.07639,        5223.99114,       -3008.08849,
       -3909.34957,       -9646.69156,

           0.02988,           0.03182,

           0.07149,           0.04513,

          -0.02356,          -0.01641,

          -0.03188,          -0.03711,           0.15084,          -0.22436,
           0.61987,           0.25706,

           0.02425,           0.01200,

          -0.05543,          -0.14435,          -0.53398,           0.10997,

           0.00465,          -0.01893,

           0.01260,          -0.01314,

           0.00650,          -0.05499,

          -0.06804,           0.01608,

           0.02134,           0.04160,

           0.00636,           0.01293,

          -0.03470,          -0.02697,

          -0.11323,           0.02409,

          -0.02618,           0.00827,

           0.01879,           0.16838,           0.08978,           0.01934,

          -0.23564,           0.05565,

           0.03686,           0.02644,

          -0.02471,           0.00558,

        -140.22669,        -120.40692,        -501.88143,         434.05868,
        1044.54998,        1162.72084,        1527.78437,        -882.37371,

          -0.00768,           0.02213,

          -0.04090,           0.16718,

          -0.05923,          -0.12595,

           0.01154,          -0.00025,

          -0.00776,          -0.01653,

          -0.01213,          -0.02773,

           0.00344,           0.02180,

          -0.02558,          -0.05682,

          -0.00490,           0.01050,

          38.75496,         -78.17502,        -189.90700,        -136.33371,
        -249.94062,         319.76423,         205.73478,         272.64549,

          -0.01132,          -0.01071,          -0.04607,          -0.00390,

           0.02903,          -0.02070,

           0.01326,          -0.00901,

          35.38435,           7.45358,          31.08987,         -70.52685,
         -92.13879,         -51.58876,         -51.80016,          48.98102,

          -0.00124,          -0.01159,

           0.47335,          13.71886,          23.71637,           5.55804,
          10.06850,         -25.65292,         -11.85300,         -10.20802,

          -4.72861,           1.27151,          -0.47322,           7.46754,
           6.99528,           1.79089,           2.05336,          -2.90866,

          -1.97528,           0.72236,          -0.25084,           1.90269,
           0.72127,           0.41354,

          -0.30286,          -0.53125,          -0.50883,          -0.01200,
          -0.08301,           0.18083,

          -0.04286,          -0.10963,          -0.04544,          -0.01645,

          -0.00013,          -0.00986,

  };
  static final double mertabb[] = {
          68.33369,         422.77623,       -2057.26405,       -2522.29068,

          -0.00030,          -0.00009,

           0.02400,          -0.06471,           0.02074,          -0.00904,
           0.00044,           0.00261,

          -0.00174,          -0.00088,          -0.00027,           0.00003,

           0.00005,          -0.00004,

          -0.00036,           0.00200,

           0.01432,           0.01199,

           0.00006,          -0.00004,

           0.00236,           0.00803,           0.01235,           0.00406,
          -0.03253,           0.00179,

          -0.00243,           0.00132,          -0.00352,           0.00011,
          -0.00146,          -0.01154,

           0.00824,          -0.01195,          -0.01829,          -0.00465,
           0.12540,           0.09997,

           0.00400,           0.00288,          -0.02848,           0.01094,
          -0.02273,          -0.07051,

           0.01305,           0.01078,

          -0.00119,           0.00136,          -0.00107,          -0.00066,

           0.00097,          -0.00315,

           0.00120,           0.00430,          -0.00710,          -0.00157,
           0.06052,          -0.04777,

           0.00192,          -0.00229,          -0.02077,           0.00647,
           0.06907,           0.07644,

          -0.00717,           0.00451,

           0.00052,          -0.00262,           0.00345,           0.00039,

          -0.00674,           0.00346,

          -0.02880,           0.00807,

           0.00054,           0.00206,          -0.01745,           0.00517,

          -0.00044,           0.00049,

           0.01749,           0.01230,

           0.01703,           0.01563,

           0.00934,           0.02372,

           0.01610,          -0.01136,

           0.00186,          -0.00503,

           0.00082,          -0.00673,

           0.00170,          -0.00539,

           0.00042,           0.00037,

           0.00415,          -0.00430,

           0.00258,          -0.00914,          -0.01761,          -0.00251,
           0.15909,           0.13276,

           0.02436,          -0.00791,           0.00491,           0.03890,
          -0.02982,           0.05645,

          -0.00003,           0.00427,

          -0.00363,           0.00221,

           0.00077,           0.00130,

           0.00131,          -0.00071,           0.00796,           0.00453,
           0.01186,           0.01631,

           0.12949,          -0.02546,           0.03613,           0.32854,
          -0.43001,           0.01417,

           0.00034,           0.00095,

          -0.03268,           0.04034,           0.11407,           0.15049,

          -0.00079,          -0.00052,

          -0.04009,           0.00988,

          -0.00259,          -0.00085,           0.00221,          -0.00133,

           0.00003,          -0.01733,

           0.01055,           0.01976,

           0.00222,           0.00085,

           0.00089,           0.00087,

           0.00014,           0.00001,

           0.00145,           0.00802,

           0.00122,           0.00068,

         947.79367,       -1654.39690,         542.00864,       -1281.09901,
          90.02068,        -318.36115,         -87.67090,          92.91960,
         376.98232,        -419.10705,        5094.60412,        2476.97098,
      -18160.57888,       16010.48165,

           0.00621,          -0.00128,

           0.00186,          -0.00153,

          -0.00790,           0.00011,

          -0.00032,           0.00165,

          -0.00277,           0.00539,

           0.00552,           0.00682,           0.01086,          -0.00978,

          -0.02292,          -0.01300,           0.02940,          -0.04427,

          -0.02051,           0.04860,

          -0.05020,           0.29089,          -0.50763,          -0.04900,
           0.11177,          -0.41357,

          -0.00222,           0.00504,

          -0.00006,          -0.00459,

          -0.00175,          -0.02691,

           0.05921,           0.18938,

          -0.00181,          -0.00154,

           0.00322,           0.00586,

          -0.01098,          -0.00520,

          -0.00861,          -0.01342,

          -0.02694,          -0.00706,

          -0.00103,           0.00012,

          -0.00284,           0.00797,

           0.00743,           0.02523,

           0.00872,           0.00096,

           0.03155,          -0.01644,

           0.00414,          -0.00583,

           0.00029,           0.00066,

           0.00935,          -0.00619,

          -0.02498,          -0.01600,          -0.03545,           0.07623,

           0.01649,           0.06498,

           0.00148,           0.00209,

           0.00621,           0.02014,

           0.17407,          -0.05022,          -0.03485,          -0.17012,

           0.06164,           0.20059,

          -0.00804,          -0.01475,

           0.00296,          -0.00068,

           0.01880,          -0.03797,

           0.00608,           0.02270,

           5.89651,          -6.62562,         -37.41057,         -10.51542,
         -47.22373,          95.76862,         494.45951,          -5.37252,
       -3991.04809,       -2886.97750,

           0.01232,           0.00487,

           0.03163,           0.00561,

          -0.01847,          -0.00207,

          -0.10138,           0.01430,          -0.04269,          -0.22338,
           0.24955,          -0.02066,

           0.01119,          -0.00186,

           0.03416,           0.01805,          -0.12498,           0.10385,

          -0.00210,          -0.01011,

           0.00346,          -0.00682,

          -0.00683,          -0.02227,

          -0.01649,           0.01259,

           0.01392,           0.01174,

           0.00440,           0.00351,

          -0.02871,          -0.00375,

          -0.03170,           0.02246,

          -0.00833,           0.00596,
           0.04081,           0.06666,           0.05400,          -0.02387,

          -0.07852,           0.05781,

           0.01881,           0.00324,

          -0.00868,           0.00606,

          -6.52157,         -19.74446,         -72.46009,          43.12366,
         321.78233,         215.45201,         452.61804,       -1025.05619,

           0.00119,           0.01169,

           0.02239,           0.09003,

          -0.05329,          -0.03974,

           0.00688,          -0.00421,

          -0.00676,          -0.00515,

          -0.01171,          -0.00952,

           0.01337,           0.01270,

          -0.02791,          -0.02184,

           0.00058,           0.00679,

           8.42102,         -11.87757,         -49.07247,         -25.34584,
         -43.54829,         161.26509,         261.70993,          56.25777,

           0.00568,           0.00871,          -0.02656,           0.01582,

           0.00875,          -0.02114,

           0.00464,          -0.01075,

           9.08966,           1.37810,           3.44548,         -27.44651,
         -59.62749,          -0.73611,          -0.77613,          65.72607,

          -0.00664,          -0.00723,

           1.04214,           4.78920,          11.67397,          -1.84524,
          -4.16685,         -19.14211,         -16.14483,           3.02496,

          -1.98140,           1.16261,           1.81526,           4.21224,
           5.59020,          -2.55741,          -1.54151,          -3.85817,

          -1.08723,           1.23372,           1.12378,           1.51554,
           0.88937,          -0.57631,

          -0.50549,          -0.25617,          -0.37618,           0.42163,
           0.18902,           0.19575,

          -0.15402,          -0.04062,          -0.04017,           0.05717,

          -0.01665,          -0.00199,

  };
  static final double mertabr[] = {
          -8.30490,         -11.68232,          86.54880,        4361.05018,

           0.00002,          -0.00001,

          -0.01102,           0.00410,           0.00007,          -0.00276,
           0.00117,           0.00082,

           0.00049,           0.00007,           0.00003,          -0.00001,

           0.00012,           0.00005,

          -0.00186,          -0.00534,

          -0.03301,           0.01808,

           0.00008,           0.00005,

          -0.00394,           0.00202,           0.02362,          -0.00359,
           0.00638,          -0.06767,

           0.00422,          -0.00493,           0.00660,           0.00513,
          -0.00417,           0.00708,

           0.05849,          -0.00213,          -0.07647,          -0.16162,
          -0.30551,           0.13856,

          -0.02789,           0.01811,          -0.04155,          -0.06229,
           0.05729,          -0.03694,

          -0.03087,           0.01610,

          -0.00297,          -0.00167,           0.00041,          -0.00157,

          -0.00115,           0.00058,

           0.00796,           0.00436,          -0.01393,           0.02921,
          -0.05902,          -0.02363,

           0.00459,          -0.01512,           0.10038,           0.02964,
          -0.08369,           0.34570,

          -0.00749,          -0.02653,

           0.01361,          -0.00326,           0.00406,           0.00952,

          -0.00594,          -0.00829,

          -0.02763,          -0.09933,

          -0.04143,           0.05152,          -0.08436,          -0.05294,

          -0.00329,          -0.00016,

          -0.04340,           0.02566,

          -0.03027,           0.10904,

           0.03665,          -0.03070,

           0.23525,           0.00182,

           0.03092,          -0.02212,

           0.01255,           0.00777,

          -0.01025,           0.00042,

          -0.00065,           0.00440,

           0.08688,           0.00136,

           0.05700,          -0.03616,          -0.11272,          -0.20838,
          -0.37048,           0.18314,

           0.00717,          -0.02911,           0.15848,           0.05266,
          -0.13451,           0.51639,

           0.00688,           0.02029,

           0.00596,           0.00423,

          -0.00253,           0.01196,

           0.05264,          -0.03301,           0.10669,           0.07558,
          -0.02461,           0.16282,

          -0.18481,          -0.57118,           0.85303,          -0.44876,
           0.37090,           0.65915,

          -0.00458,           0.00660,

           0.41186,           0.09829,          -0.31999,           1.51149,

          -0.00052,          -0.00809,

           0.01384,          -0.07114,

          -0.00435,          -0.03237,           0.02162,           0.00294,

           0.29742,          -0.15430,

          -0.04508,           0.17436,

           0.01577,           0.00485,

          -0.00258,           0.00946,

           0.00061,           0.00119,

           0.01095,          -0.00788,

           0.00530,          -0.01478,

        2885.06380,        2152.76256,        2361.91098,        1442.28586,
         602.45147,         251.18991,        -121.68155,          71.20167,
         404.94753,        1607.37580,       11211.04090,       -2905.37340,
       -9066.27933,      -40747.62807,

          -0.00189,           0.00957,

           0.00332,           0.00907,

           0.00574,          -0.01255,

          -0.01134,           0.00291,

          -0.00666,          -0.00615,

          -0.04947,           0.06182,           0.03965,           0.08091,

           0.06846,          -0.03612,           0.13966,           0.12543,

          -0.05494,          -0.05043,

          -0.24454,          -0.20507,           0.56201,          -0.75997,
           1.15728,           0.76203,
          -0.00559,          -0.00536,

           0.01872,           0.00104,

           0.03044,           0.02504,

          -1.07241,          -0.00288,

           0.00950,          -0.00760,

          -0.03211,           0.02261,

           0.02678,          -0.06868,

           0.03008,          -0.02062,

           0.04997,          -0.15164,

          -0.00176,          -0.00580,

          -0.00730,          -0.00676,

          -0.13906,          -0.00089,

          -0.00362,           0.00817,

           0.02021,           0.07719,

           0.02788,           0.02061,

          -0.00274,           0.00016,

           0.00566,           0.02293,

           0.04691,          -0.05005,          -0.05095,          -0.06225,

          -0.19770,          -0.00456,

          -0.00848,           0.00595,

          -0.04506,          -0.00172,

          -0.01960,           0.22971,           0.14459,           0.04362,

          -0.40199,           0.00386,

           0.01442,          -0.00088,

          -0.00020,           0.00544,

           0.04768,           0.05222,

          -0.04069,          -0.00003,

          15.71084,         -12.28846,         -66.23443,        -109.83758,
        -586.31996,         311.09606,        1070.75040,        2094.34080,
        3839.04103,       -1797.34193,

          -0.01216,           0.01244,

          -0.01666,           0.02627,

           0.00687,          -0.01291,

           0.00939,          -0.01905,           0.09401,           0.05027,
          -0.09398,           0.23942,

          -0.00379,           0.00834,

           0.05632,          -0.01907,          -0.04654,          -0.21243,

           0.00255,           0.00179,

           0.00540,           0.00497,

           0.01427,           0.00243,

          -0.00697,          -0.02792,

          -0.01524,           0.00810,

          -0.00461,           0.00238,

           0.00899,          -0.01515,

          -0.01011,          -0.04390,

          -0.00447,          -0.00992,

          -0.06110,           0.00975,          -0.00261,           0.03415,

          -0.02336,          -0.08776,

          -0.00883,           0.01346,

          -0.00229,          -0.00895,

          42.18049,         -48.21316,        -148.61588,        -171.57236,
        -414.27195,         343.09118,         394.59044,         511.79914,

          -0.00911,          -0.00220,

          -0.06315,          -0.00988,

           0.04357,          -0.02389,

           0.00004,           0.00232,

           0.00581,          -0.00317,

           0.00948,          -0.00497,

          -0.00734,           0.00300,

           0.01883,          -0.01055,

          -0.00365,          -0.00126,

          24.18074,          12.28004,          43.18187,         -58.69806,
        -102.40566,         -79.48349,         -74.81060,          89.71332,

           0.00241,          -0.00135,          -0.00136,          -0.01617,

           0.00818,           0.00873,

           0.00368,           0.00383,

          -2.25893,          10.18542,          20.73104,           9.07389,
          13.73458,         -29.10491,         -20.62071,         -10.63404,

           0.00382,          -0.00143,

          -3.77385,           0.12725,          -1.30842,           6.75795,
           7.94463,           1.79092,           1.24458,          -4.73211,

          -0.36978,          -1.25710,          -2.06373,           0.06194,
          -0.00509,           2.08851,           1.07491,           0.04112,

          -0.28582,          -0.51413,          -0.53312,           0.11936,
           0.04447,           0.23945,

           0.12450,          -0.11821,          -0.06100,          -0.12924,
          -0.05193,           0.02219,

           0.01977,          -0.02933,          -0.00771,          -0.01077,

           0.00109,          -0.00273,

  };

  static final byte[] merargs={
    (byte)0,  (byte)3,
    (byte)3,  (byte)1,  (byte)1,(byte)-10,  (byte)3, (byte)11,  (byte)4,(byte)0,
    (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)2,
    (byte)3,  (byte)5,  (byte)1,(byte)-14,  (byte)2,  (byte)2,  (byte)3,(byte)1,
    (byte)3,  (byte)1,  (byte)1, (byte)-5,  (byte)2,  (byte)4,  (byte)3,(byte)0,
    (byte)1,  (byte)1,  (byte)6,  (byte)0,
    (byte)1,  (byte)2,  (byte)6,  (byte)0,
    (byte)3,  (byte)2,  (byte)1, (byte)-7,  (byte)2,  (byte)3,  (byte)3,(byte)0,
    (byte)1,  (byte)1,  (byte)5,  (byte)2,
    (byte)2,  (byte)1,  (byte)1, (byte)-4,  (byte)3,  (byte)2,
    (byte)1,  (byte)2,  (byte)5,  (byte)2,
    (byte)2,  (byte)2,  (byte)1, (byte)-5,  (byte)2,  (byte)2,
    (byte)1,  (byte)3,  (byte)5,  (byte)0,
    (byte)2,  (byte)4,  (byte)1,(byte)-10,  (byte)2,  (byte)1,
    (byte)2,  (byte)3,  (byte)1, (byte)-8,  (byte)2,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-3,  (byte)2,  (byte)2,
    (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)2,  (byte)2,
    (byte)1,  (byte)1,  (byte)3,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-7,  (byte)2,  (byte)1,
    (byte)2,  (byte)1,  (byte)1, (byte)-3,  (byte)3,  (byte)0,
    (byte)1,  (byte)1,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-4,  (byte)2,  (byte)1,
    (byte)2,  (byte)4,  (byte)1, (byte)-9,  (byte)2,  (byte)0,
    (byte)1,  (byte)2,  (byte)3,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)3,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-4,  (byte)2,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-1,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-6,  (byte)2,  (byte)0,
    (byte)1,  (byte)3,  (byte)3,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-7,  (byte)2,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)4,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-1,  (byte)3,  (byte)0,
    (byte)1,  (byte)2,  (byte)2,  (byte)2,
    (byte)2,  (byte)2,  (byte)1, (byte)-3,  (byte)2,  (byte)2,
    (byte)2,  (byte)4,  (byte)1, (byte)-8,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1,(byte)-10,  (byte)2,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-4,  (byte)5,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-3,  (byte)5,  (byte)2,
    (byte)2,  (byte)1,  (byte)1, (byte)-5,  (byte)2,  (byte)2,
    (byte)2,  (byte)1,  (byte)1, (byte)-5,  (byte)6,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)5,  (byte)1,
    (byte)3,  (byte)1,  (byte)1, (byte)-4,  (byte)5,  (byte)5,  (byte)6,(byte)0,
    (byte)1,  (byte)4,  (byte)3,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-3,  (byte)6,  (byte)1,
    (byte)2,  (byte)1,  (byte)1, (byte)-1,  (byte)5,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)6,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-1,  (byte)6,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)7,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-1,  (byte)7,  (byte)0,
    (byte)3,  (byte)4,  (byte)1,(byte)-14,  (byte)2,  (byte)2,  (byte)3,(byte)0,
    (byte)3,  (byte)1,  (byte)1,  (byte)2,  (byte)5, (byte)-5,  (byte)6,(byte)0,
    (byte)1,  (byte)1,  (byte)1,  (byte)6,
    (byte)3,  (byte)2,  (byte)1,(byte)-10,  (byte)3, (byte)11,  (byte)4,(byte)0,
    (byte)3,  (byte)1,  (byte)1, (byte)-2,  (byte)5,  (byte)5,  (byte)6,(byte)0,
    (byte)3,  (byte)6,  (byte)1,(byte)-14,  (byte)2,  (byte)2,  (byte)3,(byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)1,  (byte)6,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)2,  (byte)6,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)1,  (byte)5,  (byte)1,
    (byte)2,  (byte)2,  (byte)1, (byte)-4,  (byte)3,  (byte)1,
    (byte)2,  (byte)1,  (byte)1,  (byte)2,  (byte)5,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-5,  (byte)2,  (byte)2,
    (byte)2,  (byte)1,  (byte)1,  (byte)3,  (byte)5,  (byte)0,
    (byte)2,  (byte)5,  (byte)1,(byte)-10,  (byte)2,  (byte)0,
    (byte)1,  (byte)3,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-2,  (byte)2,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)1,  (byte)3,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-7,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-3,  (byte)3,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)1,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-4,  (byte)2,  (byte)0,
    (byte)2,  (byte)5,  (byte)1, (byte)-9,  (byte)2,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)2,  (byte)3,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-2,  (byte)3,  (byte)0,
    (byte)1,  (byte)4,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-1,  (byte)2,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-6,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-2,  (byte)4,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-1,  (byte)3,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)2,  (byte)2,  (byte)1,
    (byte)2,  (byte)3,  (byte)1, (byte)-3,  (byte)2,  (byte)0,
    (byte)2,  (byte)5,  (byte)1, (byte)-8,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-3,  (byte)5,  (byte)0,
    (byte)1,  (byte)5,  (byte)2,  (byte)1,
    (byte)2,  (byte)2,  (byte)1, (byte)-2,  (byte)5,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)4,  (byte)3,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-3,  (byte)6,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-1,  (byte)5,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-2,  (byte)6,  (byte)0,
    (byte)1,  (byte)2,  (byte)1,  (byte)4,
    (byte)2,  (byte)2,  (byte)1,  (byte)1,  (byte)5,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-4,  (byte)3,  (byte)0,
    (byte)2,  (byte)2,  (byte)1,  (byte)2,  (byte)5,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-5,  (byte)2,  (byte)2,
    (byte)2,  (byte)1,  (byte)1,  (byte)3,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-2,  (byte)2,  (byte)1,
    (byte)2,  (byte)3,  (byte)1, (byte)-3,  (byte)3,  (byte)0,
    (byte)2,  (byte)2,  (byte)1,  (byte)1,  (byte)2,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-4,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-2,  (byte)3,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-1,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-1,  (byte)3,  (byte)0,
    (byte)2,  (byte)2,  (byte)1,  (byte)2,  (byte)2,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-3,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-3,  (byte)5,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)5,  (byte)2,  (byte)1,
    (byte)2,  (byte)3,  (byte)1, (byte)-2,  (byte)5,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-1,  (byte)5,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-2,  (byte)6,  (byte)0,
    (byte)1,  (byte)3,  (byte)1,  (byte)3,
    (byte)2,  (byte)4,  (byte)1, (byte)-4,  (byte)3,  (byte)0,
    (byte)2,  (byte)5,  (byte)1, (byte)-5,  (byte)2,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-2,  (byte)2,  (byte)0,
    (byte)2,  (byte)5,  (byte)1, (byte)-4,  (byte)2,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-2,  (byte)3,  (byte)0,
    (byte)2,  (byte)5,  (byte)1, (byte)-3,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1,  (byte)5,  (byte)2,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-2,  (byte)5,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-1,  (byte)5,  (byte)0,
    (byte)1,  (byte)4,  (byte)1,  (byte)3,
    (byte)2,  (byte)6,  (byte)1, (byte)-5,  (byte)2,  (byte)1,
    (byte)2,  (byte)5,  (byte)1, (byte)-2,  (byte)2,  (byte)0,
    (byte)2,  (byte)5,  (byte)1, (byte)-2,  (byte)5,  (byte)0,
    (byte)1,  (byte)5,  (byte)1,  (byte)3,
    (byte)2,  (byte)7,  (byte)1, (byte)-5,  (byte)2,  (byte)0,
    (byte)1,  (byte)6,  (byte)1,  (byte)3,
    (byte)1,  (byte)7,  (byte)1,  (byte)3,
    (byte)1,  (byte)8,  (byte)1,  (byte)2,
    (byte)1,  (byte)9,  (byte)1,  (byte)2,
    (byte)1, (byte)10,  (byte)1,  (byte)1,
    (byte)1, (byte)11,  (byte)1,  (byte)0,
   (byte)-1
  };
  /* Total terms = 130, small = 128 */
  static Plantbl mer404=new Plantbl(
                            new short[]{11, 14, 10, 11,  4,  5,  2,  0,  0},
                            (short)6,merargs,mertabl,mertabb,mertabr,
                            3.8709830979999998e-01);
}

class SwemptabNep {
  /*
  First date in file = 625296.50
  Number of records = 16731.0
  Days per record = 131.0
        Julian Years      Lon    Lat    Rad
   -3000.0 to  -2499.7:   0.44   0.30   0.50
   -2499.7 to  -1999.7:   0.39   0.20   0.39
   -1999.7 to  -1499.7:   0.31   0.15   0.31
   -1499.7 to   -999.8:   0.32   0.19   0.36
    -999.8 to   -499.8:   0.29   0.15   0.29
    -499.8 to      0.2:   0.31   0.14   0.27
       0.2 to    500.2:   0.28   0.14   0.27
     500.2 to   1000.1:   0.34   0.15   0.39
    1000.1 to   1500.1:   0.31   0.16   0.31
    1500.1 to   2000.1:   0.33   0.16   0.29
    2000.1 to   2500.0:   0.38   0.21   0.36
    2500.0 to   3000.0:   0.43   0.25   0.46
    3000.0 to   3000.4:  0.122  0.071  0.260
  */
  static final double neptabl[] = {
       -1376.86480,         730.38970,    78655362.50948,     1095691.38676,

        -196.19023,        2086.77782,

        -122.04650,        -276.81592,

         184.56164,        -148.08924,

           3.39142,         -14.75027,

          -9.22741,           0.87688,

          -0.13903,          -0.44707,

          -0.17668,          -0.36299,

          -0.12682,          -0.26636,

          -0.51426,          -0.24667,

          -0.04965,          -0.03177,

           0.05050,          -0.00249,

          -0.80362,          -0.07363,          -0.15436,          -0.07180,

           2.45034,          -3.50145,           0.86698,           0.09777,

           7.72386,           7.16565,           2.10273,           8.86682,

           2.44705,          77.90155,

           0.28323,         -11.87157,         -13.64083,         252.70556,

          -4.94214,          -6.17988,        -305.60504,          51.23962,
       -2759.81719,        2476.20912,

          12.65762,          13.31543,

           0.36996,          -0.19077,           0.67363,           0.36737,

           0.02312,           0.02216,

           0.09953,           0.04777,

          -0.00572,          -0.02772,

          -0.02478,          -0.21920,

          -0.15289,          -1.50784,

          -0.17822,           0.34638,          -0.70473,          -8.61559,

          -2.65756,           1.25632,

          -0.31453,          -1.40348,          -4.02571,          -1.50467,
         -69.62308,           3.21315,

           0.69973,           0.08832,

          -0.00551,          -0.04964,

          -0.02264,          -0.34881,

           0.00762,          -1.85072,

           0.01407,          -0.30457,

          -0.09851,          -0.02372,

          -0.07729,          -0.11602,          -0.75995,          -0.71884,

          -0.08585,          -0.30406,           0.45818,           0.14921,

          -0.01033,          -0.11776,

           0.00640,          -0.57717,

          -0.01014,          -0.01357,          -0.00544,          -0.02168,

           0.40468,           0.28195,           0.00668,           0.14448,

           0.01245,          -0.08956,

          -0.26283,           0.01864,          -0.00641,          18.55347,

           0.01460,           0.08284,

          -0.04785,           0.11360,

          -0.33861,           0.01327,          -0.06392,          -0.18758,

           0.05449,          -0.05583,

          -0.00435,          -0.09869,

          -0.00286,          -0.04613,

          -0.00395,          -0.14564,

          -0.01385,          -0.01762,

           0.21160,          -0.61631,          -0.52100,          -0.04583,

           0.32812,           0.32138,

           0.04749,          -0.05724,

           0.11239,           0.13216,

          -0.01203,           0.40084,          -0.05207,          34.07903,

          -0.21457,          -0.34938,          -0.04594,           0.11198,

          -0.30662,          -0.20776,          -0.01076,          -0.10959,

           0.10891,          -0.10304,

          -0.28141,           0.25061,          -0.20293,           0.79930,

  };
  static final double neptabb[] = {
        -391.05987,        -243.95958,         -23.83558,          58.13857,

           5.04859,          -3.93183,

         -14.21914,           7.14247,

         -12.09415,          -9.70132,

           1.04307,           0.47323,

          -0.07504,           0.70575,

          -0.05239,           0.00482,

          -0.02916,           0.00877,

          -0.00528,          -0.00286,

           0.00028,          -0.00228,

          -0.00056,          -0.00149,

           0.00049,           0.00047,

          -0.18765,          -0.59571,           0.03742,          -0.14653,

           2.30535,           0.65092,           0.42216,           0.24521,

          -2.86932,           2.37808,          -0.58456,           0.27446,

          -1.12264,          -2.04413,

         -11.71318,          -1.41554,         -23.30671,         -24.70499,

           8.82738,          85.64657,         -90.02223,          22.42604,
       -4749.41359,       -4244.46820,

          25.20811,         -18.51469,

          -1.19892,          -0.61067,           0.67734,          -1.08912,

          -0.01607,           0.00626,

          -0.00008,           0.00126,

          -0.00330,          -0.00078,

          -0.01503,           0.00758,

          -0.13208,          -0.00218,

          -0.04522,           0.20297,          -0.94708,          -0.77897,

          -2.74075,          -3.01122,

          -1.03394,           0.00886,           1.55485,          -4.68416,
          -0.13244,         -57.26983,

           0.05589,          -0.55396,

          -0.00130,           0.00526,

          -0.01028,           0.02086,

           0.01334,           0.00699,

           0.08565,           0.02020,

           0.01001,          -0.08402,

           0.08558,          -0.04488,           0.57268,          -0.59574,

           0.00807,           0.00492,           0.21993,          -0.18949,

          -0.00396,           0.00735,

           0.00487,           0.00230,

           0.00699,          -0.00473,           0.01406,          -0.00139,

           0.00738,           0.00099,           0.00161,           0.00019,

          -0.00067,          -0.00047,

           0.00572,          -0.00486,          -0.00842,           0.00322,

           0.00018,          -0.00109,

          -0.00272,           0.00112,

          -0.00041,           0.00763,           0.00211,           0.00118,

          -0.46842,          -0.17877,

           0.00209,          -0.00179,

           0.00090,          -0.00075,

           0.00618,           0.00610,

           0.00015,           0.00032,

          -0.00123,           0.00026,           0.00332,           0.00135,

           0.39130,          -0.34727,

           0.00015,          -0.00027,

          -0.00026,          -0.00052,

           0.00162,           0.00913,          -0.00697,           0.00308,

          -0.00333,          -0.00258,          -0.00117,           0.00035,

           0.00766,           0.00194,           0.00135,           0.00067,

          -0.41171,           0.24241,

           0.00106,           0.00025,           0.00013,          -0.00019,

  };
  static final double neptabr[] = {
        -767.68936,        -460.59576,         -52.41861,        -273.85897,

          59.52489,           1.85006,

         -39.64750,          23.63348,

         -34.60399,         -23.41681,

           2.74937,           1.55389,

           0.20343,           2.15502,

          -0.12846,           0.07199,

          -0.07555,           0.05582,

          -0.04354,           0.01546,

          -0.03931,           0.07623,

          -0.00491,           0.00661,

           0.00322,           0.01540,

          -0.06741,          -0.35343,           0.00469,          -0.08073,

           1.94975,           0.66376,           0.06137,           0.31426,

          -2.93841,           4.27732,          -4.00342,           1.11157,

         -36.87785,           1.24960,

           4.69573,           2.15164,        -114.24899,          -6.69320,

          12.99919,          -9.47795,         -21.82350,        -156.88624,
       -1237.19769,       -1379.88864,

           6.54369,          -6.20873,

          -0.14163,          -0.32700,           0.17937,          -0.34864,

           0.01393,          -0.01286,

           0.02876,          -0.05767,

           0.02210,          -0.00128,

           0.16495,          -0.01242,

           1.15915,          -0.10365,

          -0.33224,          -0.10045,           6.83719,          -0.27499,

          -0.31284,          -0.94332,

           1.63704,          -0.33318,           1.48134,          -1.32257,
           0.96498,          -8.31047,

          -0.00402,          -0.09441,

           0.04292,          -0.00444,

           0.30325,          -0.02012,

           1.67999,           0.00353,

           0.00467,           0.03556,

           0.01393,          -0.01229,

           0.01188,          -0.01390,           0.04615,          -0.03509,

           0.32423,          -0.12491,           0.13682,           0.15131,

           0.11221,          -0.01201,

           0.57239,           0.00093,

           0.02068,          -0.01162,           0.00647,          -0.00325,

           0.27010,          -0.42993,           0.14314,          -0.01353,

          -0.08757,          -0.00699,

           0.00199,           0.31873,          18.80329,           0.01681,

           0.08009,          -0.00998,

          -0.14421,          -0.15912,

           0.37208,           0.49744,           0.35144,           0.06582,

          -0.11501,          -0.14037,

           0.10352,          -0.00768,

           0.04826,          -0.00423,

           0.19850,           0.00310,

          -0.01780,           0.01350,

          -0.61106,          -0.20525,          -0.04388,           0.52143,

           0.19300,          -0.21446,

          -0.05749,          -0.04776,

           0.12877,          -0.10908,

           0.39821,           0.00627,          34.03956,           0.04392,

          -0.34455,           0.22015,           0.11743,           0.04638,

           0.20723,          -0.30447,           0.10976,          -0.01008,

          -0.20778,          -0.21822,

           0.24939,           0.27976,           0.79790,           0.20200,

  };

  static byte nepargs[] = {
  (byte)0,  (byte)3,
  (byte)2,  (byte)1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)3,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)3,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-8,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-6,  (byte)7,  (byte)6,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-5,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-4,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-2,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-9,  (byte)8,  (byte)1,
  (byte)2,  (byte)4,  (byte)7, (byte)-7,  (byte)8,  (byte)1,
  (byte)2,  (byte)3,  (byte)7, (byte)-5,  (byte)8,  (byte)1,
  (byte)2,  (byte)2,  (byte)7, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)7, (byte)-1,  (byte)8,  (byte)1,
  (byte)1,  (byte)1,  (byte)8,  (byte)2,
  (byte)2,  (byte)1,  (byte)7, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-5,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)6, (byte)-6,  (byte)7,  (byte)5,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-5,  (byte)7,  (byte)3,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-8,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-2,  (byte)8,  (byte)1,
  (byte)1,  (byte)1,  (byte)7,  (byte)0,
  (byte)1,  (byte)2,  (byte)8,  (byte)2,
  (byte)2,  (byte)1,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)1,  (byte)3,  (byte)8,  (byte)1,
  (byte)2,  (byte)1,  (byte)6, (byte)-2,  (byte)8,  (byte)1,
  (byte)2,  (byte)5,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)1,  (byte)4,  (byte)8,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-1,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)6,  (byte)1,  (byte)7, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-1,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)6, (byte)-1,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)1,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-5,  (byte)8,  (byte)1,
  (byte)1,  (byte)1,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-1,  (byte)8,  (byte)1,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-5,  (byte)6, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7,  (byte)5,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)7,  (byte)1,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)1,  (byte)8,  (byte)1,
  (byte)1,  (byte)1,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-1,  (byte)8,  (byte)1,
 (byte)-1
  };
  /* Total terms = 59, small = 58 */
  static Plantbl nep404 = new Plantbl(
                               new short[]{0,  0,  0,  0,  3,  8,  7,  9,  0},
                               (short)3,
                               nepargs,
                               neptabl,
                               neptabb,
                               neptabr,
                               3.0110386869399999e+01
  );
}

class SwemptabPlu {
  /*
  First date in file = 625296.50
  Number of records = 16731.0
  Days per record = 131.0
        Julian Years      Lon    Lat    Rad
   -3000.0 to  -2499.7:   1.17   0.90   0.83
   -2499.7 to  -1999.7:   0.57   0.51   0.58
   -1999.7 to  -1499.7:   0.63   0.39   0.40
   -1499.7 to   -999.8:   0.40   0.45   0.41
    -999.8 to   -499.8:   0.42   0.22   0.30
    -499.8 to      0.2:   0.41   0.24   0.35
       0.2 to    500.2:   0.58   0.24   0.26
     500.2 to   1000.1:   0.47   0.35   0.33
    1000.1 to   1500.1:   0.43   0.31   0.28
    1500.1 to   2000.1:   0.37   0.40   0.35
    2000.1 to   2500.0:   0.46   0.35   0.39
    2500.0 to   3000.0:   1.09   0.70   0.46
    3000.0 to   3000.4:  0.871  0.395  0.051
  */
  static final double plutabl[] = {
    74986469.33577,   100898343.73690,    48199471.54076,     9520076.03177,
      690431.67340,     -427355.12716,    52266623.77862,      860190.70714,

         -21.08511,        -143.39295,

        -126.71124,          48.18528,

         -88.74508,          40.50942,

          51.29367,         -10.24075,

           0.63094,          32.03258,

        -410.00781,         399.90234,        -116.54319,          51.50329,

         116.84565,         687.76781,         -13.38605,         182.70107,

       -1668.12226,       -5162.22648,        -585.68297,       -2247.56041,
         -20.95875,        -193.13703,

         -57.12097,         -10.35058,

       -1778.01442,       -6463.73779,        -657.86093,       -2713.44436,
         -41.32560,        -211.82042,

        -107.16513,         -36.58628,

    97929588.08231,   -33582903.63417,   143382679.31770,   -47411568.92345,
    79428827.73581,   -24658834.87499,    19861233.17488,    -5755585.62084,
     1995060.95931,     -693507.08147,      135176.31467,      109360.38672,
       -8188.00598,       -1680.95072,       71020.19608,      -70785.39049,

         -24.56034,         -20.34919,

        1618.45976,       -2079.48538,         635.62954,        -850.87068,
          44.95257,         -64.04459,

         -18.61475,          -1.77734,

           9.38079,           5.19958,

       17422.08783,       -4872.53852,       10985.76629,       -1137.68569,
        1771.28893,         288.93745,          40.22664,          37.90027,

           6.81361,         -32.65868,

          16.97268,          11.76152,

          29.33024,         -12.92289,

         -55.13187,         -14.73791,

           7.52474,        -102.05060,

         182.53144,         -20.18960,

  -490237997.49400,   486646248.63360,  -781277018.26430,   602300460.57290,
  -463787999.46420,   249529525.96100,  -123964746.86420,    31353019.97807,
   -13353800.92159,    -3463382.63269,      -35469.17654,    -1035343.45385,
       65076.64025,      -38181.61312,      -16473.33813,        3928.44674,

         188.60263,        1000.42530,

     -208376.39376,     -700566.62363,      114839.84613,     -342407.71113,
       39467.04812,      -14553.84849,

      581895.26100,     1012499.16715,      406317.22416,      310804.78515,
       43625.07033,       -4157.26545,

       -5930.13795,       -2070.62413,

        3348.17582,      -10871.23729,

      144609.18550,       60383.63650,       27912.02226,       15254.61228,

      -98561.37758,      -67442.28158,      -15573.63338,      -19931.99773,

       24323.06905,      -37473.32558,        2840.64042,       -8911.23694,

      -19636.31898,       71725.21946,      -12280.54554,       12251.00101,

       88626.52260,        5513.68450,       18506.41546,       -6513.87434,

      -83350.14621,       44300.00743,      -22075.37353,        3731.57531,

      -29167.76020,      -21642.67384,

    56602666.72177,   -22225578.01823,    50576897.80669,   -50319847.79086,
     5689259.25622,   -29585299.79697,    -4249711.27661,    -4490830.29568,
     -727678.08724,      366050.85631,       19183.62792,       55647.98226,

        1897.78091,       -1091.03988,         432.38158,        -138.62556,

         101.38743,          25.67379,

         320.20735,         362.16615,          85.06067,          54.02616,

           2.39460,          18.70004,

          -8.43353,           2.72100,

          -3.11205,          -3.06201,

         136.31503,         -28.33620,          48.68781,         -18.45285,
           1.15302,          -1.52360,

          -0.13706,          -0.37489,

           0.08750,          -0.14579,

          -0.07051,          -0.06518,

           0.30237,          -0.00448,

           4.83172,           6.83684,

     1752447.78043,     -945086.75857,     2340978.12819,    -1963675.42559,
     1254147.25257,    -1274861.91191,      279459.60237,     -263954.01378,
       11835.62290,      -16344.44434,        9119.98960,       -2390.44218,
         -23.67909,          86.73916,        -642.78635,       -1290.12208,

          -0.43345,          -1.85348,

           0.03094,          -0.01655,

           0.12380,           0.31834,

           5.54756,          -1.63109,           1.10598,          -0.17578,

           2.66994,          -2.17573,           0.97360,          -0.92226,

          -0.18533,          -0.39747,

           0.45809,          -0.65286,

           0.26129,           0.91922,

           0.81068,           0.11183,

           6.32182,          14.16786,           0.20872,           3.28489,

          -1.47458,          -2.11724,

           1.70020,          -1.99889,

           3.13003,           1.90638,

    -4483669.52795,     -446454.90158,    -6586256.67478,     -671890.16779,
    -3620444.55554,     -499672.41074,     -855998.32655,     -191073.94266,
      -73186.69110,      -22649.38582,       -2414.81729,       -1294.40542,
         436.80907,         125.48109,         -81.16877,         458.86508,

         -11.57414,         -26.39114,          -4.00801,          -5.01054,

         -18.17569,          20.86879,          -4.80965,           3.10535,

          -4.71122,           1.18169,

          74.75544,         649.21464,         -26.55060,         272.35592,
          -8.06982,          16.86110,

         -26.54868,          26.75711,

         -35.82910,          38.51063,

          22.22814,          19.38336,

          -6.30462,           0.90602,

           0.62856,          -0.34981,

          -0.10232,          -0.00939,

           0.04439,          -0.18875,

           0.16025,           0.11306,

          -0.06803,           0.06004,

      -91305.66728,      262370.61704,     -194633.44577,      304838.17733,
     -124505.90904,       94111.75602,      -22317.18255,        1575.23438,
         748.66316,        -349.78711,         166.64450,         -89.05045,
         120.76207,        -100.26715,

           3.13806,           3.71747,

          -1.44731,          -0.35235,

          -0.51660,          -1.50621,

           2.81310,          -3.93573,           1.20292,          -0.36412,

          -0.03340,          -0.00561,

          -5.29764,          26.02941,           1.91382,           3.30686,
          -3.35265,          -3.20868,

           0.05807,          -0.11885,

          -0.78588,           0.34807,          -0.19038,           0.11295,

          -0.03642,          -0.03794,

           0.00251,           0.03449,

          -0.08426,          -0.00310,

           0.05297,          -0.09278,

           0.10941,           0.00099,

     -228688.56632,      312567.73069,     -331458.31119,      328200.19460,
     -143760.57524,      104182.01134,      -17313.30132,       12591.15513,
        -440.32735,        -105.67674,         104.35854,        -852.84590,
           0.95527,           0.30212,         -54.63983,           4.06948,

           0.07545,          -0.13429,

          16.21005,          29.24658,           9.23410,          50.48867,
          30.55641,          12.76809,           0.11781,           0.70929,
          -0.04100,          13.60859,

           0.04976,          -0.02083,

           0.36279,           0.30130,          -0.02129,           0.09363,

          -0.07812,           0.01570,

          -0.06217,          -0.37181,

      -29348.55031,       43889.87672,      -35765.41577,       33855.90070,
      -10128.69894,        4535.32148,         281.75353,        -218.49194,
          -7.55224,         134.28640,           2.11319,          -2.13109,
          15.71244,          11.07183,

          -0.05406,          -0.23337,

          -1.28949,           1.34281,

           0.04212,          -0.02080,

           0.08109,           0.14820,

       -6010.46564,        3639.41780,       -5973.16000,        1381.66999,
       -1177.36865,        -501.06937,         166.14792,        -103.36431,
          14.92766,           4.12877,          -2.20893,          -6.32033,

          -0.29038,          -0.43172,

          -0.59341,           0.20477,          -0.13143,          -0.03150,

           0.10992,           0.01976,

          -0.00254,           0.02028,

          -0.30044,          -0.44658,          -0.03409,          -0.10758,

           0.08349,           0.06153,

          -0.06055,           0.18249,

          -1.15341,          -8.68699,          -0.11348,          -3.30688,

           1.08604,           1.04018,

          -0.46892,          -0.69765,           0.21504,           0.01968,

          -0.00455,          -0.01678,

           3.95643,          -3.17191,           3.95220,          -2.12670,
           0.99305,          -0.16651,

           0.34839,          -0.49162,

           0.85744,           0.20173,          -0.00975,           0.20225,

          -0.02627,          -0.02281,

          -0.18002,          -0.01803,

          -0.06144,          -0.21510,

           0.15935,          -0.01251,

          -0.21378,           0.44806,          -0.01174,           0.05779,

           0.07646,          -0.19656,          -0.04044,          -0.02521,

           0.02996,           0.06169,

           0.16698,          -0.04710,          -0.06506,          -0.02114,

           0.05500,           0.00276,

           0.08433,           0.03160,

           0.08193,           0.35773,           0.05454,           0.10718,

          -0.02823,          -0.00839,

           0.54078,           0.49347,           0.09609,           0.11825,

          -0.16092,          -0.11897,

           0.09059,           0.08254,

           0.16712,           0.05860,

          -0.09547,          -0.03206,

           0.03876,           0.04719,

          -0.02345,           0.02240,

          -0.00609,          -0.00649,

           0.03859,           0.00077,

           0.47819,           0.26196,           0.09780,           0.08104,

          -0.16919,           0.05042,

          -0.42652,           0.30810,

          -0.03409,          -0.51452,

          -0.23120,          -0.01380,

          -0.01157,          -0.00143,

          -0.00512,          -0.01628,

          -0.00189,           0.00183,

          -0.01427,          -0.02861,

           0.00618,          -0.00015,

           0.13087,           0.13870,

           0.15158,          -0.21056,

          -3.94829,          -1.06028,          -1.36602,           0.77954,

           0.08709,          -0.03118,

         -44.74949,          91.17393,           8.78173,          45.84010,
           1.97560,         -15.02849,          -0.10755,          -0.02884,
           3.38670,           0.30615,

         130.92778,         -24.33209,          43.01636,         -40.81327,
         -19.43900,          22.18162,          -0.12691,           0.33795,
          -6.44790,          -6.23145,

           0.00319,           0.01141,

          -0.03252,           0.03872,

           0.04467,           0.01614,

          -0.00382,          -0.00019,

           0.05955,           0.01533,

          16.11371,          41.37565,          61.44963,           6.90615,
           1.41326,          -0.73920,          -0.03871,          24.81978,

          -0.10229,          -0.32775,          -0.05188,          -0.05628,

          -2.33618,           2.39053,

          -0.00584,           0.00436,

           0.20903,           0.02220,

          -0.01738,          -0.02765,

          -0.00217,           0.00613,

          -0.01772,           0.01903,

           0.07075,          -0.00530,

           0.15234,          -0.37760,          -0.11641,          -0.20102,

          -0.63675,           0.20525,          -0.15783,           0.58945,

          -0.06243,           0.04306,

  };
  static final double plutabb[] = {
   -35042727.30412,   -49049197.81293,   -25374963.60995,    -5761406.03035,
     -467370.57540,       14040.11453,        2329.15763,      -13978.69390,

          45.43441,          29.70305,

          32.33772,         -38.34012,

          26.43575,         -28.76136,

         -18.59040,          12.64837,

           5.56569,         -12.51581,

         248.37350,         -64.44466,          54.02618,           4.39466,

        -269.35114,        -290.63134,         -48.03841,         -52.83576,

        1508.94995,        1682.78967,         554.02336,         715.65819,
          34.37602,          58.44397,

          16.63685,          16.10176,

       -1069.51609,        2300.89166,        -437.16796,         927.89245,
         -33.17679,          68.74495,

          18.72022,          32.97640,

   -34004958.12619,   -17758805.77098,   -48416073.75788,   -24973405.03542,
   -25374996.23732,   -13351084.97340,    -5738294.54942,    -3082092.63350,
     -519989.39256,     -206440.89101,       44186.23548,      -87639.22630,
        2506.47602,        2327.01164,      -53878.47903,      -19670.13471,

           2.66934,          -3.86086,

         106.32427,         576.47944,          46.56388,         218.28339,
           4.35402,          15.04642,

           2.68717,          -2.86835,

           0.81728,          -2.34417,

       -1604.85823,       -1999.24986,        -631.47343,       -1382.19156,
         -15.74075,        -256.97077,           6.99648,          -4.54257,

           2.63478,           1.88838,

           0.17628,          -2.11518,

          -2.46735,          -1.48743,

           1.83456,           4.68487,

          -7.10919,           3.57046,

          -5.36342,          -7.70367,

    28395956.20816,   -37176795.74372,    48969952.83034,   -48145798.96248,
    31155823.23557,   -21163596.14822,     9057634.38260,    -3167688.51696,
     1167488.70078,      219103.97591,      -19017.97335,      107849.61195,
       -3814.43474,        4405.92120,        5800.13959,       12619.88708,

          22.18168,         -89.47801,

       52202.81929,       55119.44083,        5082.58907,       37955.06062,
       -3165.24355,        3316.67588,

     -113906.43970,      -69279.41495,      -57358.07767,      -10176.17329,
       -4179.79867,        2495.99374,

         787.87180,        -154.35591,

       -1148.62509,        1034.58199,

      -22194.95235,        3341.97949,       -4578.53994,         108.30832,

        7444.39789,       16646.40725,         509.75430,        3808.92686,

        -179.85869,        7408.76716,         340.65366,        1504.64227,

       -3783.09873,      -13505.60867,         875.74489,       -3181.27898,

      -16220.93983,        8041.37347,       -2631.07448,        2899.50781,

       18894.92095,      -20072.81471,        5925.05701,       -1947.91902,

       -6731.56601,        8014.52403,

     -987793.49463,     6491762.34471,     -279205.73643,     6117135.96868,
     -140925.91402,     2259422.06929,      114028.61646,      605600.90358,
       91858.00186,       56506.65187,        8949.15777,       -9782.67413,

        -394.66541,        -105.19208,         -76.54752,         -32.59411,

         -19.28741,          10.40013,

        -107.64003,          -7.36229,         -22.25126,           4.05952,

          -3.74402,          -2.79308,

           1.03337,          -2.13968,

           1.53794,          -0.02617,

          35.70756,          12.97733,          14.46213,           6.20518,
           1.79381,           1.65422,

          -0.31216,           0.29053,

          -0.03538,          -0.01584,

          -0.08934,           0.00079,

           0.05539,          -0.21591,

           2.86929,          -2.24724,

      320797.07455,       93342.16556,      -20903.39115,       79523.22083,
     -226588.37473,     -121017.23944,      -48472.25935,      -74195.36778,
       -7962.48081,       -4607.76339,       -4597.33274,       -7983.12541,
         -20.34500,          56.82999,       -1038.19507,         619.69624,

           1.08907,          -0.91278,

          -0.13391,           0.34956,

          -0.19982,          -0.18296,

          -0.97688,           2.36806,          -0.30127,           0.50980,

           0.96103,           1.96432,           0.43338,           0.87317,

           0.36997,          -0.01583,

          -0.44692,          -0.25159,

          -0.53525,           0.01154,

          -0.13231,           0.35562,

           3.88928,          -4.02882,           1.06967,          -0.56305,

          -0.45204,           0.77213,

          -0.82873,          -0.25854,

           0.21136,          -1.06696,

      458529.05491,      616790.47568,      698431.01349,     1124501.41713,
      300226.10339,      766533.33698,       26896.22954,      207880.75720,
        1116.29607,       21793.26153,        -850.64044,        3528.95568,
          29.61278,        -120.13367,         376.95131,          66.45758,

          -3.64868,           2.76062,          -0.85352,           0.95115,

           5.35056,           2.52803,           0.90026,           0.76403,

           0.43191,           0.83605,

         125.81792,         -39.65364,          50.14425,          -5.75891,
           2.78555,           2.05055,

          -4.27266,          -4.92428,

           6.78868,           5.73537,

           3.35229,          -3.70143,

           0.08488,           1.07465,

           0.10227,           0.06074,

           0.00291,           0.01522,

          -0.02274,           0.00297,

           0.01095,          -0.01856,

          -0.02862,           0.00178,

      143640.07486,         707.21331,      177163.08586,       53386.52697,
       56856.89297,       48268.74645,        1764.52814,        7711.76224,
         352.34159,        -968.03169,         -45.16568,         -81.60481,
         -76.35993,         -98.06932,

          -1.42185,           1.81425,

          -0.23427,           0.59023,

           0.57127,          -0.36335,

           1.89975,           0.66890,           0.28797,           0.43592,

          -0.03769,           0.03273,

          -6.06571,          -2.68515,          -0.55315,           0.86977,
           1.53840,          -0.59422,

          -0.05453,           0.02447,

          -0.12658,           0.22814,          -0.01715,           0.08497,

          -0.01288,          -0.00606,

           0.01547,          -0.00692,

           0.01157,           0.02407,

          -0.03883,           0.00835,

          -0.01542,          -0.04761,

      174386.39024,      158048.26273,      159192.81681,      220154.55148,
       33716.11953,       87537.86597,        -116.90381,        7535.83928,
        -962.06994,        -132.28837,        -644.90482,        -110.52332,
           3.42499,           3.74660,          -0.94008,          41.55548,

          -0.03824,          -0.05607,

          28.74787,         -37.31399,          30.87853,         -26.11940,
          10.79742,          -5.97905,           1.01237,          -0.04429,
           0.54402,           0.41905,

          -0.02440,          -0.03991,

          -0.00347,          -0.04362,          -0.00347,          -0.00469,

          -0.02707,           0.02761,

          -0.17773,          -0.11789,

       26475.02580,       35363.04345,       19877.11475,       41430.35940,
        2948.09998,       12983.41406,         281.93744,         570.70054,
         147.83157,          16.00090,          -1.62814,          -8.30846,
           9.29131,         -10.16496,

          -0.15799,           0.03843,

           1.44716,           0.46953,

          -0.02150,          -0.02502,

           0.08861,          -0.06690,

        2237.41551,        3739.08722,         753.74867,        3460.41553,
        -298.69226,         520.47031,         -33.62615,        -138.12767,
           3.61843,          -8.29860,          -4.56656,           0.79553,

           0.20041,          -0.25771,

          -0.35233,          -0.27913,          -0.02799,          -0.08328,

          -0.06889,          -0.16853,

           0.01701,          -0.00964,

          -0.37737,           0.18030,          -0.08525,           0.01906,

           0.05236,          -0.05155,

           0.11320,           0.05991,

          -5.66926,          -0.54402,          -2.08508,          -0.39407,

           0.82155,          -0.55975,

           0.39168,          -0.25551,           0.00623,           0.16162,

          -0.02519,           0.02420,

          -1.23293,          -3.19649,          -0.60519,          -2.79729,
           0.05362,          -0.61569,

          -0.25638,          -0.27033,

          -0.03987,           0.46623,          -0.12070,           0.00643,

           0.00849,          -0.00768,

          -0.03687,           0.10445,

          -0.13544,          -0.00592,

           0.02078,           0.09172,

           0.15824,           0.15815,           0.02020,           0.00747,

           0.10919,           0.09553,           0.01953,          -0.00135,

           0.04266,          -0.00218,

           0.02182,          -0.13742,          -0.01249,           0.01724,

          -0.02200,           0.02975,

          -0.01401,           0.03416,

          -0.28873,           0.04235,          -0.08137,           0.04223,

          -0.00326,           0.02144,

          -0.40423,           0.14281,          -0.08256,           0.02142,

           0.08116,          -0.03680,

          -0.02324,           0.07260,

          -0.06746,           0.11645,

           0.03233,          -0.05997,

          -0.03101,           0.02197,

          -0.00896,          -0.00491,

           0.00574,           0.00855,

           0.00052,           0.01209,

          -0.31828,           0.29955,          -0.08133,           0.04318,

           0.06787,          -0.08865,

          -0.13228,          -0.06507,

           0.34008,           0.06417,

          -0.00177,          -0.15116,

          -0.00553,          -0.01950,

           0.01144,          -0.00309,

          -0.00115,          -0.00153,

           0.02063,          -0.00791,

          -0.00314,           0.00493,

          -0.10614,           0.08338,

           0.08845,           0.20168,

           1.38955,          -2.52285,          -0.30475,          -1.05787,

           0.00580,           0.06623,

         -44.33263,         -47.70073,         -29.80583,          -8.77838,
           7.02948,           2.77221,           0.05248,          -0.13702,
          -0.78176,           1.77489,

         -16.32831,          46.68457,           2.54516,          21.78145,
          -5.09080,          -8.42611,          -0.24419,          -0.03315,
           2.80629,          -1.12755,

          -0.00402,           0.00053,

           0.00024,          -0.00043,

           0.00403,          -0.00210,

           0.00603,           0.00411,

          -0.00260,           0.00416,

           2.29235,           3.05992,           2.36465,          -0.58750,
           0.14030,           0.13523,           0.89998,           0.70156,

          -0.02188,           0.02003,          -0.00533,           0.00447,

           2.96411,           1.30183,

           0.01422,           0.00624,

          -0.10737,          -0.38316,

          -0.05968,           0.04379,

           0.01171,           0.01180,

          -0.00989,          -0.01375,

          -0.00845,           0.03782,

           0.09484,           0.09909,           0.07640,          -0.00898,

          -0.01076,           0.02760,           0.01630,           0.02198,

           0.05985,           0.04130,

  };
  static final double plutabr[] = {
    17990649.12487,    24806479.30874,    12690953.00645,     2892671.69562,
      249947.71316,       -5138.71425,        1142.68629,        6075.25751,

         -34.76785,         -19.72399,

         -15.81516,          30.47718,

         -11.73638,          21.87955,

           9.42107,         -10.40957,

          -5.59670,           6.85778,

        -167.06735,          -2.31999,         -32.42575,         -13.72714,

         130.16635,         117.97555,          31.33915,          39.64331,

       -1378.54934,        -395.83244,        -562.79856,        -167.74359,
         -45.12476,         -17.08986,

          -4.20576,         -16.56724,

        1762.12089,       -1148.86987,         736.55320,        -423.09108,
          56.13621,         -26.26674,

           9.77810,         -38.05151,

     4702224.98754,    27254904.94363,     5306232.25993,    39518429.29982,
     1725110.05669,    21833263.27069,       46010.62605,     5425411.66252,
       17238.09865,      536771.62156,      -61263.36051,       66270.70142,
        2084.66296,       -1936.71208,       35898.49503,       34885.28549,

           1.93276,          10.66292,

        -665.11445,           3.70467,        -265.68478,          16.16272,
         -19.45954,           2.32738,

           3.04237,           3.97339,

          -2.64312,           0.66308,

       -3207.68754,        3418.03720,       -2342.62310,        1729.15030,
        -450.84643,         179.00943,         -13.20367,          -1.86087,

          -4.95659,           7.22347,

          -5.08890,          -1.28891,

          -6.21713,           5.10551,

          13.97276,           0.44529,

           3.25177,          25.02775,

         -45.56672,          11.58470,

   124443355.55450,  -100018293.41775,   190506421.77863,  -118262753.40162,
   108199328.45091,   -45247957.63323,    27272084.41143,    -4125106.01144,
     2583469.66051,     1024678.12935,      -22702.55109,      199269.51481,
      -15783.14789,        5564.52481,        -427.22231,       -6330.86079,

         -97.50757,        -204.32241,

       -9060.54822,      156661.77631,      -47791.83678,       59725.58975,
       -8807.74881,         -92.38886,

      -28886.11572,     -244419.59744,      -53336.36915,      -92232.16479,
       -8724.89354,       -2446.76739,

         889.71335,         936.51108,

         494.80305,        2252.83602,

      -18326.60823,      -25443.13554,       -3130.86382,       -5426.29135,

       23494.08846,          91.28882,        4664.14726,        1552.06143,

       -8090.43357,        2843.48366,       -1445.73506,        1023.11482,

       11664.20863,       -7020.08612,        3100.21504,         -64.16577,

       -9724.97938,      -12261.47155,       -3008.08276,       -1523.06301,

        6788.74046,       10708.27853,         343.09434,        1701.52760,

       14743.99857,       -4781.96586,

   -15922236.41469,     1825172.51825,   -14006084.36972,    10363332.64447,
     -979550.91360,     6542446.18797,     1160614.26915,      570804.88172,
       89912.68112,     -171247.08757,      -13899.52899,       -6182.25841,

        -240.64725,         412.42581,         -66.24510,          71.30726,

         -15.81125,         -15.76899,

         -21.85515,        -102.12717,         -10.18287,         -19.38527,

           1.43749,          -3.87533,

           1.97109,           0.20138,

           0.32012,           1.02928,

         -40.22077,          20.80684,         -15.69766,           9.63663,
          -1.26010,           0.56197,

           0.08592,           0.18540,

          -0.07303,           0.03897,

           0.01438,          -0.08809,

           0.15479,           0.10354,

           0.19052,           2.08790,

      405480.24475,     -607986.83623,      582811.58843,     -915111.10396,
      258696.21023,     -493391.09443,       23403.62628,     -119503.67282,
       -4036.86957,       -9766.17805,        -663.93268,        2544.07799,
          40.36638,          76.26390,         246.67716,         -13.93440,

           0.12403,           0.25378,

           0.14004,          -0.08501,

           0.07904,           0.12731,

           1.02117,          -1.34663,           0.25142,          -0.26903,

           0.18135,          -0.57683,          -0.30092,          -0.36121,

          -0.09623,           0.05873,

          -0.05803,           0.02869,

          -0.01194,           0.04983,

           0.04250,           0.04894,

           1.34245,           0.70137,           0.24217,           0.25912,

          -0.32759,          -0.03575,

           0.06780,          -0.41277,

           0.43865,           0.17857,

     -763933.02226,      465658.17048,    -1082753.91241,      593319.68634,
     -553911.89340,      274748.95145,     -122250.71547,       56608.95768,
       -9914.17300,        2988.43709,         707.94605,        -765.01470,
          52.73260,         -34.22263,         -43.58300,         -38.43647,

          -4.95939,          -1.97173,          -1.04406,          -0.13072,

          -0.34281,           4.75202,          -0.35513,           0.93597,

          -0.54380,           0.70536,

          84.83116,         102.93003,          26.34884,          48.57746,
           0.02853,           2.91676,

          -8.07116,           1.66613,

          -2.07908,          11.62592,

           6.64704,           0.98291,

          -1.19192,           0.93791,

           0.18822,           0.00900,

          -0.03181,          -0.02000,

           0.02755,          -0.01398,

          -0.03971,          -0.03756,

           0.13454,          -0.04193,

      -18672.98484,       28230.75834,      -28371.58823,       26448.45214,
      -13352.09393,        7461.71279,       -2609.33578,         726.50321,
        -309.72942,         -86.71982,          12.48589,          -9.69726,
           1.82185,          14.92220,

          -0.04748,           0.42510,

          -0.20047,           0.00154,

           0.00176,          -0.26262,

           0.78218,          -0.73243,           0.23694,          -0.03132,

          -0.00290,          -0.03678,

          14.03094,           4.25948,           0.79368,          -0.78489,
          -2.30962,           2.31946,

           0.00158,          -0.04125,

          -0.01387,           0.28503,           0.00892,           0.05154,

           0.00184,          -0.01727,

          -0.00889,           0.03526,

          -0.00521,          -0.02093,

           0.00200,           0.04872,

          -0.02163,           0.00578,

       20699.27413,       -2175.57827,       31177.33085,        4572.02063,
       15486.28190,        8747.74091,        2455.51737,        3839.83609,
          51.31433,         507.91086,          15.90082,          44.75942,
          -0.98374,          -2.64477,           2.52336,          -3.09203,

          -0.08897,          -0.00083,

         -15.91892,           0.72597,          14.04523,          -3.16525,
           4.33379,         -30.82980,           0.40462,          -0.75845,
          13.14831,          -0.02721,

          -0.01779,           0.00481,

           0.42365,          -0.09048,           0.08653,           0.04391,

           0.00846,           0.01082,

          -0.04736,           0.02308,

        6282.21778,       -4952.70286,        7886.57505,       -5328.36122,
        3113.76826,       -1696.84590,         330.70011,        -155.51989,
         -18.31559,          -3.90798,          -3.11242,           1.87818,
          -1.05578,           0.11198,

           0.05077,          -0.01571,

           2.41291,           2.40568,

          -0.01136,          -0.00076,

          -0.00392,          -0.02774,

         634.85065,        -352.21937,         674.31665,        -260.73473,
         199.16422,         -28.44198,           6.54187,           6.44960,
          -1.55155,           0.29755,           0.16977,           0.17540,

          -0.02652,           0.03726,

          -0.00623,           0.11777,          -0.00933,           0.02602,

          -0.13943,          -0.24818,

           0.02876,          -0.01463,

          -0.07166,           0.06747,          -0.01578,           0.01628,

           0.00233,          -0.00686,

           0.00431,          -0.00276,

           0.21774,           0.09735,           0.07894,           0.07279,

          -0.01300,          -0.00268,

           0.10824,           0.09435,           0.00720,           0.02111,

          -0.01960,           0.06154,

           0.56867,          -0.07544,           0.18210,           0.06343,
          -0.00906,           0.01942,

          -0.00850,          -0.00351,

          -0.06988,           0.01713,          -0.01110,          -0.00663,

           0.00196,          -0.02064,

          -0.00008,           0.00043,

           0.00375,           0.00084,

          -0.00279,           0.00100,

           0.00271,          -0.02017,          -0.00074,          -0.00357,

           0.03793,          -0.10108,          -0.01083,          -0.03952,

           0.00030,           0.00012,

           0.01576,           0.01142,           0.00351,           0.00277,

           0.01409,          -0.00774,

          -0.00065,           0.01895,

           0.07350,          -0.02519,           0.01528,          -0.01057,

          -0.00099,          -0.00295,

           0.21347,          -0.17458,           0.04940,          -0.02757,

          -0.06243,           0.05203,

           0.01055,          -0.00109,

           0.00003,          -0.04201,

          -0.00263,           0.02387,

           0.00886,          -0.01168,

           0.00479,           0.00204,

          -0.00239,           0.00022,

          -0.00223,          -0.02029,

          -0.14130,          -0.15237,          -0.01827,          -0.04877,

           0.12104,           0.06796,

           0.16379,           0.31892,

          -0.15605,           0.07048,

          -0.00700,           0.07481,

          -0.00370,          -0.00142,

          -0.00446,           0.00329,

          -0.00018,           0.00117,

          -0.00910,           0.00510,

          -0.00055,          -0.00114,

           0.04131,          -0.04013,

          -0.13238,           0.02680,

          -0.10369,           1.38709,           0.35515,           0.41437,

          -0.01327,          -0.02692,

          38.02603,          13.38166,          15.33389,          -7.40145,
          -8.55293,          -0.13185,          -0.03316,           0.13016,
           0.04428,          -1.60953,

         -12.87829,         -76.97922,         -23.96039,         -22.45636,
          14.83309,          14.09854,           0.24252,           0.13850,
          -4.16582,           4.08846,

           0.00751,          -0.00051,

           0.03456,           0.02900,

           0.01625,          -0.04660,

           0.01390,          -0.00530,

           0.01665,          -0.04571,

          40.90768,         -14.11641,           7.46071,         -58.07356,
          -0.27859,          -1.33816,          23.76074,          -0.03124,

          -0.27860,           0.13654,          -0.04800,           0.05375,

           4.38091,           4.39337,

           0.02233,           0.00514,

          -0.25616,          -0.54439,

          -0.05155,           0.11553,

           0.02944,          -0.00818,

           0.00570,           0.00119,

          -0.00733,          -0.02700,

          -0.23759,          -0.08712,          -0.12433,           0.07397,

           0.20629,           0.60251,           0.56512,           0.14790,

           0.07778,           0.11614,

  };

  static byte pluargs[] = {
  (byte)0,  (byte)7,
  (byte)2,  (byte)3,  (byte)7, (byte)-9,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7,(byte)-12,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-8,  (byte)8,  (byte)0,
  (byte)3, (byte)-4,  (byte)7,  (byte)5,  (byte)8,  (byte)4,  (byte)9,  (byte)0,
  (byte)3,  (byte)3,  (byte)7, (byte)-5,  (byte)8, (byte)-1,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-8,  (byte)9,  (byte)1,
  (byte)2,  (byte)3,  (byte)8, (byte)-5,  (byte)9,  (byte)1,
  (byte)2,  (byte)1,  (byte)6, (byte)-9,  (byte)9,  (byte)2,
  (byte)3,  (byte)6,  (byte)7, (byte)-6,  (byte)8, (byte)-8,  (byte)9,  (byte)0,
  (byte)3,  (byte)4,  (byte)7,(byte)-10,  (byte)8,  (byte)4,  (byte)9,  (byte)2,
  (byte)2,  (byte)3,  (byte)7, (byte)-8,  (byte)9,  (byte)0,
  (byte)1,  (byte)1,  (byte)9,  (byte)7,
  (byte)2,  (byte)3,  (byte)7,(byte)-10,  (byte)9,  (byte)0,
  (byte)3,  (byte)4,  (byte)7,(byte)-10,  (byte)8,  (byte)2,  (byte)9,  (byte)2,
  (byte)3,  (byte)5,  (byte)7,(byte)-12,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-7,  (byte)9,  (byte)0,
  (byte)1,  (byte)1,  (byte)8,  (byte)3,
  (byte)2,  (byte)1,  (byte)6,(byte)-10,  (byte)9,  (byte)0,
  (byte)3,  (byte)6,  (byte)7,(byte)-12,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)3,  (byte)5,  (byte)7,(byte)-10,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)7,(byte)-13,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7,(byte)-10,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-7,  (byte)9,  (byte)0,
  (byte)1,  (byte)2,  (byte)9,  (byte)7,
  (byte)2,  (byte)3,  (byte)7,(byte)-11,  (byte)9,  (byte)0,
  (byte)3,  (byte)4,  (byte)7, (byte)-9,  (byte)8,  (byte)4,  (byte)9,  (byte)2,
  (byte)3,  (byte)3,  (byte)7, (byte)-5,  (byte)8,  (byte)1,  (byte)9,  (byte)2,
  (byte)2,  (byte)1,  (byte)6, (byte)-6,  (byte)9,  (byte)0,
  (byte)2,  (byte)7,  (byte)8,(byte)-13,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)8, (byte)-2,  (byte)9,  (byte)1,
  (byte)3,  (byte)1,  (byte)7, (byte)-5,  (byte)8,  (byte)2,  (byte)9,  (byte)1,
  (byte)3,  (byte)6,  (byte)7,(byte)-12,  (byte)8,  (byte)3,  (byte)9,  (byte)1,
  (byte)2,  (byte)5,  (byte)7,(byte)-12,  (byte)9,  (byte)1,
  (byte)2,  (byte)4,  (byte)7, (byte)-9,  (byte)9,  (byte)1,
  (byte)2,  (byte)2,  (byte)7, (byte)-3,  (byte)9,  (byte)1,
  (byte)1,  (byte)1,  (byte)7,  (byte)0,
  (byte)1,  (byte)3,  (byte)9,  (byte)5,
  (byte)2,  (byte)3,  (byte)7,(byte)-12,  (byte)9,  (byte)1,
  (byte)3,  (byte)5,  (byte)7, (byte)-9,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)3,  (byte)4,  (byte)7, (byte)-7,  (byte)8,  (byte)2,  (byte)9,  (byte)1,
  (byte)3,  (byte)3,  (byte)7, (byte)-5,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)3,  (byte)2,  (byte)7, (byte)-5,  (byte)8,  (byte)5,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-5,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)8, (byte)-1,  (byte)9,  (byte)2,
  (byte)2,  (byte)1,  (byte)6,(byte)-12,  (byte)9,  (byte)0,
  (byte)3,  (byte)2,  (byte)7, (byte)-7,  (byte)8,  (byte)1,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)7,(byte)-11,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-8,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-2,  (byte)9,  (byte)0,
  (byte)1,  (byte)4,  (byte)9,  (byte)7,
  (byte)3,  (byte)2,  (byte)7, (byte)-8,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)3,  (byte)5,  (byte)7, (byte)-9,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)3,  (byte)4,  (byte)7, (byte)-9,  (byte)8,  (byte)6,  (byte)9,  (byte)0,
  (byte)3,  (byte)3,  (byte)7, (byte)-5,  (byte)8,  (byte)3,  (byte)9,  (byte)1,
  (byte)2,  (byte)2,  (byte)7, (byte)-1,  (byte)8,  (byte)1,
  (byte)2,  (byte)3,  (byte)8, (byte)-9,  (byte)9,  (byte)0,
  (byte)2,  (byte)9,  (byte)8, (byte)-9,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6,(byte)-13,  (byte)9,  (byte)0,
  (byte)3,  (byte)2,  (byte)7, (byte)-5,  (byte)8, (byte)-3,  (byte)9,  (byte)0,
  (byte)2,  (byte)6,  (byte)7,(byte)-13,  (byte)9,  (byte)1,
  (byte)2,  (byte)5,  (byte)7,(byte)-10,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-7,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-4,  (byte)9,  (byte)0,
  (byte)1,  (byte)5,  (byte)9,  (byte)7,
  (byte)3,  (byte)6,  (byte)7, (byte)-9,  (byte)8,  (byte)1,  (byte)9,  (byte)1,
  (byte)3,  (byte)4,  (byte)7, (byte)-5,  (byte)8,  (byte)1,  (byte)9,  (byte)1,
  (byte)3,  (byte)3,  (byte)7, (byte)-3,  (byte)8,  (byte)1,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-3,  (byte)9,  (byte)2,
  (byte)2,  (byte)3,  (byte)8,(byte)-10,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)8,  (byte)4,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)8, (byte)-2,  (byte)9,  (byte)0,
  (byte)2, (byte)11,  (byte)8,(byte)-11,  (byte)9,  (byte)0,
  (byte)3,  (byte)1,  (byte)7, (byte)-9,  (byte)8,  (byte)5,  (byte)9,  (byte)0,
  (byte)2,  (byte)6,  (byte)7,(byte)-12,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-9,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-6,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-3,  (byte)9,  (byte)0,
  (byte)1,  (byte)6,  (byte)9,  (byte)6,
  (byte)2,  (byte)2,  (byte)7,(byte)-12,  (byte)9,  (byte)0,
  (byte)3,  (byte)6,  (byte)7, (byte)-9,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)3,  (byte)3,  (byte)7,(byte)-12,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)3,  (byte)4,  (byte)7,(byte)-10,  (byte)8, (byte)-3,  (byte)9,  (byte)1,
  (byte)3,  (byte)3,  (byte)7, (byte)-3,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-2,  (byte)9,  (byte)2,
  (byte)2,  (byte)1,  (byte)8,  (byte)5,  (byte)9,  (byte)0,
  (byte)2, (byte)13,  (byte)8,(byte)-13,  (byte)9,  (byte)1,
  (byte)3,  (byte)2,  (byte)7, (byte)-9,  (byte)8,  (byte)1,  (byte)9,  (byte)0,
  (byte)2,  (byte)6,  (byte)7,(byte)-11,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-8,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-5,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-2,  (byte)9,  (byte)0,
  (byte)1,  (byte)7,  (byte)9,  (byte)7,
  (byte)3,  (byte)6,  (byte)7, (byte)-9,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-1,  (byte)9,  (byte)4,
  (byte)2,  (byte)3,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)7,  (byte)7,(byte)-13,  (byte)9,  (byte)1,
  (byte)2,  (byte)3,  (byte)7, (byte)-1,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)7,  (byte)2,  (byte)9,  (byte)0,
  (byte)1,  (byte)8,  (byte)9,  (byte)6,
  (byte)3,  (byte)7,  (byte)7, (byte)-9,  (byte)8,  (byte)1,  (byte)9,  (byte)0,
  (byte)1,  (byte)1,  (byte)6,  (byte)0,
  (byte)1,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)7,  (byte)3,  (byte)9,  (byte)0,
  (byte)1,  (byte)9,  (byte)9,  (byte)5,
  (byte)3,  (byte)1,  (byte)7,(byte)-10,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)3,  (byte)2,  (byte)7,(byte)-12,  (byte)8,  (byte)3,  (byte)9,  (byte)1,
  (byte)2,  (byte)1,  (byte)6,  (byte)1,  (byte)9,  (byte)0,
  (byte)3,  (byte)1,  (byte)7, (byte)-1,  (byte)8,  (byte)8,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)7,  (byte)1,  (byte)9,  (byte)1,
  (byte)2,  (byte)2,  (byte)7,  (byte)4,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)7,  (byte)7,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)8,  (byte)4,  (byte)9,  (byte)1,
  (byte)2, (byte)12,  (byte)8, (byte)-8,  (byte)9,  (byte)0,
  (byte)3,  (byte)1,  (byte)7,(byte)-10,  (byte)8,  (byte)2,  (byte)9,  (byte)1,
  (byte)2,  (byte)1,  (byte)6,  (byte)2,  (byte)9,  (byte)0,
  (byte)1, (byte)11,  (byte)9,  (byte)2,
  (byte)2, (byte)12,  (byte)8, (byte)-7,  (byte)9,  (byte)0,
  (byte)3,  (byte)1,  (byte)7,(byte)-10,  (byte)8,  (byte)1,  (byte)9,  (byte)1,
  (byte)1,  (byte)4,  (byte)7,  (byte)0,
  (byte)1, (byte)12,  (byte)9,  (byte)0,
  (byte)2,  (byte)6,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)3,  (byte)1,  (byte)7, (byte)-2,  (byte)8,(byte)-12,  (byte)9,  (byte)0,
  (byte)3,  (byte)7,  (byte)7, (byte)-7,  (byte)8,  (byte)2,  (byte)9,  (byte)1,
  (byte)2,  (byte)2,  (byte)6, (byte)-4,  (byte)9,  (byte)1,
  (byte)1, (byte)13,  (byte)9,  (byte)0,
  (byte)2, (byte)10,  (byte)8, (byte)-2,  (byte)9,  (byte)1,
  (byte)2,  (byte)4,  (byte)7,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-3,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)7,  (byte)8,  (byte)9,  (byte)1,
  (byte)2,  (byte)8,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)1,  (byte)5,  (byte)7,  (byte)1,
  (byte)2,  (byte)4,  (byte)7,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)7,  (byte)6,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-6,  (byte)9,  (byte)0,
  (byte)3,  (byte)2,  (byte)7,  (byte)8,  (byte)8, (byte)-3,  (byte)9,  (byte)0,
  (byte)3,  (byte)1,  (byte)7,  (byte)6,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)6,  (byte)8,  (byte)6,  (byte)9,  (byte)0,
  (byte)3,  (byte)8,  (byte)7, (byte)-7,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)9,  (byte)7,(byte)-11,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)7,  (byte)1,  (byte)9,  (byte)1,
  (byte)2,  (byte)4,  (byte)7,  (byte)4,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-1,  (byte)9,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-1,  (byte)7,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)10,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)7, (byte)13,  (byte)9,  (byte)0,
  (byte)2,  (byte)8,  (byte)7, (byte)-7,  (byte)9,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-4,  (byte)9,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-1,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)7,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7,  (byte)5,  (byte)9,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-4,  (byte)9,  (byte)1,
  (byte)3,  (byte)1,  (byte)6,  (byte)9,  (byte)8, (byte)-5,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-3,  (byte)9,  (byte)4,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)9,  (byte)4,
  (byte)3,  (byte)9,  (byte)7, (byte)-9,  (byte)8,  (byte)6,  (byte)9,  (byte)0,
  (byte)2,  (byte)8,  (byte)7, (byte)-4,  (byte)9,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-1,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)6,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)9,  (byte)3,
  (byte)3,  (byte)6,  (byte)7, (byte)-3,  (byte)8,  (byte)7,  (byte)9,  (byte)1,
  (byte)1,  (byte)1,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)6,  (byte)5,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)5,  (byte)1,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)5,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)5,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)9,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-1,  (byte)9,  (byte)1,
  (byte)1,  (byte)2,  (byte)5,  (byte)0,
 (byte)-1
  };
  /* Total terms = 173, small = 156 */
  static Plantbl plu404 = new Plantbl(
                               new short[]{0,  0,  0,  0,  2,  2,  9, 13, 13},
                               (short)7,
                               pluargs,
                               plutabl,
                               plutabb,
                               plutabr,
                               3.9539999999999999e+01
  );
}

class SwemptabSat {
  /*
  First date in file = 625296.50
  Number of records = 16731.0
  Days per record = 131.0
        Julian Years      Lon    Lat    Rad
   -3000.0 to  -2499.7:   0.78   0.26   0.55
   -2499.7 to  -1999.7:   0.66   0.19   0.57
   -1999.7 to  -1499.7:   0.62   0.19   0.53
   -1499.7 to   -999.8:   0.79   0.17   0.61
    -999.8 to   -499.8:   0.78   0.15   0.42
    -499.8 to      0.2:   0.75   0.19   0.52
       0.2 to    500.2:   0.62   0.18   0.41
     500.2 to   1000.1:   0.56   0.13   0.54
    1000.1 to   1500.1:   0.53   0.15   0.41
    1500.1 to   2000.1:   0.51   0.15   0.49
    2000.1 to   2500.0:   0.52   0.13   0.41
    2500.0 to   3000.0:   0.63   0.22   0.53
    3000.0 to   3000.4:  0.047  0.073  0.086
  */
  static final double sattabl[] = {
     1788381.26240,     2460423.68044,     1370113.15868,      415406.99187,
       72040.39885,       12669.58806,   439960754.85333,      180256.80433,

          18.71177,         -40.37092,

       66531.01889,     -195702.70142,       57188.02694,     -179110.60982,
      -19803.06520,      -58084.15705,       -9055.13344,      -31146.10779,
       11245.43286,       -3247.59575,         459.48670,        2912.82402,

          -4.06749,         -13.53763,

         -30.55598,          -4.51172,

           1.48832,           0.37139,

         597.35433,        1193.44545,        -297.50957,         976.38608,
        -263.26842,          34.84354,          -6.77785,         -29.92106,

          -0.16325,          -0.18346,

          -0.15364,          -0.08227,

           0.20180,           0.02244,

           0.04672,          -0.29867,

          -0.04143,          -0.00760,

          -0.17046,          -0.00778,

           0.04200,           0.23937,          -0.00098,          -0.05236,

          -0.02749,          -0.01813,

           0.00637,           0.01256,

          -0.04506,           0.04448,

          -0.00105,           0.06224,

           0.01157,           0.17057,          -0.03214,           0.18178,

          -0.22059,          -0.01472,

          -0.24213,           0.04309,           0.03436,           0.44873,

           0.01350,          -0.01931,

          -0.80618,          -0.56864,           0.29223,          -0.03101,

           0.04171,           0.02264,

          -0.01264,          -0.01645,

           0.01774,           0.06374,

          -0.01925,          -0.03552,

           0.10473,          -0.04119,

           0.08045,           0.04635,

          -3.01112,          -9.26158,           8.13745,           1.88838,

          -0.15184,           0.16898,

          -0.22091,           0.29070,          -0.03259,           0.06938,

          -0.08499,          -0.21688,           0.01848,          -0.05594,

           0.50100,          -0.00027,           0.13300,           0.12055,

           0.03039,           0.03854,

          -1.55287,           2.55618,          -0.45497,          -0.29895,
          -0.93268,           0.83518,

          -0.32785,           7.03878,          -1.66649,           2.75564,
          -0.29459,           0.01050,

           0.08293,          -0.03161,

          -0.12750,          -0.04359,

           0.04217,           0.07480,

        -114.43467,          49.47867,         -66.52340,         -26.27841,
          15.48190,         -13.06589,           3.28365,           5.02286,

          -0.17155,          -0.07404,

           0.00924,          -0.07407,

          -0.02922,           0.06184,

         108.04882,          86.09791,        -155.12793,         208.10044,
        -311.72810,        -268.92703,          74.57561,        -420.03057,

          -0.07893,           0.09246,

          -0.66033,          -0.39026,          -0.13816,          -0.08490,

         -36.79241,         -78.88254,          71.88167,         -68.05297,
          51.71616,          65.77970,         -43.59328,          23.51076,

          -0.02029,          -0.32943,

          -8.82754,           1.48646,          -3.12794,           2.12866,
          -0.06926,           0.44979,

           0.00621,          -0.51720,

          -3.82964,          -1.48596,          -0.11277,          -3.21677,
           0.81705,          -0.19487,

          -0.06195,           0.10005,          -0.02208,           0.00108,

           0.00455,          -0.03825,

           0.01217,          -0.00599,

          -0.17479,          -0.47290,           0.85469,           1.12548,
          -0.80648,          -0.44134,

          -0.01559,          -0.07061,

           0.01268,          -0.01773,

           0.01308,          -0.03461,

          -0.71114,           1.97680,          -0.78306,          -0.23052,
           0.94475,          -0.10743,

           0.18252,          -8.03174,

           0.00734,           0.04779,

           0.12334,          -0.03513,

           0.01341,           0.02461,

           0.02047,          -0.03454,

           0.02169,          -0.01921,

          -1.12789,           0.09304,           0.14585,           0.36365,

           0.03702,           0.10661,          -0.00464,          -1.72706,

          -0.00769,          -0.04635,

          -0.01157,           0.00099,

          10.92646,           1.96174,           2.91142,           4.74585,
          -0.29832,           0.75543,

           0.05411,           1.05850,

           0.38846,          -0.16265,

           1.52209,           0.12185,           0.18650,           0.35535,

        -278.33587,         -82.58648,        -160.00093,        -225.55776,
          35.17458,         -77.56672,          10.61975,           3.33907,

           0.06090,           2.17429,

          -4.32981,          -5.84246,          11.43116,          20.61395,

          -0.65772,           1.28796,

        1224.46687,       -3113.15508,        3798.33409,        -137.28735,
        -256.89302,        2227.35649,        -779.78215,        -260.37372,

          11.73617,         -13.25050,          -0.75248,          -2.87527,

          -8.38102,          17.21321,

      -61784.69616,       39475.02257,      -54086.68308,       54550.85490,
      -16403.69351,       29602.70098,       14672.06363,       16234.17489,
       15702.37109,      -22086.30300,      -22889.89844,       -1245.88352,

           1.48864,          19.75000,           0.78646,           3.29343,

       -1058.13125,        4095.02368,       -2793.78506,        1381.93282,
        -409.19381,        -772.54270,         161.67509,         -34.15910,

        -514.27437,          27.34222,        -311.04046,          48.01030,
         -43.36486,          16.19535,          -0.73816,          -0.81422,

         287.32231,        -110.44135,         200.43610,          37.98170,
          17.73719,          34.40023,          -2.46337,           1.48125,

           0.09042,          -0.11788,

           0.37284,           0.51725,           0.00597,           0.14590,

          -0.01536,           0.00980,

           0.00721,           0.02023,

           0.00027,           0.02451,

          -0.72448,          -0.71371,           0.29322,           0.18359,

           0.72719,          -0.37154,           0.14854,          -0.02530,

           0.23052,           0.04258,

           4.82082,           0.01885,           3.11279,          -0.63338,
           0.10559,          -0.02146,

          -0.01672,           0.03412,

           0.00605,           0.06415,

          -0.89085,           1.51929,          -0.36571,           0.39317,

          12.05250,          -3.79392,           3.96557,          -3.51272,
          -0.17953,          12.30669,

          -0.05083,          -0.11442,

           0.02013,          -0.02837,

          -0.02087,          -0.01599,

           0.49190,           0.30360,           0.01316,           0.17649,

           0.21193,          -0.09149,          -0.07173,          -0.05707,

           4.24196,          -1.25155,           1.81336,           0.68887,
          -0.01675,           0.20772,

          -0.04117,          -0.03531,

          -0.02690,          -0.02766,

          37.54264,          10.95327,           8.05610,          30.58210,
         -12.68257,           1.72831,           0.13466,          -3.27007,

           0.01864,          -0.00595,

           0.03676,           0.14857,          -0.07223,           0.06179,

           0.44878,          -1.64901,         -20.06001,           0.63384,
          -4.97849,           4.78627,          29.87370,           7.29899,

           0.00047,          -0.00155,

           0.00314,           0.01425,

          -0.17842,          -0.08461,

          -1.61020,          -8.47710,           6.85048,          -4.38196,
           1.05809,           2.68088,

          -0.01027,          -0.00833,

           0.06834,          -0.04205,

           0.03330,          -0.01271,

           0.01301,          -0.01358,

           0.03537,           0.03612,           0.02962,           0.62471,
          -0.30400,          -0.64857,

           0.01773,           0.01890,

           0.01426,          -0.00226,

          -0.50957,          -0.01955,          -0.09702,           1.09983,

           0.64387,          -0.02755,

           0.26604,           0.30684,           0.06354,           0.05114,

          -0.00058,          -0.04672,

          -0.00828,           0.00712,

          -0.00440,           0.00029,

          -0.01601,           0.03566,

           0.13398,          -0.02666,

          -0.06752,          -0.43044,           0.07172,          -0.01999,

          -0.01761,          -0.05357,

           0.06104,           0.29742,          -0.08785,           0.05241,

          -6.57162,          -4.20103,           0.03199,          -6.46187,
           1.32846,          -0.51137,

           0.06358,           0.37309,

          -1.46946,           2.34981,

          -0.18712,           0.11618,

         240.62965,        -107.21962,         219.81977,          84.04246,
         -62.22931,          68.35902,          -9.48460,         -32.62906,

           5.57483,          -1.82396,           1.00095,          -0.39774,

           7.87054,          11.45449,

        -432.67155,       55064.72398,       12444.62359,       54215.28871,
        8486.03749,       12297.48243,        -333.27968,        1147.93192,
        1403.73797,         990.40885,          -3.84938,        -722.43963,

          16.83276,          96.48787,           7.04834,          38.22208,
           0.63843,           2.61007,

         230.73221,         171.64166,           1.96751,         287.80846,
         -85.21762,          31.33649,          -2.25739,         -11.28441,

           0.04699,           0.06555,

          -0.08887,           1.70919,           0.09477,           0.26291,

          -0.15490,           0.16009,

           1.93274,           1.01953,           0.36380,           1.29582,
          -0.13911,           0.14169,

          -0.00491,          -0.00030,

          -0.08908,          -0.10216,

          -0.03265,          -0.03889,

           0.40413,          -1.12715,          -0.94687,          -0.04514,

           0.02487,          -0.01048,

           0.39729,           2.82305,          -0.61100,           1.11728,
          -0.13083,          -0.04965,

          -0.00602,          -0.02952,

          -6.13507,          13.73998,         -15.70559,          -1.28059,
           2.64422,          -9.33798,           3.26470,           1.56984,

          -0.00572,           0.09992,

          -8.80458,          -8.23890,         -11.51628,           9.47904,
          11.31646,           4.29587,

          -2.41367,          -0.05883,          -0.80022,          -1.02706,
           0.21461,          -0.06864,

           0.01882,           0.01798,

           0.27614,          -0.01007,           0.04362,           0.07560,
           0.05519,           0.23435,

          -0.09389,           0.01613,

           0.01298,           0.04691,

          -0.02665,          -0.03582,

           0.60080,          -4.28673,           1.87316,          -1.05840,
           0.13248,           0.40887,

          -0.67657,           0.67732,           0.05522,           0.07812,
          -0.17707,          -0.07510,

           0.24885,          10.63974,          -7.40226,          -2.33827,
           2.75463,         -32.51518,

           0.05140,           0.01555,

         180.43808,         263.28252,         384.50646,         -76.53434,
         -93.50706,        -220.50123,         -81.91610,         103.92061,
          30.90305,          -2.89292,

          -0.06634,          -0.37717,          -0.01945,          -0.05936,

          29.27877,         -59.73705,          35.86569,         -18.36556,
           3.88812,           4.82090,          -0.70903,           0.06615,

           0.01558,          -0.01854,

           0.16209,           0.12682,           0.02508,           0.02406,

          -0.03078,          -0.01737,          -0.00033,          -0.00020,

           0.01023,           0.05972,

          -0.03373,          -0.07289,

          -2.08162,          -0.14717,          -0.64233,          -0.75397,
           0.11752,          -0.09202,

           4.42981,          -4.19241,           5.02542,           5.03467,
          -4.22983,           2.80794,

           3.03016,          -2.74373,          -1.11490,          -2.72378,
          -0.63131,           0.74864,

          -0.00759,          -0.00675,

           0.03615,          -0.01806,

          -2.71920,          -1.50954,           0.54479,          -1.92088,
           0.66427,           0.32228,

          -2.55188,          -0.65332,          -2.73798,           2.10182,
           1.54407,           3.01357,

          38.76777,          23.54578,          27.29884,         -14.93005,
          -7.50931,          -5.66773,           0.30142,           1.52416,

           0.00634,           0.09697,          -0.00748,           0.01433,

           0.02936,           0.53228,          -0.03603,           0.06345,

           0.30816,          -1.07925,           0.46709,          -0.21568,
           0.01663,           0.10810,

          -0.42511,           0.35872,          -0.19662,          -6.74031,

           1.05776,           1.86205,           1.08919,           0.10483,
          -0.03368,          -0.21535,

           0.07556,          -0.27104,           0.05142,          -0.03812,

           1.20189,          -1.36782,           1.35764,           1.39387,
          -1.19124,           0.77347,

          -0.54760,          -0.26295,          -0.07473,           0.23043,

           2.82621,          -0.23524,           0.47352,          -0.81672,
          -0.08515,           0.04700,

           0.55355,          -0.40138,           0.22255,           0.12236,

          -0.09110,           0.31982,           0.39404,          -0.17898,

          -0.00056,           0.00014,

          -0.02012,           0.03102,

           0.43236,          -0.10037,          -0.00961,           0.07440,
          -0.07076,          -1.97272,

           0.25555,          -0.21832,          -0.00837,          -0.08393,

           0.01531,           0.00627,

           0.33193,           0.70765,          -0.43556,           0.28542,

          -0.23190,          -0.04293,          -0.08062,           0.13427,

           0.23763,          -0.17092,           0.09259,           0.05155,

           0.08065,          -0.11943,

          -0.02174,          -0.68899,

          -0.01875,          -0.01746,

           0.13604,           0.29280,          -0.17871,           0.11799,

           0.02003,           0.04065,

           0.01343,          -0.06060,

          -0.01290,          -0.26068,

          -0.09033,           0.02649,

          -0.00092,          -0.03094,

          -0.00770,          -0.10447,

          -0.04113,           0.01259,

          -0.00469,          -0.04346,

          -0.00010,           0.06547,

  };
  static final double sattabb[] = {
     -567865.62548,     -796277.29029,     -410804.00791,      -91793.12562,
       -6268.13975,         398.64391,        -710.67442,         175.29456,

          -0.87260,           0.18444,

       -1314.88121,       20709.97394,       -1850.41481,       20670.34255,
        -896.96283,        6597.16433,        -179.80702,         613.45468,
          17.37823,         -13.62177,          -0.36348,          12.34740,

           0.47532,           0.48189,

           0.27162,          -0.20655,

          -0.23268,           0.05992,

          46.94511,          15.78836,          21.57439,          23.11342,
          -0.25862,           5.21410,          -0.22612,          -0.05822,

          -0.00439,          -0.01641,

          -0.01108,          -0.00608,

           0.00957,           0.00272,

          -0.00217,           0.00001,

          -0.00534,          -0.00545,

           0.00277,          -0.00843,

           0.00167,          -0.00794,           0.00032,          -0.00242,

          -0.00002,          -0.00041,

          -0.00025,           0.00031,

           0.00062,          -0.00060,

           0.00083,           0.00032,

           0.00527,          -0.00211,           0.00054,           0.00004,

          -0.02769,          -0.01777,

           0.00247,           0.00097,           0.00020,          -0.00232,

           0.00044,          -0.00035,

          -0.00072,           0.01341,           0.00325,          -0.01159,

           0.00079,          -0.00078,

          -0.00009,           0.00066,

           0.00222,           0.00002,

           0.00013,          -0.00161,

           0.01374,          -0.05305,

           0.00478,          -0.00283,

           0.16033,           0.13859,           0.33288,          -0.16932,

          -0.00316,           0.00625,

          -0.00309,           0.01687,           0.00001,           0.00486,

           0.00401,          -0.01805,          -0.00048,          -0.00407,

          -0.01329,           0.01311,          -0.00591,           0.00166,

           0.00830,           0.00665,

          -0.80207,           0.22994,          -0.34687,           0.08460,
          -0.11499,          -0.01449,

          -0.01574,           0.78813,          -0.03063,           0.28872,
          -0.00337,           0.01801,

          -0.01703,          -0.00929,

          -0.00738,           0.03938,

           0.05616,          -0.00516,

          -3.09497,          30.13091,          -3.14968,          17.62201,
          -0.73728,           2.46962,          -0.11233,           0.03450,

          -0.07837,          -0.01573,

          -0.01595,           0.00394,

           0.00174,           0.01470,

           6.83560,          -2.37594,           4.95125,           3.24711,
           2.44781,           5.17159,           1.99820,          -2.38419,

           0.00840,           0.03614,

          -0.00209,          -0.30407,          -0.02681,          -0.06128,

           1.50134,          11.82856,           4.39644,           6.98850,
          -4.17679,           5.73436,          -9.66087,           1.98221,

          -0.29755,           0.08019,

          -0.24766,          -8.54956,          -1.74494,          -3.36794,
          -0.32661,          -0.00722,

           0.14141,           0.01023,

          -1.21541,          -2.58470,           0.38983,          -1.70307,
           0.31209,          -0.10345,

           0.02593,           0.02178,           0.00289,           0.00393,

          -0.00236,          -0.00373,

          -0.00270,          -0.00049,

          -0.06282,          -0.00443,          -0.02439,          -0.02254,
          -0.02220,           0.03532,

          -0.00072,           0.00010,

          -0.00049,          -0.00112,

           0.00086,           0.00112,

           0.10135,          -0.10972,           0.08357,           0.00155,
           0.04363,          -0.00201,

          -0.01996,          -0.01341,

          -0.00039,          -0.00042,

          -0.00294,           0.00070,

           0.00005,          -0.00027,

           0.00070,          -0.00076,

           0.00234,          -0.00239,

          -0.08365,          -0.08531,          -0.03531,           0.15012,

          -0.01995,          -0.01731,          -0.00370,          -0.00745,

          -0.00315,          -0.00079,

          -0.00120,          -0.00145,

          -0.99404,          -1.31859,           0.03584,          -0.83421,
           0.10720,          -0.05768,

           0.06664,          -0.09338,

          -0.01814,          -0.00003,

          -0.05371,          -0.06458,          -0.00100,          -0.01298,

          -7.08710,         -23.13374,           4.18669,         -19.94756,
           4.85584,          -3.37187,           0.58851,           0.31363,

           0.01994,           0.27494,

          -1.37112,           2.61742,           0.52477,          -0.46520,

          -0.13183,           0.26777,

         836.90400,        -484.65861,         815.99098,         236.54649,
         -32.38814,         288.95705,         -68.17178,         -18.87875,

          -1.79782,          -3.68662,          -1.27310,          -0.65697,

          -3.67530,           2.10471,

      -13758.97795,        4807.62301,      -14582.14552,        9019.73021,
       -3202.60105,        4570.16895,        2078.68911,        2892.62326,
       -2399.35382,        3253.16198,       -8182.38152,       -3588.77680,

          -0.16505,           1.08603,           0.53388,           0.87152,

          61.53677,         538.43813,        -407.32927,         322.27446,
        -148.71585,        -179.37765,          54.07268,         -34.12281,

         -14.76569,         -17.95681,         -10.82061,          -6.39954,
          -2.10954,           0.67063,           0.22607,          -0.43648,

          20.90476,         -45.48667,          30.39436,         -14.20077,
           5.17385,           5.12726,          -0.66319,           0.55668,

           0.02269,          -0.00016,

           0.07811,           0.00111,           0.01603,           0.01020,

          -0.00107,           0.00494,

          -0.00077,          -0.00084,

          -0.00196,           0.00081,

          -0.03776,           0.01286,          -0.00652,          -0.01450,

           0.05942,          -0.08612,           0.01093,          -0.01644,

           0.02147,          -0.00592,

           0.36350,          -0.00201,           0.14419,          -0.10070,
          -0.00491,          -0.01771,

          -0.00053,          -0.00033,

           0.00146,           0.00048,

           0.00582,           0.04423,          -0.00549,           0.00983,

           0.27355,          -0.38057,           0.24001,          -0.05441,
          -0.07706,           0.14269,

          -0.00059,          -0.00154,

          -0.00013,          -0.00088,

          -0.00046,           0.00029,

          -0.00276,          -0.00507,           0.00075,          -0.00076,

           0.01806,           0.00862,          -0.00510,          -0.01364,

          -0.00029,          -0.12664,           0.03899,          -0.03562,
           0.00318,           0.00514,

           0.00057,           0.00201,

           0.00028,           0.00014,

          -0.47022,          -0.74561,           0.40155,          -0.16471,
          -0.18445,           0.34425,          -0.07464,          -0.13709,

          -0.01018,          -0.00748,

          -0.01210,          -0.04274,          -0.00579,          -0.00692,

         -11.09188,          -1.67755,          -6.62063,         -13.84023,
          12.75563,          -6.73501,           8.31662,           5.40196,

           0.00052,           0.00034,

           0.00128,           0.00085,

          -0.02202,          -0.00599,

          -0.33458,          -1.65852,           1.47003,          -1.02434,
           0.87885,           1.15334,

          -0.00241,          -0.00721,

           0.03154,           0.00612,

           0.00318,          -0.02521,

           0.00042,           0.00213,

          -0.01094,           0.05417,          -0.03989,          -0.00567,
           0.00123,          -0.00244,

           0.00108,           0.00242,

          -0.00138,          -0.00099,

           0.04967,           0.01643,          -0.00133,           0.02296,

           0.12207,           0.05584,

           0.00437,          -0.04432,          -0.00176,          -0.00922,

          -0.00252,           0.00326,

          -0.00020,          -0.00050,

          -0.00263,          -0.00084,

          -0.01971,           0.00297,

           0.03076,           0.01736,

          -0.01331,           0.01121,          -0.00675,           0.00340,

          -0.00256,           0.00327,

          -0.00946,           0.03377,          -0.00770,           0.00337,

           0.61383,           0.71128,          -0.02018,           0.62097,
          -0.07247,           0.04418,

          -0.02886,          -0.03848,

          -0.44062,           0.03973,

          -0.00999,          -0.04382,

          57.94459,         117.45112,         -71.22893,         126.39415,
         -62.33152,         -31.90754,          12.17738,         -16.46809,

          -1.13298,           0.08962,          -0.20532,           0.16320,

          -1.55110,          -1.44757,

       -3102.08749,       -7452.61957,       -5009.53858,       -7216.29165,
       -2476.87148,       -1880.58197,        -574.49433,         227.45615,
         144.50228,         379.15791,         225.36130,        -443.47371,

          -8.51989,          -3.75208,          -4.25415,          -1.59741,
          -0.43946,          -0.06595,

         150.42986,           6.54937,          87.67736,          92.32332,
         -21.97187,          29.87097,          -4.21636,          -5.72955,

          -0.03879,          -0.01071,

          -0.45985,           0.02679,          -0.02448,           0.02397,

          -0.06551,          -0.01154,

           1.97905,          -0.82292,           1.10140,           0.30924,
           0.03389,           0.14230,

           0.00003,           0.00119,

          -0.01117,           0.00665,

          -0.00132,          -0.00576,

          -0.08356,           0.08556,          -0.26362,          -0.12450,

           0.00509,           0.00165,

           0.02591,           0.16200,          -0.03318,           0.06463,
          -0.00899,          -0.00462,

           0.00102,           0.00004,

          -0.73102,           0.08299,          -0.52957,          -0.35744,
           0.14119,          -0.24903,           0.20843,           0.14143,

           0.00031,          -0.00234,

          -0.42643,          -2.02084,           1.58848,          -1.57963,
           0.68418,           2.07749,

          -0.45888,           0.19859,          -0.30277,          -0.22591,
           0.11607,          -0.09705,

           0.00040,           0.00431,

          -0.02683,           0.03158,          -0.01302,          -0.00541,
           0.01742,          -0.00006,

          -0.02231,          -0.01128,

          -0.00800,           0.02055,

          -0.00346,           0.00151,

           0.56732,          -0.68995,           0.27701,          -0.16748,
           0.01002,           0.00043,

           0.26916,          -0.57751,           0.15547,          -0.15825,
          -0.02074,          -0.07722,

          -8.23483,          -4.02022,           0.69327,          -5.91543,
           1.72440,           1.02090,

           0.00024,          -0.00053,

          20.03959,          14.79136,          76.43531,         -14.42019,
          -7.82608,         -69.96121,         -54.94229,          23.55140,
          26.60767,          14.68275,

           0.05118,          -0.10401,          -0.00075,          -0.01942,

          -3.84266,         -26.23442,          10.20395,         -14.77139,
           3.40853,           2.07297,          -0.53348,           0.40635,

           0.00716,          -0.00189,

           0.12472,          -0.02903,           0.02254,          -0.00183,

          -0.00175,          -0.01522,           0.00003,          -0.00339,

           0.00383,          -0.00168,

           0.01327,          -0.03657,

          -0.08458,          -0.00115,          -0.03991,          -0.02629,
           0.00243,          -0.00505,

           0.33875,          -0.16744,           0.05183,           0.01744,
          -0.24427,           0.15271,

           0.37550,          -0.17378,           0.09198,          -0.27966,
          -0.22160,           0.16426,

           0.00032,          -0.00310,

          -0.00022,          -0.00144,

          -0.06170,          -0.01195,          -0.00918,           0.02538,
           0.03602,           0.03414,

          -0.14998,          -0.44351,           0.45512,          -0.11766,
           0.35638,           0.27539,

           5.93405,          10.55777,          12.42596,          -1.82530,
          -2.36124,          -6.04176,          -0.98609,           1.67652,

          -0.09271,           0.03448,          -0.01951,           0.00108,

           0.33862,           0.21461,           0.02564,           0.06924,

           0.01126,          -0.01168,          -0.00829,          -0.00740,
           0.00106,          -0.00854,

          -0.08404,           0.02508,          -0.02722,          -0.06537,

           0.01662,           0.11454,           0.06747,           0.00742,
          -0.01975,          -0.02597,

          -0.00097,          -0.01154,           0.00164,          -0.00274,

           0.02954,          -0.05161,          -0.02162,          -0.02069,
          -0.06369,           0.03846,

           0.00219,          -0.01634,          -0.04518,           0.06696,

           1.21537,           0.99500,           0.68376,          -0.28709,
          -0.11397,          -0.06468,

           0.00607,          -0.00744,           0.01531,           0.00975,

          -0.03983,           0.02405,           0.07563,           0.00356,

          -0.00018,          -0.00009,

           0.00172,          -0.00331,

           0.01565,          -0.03466,          -0.00230,           0.00142,
          -0.00788,          -0.01019,

           0.01411,          -0.01456,          -0.00672,          -0.00543,

           0.00059,          -0.00011,

          -0.00661,          -0.00496,          -0.01986,           0.01271,

          -0.01323,          -0.00764,           0.00041,           0.01145,

           0.00378,          -0.00137,           0.00652,           0.00412,

           0.01946,          -0.00573,

          -0.00326,          -0.00257,

          -0.00225,           0.00090,

          -0.00292,          -0.00317,          -0.00719,           0.00468,

           0.00245,           0.00189,

           0.00565,          -0.00330,

          -0.00168,          -0.00047,

          -0.00256,           0.00220,

           0.00180,          -0.00162,

          -0.00085,          -0.00003,

          -0.00100,           0.00098,

          -0.00043,           0.00007,

          -0.00003,          -0.00013,

  };
  static final double sattabr[] = {
      -38127.94034,      -48221.08524,      -20986.93487,       -3422.75861,
          -8.97362,          53.34259,        -404.15708,          -0.05434,

           0.46327,           0.16968,

        -387.16771,        -146.07622,         103.77956,          19.11054,
         -40.21762,         996.16803,        -702.22737,         246.36496,
         -63.89626,        -304.82756,          78.23653,          -2.58314,

          -0.11368,          -0.06541,

          -0.34321,           0.33039,

           0.05652,          -0.16493,

          67.44536,         -29.43578,          50.85074,          18.68861,
           0.39742,          13.64587,          -1.61284,           0.11482,

           0.01668,          -0.01182,

          -0.00386,           0.01025,

           0.00234,          -0.01530,

          -0.02569,          -0.00799,

          -0.00429,          -0.00217,

          -0.00672,           0.00650,

           0.01154,           0.00120,          -0.00515,           0.00125,

           0.00236,          -0.00216,

          -0.00098,           0.00009,

          -0.00460,          -0.00518,

           0.00600,           0.00003,

           0.00834,           0.00095,           0.01967,           0.00637,

          -0.00558,          -0.06911,

          -0.01344,          -0.06589,          -0.05425,          -0.00607,

          -0.00247,          -0.00266,

           0.08790,          -0.08537,          -0.00647,           0.04028,

          -0.00325,           0.00488,

           0.00111,          -0.00044,

          -0.00731,           0.00127,

          -0.00417,           0.00303,

           0.05261,           0.01858,

          -0.00807,           0.01195,

           1.26352,          -0.38591,          -0.34825,           1.10733,

          -0.02815,          -0.02148,

          -0.05083,          -0.04377,          -0.01206,          -0.00586,

           0.03158,          -0.01117,           0.00643,           0.00306,

          -0.01186,          -0.05161,           0.01136,          -0.00976,

          -0.00536,           0.01949,

          -1.41680,          -0.81290,          -0.09254,          -0.24347,
          -0.14831,          -0.34381,

          -2.44464,           0.41202,          -0.99240,          -0.33707,
          -0.01930,          -0.08473,

           0.00830,           0.01165,

          -0.01604,          -0.02439,

           0.00227,           0.04493,

         -42.75310,         -22.65155,          -9.93679,         -18.36179,
           2.73773,           3.24126,          -1.20698,           1.07731,

           0.00434,          -0.10360,

          -0.02359,           0.00054,

          -0.02664,          -0.00122,

         -19.79520,          33.11770,         -53.56452,         -35.41902,
          67.95039,         -82.46551,         117.31843,          14.08609,

           0.06447,           0.03289,

           0.40365,          -0.33397,           0.07079,          -0.09504,

         -30.36873,           6.23538,         -14.25988,         -44.91408,
          38.53146,         -16.31919,           6.99584,          22.47169,

          -0.13313,           0.28016,

           6.83715,          -6.01384,           1.68531,          -3.62443,
          -0.22469,          -0.29718,

           0.25169,           0.13780,

          -3.64824,           1.22420,          -2.48963,          -1.12515,
          -0.01510,          -0.56180,

          -0.03306,           0.01848,          -0.00103,          -0.00077,

          -0.01681,          -0.00227,

          -0.00402,          -0.00287,

           0.04965,          -0.16190,          -0.40025,           0.20734,
           0.15819,          -0.25451,

           0.02467,          -0.00495,

           0.00597,           0.00490,

          -0.01085,          -0.00460,

          -0.71564,          -0.26624,           0.03797,          -0.28263,
           0.03510,           0.30014,

           2.79810,           0.07258,

          -0.01618,           0.00337,

           0.00876,           0.04438,

           0.00742,          -0.00455,

          -0.01163,          -0.00683,

           0.00950,           0.01275,

          -0.02124,          -0.67527,          -0.23635,           0.06298,

          -0.03844,           0.01010,           0.73588,          -0.00271,

           0.01742,          -0.00467,

           0.00017,          -0.00505,

          -0.27482,           5.00521,          -1.92099,           1.55295,
          -0.35919,          -0.09314,

          -0.47002,           0.06826,

           0.07924,           0.16838,

          -0.04221,           0.71510,          -0.16482,           0.08809,

          41.76829,        -125.79427,         106.65271,         -71.30642,
          36.18112,          17.36143,          -1.63846,           5.02215,

          -1.08404,           0.00061,

           2.45567,          -2.42818,          -9.88756,           5.36587,

          -0.61253,          -0.35003,

        1523.54790,         602.82184,          68.66902,        1878.26100,
       -1098.78095,        -120.72600,         127.30918,        -383.96064,

          -7.00838,          -6.09942,          -1.54187,           0.34883,

          -9.47561,          -4.35408,

      -21541.63676,      -32542.09807,      -29720.82604,      -28072.21231,
      -15755.56255,       -8084.58657,       -8148.87315,        7434.89857,
       11033.30133,        7827.94658,         610.18256,      -11411.93624,

          -9.87426,           0.94865,          -1.63656,           0.41275,

        1996.57150,         511.48468,         669.78228,        1363.67610,
        -379.72037,         198.84438,         -16.63126,         -79.37624,

          -2.30776,        -246.07820,         -16.85846,        -148.18168,
          -6.89632,         -20.49587,           0.39892,          -0.34627,

         -57.81309,        -136.96971,          15.25671,         -96.61153,
          16.09785,          -8.79091,           0.70515,           1.16197,

           0.05647,           0.04684,

           0.25032,          -0.19951,           0.07282,          -0.00696,

           0.00493,           0.00733,

          -0.01085,           0.00422,

          -0.01309,           0.00262,

           0.37616,          -0.36203,          -0.11154,           0.18213,

           0.15691,           0.29343,           0.00485,           0.06106,

          -0.01492,           0.09954,

           0.28486,           2.27190,           0.33102,           1.50696,
          -0.01926,           0.04901,

           0.01827,           0.00863,

          -0.03315,           0.00178,

          -0.77600,          -0.48576,          -0.21111,          -0.19485,

           1.90295,           6.44856,           1.71638,           2.12980,
          -7.19585,          -0.08043,

           0.07004,          -0.02764,

           0.01604,           0.01158,

           0.00936,          -0.01199,

           0.18396,          -0.29234,           0.10422,          -0.00720,

           0.05196,           0.10753,           0.02859,          -0.03602,

           0.63828,           1.96280,          -0.31919,           0.85859,
          -0.10218,          -0.00673,

           0.01748,          -0.02190,

           0.01266,          -0.02729,

          -4.80220,           8.90557,          -5.94059,           2.28577,
          -0.19687,          -1.28666,           0.32398,           0.14879,

          -0.02619,          -0.02056,

          -0.04872,          -0.07011,          -0.04082,          -0.04740,

           0.60167,          -2.20365,          -0.27919,          -0.45957,
          -1.31664,          -2.22682,         176.89871,          13.03918,

           0.00568,           0.00560,

           0.01093,           0.00486,

          -0.00948,          -0.31272,

         -11.87638,          -3.68471,          -1.74977,          -9.60468,
           2.94988,          -0.57118,

           0.00307,          -0.01636,

           0.02624,           0.03032,

          -0.00464,          -0.01338,

           0.00935,           0.00530,

          -0.11822,           0.03328,          -0.41854,           0.04331,
           0.41340,          -0.21657,

          -0.00865,           0.00849,

          -0.00374,          -0.00899,

           0.01227,          -0.23462,          -0.71894,          -0.04515,

           0.00047,           0.28112,

          -0.12788,           0.11698,          -0.02030,           0.02759,

           0.02967,          -0.00092,

           0.00454,           0.00565,

          -0.00026,           0.00164,

          -0.01405,          -0.00862,

           0.01088,           0.05589,

           0.18248,          -0.06931,          -0.00011,           0.03713,

           0.01932,          -0.00982,

          -0.13861,           0.09853,          -0.03441,          -0.02492,

           2.26163,          -5.94453,           4.14361,          -0.94105,
           0.39561,           0.75414,

          -0.17642,           0.03724,

          -1.32978,          -0.56610,

          -0.03259,          -0.06752,

          39.07495,          80.25429,         -28.15558,          82.69851,
         -37.53894,         -17.88963,           6.98299,         -13.04691,

          -0.48675,          -1.84530,          -0.07985,          -0.33004,

          -3.39292,           2.73153,

      -17268.46134,        1144.22336,      -16658.48585,        5252.94094,
       -3461.47865,        2910.56452,        -433.49442,        -305.74268,
        -383.45023,         545.16136,         313.83376,          27.00533,

         -31.41075,           7.90570,         -12.40592,           3.01833,
          -0.83334,           0.23404,

          59.26487,        -112.74279,         113.29402,         -15.37579,
          14.03282,          32.74482,          -4.73299,           1.30224,

          -0.00866,           0.01232,

          -0.53797,           0.00238,          -0.07979,           0.04443,

          -0.05617,          -0.05396,

           0.10185,          -1.05476,           0.43791,          -0.32302,
           0.06465,           0.03815,

           0.00028,          -0.00446,

           0.09289,          -0.06389,

           0.01701,          -0.01409,

           0.47101,           0.16158,           0.01036,          -0.39836,

           0.00477,           0.01101,

          -2.06535,           0.33197,          -0.82468,          -0.41414,
           0.03209,          -0.09348,

           0.00843,          -0.00030,

          -9.49517,          -3.82206,           0.66899,         -10.28786,
           6.33435,           1.73684,          -0.98164,           2.25164,

          -0.07577,          -0.00277,

           1.02122,           0.75747,           1.79155,          -0.77789,
          -2.56780,          -2.07807,

           0.19528,           0.77118,          -0.28083,           0.32130,
          -0.04350,          -0.07428,

          -0.01161,           0.01387,

           0.02074,           0.19802,          -0.03600,           0.04922,
          -0.19837,           0.02572,

          -0.00682,          -0.04277,

          -0.01805,           0.00299,

           0.03283,          -0.02099,

           3.57307,           1.17468,           0.65769,           1.88181,
          -0.39215,           0.08415,

          -0.53635,          -0.19087,          -0.12456,           0.02176,
           0.01182,          -0.07941,

          -2.43731,           2.44464,           1.03961,          -1.81936,
          30.33140,           0.92645,

           0.00508,          -0.01771,

         -81.06338,          66.43957,          33.16729,         131.44697,
          76.63344,         -34.34324,         -35.33012,         -28.04413,
          -1.47440,          13.09015,

           0.13253,          -0.01629,           0.02187,          -0.00963,

         -21.47470,          -9.44332,          -7.21711,         -12.59472,
           1.76195,          -1.63911,           0.09060,           0.28656,

           0.00635,           0.00536,

           0.03470,          -0.06493,           0.00666,          -0.01084,

           0.01116,          -0.01612,          -0.00102,           0.00208,

          -0.05568,           0.00628,

           0.02665,          -0.01032,

           0.21261,          -1.90651,           0.72728,          -0.57788,
           0.08662,           0.10918,

           3.39133,           3.97302,          -4.63381,           4.26670,
          -2.50873,          -3.76064,

           1.28114,           1.81919,           1.48064,          -0.37578,
          -0.26209,          -0.47187,

           0.00282,          -0.00499,

           0.01749,           0.03222,

           1.60521,          -1.79705,           1.61453,           0.68886,
          -0.29909,           0.55025,

          -0.07894,           0.19880,          -0.15635,           0.46159,
           2.09769,           1.52742,

          -7.60312,          11.34886,           4.35640,           8.61048,
           2.15001,          -2.15303,          -0.61587,          -0.11950,

          -0.03289,          -0.00520,          -0.00501,          -0.00445,

           0.15294,          -0.05277,           0.02455,           0.00408,

           1.19601,           0.43479,           0.20422,           0.57125,
          -0.12790,           0.01318,

          -0.15275,          -0.43856,           6.99144,          -0.08794,

          -1.69865,           0.82589,          -0.20235,           0.97040,
           0.20903,           0.00675,

           0.26943,           0.08281,           0.03686,           0.05311,

           1.28468,           1.21735,          -1.38174,           1.29570,
          -0.75899,          -1.17168,

           0.44696,          -0.32341,          -0.06378,          -0.27573,

          -0.06406,           0.87186,           0.21069,           0.19724,
           0.00119,          -0.04147,

           0.39279,           0.51437,          -0.11035,           0.21450,

          -0.04309,           0.02359,           0.20490,           0.14210,

           0.00007,          -0.00017,

          -0.03529,          -0.02644,

           0.10710,           0.44476,          -0.02632,          -0.01817,
           2.11335,          -0.04432,

           0.18206,           0.27335,           0.08867,           0.00313,

          -0.00692,           0.01595,

          -0.72957,           0.32080,          -0.29291,          -0.44764,

           0.12767,          -0.05778,           0.04797,          -0.00223,

           0.17661,           0.22427,          -0.04914,           0.09114,

           0.12236,           0.00708,

           0.74315,          -0.01346,

           0.02245,          -0.02555,

          -0.30446,           0.13947,          -0.12340,          -0.18498,

          -0.04099,           0.02103,

           0.06337,          -0.01224,

           0.28181,          -0.01019,

          -0.02794,          -0.09412,

           0.03272,          -0.01095,

           0.11247,          -0.00650,

          -0.01319,          -0.04296,

           0.04653,          -0.00423,

           0.06535,           0.00014,

  };

  static final byte satargs[] = {
  (byte)0,  (byte)7,
  (byte)3,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)5,
  (byte)3,  (byte)1,  (byte)6, (byte)-4,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)5,(byte)-10,  (byte)6,  (byte)3,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6, (byte)-4,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-8,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)5,(byte)-10,  (byte)6,  (byte)7,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)5,(byte)-15,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-6,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)4,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)1,  (byte)7,  (byte)1,
  (byte)1,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)2,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-5,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-6,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-7,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6, (byte)-5,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-7,  (byte)7,  (byte)5,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-2,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-4,  (byte)7,  (byte)4,  (byte)8,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)2,  (byte)8,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)2,  (byte)7,  (byte)1,
  (byte)2,  (byte)2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)7,  (byte)2,
  (byte)2,  (byte)5,  (byte)5,(byte)-12,  (byte)6,  (byte)2,
  (byte)3,  (byte)2,  (byte)6, (byte)-5,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)7,  (byte)5,(byte)-18,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-7,  (byte)6,  (byte)3,
  (byte)3,  (byte)1,  (byte)6,  (byte)1,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)5,  (byte)5,(byte)-13,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)3,
  (byte)3,  (byte)3,  (byte)5, (byte)-9,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)2,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)3,
  (byte)3,  (byte)5,  (byte)5,(byte)-14,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)3,  (byte)7,  (byte)2,
  (byte)2,  (byte)3,  (byte)6, (byte)-7,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)2,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-4,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)7,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)5,(byte)-13,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-4,  (byte)7,  (byte)2,
  (byte)3,  (byte)2,  (byte)6, (byte)-5,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)4,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-2,  (byte)8,  (byte)2,
  (byte)2,  (byte)1,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-2,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)2,  (byte)7,  (byte)1,
  (byte)2,  (byte)1,  (byte)6, (byte)-1,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-6,  (byte)7,  (byte)2,
  (byte)2,  (byte)6,  (byte)5,(byte)-14,  (byte)6,  (byte)0,
  (byte)3,  (byte)3,  (byte)6, (byte)-7,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)2,  (byte)4,  (byte)5, (byte)-9,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)6, (byte)-2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-4,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)6,  (byte)1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)6,  (byte)5,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)3,
  (byte)1,  (byte)3,  (byte)7,  (byte)3,
  (byte)2,  (byte)4,  (byte)5,(byte)-11,  (byte)6,  (byte)3,
  (byte)2,  (byte)1,  (byte)5, (byte)-4,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)2,  (byte)6,  (byte)5,(byte)-16,  (byte)6,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-7,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)6, (byte)-4,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-5,  (byte)7,  (byte)1,
  (byte)3,  (byte)3,  (byte)6, (byte)-6,  (byte)7,  (byte)2,  (byte)8,  (byte)1,
  (byte)3,  (byte)3,  (byte)6, (byte)-7,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-2,  (byte)7,  (byte)2,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)5,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-4,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-1,  (byte)7, (byte)-2,  (byte)8,  (byte)1,
  (byte)2,  (byte)2,  (byte)6, (byte)-2,  (byte)7,  (byte)2,
  (byte)3,  (byte)2,  (byte)6, (byte)-3,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)2,  (byte)7,  (byte)1,
  (byte)2,  (byte)1,  (byte)6,  (byte)1,  (byte)7,  (byte)1,
  (byte)2,  (byte)5,  (byte)5,(byte)-11,  (byte)6,  (byte)2,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-6,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)6,  (byte)1,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-3,  (byte)8,  (byte)1,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)3,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-7,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-1,  (byte)6, (byte)-7,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)2,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-7,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-2,  (byte)6, (byte)-4,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-4,  (byte)7,  (byte)2,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)4,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-2,  (byte)8,  (byte)1,
  (byte)2,  (byte)2,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-2,  (byte)7,  (byte)2,  (byte)8,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-6,  (byte)7,  (byte)1,
  (byte)2,  (byte)6,  (byte)5,(byte)-13,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-2,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)2,  (byte)4,  (byte)5, (byte)-8,  (byte)6,  (byte)2,
  (byte)3,  (byte)3,  (byte)6, (byte)-2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)6, (byte)-4,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6,  (byte)1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)5,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)3,  (byte)7,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)3,
  (byte)3,  (byte)1,  (byte)6,  (byte)4,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)6,  (byte)2,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)5,(byte)-12,  (byte)6,  (byte)2,
  (byte)2,  (byte)5,  (byte)6, (byte)-8,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-5,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-2,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-2,  (byte)7,  (byte)1,
  (byte)3,  (byte)3,  (byte)6, (byte)-3,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)5,(byte)-10,  (byte)6,  (byte)2,
  (byte)3,  (byte)1,  (byte)5,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-5,  (byte)6,  (byte)3,
  (byte)2,  (byte)3,  (byte)6, (byte)-3,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)5,  (byte)2,
  (byte)2,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)2,
  (byte)2,  (byte)5,  (byte)6, (byte)-7,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-4,  (byte)7,  (byte)2,
  (byte)2,  (byte)3,  (byte)6, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)6, (byte)-6,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-7,  (byte)6,  (byte)2,
  (byte)2,  (byte)4,  (byte)6, (byte)-3,  (byte)7,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)6,  (byte)2,
  (byte)3,  (byte)2,  (byte)6, (byte)-9,  (byte)7,  (byte)3,  (byte)8,  (byte)0,
  (byte)1,  (byte)3,  (byte)6,  (byte)4,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)6,  (byte)4,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)5,(byte)-13,  (byte)6,  (byte)1,
  (byte)2,  (byte)6,  (byte)6, (byte)-8,  (byte)7,  (byte)1,
  (byte)2,  (byte)5,  (byte)6, (byte)-5,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-9,  (byte)6,  (byte)2,
  (byte)2,  (byte)3,  (byte)5, (byte)-4,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)5,  (byte)1,  (byte)6,  (byte)2,
  (byte)2,  (byte)6,  (byte)5,(byte)-11,  (byte)6,  (byte)0,
  (byte)3,  (byte)6,  (byte)6, (byte)-7,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-6,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-1,  (byte)6,  (byte)2,
  (byte)1,  (byte)4,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-2,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-9,  (byte)6,  (byte)1,
  (byte)2,  (byte)5,  (byte)5, (byte)-8,  (byte)6,  (byte)2,
  (byte)2,  (byte)3,  (byte)5, (byte)-3,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)5,  (byte)2,  (byte)6,  (byte)2,
  (byte)2,  (byte)6,  (byte)5,(byte)-10,  (byte)6,  (byte)1,
  (byte)2,  (byte)4,  (byte)5, (byte)-5,  (byte)6,  (byte)2,
  (byte)1,  (byte)2,  (byte)5,  (byte)1,
  (byte)1,  (byte)5,  (byte)6,  (byte)2,
  (byte)2,  (byte)5,  (byte)5, (byte)-7,  (byte)6,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-2,  (byte)6,  (byte)1,
  (byte)3,  (byte)1,  (byte)5,  (byte)2,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-4,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5,  (byte)1,  (byte)6,  (byte)1,
  (byte)2,  (byte)7,  (byte)5,(byte)-11,  (byte)6,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-6,  (byte)6,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-1,  (byte)6,  (byte)1,
  (byte)2,  (byte)6,  (byte)5, (byte)-8,  (byte)6,  (byte)1,
  (byte)2,  (byte)4,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)1,  (byte)3,  (byte)5,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-7,  (byte)6,  (byte)1,
  (byte)2,  (byte)7,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-4,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-6,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)5, (byte)-8,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)5, (byte)-7,  (byte)6,  (byte)0,
  (byte)2,  (byte)8,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)2,  (byte)8,  (byte)5, (byte)-8,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)6,  (byte)0,
 (byte)-1
  };
  /* Total terms = 215, small = 211 */
  static Plantbl sat404 = new Plantbl(
                               new short[]{0,  0,  1,  0,  8, 18,  9,  5,  0},
                               (short)7,
                               satargs,
                               sattabl,
                               sattabb,
                               sattabr,
                               9.5575813548599999e+00
  );
}


class SwemptabUra {
  /*
  First date in file = 625296.50
  Number of records = 16731.0
  Days per record = 131.0
        Julian Years      Lon    Lat    Rad
   -3000.0 to  -2499.7:   0.35   0.06   0.42
   -2499.7 to  -1999.7:   0.50   0.06   0.38
   -1999.7 to  -1499.7:   0.39   0.07   0.34
   -1499.7 to   -999.8:   0.34   0.06   0.30
    -999.8 to   -499.8:   0.35   0.05   0.32
    -499.8 to      0.2:   0.32   0.05   0.27
       0.2 to    500.2:   0.26   0.04   0.25
     500.2 to   1000.1:   0.28   0.04   0.25
    1000.1 to   1500.1:   0.26   0.06   0.31
    1500.1 to   2000.1:   0.33   0.05   0.24
    2000.1 to   2500.0:   0.32   0.06   0.26
    2500.0 to   3000.0:   0.34   0.06   0.32
    3000.0 to   3000.4:  0.406  0.035  0.172
  */
  static final double uratabl[] = {
          21.56000,       -4652.06828,   154246324.90417,     1130486.05080,

         330.11531,       -3020.20235,

          -8.03769,        -122.02019,

         212.45130,         254.23866,          25.39758,          60.08296,

        6949.85053,       51951.42606,       -1834.66531,       44481.91144,
       -3267.45825,       10776.65972,        -628.05388,         532.83011,
         -16.80583,         -30.05544,

        1420.33767,        2007.21040,         592.32842,        1541.61732,
        -163.55984,         121.14134,         114.74969,         -16.04944,

           0.06069,           0.00725,

          -0.16861,           0.28785,

           0.07399,          -0.09680,

           0.19936,          -0.41620,

           0.02922,           0.07398,

           0.17272,           0.05602,

           1.65461,          -0.68278,          -2.18745,          -0.85327,
           0.52467,          -0.30863,

           0.01598,           0.30017,

          -0.04190,          -0.03288,

          -0.02013,           0.02257,

          -0.54883,          -0.22701,          -0.09257,          -0.03921,

           0.02644,           0.04667,

           0.24773,          -0.16562,

       44242.85814,     -223163.54065,      123776.84417,     -206375.74884,
       70472.73820,      -27456.55173,        4065.74401,       13202.39154,
       -3260.72648,         802.50579,        -153.13236,        -503.81026,
          30.17812,         -31.91893,

         -65.14719,          77.78417,         -37.38185,          19.13337,
          -3.14043,          -0.21147,

           0.27143,           0.17424,

           0.04458,           0.10976,

          -0.41841,          -0.21887,          -0.09194,          -0.02303,

           0.02896,           0.10044,

           0.01385,           0.01723,

          -0.01126,          -0.09318,

         -57.95890,          29.69059,         -46.41390,           3.07177,
           0.42494,           2.33678,          -3.09621,           0.05256,

          -0.02134,          -0.35202,

          -0.44475,          -0.83135,

        1318.18265,       25605.86848,       -9168.38371,       18917.31507,
       -5145.74480,        2130.77612,        -485.25920,        -438.44867,
          19.97802,         -33.14800,

      -23383.91826,      -45133.19122,      -18520.80729,      -26549.95198,
       -2276.70124,       -2974.01604,         603.23665,         306.87616,
         -87.73070,         -32.49134,

      549975.14525,      261920.31896,      526261.09735,      362619.26839,
      150616.68873,      164643.90808,        9550.02662,       27381.83042,
       -1065.89047,        1024.20231,         -66.63822,         -44.75169,

         -92.10532,         -20.26930,

     -313205.95341,     1462242.64616,      112982.53079,     1865690.41965,
      308844.30901,      639864.93227,       89716.32843,       10378.80773,
        4395.08428,      -14565.35913,       -3016.07754,      -19348.64612,

        3838.36899,       -9813.42713,        6883.58821,       -6064.92588,
        2740.47455,        -176.29547,         241.91895,         268.44181,
          -6.13397,          17.92503,

          -0.01377,          -0.08742,

         387.51915,         257.03872,         152.81792,         221.56197,
         -22.94836,          29.56640,          -2.27801,           4.72805,
          -6.03420,          -0.36763,

           0.00667,           0.00443,

          -0.01405,           0.04658,

          -0.06533,          -0.01966,

           0.10738,           0.00443,

           0.02889,           0.01056,

           0.00900,          -0.02206,

           0.00013,           0.05281,

           0.03035,           0.34793,

           0.19460,           2.47360,

           0.18189,          -0.83895,           0.24983,          15.32050,

           0.46010,           2.79643,

          -0.45793,           0.96707,          -0.31226,           0.51911,
           0.04071,           0.39399,

           0.00038,           0.03854,

           0.22446,           0.13630,          -0.04357,           0.03635,

           0.00202,          -0.04502,

          -0.00458,          -0.03884,

           1.32597,           3.40849,          -1.67839,          -0.95411,

          -1.00116,          -0.72744,          -0.22484,          -0.27682,

          -0.18069,           0.00405,

          -0.01000,           0.27523,

          -0.07038,          -0.01051,

          -0.09064,           0.08518,

           0.02083,          -0.25406,

           0.17745,          -0.00944,

           0.21326,           0.20454,

          18.84894,          -7.64400,           0.62670,         -11.02728,
           8.91329,          20.67190,

           0.17757,          -0.15471,

          -0.11385,          -0.46057,

           6.23014,         -14.46025,           2.30012,          -2.22677,

           5.16823,          -1.64235,

        -274.58413,         833.33247,        -191.26241,         269.90157,
         -17.25965,           9.11368,

        -261.65136,      -18274.45858,       -2553.83872,      -10039.10490,
        -508.52567,         336.18172,          14.88587,         421.35954,
         162.43462,         544.92580,

          -0.44246,           0.23216,

          -0.29024,          -0.13057,

          -1.58438,           0.34032,          -0.31604,          -0.01166,

          -0.07112,           0.05721,

          -0.10813,           0.01064,

          -0.05413,           0.06705,

          -0.41582,          -0.47725,           0.31031,           0.08605,

           0.00409,           0.02373,

           0.08092,           0.06247,          -0.01026,           0.05863,

          -0.00238,           0.02948,

           0.00117,           0.02714,

           0.01720,           0.18261,

          -0.04067,           0.88639,

          -0.15502,          -0.96383,

          -0.05307,          -0.17319,

          -0.00486,          -0.02373,

          -0.14748,          -0.11884,           0.07798,          -0.00358,

           0.01104,           0.00805,

           0.15099,          -0.03453,           0.01846,           0.03459,

           0.02197,           0.07012,

          -0.43677,          -1.87445,           1.35202,           2.28294,

          -0.03592,           0.07679,

           0.16427,           0.03014,           0.02472,           0.05549,

          -0.04985,           0.05874,

           0.35361,           0.01144,          -0.57400,           1.34898,

           0.00265,           0.01540,

           0.00951,           0.08159,

          -0.00435,           0.34759,

          -0.12413,          -0.49848,

          -0.77075,          -2.73810,

         -31.77702,          12.16042,         -14.87605,          11.98287,
          12.69358,           1.31307,          -8.22911,         -21.47437,

          -0.24051,          -0.38332,

          -0.01162,          -0.03175,

           0.00556,           0.02454,

          -0.02297,          -0.01654,

           0.00707,           0.04828,

          -0.00309,           0.17381,

          -0.00500,          -0.07579,

           0.02008,           0.05356,

           0.00702,           0.01133,

          -0.00237,          -0.00612,

           0.18551,           0.22799,          -0.14194,          -0.08593,

           0.00002,          -0.01049,

          -0.17363,          -0.13986,           0.00078,          -0.06993,

          -0.00430,          -0.07795,

          -0.03232,          -4.13170,

           0.00311,           0.05356,

          -0.17324,          -0.15505,          -0.00590,          -0.06608,

           0.04257,          -0.04571,

           0.00501,           0.02141,

          -0.00037,           0.07845,

          -0.00381,          -0.03417,

           0.01834,           0.03349,

           0.07994,           0.15297,

          -0.82299,           0.24672,           0.51764,           0.96379,

           0.01729,           0.02489,

          -0.08581,           0.13252,

           0.00538,           0.01995,

          -0.00148,          -0.02261,

           0.00534,           0.01565,

          -0.07518,          -0.28114,           0.22386,           0.39023,

          -0.00864,           0.00964,

          -0.01923,          -0.02426,

          -0.00112,           0.00923,

          -0.00685,           0.02450,

           0.26733,          -0.99972,          -0.82005,           0.13725,

           0.01520,          -0.00790,

           0.00358,           0.00751,

          -0.00648,          -0.00605,

          -0.04966,          -0.04633,

           0.06394,          -0.01965,

           0.50185,           0.40553,          -0.25809,           0.28853,
           0.52545,          -3.41675,

          -0.00347,          -0.11848,

           0.02945,          -0.01061,

          -0.04160,          -0.03519,

          -0.03234,          -0.81852,

          -0.02156,          -0.00841,

           0.00029,           0.00020,

          -0.02281,          -0.00364,

           0.04738,          -0.04504,

          -0.19161,           0.37225,           0.05765,           0.11987,

           0.00050,           0.02012,

          -0.03806,           0.39498,

           0.29982,           0.00886,           0.01671,          53.04042,

          -0.04160,          -0.38856,

          -0.00174,          -0.01773,

          -0.47661,          -0.32010,          -0.01088,          -0.16231,

          -0.01584,          -0.00144,

           0.06659,           0.12734,

           0.04884,           0.02236,

           0.00146,           0.06030,

          -0.20660,          -0.03982,           0.15091,           1.24562,

          -0.01303,          -0.22426,

          -0.01518,          -0.03922,

          -0.00043,          -0.00047,

           0.02451,           0.04437,

           0.02380,          -0.00189,

          -0.00640,          -0.07114,

          -0.00320,          -0.02491,

          -0.00829,           0.07284,

           0.02846,          -0.28034,

          -0.00268,           0.00256,

          -0.43420,           0.39645,          -0.31053,           1.25916,

          -0.00371,          -0.00651,

          -0.00096,           0.02762,

          -0.00067,          -0.02503,

          -0.01517,           0.03748,

  };
  static final double uratabb[] = {
           0.00000,         107.91527,          83.39404,        -124.29804,

          -7.73277,          -3.99442,

          -0.08328,          -1.74251,

          -9.05659,         -22.88559,          -2.30655,          -4.40259,

        -470.94604,       -3648.43408,         326.28960,       -2972.91303,
         337.37285,        -650.33570,          57.18479,         -18.29130,
           1.13897,           2.70158,

         -13.64388,         -71.88619,           7.36408,         -43.79994,
           6.57463,          -5.81111,          -0.06451,           0.73379,

           0.00574,          -0.01635,

           0.00074,          -0.01496,

          -0.00418,           0.00647,

          -0.00407,           0.00548,

           0.00002,           0.00187,

          -0.00591,           0.00557,

           0.32568,          -0.01574,           0.19347,          -0.01705,
           0.00173,           0.02384,

          -0.00248,          -0.00103,

           0.00227,           0.00146,

           0.00307,          -0.00040,

           0.03886,           0.01987,           0.00546,           0.00345,

           0.00134,          -0.00609,

          -0.01502,          -0.01569,

      -10080.59325,       10806.67752,      -14013.76861,        9928.38683,
       -6540.83480,        2084.91597,       -1093.05006,        -305.34266,
          -9.04558,        -110.32310,           9.26094,          -3.93195,
           0.25552,           0.50327,

         -13.12170,          -4.19317,          -4.50857,          -3.37626,
          -0.26850,          -0.36028,

          -0.00357,           0.05862,

          -0.00828,           0.00926,

          -0.01515,          -0.03687,          -0.00224,          -0.00802,

          -0.00225,          -0.00158,

          -0.00022,          -0.00044,

          -0.00281,           0.00371,

           2.28259,          -4.29888,           1.74622,          -2.13604,
           0.37023,          -0.37022,           0.00886,           0.07081,

           0.01669,           0.00056,

          -0.02020,           0.01586,

       -4255.31929,        5978.03267,       -7264.48027,        1884.12585,
       -2353.93882,       -1593.23001,          17.57205,        -498.54139,
          33.28704,         -13.79498,

      -38416.64883,      -13774.09664,      -32822.03952,       -3983.42726,
       -7538.09822,        1906.66915,        -221.24439,         512.77046,
          32.26101,          12.46483,

      142710.47871,      -96584.83892,      145395.05981,      -86630.96423,
       48202.96749,      -23596.77676,        5286.16967,       -1626.44031,
         -16.53568,          95.15428,         -15.19472,           5.69207,

          -6.72181,           7.28683,

        9515.16142,     -166495.49381,        5588.84271,     -146260.29445,
        2023.55881,      -30687.22422,         243.64741,         971.58076,
         390.73247,        -236.13754,       -2684.56349,         739.81087,

        -597.39429,         474.89313,        -631.69166,         213.04947,
        -204.89515,         -33.09139,         -17.78004,         -22.21866,
           0.61083,          -1.41177,

          -0.00070,          -0.00501,

         -58.24552,          25.27978,         -36.39386,           0.36376,
          -2.21030,          -6.46685,          -0.58473,          -0.09357,
           0.12829,          -0.94855,

           0.00042,           0.00048,

           0.00411,           0.00101,

           0.00249,          -0.00865,

           0.00223,           0.00293,

           0.00041,          -0.00042,

           0.00104,          -0.00086,

           0.00126,          -0.00380,

           0.00906,          -0.02253,

           0.05998,          -0.10318,

           0.00004,          -0.03225,           0.14303,          -0.05273,

           0.32683,           0.09386,

          -0.17053,           0.60847,          -0.06190,           0.28166,
           0.06411,           0.05289,

           0.01138,           0.00128,

          -0.00930,           0.00272,           0.00037,           0.00215,

           0.00004,           0.00050,

           0.00114,          -0.00217,

           0.05358,          -0.06413,          -0.00124,           0.03842,

           0.01006,           0.22479,           0.00412,           0.04040,

           0.01708,           0.02164,

           0.02484,          -0.02463,

          -0.00103,           0.02633,

          -0.01303,          -0.03214,

           0.03613,           0.02205,

          -0.02677,          -0.02522,

          -0.00293,           0.03130,

          -1.87255,          -2.50308,          -1.53715,           0.36859,
          -0.17829,          -1.12095,

          -0.05652,          -0.00786,

          -0.06992,           0.07279,

          -2.95896,           0.55138,          -0.61498,          -0.11008,

          -0.87790,          -0.50965,

         119.73553,         -35.18217,          44.78683,          -4.22438,
           1.95723,           0.58033,

       -4077.02379,        -353.39110,       -2781.63273,         -75.23318,
        -312.50478,         -23.86495,          24.59887,          32.56837,
         120.09593,         -51.00495,

           0.09737,           0.09111,

           0.04799,          -0.05029,

           0.08351,          -0.33726,           0.03158,          -0.06435,

          -0.00523,          -0.01736,

           0.00751,          -0.01757,

          -0.00406,          -0.01198,

           0.16402,          -0.10986,          -0.02024,           0.07205,

          -0.00440,          -0.00072,

          -0.00465,           0.00310,          -0.00121,          -0.00121,

           0.00083,           0.00020,

           0.00140,          -0.00176,

           0.00381,          -0.00731,

          -0.01618,           0.01570,

          -0.10201,           0.05809,

          -0.03359,           0.01024,

          -0.00535,           0.00018,

           0.00024,           0.00509,          -0.00158,          -0.00466,

           0.00009,          -0.00083,

          -0.00700,          -0.00090,          -0.00011,          -0.00079,

           0.00133,          -0.00126,

           0.01416,           0.05553,           0.04283,          -0.06719,

           0.00119,           0.00291,

          -0.00263,           0.01282,          -0.00040,           0.00188,

          -0.00237,           0.00973,

          -0.39533,           0.18773,          -0.79821,          -0.40168,

           0.00151,          -0.00161,

           0.00123,          -0.00516,

          -0.01432,          -0.00293,

          -0.05477,           0.04130,

          -0.48837,           0.18944,

          -0.12552,           9.37098,           1.02045,           5.11382,
           0.72098,          -3.70049,          -5.80982,           3.30105,

          -0.09682,           0.09696,

          -0.00876,           0.00504,

           0.00318,           0.00245,

           0.00563,          -0.00665,

           0.00108,          -0.00233,

          -0.00117,           0.00177,

          -0.00343,           0.00503,

           0.01044,          -0.00651,

           0.00296,          -0.00162,

           0.00037,           0.00028,

          -0.00020,          -0.00786,           0.00029,           0.00836,

           0.00004,           0.00033,

          -0.00309,          -0.00086,          -0.00157,          -0.00086,

          -0.00058,           0.00105,

          -0.04557,           0.01794,

          -0.00122,          -0.00086,

           0.00420,          -0.00285,           0.00118,          -0.00020,

           0.00743,          -0.01217,

           0.00053,          -0.00084,

          -0.00075,           0.00097,

          -0.00107,           0.00314,

           0.00576,          -0.00505,

           0.03624,          -0.02546,

           0.05379,           0.30081,           0.29870,          -0.22106,

           0.00696,          -0.00801,

          -0.03995,          -0.01808,

          -0.00139,           0.00102,

          -0.00059,           0.00138,

           0.00019,          -0.00037,

           0.00274,           0.00658,           0.00672,          -0.01132,

           0.00023,           0.00051,

           0.00031,           0.00090,

          -0.00017,          -0.00001,

           0.00085,           0.00004,

           0.02221,          -0.01977,           0.07498,           0.03025,

          -0.00082,          -0.00022,

          -0.00073,          -0.00028,

          -0.00253,           0.00259,

          -0.01329,           0.01805,

           0.00096,           0.00833,

          -0.11836,           0.04277,          -0.10820,          -0.03018,
           0.34504,           0.09834,

          -0.00538,          -0.00231,

           0.00036,           0.00042,

          -0.00023,           0.00260,

          -0.01137,           0.00036,

           0.01081,          -0.03271,

          -0.00029,          -0.00028,

           0.00018,          -0.00003,

           0.00009,           0.00012,

           0.00127,           0.00343,           0.00100,          -0.00064,

           0.00014,           0.00004,

           0.00150,           0.00069,

          -0.01484,           0.00135,           0.03930,           0.01405,

           0.00064,           0.00029,

           0.00009,           0.00009,

           0.00054,          -0.00048,           0.00019,           0.00005,

          -0.00009,           0.00018,

           0.00192,          -0.00333,

           0.01824,           0.01071,

           0.00107,          -0.00341,

           0.25530,          -0.18414,          -0.84151,          -0.31475,

          -0.00400,          -0.00010,

          -0.00174,           0.00019,

           0.00006,          -0.00079,

           0.00066,          -0.00070,

           0.00599,           0.00330,

          -0.00160,          -0.00013,

          -0.00067,          -0.00006,

          -0.00176,          -0.00111,

           0.00652,           0.00368,

           0.00004,           0.00001,

          -0.00081,           0.00089,           0.00366,           0.00139,

           0.00002,           0.00001,

          -0.01870,          -0.00998,

          -0.00020,          -0.00007,

           0.00005,           0.00003,

  };
  static final double uratabr[] = {
           0.00000,         -53.23277,         -44.70609,         -62.54432,

         -19.15218,           0.10867,

          -1.91911,           1.47517,

          16.51994,           5.00458,           3.88980,           1.55740,

        3598.17109,        1831.07574,        2633.34851,        1775.69482,
         497.10486,         488.77343,           6.03892,          31.08365,
          -2.06585,          -1.12599,

         230.37762,        -113.95449,         162.40244,         -46.57185,
           6.70207,          17.27241,          -0.66092,         -14.42065,

          -0.01044,          -0.00287,

          -0.03894,          -0.01663,

           0.01629,           0.00496,

           0.08411,           0.02855,

           0.01795,          -0.00695,

           0.02426,          -0.03921,

          -0.24495,          -0.77369,          -0.31404,           0.38668,
          -0.05682,          -0.17197,

           0.06145,          -0.00510,

           0.00606,          -0.00886,

          -0.00370,          -0.00588,

           0.02173,          -0.11909,           0.00302,          -0.01796,

          -0.01067,           0.00990,

           0.05283,           0.06517,

       59710.89716,        -491.12783,       58672.38609,       19564.41947,
       10597.99050,       14313.02561,       -2585.52040,         766.78396,
        -138.39893,        -802.43403,         131.35006,         -31.97561,
           7.95978,           8.16075,

          28.72669,          31.72473,           6.45792,          16.50701,
           0.01066,           1.29718,

           0.11565,          -0.13240,

           0.05110,          -0.01543,

          -0.09994,           0.18864,          -0.01330,           0.04148,

           0.03510,          -0.00366,

           0.00604,          -0.00604,

           0.03752,          -0.00256,

          -7.00488,         -21.63748,           1.43064,         -17.10914,
          -0.62987,           0.48719,           0.00697,          -1.22665,

          -0.14435,          -0.00550,

           0.32008,          -0.19855,

      -13976.73731,       -3559.49432,       -7709.90803,       -9310.80334,
         749.31835,       -3491.50696,         540.94979,         -84.57550,
          16.96663,          35.53930,

       37214.64771,      -36361.15845,       21093.74492,      -31855.33076,
        1500.84653,       -7031.97901,        -453.40865,         -18.36692,
          -2.07726,         -17.92336,

      -56348.30507,      378512.71483,     -111444.43340,      370543.95160,
      -61893.70301,      112131.05507,      -11977.44617,        9156.15245,
        -567.61838,        -495.25760,          16.96202,         -44.06279,

           4.24760,         -48.83674,

     -643705.49516,     -131013.09649,     -838580.02217,       67627.11556,
     -288441.70339,      150227.25291,       -2500.57537,       42676.19888,
        7084.60505,        2043.65642,        9639.56835,       -1502.03390,

       -4126.00409,        -828.73564,       -2801.35204,       -2293.77751,
        -209.23365,       -1045.31476,          95.57334,        -102.74623,
           7.19216,           1.89593,

          -0.05661,           0.02166,

         120.38332,        -141.16507,          98.31386,         -40.23448,
          10.84269,          17.57713,           1.69239,           1.45065,
          -0.19626,           2.76108,

          -0.00270,           0.00360,

          -0.02333,          -0.00710,

          -0.01035,           0.02950,

           0.00737,          -0.06311,

          -0.00613,           0.01407,

           0.01377,           0.00879,

          -0.03287,           0.00012,

          -0.21667,           0.01793,

          -1.54865,           0.10953,

           0.54543,           0.12102,          -9.48047,           0.11477,

          -1.34966,           0.23199,

          -1.50834,           0.26567,          -0.64503,           0.10742,
          -0.21452,           0.04428,

          -0.01920,          -0.00906,

          -0.09378,           0.12773,          -0.02787,          -0.03090,

           0.03111,           0.00140,

           0.03771,          -0.01269,

          -1.94794,           1.22823,           0.64183,          -1.11467,

          -0.19301,          -0.27357,           0.05710,          -0.08115,

          -0.07318,           0.00806,

           0.14286,           0.20297,

           0.14920,          -0.07897,

           0.09682,           0.02379,

          -0.13928,           0.01679,

          -0.00774,           0.10060,

           0.24433,           0.16760,

          -2.88905,          -1.61439,           2.83052,          -3.41031,
          36.37048,           3.37867,

           0.29321,           0.09687,

           0.29324,          -0.14651,

           8.11116,           1.79211,           1.36421,           0.88111,

           1.21683,           2.37950,

        -357.76211,         -87.84636,        -117.55745,         -67.18338,
          -5.26029,          -6.27559,

        7509.94562,           3.68942,        4223.62097,       -1041.13557,
         -74.64464,        -251.41613,        -166.22180,          -1.68190,
        -214.55340,          62.79593,

          -0.08250,          -0.15936,

          -0.03830,           0.10857,

           0.21368,           0.50812,           0.00869,           0.09832,

           0.02158,           0.02045,

           0.01407,           0.03591,

           0.03460,           0.01171,

          -0.16400,           0.09751,           0.03521,          -0.12858,

           0.00700,          -0.00524,

           0.01698,          -0.04796,           0.04006,           0.00565,

          -0.02783,          -0.00205,

          -0.02296,           0.00153,

          -0.16139,           0.01514,

          -0.78136,          -0.01546,

           0.40374,          -0.06014,

           0.06212,          -0.01828,

           0.00831,          -0.00173,

           0.06857,          -0.11677,           0.00028,           0.05765,

          -0.00796,           0.00691,

           0.03764,           0.14902,          -0.02653,           0.02122,

          -0.05503,           0.01549,

           1.56630,          -0.35551,          -1.87960,           1.14303,

          -0.06063,          -0.03425,

           0.03367,          -0.11969,           0.04485,          -0.01651,

           0.04647,          -0.02097,

           0.22841,           0.47362,           0.99226,          -0.60660,

          -0.01249,           0.00134,

          -0.07435,           0.00722,

          -0.31796,          -0.00015,

           0.20533,          -0.04398,

           0.93944,          -0.26710,

          -5.60051,          -9.32918,          -5.13538,          -4.05130,
          -0.56529,           4.34112,           7.18308,          -2.66103,

           0.13241,          -0.07999,

           0.01046,          -0.00535,

          -0.04037,          -0.00455,

          -0.00510,           0.00731,

          -0.04576,           0.00513,

          -0.15846,          -0.00236,

           0.04628,          -0.00463,

          -0.01585,           0.00585,

          -0.00213,           0.00283,

           0.00778,          -0.00198,

          -0.17803,           0.18321,           0.07702,          -0.12325,

           0.01091,           0.00349,

           0.14211,          -0.21830,           0.07289,          -0.00994,

           0.07090,          -0.00079,

           4.18441,          -0.07413,

          -0.06247,          -0.00011,

          -0.15453,           0.14499,          -0.06557,          -0.00098,

           0.00290,           0.02921,

          -0.01923,           0.00457,

          -0.07538,          -0.00120,

           0.02263,          -0.00037,

          -0.01061,           0.00591,

          -0.04725,           0.02364,

          -0.07460,          -0.24108,          -0.28310,           0.14643,

          -0.00700,           0.00427,

           0.22963,           0.03713,

          -0.02062,           0.00478,

           0.01434,           0.00095,

          -0.01425,           0.00376,

           0.29611,          -0.08038,          -0.37811,           0.21703,

          -0.00723,          -0.00924,

          -0.02736,           0.01814,

           0.00934,           0.00731,

           0.00613,           0.00686,

          -0.91503,          -0.32009,          -0.15505,           0.79589,

          -0.00555,          -0.01536,

          -0.00698,           0.00480,

           0.00373,          -0.00046,

           0.00715,          -0.00470,

          -0.01970,          -0.05238,

           0.60649,          -0.32669,           0.17790,           0.33383,
          -2.74922,          -0.25827,

          -0.07862,           0.00406,

          -0.00948,          -0.02117,

           0.03127,          -0.04199,

           0.89670,          -0.02413,

           0.01954,           0.03990,

           0.00063,          -0.00071,

          -0.00226,           0.02009,

          -0.04407,          -0.05069,

           0.38230,           0.16101,           0.11893,          -0.06125,

           0.02051,          -0.00046,

           0.39211,           0.03679,

           0.01666,          -0.31336,          53.28735,          -0.01791,

          -0.39414,           0.04181,

          -0.01885,           0.00165,

           0.31349,          -0.47359,           0.16133,          -0.01023,

           0.00007,           0.01758,

          -0.13351,           0.07249,

           0.00977,           0.05445,

           0.11650,          -0.00191,

          -0.09824,           0.40106,           2.41155,          -0.30655,

           0.24975,          -0.01248,

          -0.03688,           0.01097,

           0.00038,          -0.00051,

          -0.04736,           0.02610,

           0.00968,           0.02634,

           0.07918,          -0.00606,

           0.02735,          -0.00320,

          -0.07544,          -0.00468,

           0.19996,          -0.01964,

           0.00201,           0.00267,

           0.39562,           0.43289,           1.24743,           0.31084,

          -0.00666,           0.00377,

           0.05668,           0.00148,

           0.03220,          -0.00026,

           0.03717,           0.01509,

  };

  static byte uraargs[] = {
  (byte)0,  (byte)3,
  (byte)2,  (byte)1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-6,  (byte)8,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)4,
  (byte)2,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)3,
  (byte)3,  (byte)1,  (byte)6, (byte)-1,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)6,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-6,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-7,  (byte)7,  (byte)3,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-8,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-7,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-6,  (byte)7,  (byte)2,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)4,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-2,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-4,  (byte)7,  (byte)3,  (byte)8,  (byte)1,
  (byte)2,  (byte)5,  (byte)7, (byte)-9,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-3,  (byte)8,  (byte)6,
  (byte)2,  (byte)1,  (byte)7, (byte)-3,  (byte)8,  (byte)2,
  (byte)2,  (byte)2,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-6,  (byte)7,  (byte)5,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)6, (byte)-5,  (byte)7,  (byte)3,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)8,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)5,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-5,  (byte)7,  (byte)3,
  (byte)3,  (byte)1,  (byte)6,  (byte)1,  (byte)7, (byte)-9,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-4,  (byte)8,  (byte)4,
  (byte)2,  (byte)1,  (byte)6, (byte)-2,  (byte)7,  (byte)4,
  (byte)2,  (byte)5,  (byte)7, (byte)-8,  (byte)8,  (byte)5,
  (byte)2,  (byte)3,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)7,  (byte)5,
  (byte)2,  (byte)2,  (byte)7, (byte)-6,  (byte)8,  (byte)4,
  (byte)3,  (byte)1,  (byte)6, (byte)-6,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-4,  (byte)7,  (byte)4,
  (byte)3,  (byte)2,  (byte)6, (byte)-5,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-6,  (byte)7,  (byte)3,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-7,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-1,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-9,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-3,  (byte)8,  (byte)1,
  (byte)2,  (byte)2,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)7,  (byte)1,  (byte)8,  (byte)2,
  (byte)1,  (byte)3,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-7,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-4,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-3,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-4,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-5,  (byte)7,  (byte)2,  (byte)8,  (byte)1,
  (byte)3,  (byte)5,  (byte)5, (byte)-9,  (byte)6, (byte)-8,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)6,  (byte)3,  (byte)7, (byte)-8,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-8,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)4,  (byte)7,  (byte)0,
  (byte)3,  (byte)4,  (byte)5,(byte)-10,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-1,  (byte)7,  (byte)2,
  (byte)2,  (byte)8,  (byte)7,(byte)-12,  (byte)8,  (byte)0,
  (byte)2,  (byte)7,  (byte)7,(byte)-10,  (byte)8,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-8,  (byte)8,  (byte)1,
  (byte)2,  (byte)5,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-4,  (byte)8,  (byte)2,
  (byte)1,  (byte)2,  (byte)7,  (byte)4,
  (byte)1,  (byte)4,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-8,  (byte)8,  (byte)1,
  (byte)2,  (byte)3,  (byte)7,(byte)-10,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7,(byte)-12,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-6,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-5,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)6, (byte)-4,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)2,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-9,  (byte)8,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-6,  (byte)7,  (byte)1,
  (byte)3,  (byte)3,  (byte)6, (byte)-7,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-4,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)6,  (byte)1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)6,  (byte)1,
  (byte)2,  (byte)8,  (byte)7,(byte)-10,  (byte)8,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-8,  (byte)8,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)3,  (byte)7,  (byte)3,
  (byte)2,  (byte)2,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-4,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-6,  (byte)7,  (byte)0,
  (byte)2,  (byte)8,  (byte)7, (byte)-9,  (byte)8,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)6, (byte)-4,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-5,  (byte)7,  (byte)1,
  (byte)3,  (byte)3,  (byte)6, (byte)-6,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-2,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-3,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)2,  (byte)7,  (byte)1,
  (byte)2,  (byte)1,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)9,  (byte)7,(byte)-10,  (byte)8,  (byte)0,
  (byte)2,  (byte)8,  (byte)7, (byte)-8,  (byte)8,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)4,  (byte)7,  (byte)1,
  (byte)2,  (byte)3,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)9,  (byte)7, (byte)-9,  (byte)8,  (byte)0,
  (byte)2,  (byte)8,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)6, (byte)-3,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-4,  (byte)7,  (byte)1,
  (byte)3,  (byte)3,  (byte)6, (byte)-5,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)4,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-1,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-2,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)5,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)6, (byte)-4,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)7,  (byte)2,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-6,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5,  (byte)1,  (byte)6, (byte)-4,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-5,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)1,  (byte)6,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)5,  (byte)1,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)1,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-5,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5,  (byte)1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)5,  (byte)1,
  (byte)2,  (byte)4,  (byte)6, (byte)-4,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-5,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)6, (byte)-6,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)6, (byte)-5,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)6, (byte)-6,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-1,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-2,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)1,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-1,  (byte)7,  (byte)0,
 (byte)-1
  };
  /* Total terms = 177, small = 171 */
  static Plantbl ura404 = new Plantbl(
                               new short[]{0,  0,  0,  0,  5, 10,  9, 12,  0},
                               (short)6,
                               uraargs,
                               uratabl,
                               uratabb,
                               uratabr,
                               1.9218446061800002e+01
  );
}

class SwemptabVen {
  /*
  First date in file = 1228000.50
  Number of records = 397276.0
  Days per record = 4.0
        Julian Years      Lon    Lat    Rad
   -1349.9 to  -1000.0:   0.23   0.15   0.10
   -1000.0 to   -500.0:   0.25   0.15   0.10
    -500.0 to      0.0:   0.20   0.13   0.09
       0.0 to    500.0:   0.16   0.11   0.08
     500.0 to   1000.0:   0.19   0.09   0.08
    1000.0 to   1500.0:   0.16   0.09   0.08
    1500.0 to   2000.0:   0.21   0.12   0.08
    2000.0 to   2500.0:   0.28   0.14   0.09
    2500.0 to   3000.0:   0.30   0.15   0.10
    3000.0 to   3000.8:  0.116  0.062  0.058
  */
  static final double ventabl[] = {
           9.08078,          55.42416, 21066413644.98911,      655127.20186,

           0.00329,           0.10408,

           0.00268,          -0.01908,

           0.00653,           0.00183,

           0.15083,          -0.21997,

           6.08596,           2.34841,           3.70668,          -0.22740,
          -2.29376,          -1.46741,

          -0.03840,           0.01242,

           0.00176,           0.00913,

           0.00121,          -0.01222,

          -1.22624,           0.65264,          -1.15974,          -1.28172,
           1.00656,          -0.66266,

           0.01560,          -0.00654,           0.00896,           0.00069,

           0.21649,          -0.01786,

           0.01239,           0.00255,

           0.00084,          -0.06086,

          -0.00041,           0.00887,

           0.13453,          -0.20013,           0.08234,           0.01575,

           0.00658,          -0.00214,

           0.00254,           0.00857,

          -0.01047,          -0.00519,

           0.63215,          -0.40914,           0.34271,          -1.53258,

           0.00038,          -0.01437,

          -0.02599,          -2.27805,          -0.36873,          -1.01799,
          -0.36798,           1.41356,

          -0.08167,           0.01368,           0.20676,           0.06807,

           0.02282,          -0.04691,

           0.30308,          -0.20218,           0.24785,           0.27522,

           0.00197,          -0.00499,

           1.43909,          -0.46154,           0.93459,           2.99583,
          -3.43274,           0.05672,

          -0.06586,           0.12467,           0.02505,          -0.08433,

           0.00743,           0.00174,

          -0.04013,           0.17715,

          -0.00603,          -0.01024,

           0.01542,          -0.02378,

           0.00676,           0.00002,

          -0.00168,          -4.89487,

           0.02393,          -0.03064,

           0.00090,           0.00977,

           0.01223,           0.00381,

           0.28135,          -0.09158,           0.18550,           0.58372,
          -0.67437,           0.01409,

          -0.25404,          -0.06863,

           0.06763,          -0.02939,

          -0.00009,          -0.04888,

           0.01718,          -0.00978,

          -0.01945,           0.08847,

          -0.00135,         -11.29920,

           0.01689,          -0.04756,

           0.02075,          -0.01667,

           0.01397,           0.00443,

          -0.28437,           0.07600,           0.17996,          -0.44326,

           0.29356,           1.41869,          -1.58617,           0.03206,

           0.00229,          -0.00753,

          -0.03076,          -2.96766,

           0.00245,           0.00697,

           0.01063,          -0.02468,

          -0.00351,          -0.18179,

          -0.01088,           0.00380,

           0.00496,           0.02072,

          -0.12890,           0.16719,          -0.06820,          -0.03234,

         -60.36135,         -11.74485,         -11.03752,          -3.80145,
         -21.33955,        -284.54495,        -763.43839,         248.50823,
        1493.02775,        1288.79621,       -2091.10921,       -1851.15420,

          -0.00922,           0.06233,

           0.00004,           0.00785,

           0.10363,          -0.16770,           0.45497,           0.24051,
          -0.28057,           0.61126,

          -0.02057,           0.00010,

           0.00561,           0.01994,

           0.01416,          -0.00442,

           0.03073,          -0.14961,

          -0.06272,           0.08301,

           0.02040,           7.12824,

          -0.00453,          -0.01815,

           0.00004,          -0.00013,

          -0.03593,          -0.18147,           0.20353,          -0.00683,

           0.00003,           0.06226,

          -0.00443,           0.00257,

           0.03194,           0.03254,

           0.00282,          -0.01401,

           0.00422,           1.03169,

          -0.00169,          -0.00591,

          -0.00307,           0.00540,

           0.05511,           0.00347,

           0.07896,           0.06583,

           0.00783,           0.01926,

           0.03109,           0.15967,

           0.00343,           0.88734,

           0.01047,           0.32054,

           0.00814,           0.00051,

           0.02474,           0.00047,

           0.00052,           0.03763,

         -57.06618,          20.34614,         -45.06541,        -115.20465,
         136.46887,         -84.67046,          92.93308,         160.44644,

          -0.00020,          -0.00082,

           0.02496,           0.00279,

           0.00849,           0.00195,

          -0.05013,          -0.04331,

          -0.00136,           0.14491,

          -0.00183,          -0.00406,

           0.01163,           0.00093,

          -0.00604,          -0.00680,

          -0.00036,           0.06861,

          -0.00450,          -0.00969,

           0.00171,           0.00979,

          -0.00152,           0.03929,

           0.00631,           0.00048,

          -0.00709,          -0.00864,

           1.51002,          -0.24657,           1.27338,           2.64699,
          -2.40990,          -0.57413,

          -0.00023,           0.03528,

           0.00268,           0.00522,

          -0.00010,           0.01933,

          -0.00006,           0.01100,

           0.06313,          -0.09939,           0.08571,           0.03206,

          -0.00004,           0.00645,

  };
  static final double ventabb[] = {
         -23.91858,          31.44154,          25.93273,         -67.68643,

          -0.00171,           0.00123,

           0.00001,          -0.00018,

          -0.00005,           0.00018,

          -0.00001,           0.00019,

           0.00733,           0.00030,          -0.00038,           0.00011,
           0.00181,           0.00120,

           0.00010,           0.00002,

          -0.00012,           0.00002,

           0.00021,           0.00004,

          -0.00403,           0.00101,           0.00342,          -0.00328,
           0.01564,           0.01212,

           0.00011,           0.00010,          -0.00002,          -0.00004,

          -0.00524,           0.00079,

           0.00011,           0.00002,

          -0.00001,           0.00003,

           0.00001,           0.00000,

           0.00108,           0.00035,           0.00003,           0.00064,

          -0.00000,          -0.00002,

          -0.00069,           0.00031,

           0.00020,           0.00003,

           0.00768,           0.03697,          -0.07906,           0.01673,

          -0.00003,          -0.00001,

          -0.00198,          -0.01045,           0.01761,          -0.00803,
          -0.00751,           0.04199,

           0.00280,          -0.00213,          -0.00482,          -0.00209,

          -0.01077,           0.00715,

           0.00048,          -0.00004,           0.00199,           0.00237,

           0.00017,          -0.00032,

          -0.07513,          -0.00658,          -0.04213,           0.16065,
           0.27661,           0.06515,

           0.02156,          -0.08144,          -0.23994,          -0.05674,

           0.00167,           0.00069,

           0.00244,          -0.01247,

          -0.00100,           0.00036,

           0.00240,           0.00012,

           0.00010,           0.00018,

           0.00208,          -0.00098,

          -0.00217,           0.00707,

          -0.00338,           0.01260,

          -0.00127,          -0.00039,

          -0.03516,          -0.00544,          -0.01746,           0.08258,
           0.10633,           0.02523,

           0.00077,          -0.00214,

          -0.02335,           0.00976,

          -0.00019,           0.00003,

           0.00041,           0.00039,

           0.00199,          -0.01098,

           0.00813,          -0.00853,

           0.02230,           0.00349,

          -0.02250,           0.08119,

          -0.00214,          -0.00052,

          -0.00220,           0.15216,           0.17152,           0.08051,

          -0.01561,           0.27727,           0.25837,           0.07021,

          -0.00005,          -0.00000,

          -0.02692,          -0.00047,

          -0.00007,          -0.00016,

           0.01072,           0.01418,

          -0.00076,           0.00379,

          -0.00807,           0.03463,

          -0.05199,           0.06680,

          -0.00622,           0.00787,           0.00672,           0.00453,

         -10.69951,         -67.43445,        -183.55956,         -37.87932,
        -102.30497,        -780.40465,        2572.21990,        -446.97798,
        1665.42632,        5698.61327,      -11889.66501,        2814.93799,

           0.03204,          -0.09479,

           0.00014,          -0.00001,

          -0.04118,          -0.04562,           0.03435,          -0.05878,
           0.01700,           0.02566,

          -0.00121,           0.00170,

           0.02390,           0.00403,

           0.04629,           0.01896,

          -0.00521,           0.03215,

          -0.01051,           0.00696,

          -0.01332,          -0.08937,

          -0.00469,          -0.00751,

           0.00016,          -0.00035,

           0.00492,          -0.03930,          -0.04742,          -0.01013,

           0.00065,           0.00021,

          -0.00006,           0.00017,

           0.06768,          -0.01558,

          -0.00055,           0.00322,

          -0.00287,          -0.01656,

           0.00061,          -0.00041,

           0.00030,           0.00047,

          -0.01436,          -0.00148,

           0.30302,          -0.05511,

          -0.00020,          -0.00005,

           0.00042,          -0.00025,

           0.01270,           0.00458,

          -0.00593,          -0.04480,

           0.00005,          -0.00008,

           0.08457,          -0.01569,

           0.00062,           0.00018,

           9.79942,          -2.48836,           4.17423,           6.72044,
         -63.33456,          34.63597,          39.11878,         -72.89581,

          -0.00066,           0.00036,

          -0.00045,          -0.00062,

          -0.00287,          -0.00118,

          -0.21879,           0.03947,

           0.00086,           0.00671,

          -0.00113,           0.00122,

          -0.00193,          -0.00029,

          -0.03612,           0.00635,

           0.00024,           0.00207,

          -0.00273,           0.00443,

          -0.00055,           0.00030,

          -0.00451,           0.00175,

          -0.00110,          -0.00015,

          -0.02608,           0.00480,

           2.16555,          -0.70419,           1.74648,           0.97514,
          -1.15360,           1.73688,

           0.00004,           0.00105,

           0.00187,          -0.00311,

           0.00005,           0.00055,

           0.00004,           0.00032,

          -0.04629,           0.02292,          -0.00363,          -0.03807,

           0.00002,           0.00020,

  };
  static final double ventabr[] = {
          -0.24459,           3.72698,          -6.67281,           5.24378,

           0.00030,           0.00003,

          -0.00002,          -0.00000,

          -0.00000,           0.00001,

           0.00032,           0.00021,

          -0.00326,           0.01002,           0.00067,           0.00653,
           0.00243,          -0.00417,

          -0.00004,          -0.00010,

          -0.00002,          -0.00001,

           0.00004,          -0.00002,

          -0.00638,          -0.01453,           0.01458,          -0.01235,
           0.00755,           0.01030,

           0.00006,           0.00014,           0.00000,           0.00009,

           0.00063,           0.00176,

           0.00003,          -0.00022,

           0.00112,           0.00001,

          -0.00014,          -0.00001,

           0.00485,           0.00322,          -0.00035,           0.00198,

           0.00004,           0.00013,

          -0.00015,          -0.00003,

           0.00011,          -0.00025,

           0.00634,           0.02207,           0.04620,           0.00160,

           0.00045,           0.00001,

          -0.11563,           0.00643,          -0.05947,           0.02018,
           0.07704,           0.01574,

          -0.00090,          -0.00471,          -0.00322,           0.01104,

           0.00265,          -0.00038,

           0.01395,           0.02165,          -0.01948,           0.01713,

          -0.00057,          -0.00019,

           0.04889,           0.13403,          -0.28327,           0.10597,
          -0.02325,          -0.35829,

           0.01171,          -0.00904,           0.00747,           0.02546,

           0.00029,          -0.00190,

          -0.03408,          -0.00703,

           0.00176,          -0.00109,

           0.00463,           0.00293,

           0.00000,           0.00148,

           1.06691,          -0.00054,

          -0.00935,          -0.00790,

           0.00552,          -0.00084,

          -0.00100,           0.00336,

           0.02874,           0.08604,          -0.17876,           0.05973,
          -0.00720,          -0.21195,

           0.02134,          -0.07980,

           0.01500,           0.01398,

           0.01758,          -0.00004,

           0.00371,           0.00650,

          -0.03375,          -0.00723,

           4.65465,          -0.00040,

           0.02040,           0.00707,

          -0.00727,          -0.01144,

          -0.00196,           0.00620,

          -0.03396,          -0.12904,           0.20160,           0.08092,

          -0.67045,           0.14014,          -0.01571,          -0.75141,

           0.00361,           0.00110,

           1.42165,          -0.01499,

          -0.00334,           0.00117,

           0.01187,           0.00507,

           0.08935,          -0.00174,

          -0.00211,          -0.00525,

           0.01035,          -0.00252,

          -0.08355,          -0.06442,           0.01616,          -0.03409,

           5.55241,         -30.62428,           2.03824,          -6.26978,
         143.07279,         -10.24734,        -125.25411,        -380.85360,
        -644.78411,         745.02852,         926.70000,       -1045.09820,

          -0.03124,          -0.00465,

          -0.00396,           0.00002,

           0.08518,           0.05248,          -0.12178,           0.23023,
          -0.30943,          -0.14208,

          -0.00005,          -0.01054,

          -0.00894,           0.00233,

          -0.00173,          -0.00768,

           0.07881,           0.01633,

          -0.04463,          -0.03347,

          -3.92991,           0.00945,

           0.01524,          -0.00422,

          -0.00011,          -0.00005,

           0.10842,          -0.02126,           0.00349,           0.12097,

          -0.03752,           0.00001,

          -0.00156,          -0.00270,

          -0.01520,           0.01349,

           0.00895,           0.00186,

          -0.67751,           0.00180,

           0.00516,          -0.00151,

          -0.00365,          -0.00210,

          -0.00276,           0.03793,

          -0.02637,           0.03235,

          -0.01343,           0.00541,

          -0.11270,           0.02169,

          -0.63365,           0.00122,

          -0.24329,           0.00428,

          -0.00040,           0.00586,

           0.00581,           0.01112,

          -0.02731,           0.00008,

          -2.69091,           0.42729,           2.78805,           3.43849,
          -0.87998,          -6.62373,           0.56882,           4.69370,

           0.00005,          -0.00008,

          -0.00181,           0.01767,

          -0.00168,           0.00660,

           0.01802,          -0.01836,

          -0.11245,          -0.00061,

           0.00199,          -0.00070,

          -0.00076,           0.00919,

           0.00311,          -0.00165,

          -0.05650,          -0.00018,

           0.00121,          -0.00069,

          -0.00803,           0.00146,

          -0.03260,          -0.00072,

          -0.00042,           0.00524,

           0.00464,          -0.00339,

          -0.06203,          -0.00278,           0.04145,           0.02871,
          -0.01962,          -0.01362,

          -0.03040,          -0.00010,

           0.00085,          -0.00001,

          -0.01712,          -0.00006,

          -0.00996,          -0.00003,

          -0.00029,           0.00026,           0.00016,          -0.00005,

          -0.00594,          -0.00003,

  };

  static byte venargs[] = {
  (byte)0,  (byte)3,
  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)2,  (byte)1,  (byte)3, (byte)-8,  (byte)4,  (byte)0,
  (byte)3,  (byte)5,  (byte)1,(byte)-14,  (byte)2,  (byte)2,  (byte)3,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-7,  (byte)3,  (byte)4,  (byte)4,  (byte)0,
  (byte)2,  (byte)8,  (byte)2,(byte)-13,  (byte)3,  (byte)2,
  (byte)3,  (byte)6,  (byte)2,(byte)-10,  (byte)3,  (byte)3,  (byte)5,  (byte)0,
  (byte)1,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-3,  (byte)4,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)1,
  (byte)1,  (byte)1,  (byte)6,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-5,  (byte)3,  (byte)1,  (byte)5,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-5,  (byte)3,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-6,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)1,  (byte)1,  (byte)5,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-5,  (byte)3,  (byte)2,
  (byte)2,  (byte)5,  (byte)2, (byte)-8,  (byte)3,  (byte)1,
  (byte)1,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)1, (byte)-5,  (byte)2,  (byte)1,
  (byte)2,  (byte)6,  (byte)2,(byte)-10,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-3,  (byte)3,  (byte)2,
  (byte)2,  (byte)1,  (byte)2, (byte)-2,  (byte)3,  (byte)1,
  (byte)2,  (byte)4,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-6,  (byte)3,  (byte)0,
  (byte)1,  (byte)1,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-5,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-1,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)1, (byte)-3,  (byte)2,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-4,  (byte)3,  (byte)0,
  (byte)2,  (byte)6,  (byte)2, (byte)-9,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-4,  (byte)3,  (byte)2,
  (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)2,  (byte)0,
  (byte)1,  (byte)1,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-1,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)5,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-2,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-3,  (byte)5,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-3,  (byte)3,  (byte)0,
  (byte)2,  (byte)7,  (byte)2,(byte)-10,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-2,  (byte)5,  (byte)1,
  (byte)2,  (byte)4,  (byte)2, (byte)-5,  (byte)3,  (byte)1,
  (byte)3,  (byte)1,  (byte)2,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-1,  (byte)5,  (byte)0,
  (byte)3,  (byte)1,  (byte)2, (byte)-3,  (byte)5,  (byte)5,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-1,  (byte)6,  (byte)0,
  (byte)1,  (byte)3,  (byte)4,  (byte)0,
  (byte)2,  (byte)7,  (byte)2,(byte)-13,  (byte)3,  (byte)0,
  (byte)3,  (byte)1,  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)1,  (byte)1,  (byte)2,  (byte)5,
  (byte)2,  (byte)9,  (byte)2,(byte)-13,  (byte)3,  (byte)0,
  (byte)3,  (byte)1,  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-3,  (byte)4,  (byte)2,
  (byte)2,  (byte)3,  (byte)2, (byte)-6,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)2,  (byte)1,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-5,  (byte)3,  (byte)0,
  (byte)2,  (byte)6,  (byte)2, (byte)-8,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)1, (byte)-4,  (byte)2,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-3,  (byte)3,  (byte)0,
  (byte)1,  (byte)2,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)5,  (byte)2, (byte)-6,  (byte)3,  (byte)1,
  (byte)2,  (byte)2,  (byte)2, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-5,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-1,  (byte)3,  (byte)0,
  (byte)2,  (byte)7,  (byte)2, (byte)-9,  (byte)3,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-4,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)2,  (byte)1,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)6,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-2,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-3,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-2,  (byte)5,  (byte)0,
  (byte)2,  (byte)5,  (byte)2, (byte)-5,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-1,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-2,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)2,  (byte)3,
  (byte)2,  (byte)2,  (byte)2,  (byte)1,  (byte)5,  (byte)0,
  (byte)2,  (byte)7,  (byte)2, (byte)-8,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)1, (byte)-3,  (byte)2,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-3,  (byte)3,  (byte)0,
  (byte)2,  (byte)6,  (byte)2, (byte)-6,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-1,  (byte)3,  (byte)0,
  (byte)2,  (byte)8,  (byte)2, (byte)-9,  (byte)3,  (byte)0,
  (byte)2,  (byte)5,  (byte)2, (byte)-4,  (byte)3,  (byte)0,
  (byte)2,  (byte)7,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-2,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-3,  (byte)5,  (byte)0,
  (byte)2,  (byte)9,  (byte)2,(byte)-10,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-2,  (byte)5,  (byte)0,
  (byte)1,  (byte)3,  (byte)2,  (byte)2,
  (byte)2,  (byte)8,  (byte)2, (byte)-8,  (byte)3,  (byte)0,
  (byte)2,  (byte)5,  (byte)2, (byte)-3,  (byte)3,  (byte)0,
  (byte)2,  (byte)9,  (byte)2, (byte)-9,  (byte)3,  (byte)0,
  (byte)2, (byte)10,  (byte)2,(byte)-10,  (byte)3,  (byte)0,
  (byte)1,  (byte)4,  (byte)2,  (byte)1,
  (byte)2, (byte)11,  (byte)2,(byte)-11,  (byte)3,  (byte)0,
 (byte)-1
  };
  /* Total terms = 108, small = 107 */
  static Plantbl ven404 = new Plantbl(
                               new short[]{5, 14, 13,  8,  4,  5,  1,  0,  0},
                               (short)5,
                               venargs,
                               ventabl,
                               ventabb,
                               ventabr,
                               7.2332982000000001e-01
                              );
}

class Swenut2000a {
  /* 0.1 microarcsecond to degrees */
  static final double O1MAS2DEG = 1 / 3600.0 / 10000000.0;
  /* Number of terms in the luni-solar nutation model */
  static final int NLS = 678;
  static final int NLS_2000B = 77;
  /* Number of terms in the planetary nutation model */
  static final int NPL = 687;
  /* Luni-Solar argument multipliers
  L L' F D Om */
  static final int nls[] = {
  0, 0, 0, 0, 1,
  0, 0, 2, -2, 2,
  0, 0, 2, 0, 2,
  0, 0, 0, 0, 2,
  0, 1, 0, 0, 0,
  0, 1, 2, -2, 2,
  1, 0, 0, 0, 0,
  0, 0, 2, 0, 1,
  1, 0, 2, 0, 2,
  0, -1, 2, -2, 2,
  0, 0, 2, -2, 1,
  -1, 0, 2, 0, 2,
  -1, 0, 0, 2, 0,
  1, 0, 0, 0, 1,
  -1, 0, 0, 0, 1,
  -1, 0, 2, 2, 2,
  1, 0, 2, 0, 1,
  -2, 0, 2, 0, 1,
  0, 0, 0, 2, 0,
  0, 0, 2, 2, 2,
  0, -2, 2, -2, 2,
  -2, 0, 0, 2, 0,
  2, 0, 2, 0, 2,
  1, 0, 2, -2, 2,
  -1, 0, 2, 0, 1,
  2, 0, 0, 0, 0,
  0, 0, 2, 0, 0,
  0, 1, 0, 0, 1,
  -1, 0, 0, 2, 1,
  0, 2, 2, -2, 2,
  0, 0, -2, 2, 0,
  1, 0, 0, -2, 1,
  0, -1, 0, 0, 1,
  -1, 0, 2, 2, 1,
  0, 2, 0, 0, 0,
  1, 0, 2, 2, 2,
  -2, 0, 2, 0, 0,
  0, 1, 2, 0, 2,
  0, 0, 2, 2, 1,
  0, -1, 2, 0, 2,
  0, 0, 0, 2, 1,
  1, 0, 2, -2, 1,
  2, 0, 2, -2, 2,
  -2, 0, 0, 2, 1,
  2, 0, 2, 0, 1,
  0, -1, 2, -2, 1,
  0, 0, 0, -2, 1,
  -1, -1, 0, 2, 0,
  2, 0, 0, -2, 1,
  1, 0, 0, 2, 0,
  0, 1, 2, -2, 1,
  1, -1, 0, 0, 0,
  -2, 0, 2, 0, 2,
  3, 0, 2, 0, 2,
  0, -1, 0, 2, 0,
  1, -1, 2, 0, 2,
  0, 0, 0, 1, 0,
  -1, -1, 2, 2, 2,
  -1, 0, 2, 0, 0,
  0, -1, 2, 2, 2,
  -2, 0, 0, 0, 1,
  1, 1, 2, 0, 2,
  2, 0, 0, 0, 1,
  -1, 1, 0, 1, 0,
  1, 1, 0, 0, 0,
  1, 0, 2, 0, 0,
  -1, 0, 2, -2, 1,
  1, 0, 0, 0, 2,
  -1, 0, 0, 1, 0,
  0, 0, 2, 1, 2,
  -1, 0, 2, 4, 2,
  -1, 1, 0, 1, 1,
  0, -2, 2, -2, 1,
  1, 0, 2, 2, 1,
  -2, 0, 2, 2, 2,
  -1, 0, 0, 0, 2,
  1, 1, 2, -2, 2,
  -2, 0, 2, 4, 2,
  -1, 0, 4, 0, 2,
  2, 0, 2, -2, 1,
  2, 0, 2, 2, 2,
  1, 0, 0, 2, 1,
  3, 0, 0, 0, 0,
  3, 0, 2, -2, 2,
  0, 0, 4, -2, 2,
  0, 1, 2, 0, 1,
  0, 0, -2, 2, 1,
  0, 0, 2, -2, 3,
  -1, 0, 0, 4, 0,
  2, 0, -2, 0, 1,
  -2, 0, 0, 4, 0,
  -1, -1, 0, 2, 1,
  -1, 0, 0, 1, 1,
  0, 1, 0, 0, 2,
  0, 0, -2, 0, 1,
  0, -1, 2, 0, 1,
  0, 0, 2, -1, 2,
  0, 0, 2, 4, 2,
  -2, -1, 0, 2, 0,
  1, 1, 0, -2, 1,
  -1, 1, 0, 2, 0,
  -1, 1, 0, 1, 2,
  1, -1, 0, 0, 1,
  1, -1, 2, 2, 2,
  -1, 1, 2, 2, 2,
  3, 0, 2, 0, 1,
  0, 1, -2, 2, 0,
  -1, 0, 0, -2, 1,
  0, 1, 2, 2, 2,
  -1, -1, 2, 2, 1,
  0, -1, 0, 0, 2,
  1, 0, 2, -4, 1,
  -1, 0, -2, 2, 0,
  0, -1, 2, 2, 1,
  2, -1, 2, 0, 2,
  0, 0, 0, 2, 2,
  1, -1, 2, 0, 1,
  -1, 1, 2, 0, 2,
  0, 1, 0, 2, 0,
  0, -1, -2, 2, 0,
  0, 3, 2, -2, 2,
  0, 0, 0, 1, 1,
  -1, 0, 2, 2, 0,
  2, 1, 2, 0, 2,
  1, 1, 0, 0, 1,
  1, 1, 2, 0, 1,
  2, 0, 0, 2, 0,
  1, 0, -2, 2, 0,
  -1, 0, 0, 2, 2,
  0, 1, 0, 1, 0,
  0, 1, 0, -2, 1,
  -1, 0, 2, -2, 2,
  0, 0, 0, -1, 1,
  -1, 1, 0, 0, 1,
  1, 0, 2, -1, 2,
  1, -1, 0, 2, 0,
  0, 0, 0, 4, 0,
  1, 0, 2, 1, 2,
  0, 0, 2, 1, 1,
  1, 0, 0, -2, 2,
  -1, 0, 2, 4, 1,
  1, 0, -2, 0, 1,
  1, 1, 2, -2, 1,
  0, 0, 2, 2, 0,
  -1, 0, 2, -1, 1,
  -2, 0, 2, 2, 1,
  4, 0, 2, 0, 2,
  2, -1, 0, 0, 0,
  2, 1, 2, -2, 2,
  0, 1, 2, 1, 2,
  1, 0, 4, -2, 2,
  -1, -1, 0, 0, 1,
  0, 1, 0, 2, 1,
  -2, 0, 2, 4, 1,
  2, 0, 2, 0, 0,
  1, 0, 0, 1, 0,
  -1, 0, 0, 4, 1,
  -1, 0, 4, 0, 1,
  2, 0, 2, 2, 1,
  0, 0, 2, -3, 2,
  -1, -2, 0, 2, 0,
  2, 1, 0, 0, 0,
  0, 0, 4, 0, 2,
  0, 0, 0, 0, 3,
  0, 3, 0, 0, 0,
  0, 0, 2, -4, 1,
  0, -1, 0, 2, 1,
  0, 0, 0, 4, 1,
  -1, -1, 2, 4, 2,
  1, 0, 2, 4, 2,
  -2, 2, 0, 2, 0,
  -2, -1, 2, 0, 1,
  -2, 0, 0, 2, 2,
  -1, -1, 2, 0, 2,
  0, 0, 4, -2, 1,
  3, 0, 2, -2, 1,
  -2, -1, 0, 2, 1,
  1, 0, 0, -1, 1,
  0, -2, 0, 2, 0,
  -2, 0, 0, 4, 1,
  -3, 0, 0, 0, 1,
  1, 1, 2, 2, 2,
  0, 0, 2, 4, 1,
  3, 0, 2, 2, 2,
  -1, 1, 2, -2, 1,
  2, 0, 0, -4, 1,
  0, 0, 0, -2, 2,
  2, 0, 2, -4, 1,
  -1, 1, 0, 2, 1,
  0, 0, 2, -1, 1,
  0, -2, 2, 2, 2,
  2, 0, 0, 2, 1,
  4, 0, 2, -2, 2,
  2, 0, 0, -2, 2,
  0, 2, 0, 0, 1,
  1, 0, 0, -4, 1,
  0, 2, 2, -2, 1,
  -3, 0, 0, 4, 0,
  -1, 1, 2, 0, 1,
  -1, -1, 0, 4, 0,
  -1, -2, 2, 2, 2,
  -2, -1, 2, 4, 2,
  1, -1, 2, 2, 1,
  -2, 1, 0, 2, 0,
  -2, 1, 2, 0, 1,
  2, 1, 0, -2, 1,
  -3, 0, 2, 0, 1,
  -2, 0, 2, -2, 1,
  -1, 1, 0, 2, 2,
  0, -1, 2, -1, 2,
  -1, 0, 4, -2, 2,
  0, -2, 2, 0, 2,
  -1, 0, 2, 1, 2,
  2, 0, 0, 0, 2,
  0, 0, 2, 0, 3,
  -2, 0, 4, 0, 2,
  -1, 0, -2, 0, 1,
  -1, 1, 2, 2, 1,
  3, 0, 0, 0, 1,
  -1, 0, 2, 3, 2,
  2, -1, 2, 0, 1,
  0, 1, 2, 2, 1,
  0, -1, 2, 4, 2,
  2, -1, 2, 2, 2,
  0, 2, -2, 2, 0,
  -1, -1, 2, -1, 1,
  0, -2, 0, 0, 1,
  1, 0, 2, -4, 2,
  1, -1, 0, -2, 1,
  -1, -1, 2, 0, 1,
  1, -1, 2, -2, 2,
  -2, -1, 0, 4, 0,
  -1, 0, 0, 3, 0,
  -2, -1, 2, 2, 2,
  0, 2, 2, 0, 2,
  1, 1, 0, 2, 0,
  2, 0, 2, -1, 2,
  1, 0, 2, 1, 1,
  4, 0, 0, 0, 0,
  2, 1, 2, 0, 1,
  3, -1, 2, 0, 2,
  -2, 2, 0, 2, 1,
  1, 0, 2, -3, 1,
  1, 1, 2, -4, 1,
  -1, -1, 2, -2, 1,
  0, -1, 0, -1, 1,
  0, -1, 0, -2, 1,
  -2, 0, 0, 0, 2,
  -2, 0, -2, 2, 0,
  -1, 0, -2, 4, 0,
  1, -2, 0, 0, 0,
  0, 1, 0, 1, 1,
  -1, 2, 0, 2, 0,
  1, -1, 2, -2, 1,
  1, 2, 2, -2, 2,
  2, -1, 2, -2, 2,
  1, 0, 2, -1, 1,
  2, 1, 2, -2, 1,
  -2, 0, 0, -2, 1,
  1, -2, 2, 0, 2,
  0, 1, 2, 1, 1,
  1, 0, 4, -2, 1,
  -2, 0, 4, 2, 2,
  1, 1, 2, 1, 2,
  1, 0, 0, 4, 0,
  1, 0, 2, 2, 0,
  2, 0, 2, 1, 2,
  3, 1, 2, 0, 2,
  4, 0, 2, 0, 1,
  -2, -1, 2, 0, 0,
  0, 1, -2, 2, 1,
  1, 0, -2, 1, 0,
  0, -1, -2, 2, 1,
  2, -1, 0, -2, 1,
  -1, 0, 2, -1, 2,
  1, 0, 2, -3, 2,
  0, 1, 2, -2, 3,
  0, 0, 2, -3, 1,
  -1, 0, -2, 2, 1,
  0, 0, 2, -4, 2,
  -2, 1, 0, 0, 1,
  -1, 0, 0, -1, 1,
  2, 0, 2, -4, 2,
  0, 0, 4, -4, 4,
  0, 0, 4, -4, 2,
  -1, -2, 0, 2, 1,
  -2, 0, 0, 3, 0,
  1, 0, -2, 2, 1,
  -3, 0, 2, 2, 2,
  -3, 0, 2, 2, 1,
  -2, 0, 2, 2, 0,
  2, -1, 0, 0, 1,
  -2, 1, 2, 2, 2,
  1, 1, 0, 1, 0,
  0, 1, 4, -2, 2,
  -1, 1, 0, -2, 1,
  0, 0, 0, -4, 1,
  1, -1, 0, 2, 1,
  1, 1, 0, 2, 1,
  -1, 2, 2, 2, 2,
  3, 1, 2, -2, 2,
  0, -1, 0, 4, 0,
  2, -1, 0, 2, 0,
  0, 0, 4, 0, 1,
  2, 0, 4, -2, 2,
  -1, -1, 2, 4, 1,
  1, 0, 0, 4, 1,
  1, -2, 2, 2, 2,
  0, 0, 2, 3, 2,
  -1, 1, 2, 4, 2,
  3, 0, 0, 2, 0,
  -1, 0, 4, 2, 2,
  1, 1, 2, 2, 1,
  -2, 0, 2, 6, 2,
  2, 1, 2, 2, 2,
  -1, 0, 2, 6, 2,
  1, 0, 2, 4, 1,
  2, 0, 2, 4, 2,
  1, 1, -2, 1, 0,
  -3, 1, 2, 1, 2,
  2, 0, -2, 0, 2,
  -1, 0, 0, 1, 2,
  -4, 0, 2, 2, 1,
  -1, -1, 0, 1, 0,
  0, 0, -2, 2, 2,
  1, 0, 0, -1, 2,
  0, -1, 2, -2, 3,
  -2, 1, 2, 0, 0,
  0, 0, 2, -2, 4,
  -2, -2, 0, 2, 0,
  -2, 0, -2, 4, 0,
  0, -2, -2, 2, 0,
  1, 2, 0, -2, 1,
  3, 0, 0, -4, 1,
  -1, 1, 2, -2, 2,
  1, -1, 2, -4, 1,
  1, 1, 0, -2, 2,
  -3, 0, 2, 0, 0,
  -3, 0, 2, 0, 2,
  -2, 0, 0, 1, 0,
  0, 0, -2, 1, 0,
  -3, 0, 0, 2, 1,
  -1, -1, -2, 2, 0,
  0, 1, 2, -4, 1,
  2, 1, 0, -4, 1,
  0, 2, 0, -2, 1,
  1, 0, 0, -3, 1,
  -2, 0, 2, -2, 2,
  -2, -1, 0, 0, 1,
  -4, 0, 0, 2, 0,
  1, 1, 0, -4, 1,
  -1, 0, 2, -4, 1,
  0, 0, 4, -4, 1,
  0, 3, 2, -2, 2,
  -3, -1, 0, 4, 0,
  -3, 0, 0, 4, 1,
  1, -1, -2, 2, 0,
  -1, -1, 0, 2, 2,
  1, -2, 0, 0, 1,
  1, -1, 0, 0, 2,
  0, 0, 0, 1, 2,
  -1, -1, 2, 0, 0,
  1, -2, 2, -2, 2,
  0, -1, 2, -1, 1,
  -1, 0, 2, 0, 3,
  1, 1, 0, 0, 2,
  -1, 1, 2, 0, 0,
  1, 2, 0, 0, 0,
  -1, 2, 2, 0, 2,
  -1, 0, 4, -2, 1,
  3, 0, 2, -4, 2,
  1, 2, 2, -2, 1,
  1, 0, 4, -4, 2,
  -2, -1, 0, 4, 1,
  0, -1, 0, 2, 2,
  -2, 1, 0, 4, 0,
  -2, -1, 2, 2, 1,
  2, 0, -2, 2, 0,
  1, 0, 0, 1, 1,
  0, 1, 0, 2, 2,
  1, -1, 2, -1, 2,
  -2, 0, 4, 0, 1,
  2, 1, 0, 0, 1,
  0, 1, 2, 0, 0,
  0, -1, 4, -2, 2,
  0, 0, 4, -2, 4,
  0, 2, 2, 0, 1,
  -3, 0, 0, 6, 0,
  -1, -1, 0, 4, 1,
  1, -2, 0, 2, 0,
  -1, 0, 0, 4, 2,
  -1, -2, 2, 2, 1,
  -1, 0, 0, -2, 2,
  1, 0, -2, -2, 1,
  0, 0, -2, -2, 1,
  -2, 0, -2, 0, 1,
  0, 0, 0, 3, 1,
  0, 0, 0, 3, 0,
  -1, 1, 0, 4, 0,
  -1, -1, 2, 2, 0,
  -2, 0, 2, 3, 2,
  1, 0, 0, 2, 2,
  0, -1, 2, 1, 2,
  3, -1, 0, 0, 0,
  2, 0, 0, 1, 0,
  1, -1, 2, 0, 0,
  0, 0, 2, 1, 0,
  1, 0, 2, 0, 3,
  3, 1, 0, 0, 0,
  3, -1, 2, -2, 2,
  2, 0, 2, -1, 1,
  1, 1, 2, 0, 0,
  0, 0, 4, -1, 2,
  1, 2, 2, 0, 2,
  -2, 0, 0, 6, 0,
  0, -1, 0, 4, 1,
  -2, -1, 2, 4, 1,
  0, -2, 2, 2, 1,
  0, -1, 2, 2, 0,
  -1, 0, 2, 3, 1,
  -2, 1, 2, 4, 2,
  2, 0, 0, 2, 2,
  2, -2, 2, 0, 2,
  -1, 1, 2, 3, 2,
  3, 0, 2, -1, 2,
  4, 0, 2, -2, 1,
  -1, 0, 0, 6, 0,
  -1, -2, 2, 4, 2,
  -3, 0, 2, 6, 2,
  -1, 0, 2, 4, 0,
  3, 0, 0, 2, 1,
  3, -1, 2, 0, 1,
  3, 0, 2, 0, 0,
  1, 0, 4, 0, 2,
  5, 0, 2, -2, 2,
  0, -1, 2, 4, 1,
  2, -1, 2, 2, 1,
  0, 1, 2, 4, 2,
  1, -1, 2, 4, 2,
  3, -1, 2, 2, 2,
  3, 0, 2, 2, 1,
  5, 0, 2, 0, 2,
  0, 0, 2, 6, 2,
  4, 0, 2, 2, 2,
  0, -1, 1, -1, 1,
  -1, 0, 1, 0, 3,
  0, -2, 2, -2, 3,
  1, 0, -1, 0, 1,
  2, -2, 0, -2, 1,
  -1, 0, 1, 0, 2,
  -1, 0, 1, 0, 1,
  -1, -1, 2, -1, 2,
  -2, 2, 0, 2, 2,
  -1, 0, 1, 0, 0,
  -4, 1, 2, 2, 2,
  -3, 0, 2, 1, 1,
  -2, -1, 2, 0, 2,
  1, 0, -2, 1, 1,
  2, -1, -2, 0, 1,
  -4, 0, 2, 2, 0,
  -3, 1, 0, 3, 0,
  -1, 0, -1, 2, 0,
  0, -2, 0, 0, 2,
  0, -2, 0, 0, 2,
  -3, 0, 0, 3, 0,
  -2, -1, 0, 2, 2,
  -1, 0, -2, 3, 0,
  -4, 0, 0, 4, 0,
  2, 1, -2, 0, 1,
  2, -1, 0, -2, 2,
  0, 0, 1, -1, 0,
  -1, 2, 0, 1, 0,
  -2, 1, 2, 0, 2,
  1, 1, 0, -1, 1,
  1, 0, 1, -2, 1,
  0, 2, 0, 0, 2,
  1, -1, 2, -3, 1,
  -1, 1, 2, -1, 1,
  -2, 0, 4, -2, 2,
  -2, 0, 4, -2, 1,
  -2, -2, 0, 2, 1,
  -2, 0, -2, 4, 0,
  1, 2, 2, -4, 1,
  1, 1, 2, -4, 2,
  -1, 2, 2, -2, 1,
  2, 0, 0, -3, 1,
  -1, 2, 0, 0, 1,
  0, 0, 0, -2, 0,
  -1, -1, 2, -2, 2,
  -1, 1, 0, 0, 2,
  0, 0, 0, -1, 2,
  -2, 1, 0, 1, 0,
  1, -2, 0, -2, 1,
  1, 0, -2, 0, 2,
  -3, 1, 0, 2, 0,
  -1, 1, -2, 2, 0,
  -1, -1, 0, 0, 2,
  -3, 0, 0, 2, 0,
  -3, -1, 0, 2, 0,
  2, 0, 2, -6, 1,
  0, 1, 2, -4, 2,
  2, 0, 0, -4, 2,
  -2, 1, 2, -2, 1,
  0, -1, 2, -4, 1,
  0, 1, 0, -2, 2,
  -1, 0, 0, -2, 0,
  2, 0, -2, -2, 1,
  -4, 0, 2, 0, 1,
  -1, -1, 0, -1, 1,
  0, 0, -2, 0, 2,
  -3, 0, 0, 1, 0,
  -1, 0, -2, 1, 0,
  -2, 0, -2, 2, 1,
  0, 0, -4, 2, 0,
  -2, -1, -2, 2, 0,
  1, 0, 2, -6, 1,
  -1, 0, 2, -4, 2,
  1, 0, 0, -4, 2,
  2, 1, 2, -4, 2,
  2, 1, 2, -4, 1,
  0, 1, 4, -4, 4,
  0, 1, 4, -4, 2,
  -1, -1, -2, 4, 0,
  -1, -3, 0, 2, 0,
  -1, 0, -2, 4, 1,
  -2, -1, 0, 3, 0,
  0, 0, -2, 3, 0,
  -2, 0, 0, 3, 1,
  0, -1, 0, 1, 0,
  -3, 0, 2, 2, 0,
  1, 1, -2, 2, 0,
  -1, 1, 0, 2, 2,
  1, -2, 2, -2, 1,
  0, 0, 1, 0, 2,
  0, 0, 1, 0, 1,
  0, 0, 1, 0, 0,
  -1, 2, 0, 2, 1,
  0, 0, 2, 0, 2,
  -2, 0, 2, 0, 2,
  2, 0, 0, -1, 1,
  3, 0, 0, -2, 1,
  1, 0, 2, -2, 3,
  1, 2, 0, 0, 1,
  2, 0, 2, -3, 2,
  -1, 1, 4, -2, 2,
  -2, -2, 0, 4, 0,
  0, -3, 0, 2, 0,
  0, 0, -2, 4, 0,
  -1, -1, 0, 3, 0,
  -2, 0, 0, 4, 2,
  -1, 0, 0, 3, 1,
  2, -2, 0, 0, 0,
  1, -1, 0, 1, 0,
  -1, 0, 0, 2, 0,
  0, -2, 2, 0, 1,
  -1, 0, 1, 2, 1,
  -1, 1, 0, 3, 0,
  -1, -1, 2, 1, 2,
  0, -1, 2, 0, 0,
  -2, 1, 2, 2, 1,
  2, -2, 2, -2, 2,
  1, 1, 0, 1, 1,
  1, 0, 1, 0, 1,
  1, 0, 1, 0, 0,
  0, 2, 0, 2, 0,
  2, -1, 2, -2, 1,
  0, -1, 4, -2, 1,
  0, 0, 4, -2, 3,
  0, 1, 4, -2, 1,
  4, 0, 2, -4, 2,
  2, 2, 2, -2, 2,
  2, 0, 4, -4, 2,
  -1, -2, 0, 4, 0,
  -1, -3, 2, 2, 2,
  -3, 0, 2, 4, 2,
  -3, 0, 2, -2, 1,
  -1, -1, 0, -2, 1,
  -3, 0, 0, 0, 2,
  -3, 0, -2, 2, 0,
  0, 1, 0, -4, 1,
  -2, 1, 0, -2, 1,
  -4, 0, 0, 0, 1,
  -1, 0, 0, -4, 1,
  -3, 0, 0, -2, 1,
  0, 0, 0, 3, 2,
  -1, 1, 0, 4, 1,
  1, -2, 2, 0, 1,
  0, 1, 0, 3, 0,
  -1, 0, 2, 2, 3,
  0, 0, 2, 2, 2,
  -2, 0, 2, 2, 2,
  -1, 1, 2, 2, 0,
  3, 0, 0, 0, 2,
  2, 1, 0, 1, 0,
  2, -1, 2, -1, 2,
  0, 0, 2, 0, 1,
  0, 0, 3, 0, 3,
  0, 0, 3, 0, 2,
  -1, 2, 2, 2, 1,
  -1, 0, 4, 0, 0,
  1, 2, 2, 0, 1,
  3, 1, 2, -2, 1,
  1, 1, 4, -2, 2,
  -2, -1, 0, 6, 0,
  0, -2, 0, 4, 0,
  -2, 0, 0, 6, 1,
  -2, -2, 2, 4, 2,
  0, -3, 2, 2, 2,
  0, 0, 0, 4, 2,
  -1, -1, 2, 3, 2,
  -2, 0, 2, 4, 0,
  2, -1, 0, 2, 1,
  1, 0, 0, 3, 0,
  0, 1, 0, 4, 1,
  0, 1, 0, 4, 0,
  1, -1, 2, 1, 2,
  0, 0, 2, 2, 3,
  1, 0, 2, 2, 2,
  -1, 0, 2, 2, 2,
  -2, 0, 4, 2, 1,
  2, 1, 0, 2, 1,
  2, 1, 0, 2, 0,
  2, -1, 2, 0, 0,
  1, 0, 2, 1, 0,
  0, 1, 2, 2, 0,
  2, 0, 2, 0, 3,
  3, 0, 2, 0, 2,
  1, 0, 2, 0, 2,
  1, 0, 3, 0, 3,
  1, 1, 2, 1, 1,
  0, 2, 2, 2, 2,
  2, 1, 2, 0, 0,
  2, 0, 4, -2, 1,
  4, 1, 2, -2, 2,
  -1, -1, 0, 6, 0,
  -3, -1, 2, 6, 2,
  -1, 0, 0, 6, 1,
  -3, 0, 2, 6, 1,
  1, -1, 0, 4, 1,
  1, -1, 0, 4, 0,
  -2, 0, 2, 5, 2,
  1, -2, 2, 2, 1,
  3, -1, 0, 2, 0,
  1, -1, 2, 2, 0,
  0, 0, 2, 3, 1,
  -1, 1, 2, 4, 1,
  0, 1, 2, 3, 2,
  -1, 0, 4, 2, 1,
  2, 0, 2, 1, 1,
  5, 0, 0, 0, 0,
  2, 1, 2, 1, 2,
  1, 0, 4, 0, 1,
  3, 1, 2, 0, 1,
  3, 0, 4, -2, 2,
  -2, -1, 2, 6, 2,
  0, 0, 0, 6, 0,
  0, -2, 2, 4, 2,
  -2, 0, 2, 6, 1,
  2, 0, 0, 4, 1,
  2, 0, 0, 4, 0,
  2, -2, 2, 2, 2,
  0, 0, 2, 4, 0,
  1, 0, 2, 3, 2,
  4, 0, 0, 2, 0,
  2, 0, 2, 2, 0,
  0, 0, 4, 2, 2,
  4, -1, 2, 0, 2,
  3, 0, 2, 1, 2,
  2, 1, 2, 2, 1,
  4, 1, 2, 0, 2,
  -1, -1, 2, 6, 2,
  -1, 0, 2, 6, 1,
  1, -1, 2, 4, 1,
  1, 1, 2, 4, 2,
  3, 1, 2, 2, 2,
  5, 0, 2, 0, 1,
  2, -1, 2, 4, 2,
  2, 0, 2, 4, 1,
  };

  /* Luni-Solar nutation coefficients, unit 1e-7 arcsec
   * longitude (sin, t*sin, cos), obliquity (cos, t*cos, sin) */
  static final int cls[] = {
  -172064161, -174666, 33386, 92052331, 9086, 15377,
  -13170906, -1675, -13696, 5730336, -3015, -4587,
  -2276413, -234, 2796, 978459, -485, 1374,
  2074554, 207, -698, -897492, 470, -291,
  1475877, -3633, 11817, 73871, -184, -1924,
  -516821, 1226, -524, 224386, -677, -174,
  711159, 73, -872, -6750, 0, 358,
  -387298, -367, 380, 200728, 18, 318,
  -301461, -36, 816, 129025, -63, 367,
  215829, -494, 111, -95929, 299, 132,
  128227, 137, 181, -68982, -9, 39,
  123457, 11, 19, -53311, 32, -4,
  156994, 10, -168, -1235, 0, 82,
  63110, 63, 27, -33228, 0, -9,
  -57976, -63, -189, 31429, 0, -75,
  -59641, -11, 149, 25543, -11, 66,
  -51613, -42, 129, 26366, 0, 78,
  45893, 50, 31, -24236, -10, 20,
  63384, 11, -150, -1220, 0, 29,
  -38571, -1, 158, 16452, -11, 68,
  32481, 0, 0, -13870, 0, 0,
  -47722, 0, -18, 477, 0, -25,
  -31046, -1, 131, 13238, -11, 59,
  28593, 0, -1, -12338, 10, -3,
  20441, 21, 10, -10758, 0, -3,
  29243, 0, -74, -609, 0, 13,
  25887, 0, -66, -550, 0, 11,
  -14053, -25, 79, 8551, -2, -45,
  15164, 10, 11, -8001, 0, -1,
  -15794, 72, -16, 6850, -42, -5,
  21783, 0, 13, -167, 0, 13,
  -12873, -10, -37, 6953, 0, -14,
  -12654, 11, 63, 6415, 0, 26,
  -10204, 0, 25, 5222, 0, 15,
  16707, -85, -10, 168, -1, 10,
  -7691, 0, 44, 3268, 0, 19,
  -11024, 0, -14, 104, 0, 2,
  7566, -21, -11, -3250, 0, -5,
  -6637, -11, 25, 3353, 0, 14,
  -7141, 21, 8, 3070, 0, 4,
  -6302, -11, 2, 3272, 0, 4,
  5800, 10, 2, -3045, 0, -1,
  6443, 0, -7, -2768, 0, -4,
  -5774, -11, -15, 3041, 0, -5,
  -5350, 0, 21, 2695, 0, 12,
  -4752, -11, -3, 2719, 0, -3,
  -4940, -11, -21, 2720, 0, -9,
  7350, 0, -8, -51, 0, 4,
  4065, 0, 6, -2206, 0, 1,
  6579, 0, -24, -199, 0, 2,
  3579, 0, 5, -1900, 0, 1,
  4725, 0, -6, -41, 0, 3,
  -3075, 0, -2, 1313, 0, -1,
  -2904, 0, 15, 1233, 0, 7,
  4348, 0, -10, -81, 0, 2,
  -2878, 0, 8, 1232, 0, 4,
  -4230, 0, 5, -20, 0, -2,
  -2819, 0, 7, 1207, 0, 3,
  -4056, 0, 5, 40, 0, -2,
  -2647, 0, 11, 1129, 0, 5,
  -2294, 0, -10, 1266, 0, -4,
  2481, 0, -7, -1062, 0, -3,
  2179, 0, -2, -1129, 0, -2,
  3276, 0, 1, -9, 0, 0,
  -3389, 0, 5, 35, 0, -2,
  3339, 0, -13, -107, 0, 1,
  -1987, 0, -6, 1073, 0, -2,
  -1981, 0, 0, 854, 0, 0,
  4026, 0, -353, -553, 0, -139,
  1660, 0, -5, -710, 0, -2,
  -1521, 0, 9, 647, 0, 4,
  1314, 0, 0, -700, 0, 0,
  -1283, 0, 0, 672, 0, 0,
  -1331, 0, 8, 663, 0, 4,
  1383, 0, -2, -594, 0, -2,
  1405, 0, 4, -610, 0, 2,
  1290, 0, 0, -556, 0, 0,
  -1214, 0, 5, 518, 0, 2,
  1146, 0, -3, -490, 0, -1,
  1019, 0, -1, -527, 0, -1,
  -1100, 0, 9, 465, 0, 4,
  -970, 0, 2, 496, 0, 1,
  1575, 0, -6, -50, 0, 0,
  934, 0, -3, -399, 0, -1,
  922, 0, -1, -395, 0, -1,
  815, 0, -1, -422, 0, -1,
  834, 0, 2, -440, 0, 1,
  1248, 0, 0, -170, 0, 1,
  1338, 0, -5, -39, 0, 0,
  716, 0, -2, -389, 0, -1,
  1282, 0, -3, -23, 0, 1,
  742, 0, 1, -391, 0, 0,
  1020, 0, -25, -495, 0, -10,
  715, 0, -4, -326, 0, 2,
  -666, 0, -3, 369, 0, -1,
  -667, 0, 1, 346, 0, 1,
  -704, 0, 0, 304, 0, 0,
  -694, 0, 5, 294, 0, 2,
  -1014, 0, -1, 4, 0, -1,
  -585, 0, -2, 316, 0, -1,
  -949, 0, 1, 8, 0, -1,
  -595, 0, 0, 258, 0, 0,
  528, 0, 0, -279, 0, 0,
  -590, 0, 4, 252, 0, 2,
  570, 0, -2, -244, 0, -1,
  -502, 0, 3, 250, 0, 2,
  -875, 0, 1, 29, 0, 0,
  -492, 0, -3, 275, 0, -1,
  535, 0, -2, -228, 0, -1,
  -467, 0, 1, 240, 0, 1,
  591, 0, 0, -253, 0, 0,
  -453, 0, -1, 244, 0, -1,
  766, 0, 1, 9, 0, 0,
  -446, 0, 2, 225, 0, 1,
  -488, 0, 2, 207, 0, 1,
  -468, 0, 0, 201, 0, 0,
  -421, 0, 1, 216, 0, 1,
  463, 0, 0, -200, 0, 0,
  -673, 0, 2, 14, 0, 0,
  658, 0, 0, -2, 0, 0,
  -438, 0, 0, 188, 0, 0,
  -390, 0, 0, 205, 0, 0,
  639, -11, -2, -19, 0, 0,
  412, 0, -2, -176, 0, -1,
  -361, 0, 0, 189, 0, 0,
  360, 0, -1, -185, 0, -1,
  588, 0, -3, -24, 0, 0,
  -578, 0, 1, 5, 0, 0,
  -396, 0, 0, 171, 0, 0,
  565, 0, -1, -6, 0, 0,
  -335, 0, -1, 184, 0, -1,
  357, 0, 1, -154, 0, 0,
  321, 0, 1, -174, 0, 0,
  -301, 0, -1, 162, 0, 0,
  -334, 0, 0, 144, 0, 0,
  493, 0, -2, -15, 0, 0,
  494, 0, -2, -19, 0, 0,
  337, 0, -1, -143, 0, -1,
  280, 0, -1, -144, 0, 0,
  309, 0, 1, -134, 0, 0,
  -263, 0, 2, 131, 0, 1,
  253, 0, 1, -138, 0, 0,
  245, 0, 0, -128, 0, 0,
  416, 0, -2, -17, 0, 0,
  -229, 0, 0, 128, 0, 0,
  231, 0, 0, -120, 0, 0,
  -259, 0, 2, 109, 0, 1,
  375, 0, -1, -8, 0, 0,
  252, 0, 0, -108, 0, 0,
  -245, 0, 1, 104, 0, 0,
  243, 0, -1, -104, 0, 0,
  208, 0, 1, -112, 0, 0,
  199, 0, 0, -102, 0, 0,
  -208, 0, 1, 105, 0, 0,
  335, 0, -2, -14, 0, 0,
  -325, 0, 1, 7, 0, 0,
  -187, 0, 0, 96, 0, 0,
  197, 0, -1, -100, 0, 0,
  -192, 0, 2, 94, 0, 1,
  -188, 0, 0, 83, 0, 0,
  276, 0, 0, -2, 0, 0,
  -286, 0, 1, 6, 0, 0,
  186, 0, -1, -79, 0, 0,
  -219, 0, 0, 43, 0, 0,
  276, 0, 0, 2, 0, 0,
  -153, 0, -1, 84, 0, 0,
  -156, 0, 0, 81, 0, 0,
  -154, 0, 1, 78, 0, 0,
  -174, 0, 1, 75, 0, 0,
  -163, 0, 2, 69, 0, 1,
  -228, 0, 0, 1, 0, 0,
  91, 0, -4, -54, 0, -2,
  175, 0, 0, -75, 0, 0,
  -159, 0, 0, 69, 0, 0,
  141, 0, 0, -72, 0, 0,
  147, 0, 0, -75, 0, 0,
  -132, 0, 0, 69, 0, 0,
  159, 0, -28, -54, 0, 11,
  213, 0, 0, -4, 0, 0,
  123, 0, 0, -64, 0, 0,
  -118, 0, -1, 66, 0, 0,
  144, 0, -1, -61, 0, 0,
  -121, 0, 1, 60, 0, 0,
  -134, 0, 1, 56, 0, 1,
  -105, 0, 0, 57, 0, 0,
  -102, 0, 0, 56, 0, 0,
  120, 0, 0, -52, 0, 0,
  101, 0, 0, -54, 0, 0,
  -113, 0, 0, 59, 0, 0,
  -106, 0, 0, 61, 0, 0,
  -129, 0, 1, 55, 0, 0,
  -114, 0, 0, 57, 0, 0,
  113, 0, -1, -49, 0, 0,
  -102, 0, 0, 44, 0, 0,
  -94, 0, 0, 51, 0, 0,
  -100, 0, -1, 56, 0, 0,
  87, 0, 0, -47, 0, 0,
  161, 0, 0, -1, 0, 0,
  96, 0, 0, -50, 0, 0,
  151, 0, -1, -5, 0, 0,
  -104, 0, 0, 44, 0, 0,
  -110, 0, 0, 48, 0, 0,
  -100, 0, 1, 50, 0, 0,
  92, 0, -5, 12, 0, -2,
  82, 0, 0, -45, 0, 0,
  82, 0, 0, -45, 0, 0,
  -78, 0, 0, 41, 0, 0,
  -77, 0, 0, 43, 0, 0,
  2, 0, 0, 54, 0, 0,
  94, 0, 0, -40, 0, 0,
  -93, 0, 0, 40, 0, 0,
  -83, 0, 10, 40, 0, -2,
  83, 0, 0, -36, 0, 0,
  -91, 0, 0, 39, 0, 0,
  128, 0, 0, -1, 0, 0,
  -79, 0, 0, 34, 0, 0,
  -83, 0, 0, 47, 0, 0,
  84, 0, 0, -44, 0, 0,
  83, 0, 0, -43, 0, 0,
  91, 0, 0, -39, 0, 0,
  -77, 0, 0, 39, 0, 0,
  84, 0, 0, -43, 0, 0,
  -92, 0, 1, 39, 0, 0,
  -92, 0, 1, 39, 0, 0,
  -94, 0, 0, 0, 0, 0,
  68, 0, 0, -36, 0, 0,
  -61, 0, 0, 32, 0, 0,
  71, 0, 0, -31, 0, 0,
  62, 0, 0, -34, 0, 0,
  -63, 0, 0, 33, 0, 0,
  -73, 0, 0, 32, 0, 0,
  115, 0, 0, -2, 0, 0,
  -103, 0, 0, 2, 0, 0,
  63, 0, 0, -28, 0, 0,
  74, 0, 0, -32, 0, 0,
  -103, 0, -3, 3, 0, -1,
  -69, 0, 0, 30, 0, 0,
  57, 0, 0, -29, 0, 0,
  94, 0, 0, -4, 0, 0,
  64, 0, 0, -33, 0, 0,
  -63, 0, 0, 26, 0, 0,
  -38, 0, 0, 20, 0, 0,
  -43, 0, 0, 24, 0, 0,
  -45, 0, 0, 23, 0, 0,
  47, 0, 0, -24, 0, 0,
  -48, 0, 0, 25, 0, 0,
  45, 0, 0, -26, 0, 0,
  56, 0, 0, -25, 0, 0,
  88, 0, 0, 2, 0, 0,
  -75, 0, 0, 0, 0, 0,
  85, 0, 0, 0, 0, 0,
  49, 0, 0, -26, 0, 0,
  -74, 0, -3, -1, 0, -1,
  -39, 0, 0, 21, 0, 0,
  45, 0, 0, -20, 0, 0,
  51, 0, 0, -22, 0, 0,
  -40, 0, 0, 21, 0, 0,
  41, 0, 0, -21, 0, 0,
  -42, 0, 0, 24, 0, 0,
  -51, 0, 0, 22, 0, 0,
  -42, 0, 0, 22, 0, 0,
  39, 0, 0, -21, 0, 0,
  46, 0, 0, -18, 0, 0,
  -53, 0, 0, 22, 0, 0,
  82, 0, 0, -4, 0, 0,
  81, 0, -1, -4, 0, 0,
  47, 0, 0, -19, 0, 0,
  53, 0, 0, -23, 0, 0,
  -45, 0, 0, 22, 0, 0,
  -44, 0, 0, -2, 0, 0,
  -33, 0, 0, 16, 0, 0,
  -61, 0, 0, 1, 0, 0,
  28, 0, 0, -15, 0, 0,
  -38, 0, 0, 19, 0, 0,
  -33, 0, 0, 21, 0, 0,
  -60, 0, 0, 0, 0, 0,
  48, 0, 0, -10, 0, 0,
  27, 0, 0, -14, 0, 0,
  38, 0, 0, -20, 0, 0,
  31, 0, 0, -13, 0, 0,
  -29, 0, 0, 15, 0, 0,
  28, 0, 0, -15, 0, 0,
  -32, 0, 0, 15, 0, 0,
  45, 0, 0, -8, 0, 0,
  -44, 0, 0, 19, 0, 0,
  28, 0, 0, -15, 0, 0,
  -51, 0, 0, 0, 0, 0,
  -36, 0, 0, 20, 0, 0,
  44, 0, 0, -19, 0, 0,
  26, 0, 0, -14, 0, 0,
  -60, 0, 0, 2, 0, 0,
  35, 0, 0, -18, 0, 0,
  -27, 0, 0, 11, 0, 0,
  47, 0, 0, -1, 0, 0,
  36, 0, 0, -15, 0, 0,
  -36, 0, 0, 20, 0, 0,
  -35, 0, 0, 19, 0, 0,
  -37, 0, 0, 19, 0, 0,
  32, 0, 0, -16, 0, 0,
  35, 0, 0, -14, 0, 0,
  32, 0, 0, -13, 0, 0,
  65, 0, 0, -2, 0, 0,
  47, 0, 0, -1, 0, 0,
  32, 0, 0, -16, 0, 0,
  37, 0, 0, -16, 0, 0,
  -30, 0, 0, 15, 0, 0,
  -32, 0, 0, 16, 0, 0,
  -31, 0, 0, 13, 0, 0,
  37, 0, 0, -16, 0, 0,
  31, 0, 0, -13, 0, 0,
  49, 0, 0, -2, 0, 0,
  32, 0, 0, -13, 0, 0,
  23, 0, 0, -12, 0, 0,
  -43, 0, 0, 18, 0, 0,
  26, 0, 0, -11, 0, 0,
  -32, 0, 0, 14, 0, 0,
  -29, 0, 0, 14, 0, 0,
  -27, 0, 0, 12, 0, 0,
  30, 0, 0, 0, 0, 0,
  -11, 0, 0, 5, 0, 0,
  -21, 0, 0, 10, 0, 0,
  -34, 0, 0, 15, 0, 0,
  -10, 0, 0, 6, 0, 0,
  -36, 0, 0, 0, 0, 0,
  -9, 0, 0, 4, 0, 0,
  -12, 0, 0, 5, 0, 0,
  -21, 0, 0, 5, 0, 0,
  -29, 0, 0, -1, 0, 0,
  -15, 0, 0, 3, 0, 0,
  -20, 0, 0, 0, 0, 0,
  28, 0, 0, 0, 0, -2,
  17, 0, 0, 0, 0, 0,
  -22, 0, 0, 12, 0, 0,
  -14, 0, 0, 7, 0, 0,
  24, 0, 0, -11, 0, 0,
  11, 0, 0, -6, 0, 0,
  14, 0, 0, -6, 0, 0,
  24, 0, 0, 0, 0, 0,
  18, 0, 0, -8, 0, 0,
  -38, 0, 0, 0, 0, 0,
  -31, 0, 0, 0, 0, 0,
  -16, 0, 0, 8, 0, 0,
  29, 0, 0, 0, 0, 0,
  -18, 0, 0, 10, 0, 0,
  -10, 0, 0, 5, 0, 0,
  -17, 0, 0, 10, 0, 0,
  9, 0, 0, -4, 0, 0,
  16, 0, 0, -6, 0, 0,
  22, 0, 0, -12, 0, 0,
  20, 0, 0, 0, 0, 0,
  -13, 0, 0, 6, 0, 0,
  -17, 0, 0, 9, 0, 0,
  -14, 0, 0, 8, 0, 0,
  0, 0, 0, -7, 0, 0,
  14, 0, 0, 0, 0, 0,
  19, 0, 0, -10, 0, 0,
  -34, 0, 0, 0, 0, 0,
  -20, 0, 0, 8, 0, 0,
  9, 0, 0, -5, 0, 0,
  -18, 0, 0, 7, 0, 0,
  13, 0, 0, -6, 0, 0,
  17, 0, 0, 0, 0, 0,
  -12, 0, 0, 5, 0, 0,
  15, 0, 0, -8, 0, 0,
  -11, 0, 0, 3, 0, 0,
  13, 0, 0, -5, 0, 0,
  -18, 0, 0, 0, 0, 0,
  -35, 0, 0, 0, 0, 0,
  9, 0, 0, -4, 0, 0,
  -19, 0, 0, 10, 0, 0,
  -26, 0, 0, 11, 0, 0,
  8, 0, 0, -4, 0, 0,
  -10, 0, 0, 4, 0, 0,
  10, 0, 0, -6, 0, 0,
  -21, 0, 0, 9, 0, 0,
  -15, 0, 0, 0, 0, 0,
  9, 0, 0, -5, 0, 0,
  -29, 0, 0, 0, 0, 0,
  -19, 0, 0, 10, 0, 0,
  12, 0, 0, -5, 0, 0,
  22, 0, 0, -9, 0, 0,
  -10, 0, 0, 5, 0, 0,
  -20, 0, 0, 11, 0, 0,
  -20, 0, 0, 0, 0, 0,
  -17, 0, 0, 7, 0, 0,
  15, 0, 0, -3, 0, 0,
  8, 0, 0, -4, 0, 0,
  14, 0, 0, 0, 0, 0,
  -12, 0, 0, 6, 0, 0,
  25, 0, 0, 0, 0, 0,
  -13, 0, 0, 6, 0, 0,
  -14, 0, 0, 8, 0, 0,
  13, 0, 0, -5, 0, 0,
  -17, 0, 0, 9, 0, 0,
  -12, 0, 0, 6, 0, 0,
  -10, 0, 0, 5, 0, 0,
  10, 0, 0, -6, 0, 0,
  -15, 0, 0, 0, 0, 0,
  -22, 0, 0, 0, 0, 0,
  28, 0, 0, -1, 0, 0,
  15, 0, 0, -7, 0, 0,
  23, 0, 0, -10, 0, 0,
  12, 0, 0, -5, 0, 0,
  29, 0, 0, -1, 0, 0,
  -25, 0, 0, 1, 0, 0,
  22, 0, 0, 0, 0, 0,
  -18, 0, 0, 0, 0, 0,
  15, 0, 0, 3, 0, 0,
  -23, 0, 0, 0, 0, 0,
  12, 0, 0, -5, 0, 0,
  -8, 0, 0, 4, 0, 0,
  -19, 0, 0, 0, 0, 0,
  -10, 0, 0, 4, 0, 0,
  21, 0, 0, -9, 0, 0,
  23, 0, 0, -1, 0, 0,
  -16, 0, 0, 8, 0, 0,
  -19, 0, 0, 9, 0, 0,
  -22, 0, 0, 10, 0, 0,
  27, 0, 0, -1, 0, 0,
  16, 0, 0, -8, 0, 0,
  19, 0, 0, -8, 0, 0,
  9, 0, 0, -4, 0, 0,
  -9, 0, 0, 4, 0, 0,
  -9, 0, 0, 4, 0, 0,
  -8, 0, 0, 4, 0, 0,
  18, 0, 0, -9, 0, 0,
  16, 0, 0, -1, 0, 0,
  -10, 0, 0, 4, 0, 0,
  -23, 0, 0, 9, 0, 0,
  16, 0, 0, -1, 0, 0,
  -12, 0, 0, 6, 0, 0,
  -8, 0, 0, 4, 0, 0,
  30, 0, 0, -2, 0, 0,
  24, 0, 0, -10, 0, 0,
  10, 0, 0, -4, 0, 0,
  -16, 0, 0, 7, 0, 0,
  -16, 0, 0, 7, 0, 0,
  17, 0, 0, -7, 0, 0,
  -24, 0, 0, 10, 0, 0,
  -12, 0, 0, 5, 0, 0,
  -24, 0, 0, 11, 0, 0,
  -23, 0, 0, 9, 0, 0,
  -13, 0, 0, 5, 0, 0,
  -15, 0, 0, 7, 0, 0,
  0, 0, -1988, 0, 0, -1679,
  0, 0, -63, 0, 0, -27,
  -4, 0, 0, 0, 0, 0,
  0, 0, 5, 0, 0, 4,
  5, 0, 0, -3, 0, 0,
  0, 0, 364, 0, 0, 176,
  0, 0, -1044, 0, 0, -891,
  -3, 0, 0, 1, 0, 0,
  4, 0, 0, -2, 0, 0,
  0, 0, 330, 0, 0, 0,
  5, 0, 0, -2, 0, 0,
  3, 0, 0, -2, 0, 0,
  -3, 0, 0, 1, 0, 0,
  -5, 0, 0, 2, 0, 0,
  3, 0, 0, -1, 0, 0,
  3, 0, 0, 0, 0, 0,
  3, 0, 0, 0, 0, 0,
  0, 0, 5, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  4, 0, 0, -2, 0, 0,
  6, 0, 0, 0, 0, 0,
  5, 0, 0, -2, 0, 0,
  -7, 0, 0, 0, 0, 0,
  -12, 0, 0, 0, 0, 0,
  5, 0, 0, -3, 0, 0,
  3, 0, 0, -1, 0, 0,
  -5, 0, 0, 0, 0, 0,
  3, 0, 0, 0, 0, 0,
  -7, 0, 0, 3, 0, 0,
  7, 0, 0, -4, 0, 0,
  0, 0, -12, 0, 0, -10,
  4, 0, 0, -2, 0, 0,
  3, 0, 0, -2, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -7, 0, 0, 3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  -3, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  -3, 0, 0, 1, 0, 0,
  7, 0, 0, -3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  4, 0, 0, -2, 0, 0,
  -5, 0, 0, 3, 0, 0,
  5, 0, 0, 0, 0, 0,
  -5, 0, 0, 2, 0, 0,
  5, 0, 0, -2, 0, 0,
  -8, 0, 0, 3, 0, 0,
  9, 0, 0, 0, 0, 0,
  6, 0, 0, -3, 0, 0,
  -5, 0, 0, 2, 0, 0,
  3, 0, 0, 0, 0, 0,
  -7, 0, 0, 0, 0, 0,
  -3, 0, 0, 1, 0, 0,
  5, 0, 0, 0, 0, 0,
  3, 0, 0, 0, 0, 0,
  -3, 0, 0, 2, 0, 0,
  4, 0, 0, -2, 0, 0,
  3, 0, 0, -1, 0, 0,
  -5, 0, 0, 2, 0, 0,
  4, 0, 0, -2, 0, 0,
  9, 0, 0, -3, 0, 0,
  4, 0, 0, 0, 0, 0,
  4, 0, 0, -2, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -4, 0, 0, 2, 0, 0,
  9, 0, 0, -3, 0, 0,
  -4, 0, 0, 0, 0, 0,
  -4, 0, 0, 0, 0, 0,
  3, 0, 0, -2, 0, 0,
  8, 0, 0, 0, 0, 0,
  3, 0, 0, 0, 0, 0,
  -3, 0, 0, 2, 0, 0,
  3, 0, 0, -1, 0, 0,
  3, 0, 0, -1, 0, 0,
  -3, 0, 0, 1, 0, 0,
  6, 0, 0, -3, 0, 0,
  3, 0, 0, 0, 0, 0,
  -3, 0, 0, 1, 0, 0,
  -7, 0, 0, 0, 0, 0,
  9, 0, 0, 0, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -3, 0, 0, 0, 0, 0,
  -4, 0, 0, 0, 0, 0,
  -5, 0, 0, 3, 0, 0,
  -13, 0, 0, 0, 0, 0,
  -7, 0, 0, 0, 0, 0,
  10, 0, 0, 0, 0, 0,
  3, 0, 0, -1, 0, 0,
  10, 0, 13, 6, 0, -5,
  0, 0, 30, 0, 0, 14,
  0, 0, -162, 0, 0, -138,
  0, 0, 75, 0, 0, 0,
  -7, 0, 0, 4, 0, 0,
  -4, 0, 0, 2, 0, 0,
  4, 0, 0, -2, 0, 0,
  5, 0, 0, -2, 0, 0,
  5, 0, 0, -3, 0, 0,
  -3, 0, 0, 0, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -4, 0, 0, 2, 0, 0,
  -5, 0, 0, 2, 0, 0,
  6, 0, 0, 0, 0, 0,
  9, 0, 0, 0, 0, 0,
  5, 0, 0, 0, 0, 0,
  -7, 0, 0, 0, 0, 0,
  -3, 0, 0, 1, 0, 0,
  -4, 0, 0, 2, 0, 0,
  7, 0, 0, 0, 0, 0,
  -4, 0, 0, 0, 0, 0,
  4, 0, 0, 0, 0, 0,
  -6, 0, -3, 3, 0, 1,
  0, 0, -3, 0, 0, -2,
  11, 0, 0, 0, 0, 0,
  3, 0, 0, -1, 0, 0,
  11, 0, 0, 0, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -1, 0, 3, 3, 0, -1,
  4, 0, 0, -2, 0, 0,
  0, 0, -13, 0, 0, -11,
  3, 0, 6, 0, 0, 0,
  -7, 0, 0, 0, 0, 0,
  5, 0, 0, -3, 0, 0,
  -3, 0, 0, 1, 0, 0,
  3, 0, 0, 0, 0, 0,
  5, 0, 0, -3, 0, 0,
  -7, 0, 0, 3, 0, 0,
  8, 0, 0, -3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  11, 0, 0, 0, 0, 0,
  -3, 0, 0, 1, 0, 0,
  3, 0, 0, -1, 0, 0,
  -4, 0, 0, 2, 0, 0,
  8, 0, 0, -4, 0, 0,
  3, 0, 0, -1, 0, 0,
  11, 0, 0, 0, 0, 0,
  -6, 0, 0, 3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  -8, 0, 0, 4, 0, 0,
  -7, 0, 0, 3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  3, 0, 0, -1, 0, 0,
  6, 0, 0, -3, 0, 0,
  -6, 0, 0, 3, 0, 0,
  6, 0, 0, 0, 0, 0,
  6, 0, 0, -1, 0, 0,
  5, 0, 0, -2, 0, 0,
  -5, 0, 0, 2, 0, 0,
  -4, 0, 0, 0, 0, 0,
  -4, 0, 0, 2, 0, 0,
  4, 0, 0, 0, 0, 0,
  6, 0, 0, -3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  0, 0, -26, 0, 0, -11,
  0, 0, -10, 0, 0, -5,
  5, 0, 0, -3, 0, 0,
  -13, 0, 0, 0, 0, 0,
  3, 0, 0, -2, 0, 0,
  4, 0, 0, -2, 0, 0,
  7, 0, 0, -3, 0, 0,
  4, 0, 0, 0, 0, 0,
  5, 0, 0, 0, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -6, 0, 0, 2, 0, 0,
  -5, 0, 0, 2, 0, 0,
  -7, 0, 0, 3, 0, 0,
  5, 0, 0, -2, 0, 0,
  13, 0, 0, 0, 0, 0,
  -4, 0, 0, 2, 0, 0,
  -3, 0, 0, 0, 0, 0,
  5, 0, 0, -2, 0, 0,
  -11, 0, 0, 0, 0, 0,
  5, 0, 0, -2, 0, 0,
  4, 0, 0, 0, 0, 0,
  4, 0, 0, -2, 0, 0,
  -4, 0, 0, 2, 0, 0,
  6, 0, 0, -3, 0, 0,
  3, 0, 0, -2, 0, 0,
  -12, 0, 0, 0, 0, 0,
  4, 0, 0, 0, 0, 0,
  -3, 0, 0, 0, 0, 0,
  -4, 0, 0, 0, 0, 0,
  3, 0, 0, 0, 0, 0,
  3, 0, 0, -1, 0, 0,
  -3, 0, 0, 1, 0, 0,
  0, 0, -5, 0, 0, -2,
  -7, 0, 0, 4, 0, 0,
  6, 0, 0, -3, 0, 0,
  -3, 0, 0, 0, 0, 0,
  5, 0, 0, -3, 0, 0,
  3, 0, 0, -1, 0, 0,
  3, 0, 0, 0, 0, 0,
  -3, 0, 0, 1, 0, 0,
  -5, 0, 0, 3, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -3, 0, 0, 2, 0, 0,
  12, 0, 0, 0, 0, 0,
  3, 0, 0, -1, 0, 0,
  -4, 0, 0, 2, 0, 0,
  4, 0, 0, 0, 0, 0,
  6, 0, 0, 0, 0, 0,
  5, 0, 0, -3, 0, 0,
  4, 0, 0, -2, 0, 0,
  -6, 0, 0, 3, 0, 0,
  4, 0, 0, -2, 0, 0,
  6, 0, 0, -3, 0, 0,
  6, 0, 0, 0, 0, 0,
  -6, 0, 0, 3, 0, 0,
  3, 0, 0, -2, 0, 0,
  7, 0, 0, -4, 0, 0,
  4, 0, 0, -2, 0, 0,
  -5, 0, 0, 2, 0, 0,
  5, 0, 0, 0, 0, 0,
  -6, 0, 0, 3, 0, 0,
  -6, 0, 0, 3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  10, 0, 0, 0, 0, 0,
  -4, 0, 0, 2, 0, 0,
  7, 0, 0, 0, 0, 0,
  7, 0, 0, -3, 0, 0,
  4, 0, 0, 0, 0, 0,
  11, 0, 0, 0, 0, 0,
  5, 0, 0, -2, 0, 0,
  -6, 0, 0, 2, 0, 0,
  4, 0, 0, -2, 0, 0,
  3, 0, 0, -2, 0, 0,
  5, 0, 0, -2, 0, 0,
  -4, 0, 0, 2, 0, 0,
  -4, 0, 0, 2, 0, 0,
  -3, 0, 0, 2, 0, 0,
  4, 0, 0, -2, 0, 0,
  3, 0, 0, -1, 0, 0,
  -3, 0, 0, 1, 0, 0,
  -3, 0, 0, 1, 0, 0,
  -3, 0, 0, 2, 0, 0,
  };
  

}


/*
* This class contains many constants for internal use only.
* It does not need to be instantiated.
*/
class SwephData {

  // Mean node seems to have a constant speed and distance?

  // Aus: sweodef.h:
  static final double M_PI = 3.14159265358979323846;

  // Aus sweph.h:
  static final int[] PNOINT2JPL = new int[] {SwephJPL.J_EARTH, SwephJPL.J_MOON,
                    SwephJPL.J_MERCURY, SwephJPL.J_VENUS, SwephJPL.J_MARS,
                    SwephJPL.J_JUPITER, SwephJPL.J_SATURN, SwephJPL.J_URANUS,
                    SwephJPL.J_NEPTUNE, SwephJPL.J_PLUTO, SwephJPL.J_SUN};
  static final int[] pnoint2jpl = PNOINT2JPL;

  /* planetary radii in meters */
  static final int NDIAM = (SweConst.SE_VESTA + 1);
  static final double pla_diam[] = {1392000000.0, /* Sun */
                           3476300.0, /* Moon */
                           2439000.0 * 2, /* Mercury */
                           6052000.0 * 2, /* Venus */
                           3397200.0 * 2, /* Mars */
                          71398000.0 * 2, /* Jupiter */
                          60000000.0 * 2, /* Saturn */
                          25400000.0 * 2, /* Uranus */
                          24300000.0 * 2, /* Neptune */
                           2500000.0 * 2, /* Pluto */
                           0, 0, 0, 0,    /* nodes and apogees */
                           6378140.0 * 2, /* Earth */
                                 0.0, /* Chiron */
                                 0.0, /* Pholus */
                            913000.0, /* Ceres */
                            523000.0, /* Pallas */
                            244000.0, /* Juno */
                            501000.0, /* Vesta */
                        };

  static final double J2000 = 2451545.0;        // 2000 January 1.5
  static final double B1950 = 2433282.42345905; // 1950 January 0.923
  static final double J1900 = 2415020.0;        // 1900 January 0.5

  static final int MPC_CERES = 1;
  static final int MPC_PALLAS = 2;
  static final int MPC_JUNO = 3;
  static final int MPC_VESTA = 4;
  static final int MPC_CHIRON = 2060;
  static final int MPC_PHOLUS = 5145;

  static final String SE_NAME_SUN = "Sun";
  static final String SE_NAME_MOON = "Moon";
  static final String SE_NAME_MERCURY = "Mercury";
  static final String SE_NAME_VENUS = "Venus";
  static final String SE_NAME_MARS = "Mars";
  static final String SE_NAME_JUPITER = "Jupiter";
  static final String SE_NAME_SATURN = "Saturn";
  static final String SE_NAME_URANUS = "Uranus";
  static final String SE_NAME_NEPTUNE = "Neptune";
  static final String SE_NAME_PLUTO = "Pluto";
  static final String SE_NAME_MEAN_NODE = "mean Node";
  static final String SE_NAME_TRUE_NODE = "true Node";
  static final String SE_NAME_MEAN_APOG = "mean Apogee";
  static final String SE_NAME_OSCU_APOG = "osc. Apogee";
  static final String SE_NAME_INTP_APOG = "intp. Apogee";
  static final String SE_NAME_INTP_PERG = "intp. Perigee";
  static final String SE_NAME_EARTH = "Earth";
  static final String SE_NAME_CERES = "Ceres";
  static final String SE_NAME_PALLAS = "Pallas";
  static final String SE_NAME_JUNO = "Juno";
  static final String SE_NAME_VESTA = "Vesta";
  static final String SE_NAME_CHIRON = "Chiron";
  static final String SE_NAME_PHOLUS = "Pholus";


  static final String SE_NAME_CUPIDO = "Cupido";
  static final String SE_NAME_HADES = "Hades";
  static final String SE_NAME_ZEUS = "Zeus";
  static final String SE_NAME_KRONOS = "Kronos";
  static final String SE_NAME_APOLLON = "Apollon";
  static final String SE_NAME_ADMETOS = "Admetos";
  static final String SE_NAME_VULKANUS = "Vulkanus";
  static final String SE_NAME_POSEIDON = "Poseidon";
  static final String SE_NAME_ISIS = "Isis";
  static final String SE_NAME_NIBIRU = "Nibiru";
  static final String SE_NAME_HARRINGTON = "Harrington";
  static final String SE_NAME_NEPTUNE_LEVERRIER = "Leverrier";
  static final String SE_NAME_NEPTUNE_ADAMS = "Adams";
  static final String SE_NAME_PLUTO_LOWELL = "Lowell";
  static final String SE_NAME_PLUTO_PICKERING = "Pickering";
  static final String SE_NAME_VULCAN = "Vulcan";
  static final String SE_NAME_WHITE_MOON = "White Moon";

  static final AyaInit[] ayanamsa = new AyaInit[] {
    new AyaInit(2433282.5, 24.042044444),  /* 0: Fagan/Bradley (Default) */
    new AyaInit(J1900, 360 - 337.53953),   /* 1: Lahiri (Robert Hand) */
    new AyaInit(J1900, 360 - 333.58695),   /* 2: De Luce (Robert Hand) */
    new AyaInit(J1900, 360 - 338.98556),   /* 3: Raman (Robert Hand) */
    new AyaInit(J1900, 360 - 341.33904),   /* 4: Ushashashi (Robert Hand) */
    new AyaInit(J1900, 360 - 337.636111),  /* 5: Krishnamurti (Robert Hand) */
    new AyaInit(J1900, 360 - 333.0369024), /* 6: Djwhal Khool; (Graham Dawson)
                                            *    Aquarius entered on 1 July 2117 */
    new AyaInit(J1900, 360 - 338.917778),  /* 7: Yukteshwar; (David Cochrane) */
    new AyaInit(J1900, 360 - 338.634444),  /* 8: JN Bhasin; (David Cochrane) */
    new AyaInit(1684532.5, -3.36667),      /* 9: Babylonian, Kugler 1 */
    new AyaInit(1684532.5, -4.76667),      /*10: Babylonian, Kugler 2 */
    new AyaInit(1684532.5, -5.61667),      /*11: Babylonian, Kugler 3 */
    new AyaInit(1684532.5, -4.56667),      /*12: Babylonian, Huber */
    new AyaInit(1673941, -5.079167),       /*13: Babylonian, Mercier;
                                            *    eta Piscium culminates with zero point */
    new AyaInit(1684532.5, -4.44088389),   /*14: t0 is defined by Aldebaran at 15 Taurus */
    new AyaInit(1674484, -9.33333),        /*15: Hipparchos */
    new AyaInit(1927135.8747793, 0),       /*16: Sassanian */
    new AyaInit(1746443.513, 0),           /*17: Galactic Center at 0 Sagittarius */
    new AyaInit(J2000, 0),                 /*18: J2000 */
    new AyaInit(J1900, 0),                 /*19: J1900 */
    new AyaInit(B1950, 0),                 /*20: B1950 */
        };

/*
 * earlier content
 */

  static final double PI = M_PI;   // 3.14159265358979323846, math.h
  static final double TWOPI = 2.0 * PI;

//  static final int ENDMARK = -99;

  static final int SEI_EPSILON = -2;
  static final int SEI_NUTATION = -1;
  static final int SEI_EMB = 0;
  static final int SEI_EARTH = 0;
  static final int SEI_SUN = 0;
  static final int SEI_MOON = 1;
  static final int SEI_MERCURY = 2;
  static final int SEI_VENUS = 3;
  static final int SEI_MARS = 4;
  static final int SEI_JUPITER = 5;
  static final int SEI_SATURN = 6;
  static final int SEI_URANUS = 7;
  static final int SEI_NEPTUNE = 8;
  static final int SEI_PLUTO = 9;
  static final int SEI_SUNBARY = 10;     // barycentric sun
  static final int SEI_ANYBODY = 11;     // any asteroid
  static final int SEI_CHIRON = 12;
  static final int SEI_PHOLUS = 13;
  static final int SEI_CERES = 14;
  static final int SEI_PALLAS = 15;
  static final int SEI_JUNO = 16;
  static final int SEI_VESTA = 17;

  static final int SEI_NPLANETS = 18;

  static final int SEI_MEAN_NODE = 0;
  static final int SEI_TRUE_NODE = 1;
  static final int SEI_MEAN_APOG = 2;
  static final int SEI_OSCU_APOG = 3;
  static final int SEI_INTP_APOG = 4;
  static final int SEI_INTP_PERG = 5;

  static final int SEI_NNODE_ETC = 6;

  static final int SEI_FLG_HELIO = 1;
  static final int SEI_FLG_ROTATE = 2;
  static final int SEI_FLG_ELLIPSE = 4;
  static final int SEI_FLG_EMBHEL = 8; // TRUE, if heliocentric earth is given
                                     // instead of barycentric sun
                                     // i.e. bary sun is computed from
                                     // barycentric and heliocentric earth

  static final int SEI_FILE_PLANET = 0;
  static final int SEI_FILE_MOON = 1;
  static final int SEI_FILE_MAIN_AST = 2;
  static final int SEI_FILE_ANY_AST = 3;
  static final int SEI_FILE_FIXSTAR = 4;

  // Aus swephexph.h:
  static final int SEI_FILE_TEST_ENDIAN = 0x616263;   // abc
  static final int SEI_FILE_BIGENDIAN = 0;
  static final int SEI_FILE_NOREORD = 0;
  static final int SEI_FILE_LITENDIAN = 1;
  static final int SEI_FILE_REORD = 2;

  static final int SEI_FILE_NMAXPLAN = 50;
  static final int SEI_FILE_EFPOSBEGIN = 500;

  static final String SE_FILE_SUFFIX = "se1";

  static final int SEI_NEPHFILES = 7;
  static final int SEI_CURR_FPOS = -1;

/* Chiron's orbit becomes chaotic
 * before 720 AD and after 4606 AD, because of close encounters
 * with Saturn. Accepting a maximum error of 5 degrees,
 * the ephemeris is good between the following dates:
 */
  static final double CHIRON_START = 1958470.5;      // 1.1.650
  static final double CHIRON_END = 3419437.5;        // 1.1.4650

/* Pholus's orbit is unstable as well, because he sometimes
 * approaches Saturn.
 * Accepting a maximum error of 5 degrees,
 * the ephemeris is good after the following date:
 */
  static final double PHOLUS_START = 314845.5;       // 1.1.-3850

  static final double MOSHPLEPH_START =  625000.5;
  static final double MOSHPLEPH_END =   2818000.5;
  static final double MOSHLUEPH_START =  625000.5;
  static final double MOSHLUEPH_END =   2818000.5;
  static final double MOSHNDEPH_START = -254900.5; // 14 Feb -5410 00:00 ET jul.
  static final double MOSHNDEPH_END =   3697000.5; // 11 Dec 5409 00:00 ET, greg.


  static final int MAXORD = 40;

  static final double NCTIES = 6.0;    // number of centuries per eph. file

  static final int NOT_AVAILABLE = -2;
  static final int BEYOND_EPH_LIMITS = -3;

  static final int J_TO_J2000 = 1;
  static final int J2000_TO_J = -1;


  // we always use Astronomical Almanac constants, if available
  static final double MOON_MEAN_DIST = 384400000.0;           // in m, AA 1996, F2
  static final double MOON_MEAN_INCL = 5.1453964;             // AA 1996, D2
  static final double MOON_MEAN_ECC = 0.054900489;            // AA 1996, F2
  // static final double SUN_EARTH_MRAT = 328900.561400;         Su/(Ea+Mo) AA 2006 K7
  static final double SUN_EARTH_MRAT = 332946.050895;         // Su / (Ea only) AA 2006 K7
  static final double EARTH_MOON_MRAT = (1 / 0.0123000383);   // AA 2006, K7
  static final double AUNIT = 1.49597870691e+11;              // au in meters, AA 2006 K6
  static final double CLIGHT = 2.99792458e+8;                 // m/s, AA 1996 K6
  static final double HELGRAVCONST = 1.32712440017987e+20;    // G * M(sun), m^3/sec^2, AA 2006 K6
  static final double GEOGCONST = 3.98600448e+14; // G * M(earth) m^3/sec^2, AA 1996 K6
  static final double KGAUSS = 0.01720209895; // Gaussian gravitational constant K6
  static final double KGAUSS_GEO = 0.0000298122353216;        // Earth only
  // static final double KGAUSS_GEO = 0.0000299502129737        // Earth + Moon
  static final double SUN_RADIUS = 959.63 / 3600 * SwissData.DEGTORAD;  // Meeus germ. p 391
  static final double EARTH_RADIUS = 6378136.6;               // AA 2006 K6
  /*static final double EARTH_OBLATENESS = (1.0/ 298.257223563); * AA 1998 K13 */
  static final double EARTH_OBLATENESS = (1.0/ 298.25642);    // AA 2006 K6
  static final double EARTH_ROT_SPEED = 7.2921151467e-5 * 86400; // in rad/day, expl. suppl., p 162

  static final double LIGHTTIME_AUNIT = (499.0047838061/3600/24); // 8.3167 minutes (days), AA 2006 K6

  /* node of ecliptic measured on ecliptic 2000 */
  static final double SSY_PLANE_NODE_E2000 = 107.582569 * SwissData.DEGTORAD;
  /* node of ecliptic measured on solar system rotation plane */
  static final double SSY_PLANE_NODE = 107.58883388 * SwissData.DEGTORAD;
  /* inclination of ecliptic against solar system rotation plane */
  static final double SSY_PLANE_INCL = 1.578701 * SwissData.DEGTORAD;

  static final double KM_S_TO_AU_CTY = 21.095;           // km/s to AU/century
  static final double MOON_SPEED_INTV = 0.00005;         // 4.32 seconds (in days)
  static final double PLAN_SPEED_INTV = 0.0001;          // 8.64 seconds (in days)
  static final double MEAN_NODE_SPEED_INTV = 0.001;
  static final double NODE_CALC_INTV = 0.0001;
  static final double NODE_CALC_INTV_MOSH = 0.1;
  static final double NUT_SPEED_INTV = 0.0001;
  static final double DEFL_SPEED_INTV = 0.0000005;


/*
 * stuff exported from swemplan.c and swemmoon.c
 * and constants used inside these functions.
************************************************************/

  static final double STR = 4.8481368110953599359e-6;   // radians per arc second


  // Aus sweph.c:
  static final int IS_PLANET = 0;
  static final int IS_MOON = 1;
  static final int IS_ANY_BODY = 2;
  static final int IS_MAIN_ASTEROID = 3;

  static final boolean DO_SAVE = true;
  static final boolean NO_SAVE = false;

//  java.io.RandomAccessFile fixfp = null;     // fixed stars


//  static final int pnoext2int[] = {SEI_SUN, SEI_MOON, SEI_MERCURY, SEI_VENUS,
//    SEI_MARS, SEI_JUPITER, SEI_SATURN, SEI_URANUS, SEI_NEPTUNE, SEI_PLUTO,
//    0, 0, 0, 0, SEI_EARTH, SEI_CHIRON, SEI_PHOLUS, SEI_CERES, SEI_PALLAS,
//    SEI_JUNO, SEI_VESTA, };


//////////////////////////////////////////////////////////////////////////////
// extensions: ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////
// SURYA: /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double SURYA_MAX_LON_SPEED = 1.025;
// NOTOPO, JPL: 1.0233362482825890 198.1481527339882689 656297.5935287680476904 /    nan    nan    nan

  static final double SURYA_MIN_LON_SPEED = 0.946;
// NOTOPO, JPL: 0.9495985191372013 13.6641834118152925 630178.1503921914845705 /    nan    nan    nan

  static final double SURYA_MAX_LON_ACCEL = 0.000735;
// NOTOPO, JPL: 0.0007321244674241 111.1489600158149074 632105.3974533881992102 632105.4891571882180870 /    nan    nan    nan

  static final double SURYA_MIN_LON_ACCEL = -0.000720;
// NOTOPO, JPL: -0.0007172603891239 281.9291936621758623 663685.2516582887619734 663685.3433620887808502 /    nan    nan    nan

  static final double SURYA_MAX_TOPO_LON_SPEED = 1.04;
// TOPO, SWI:   1.0384413287108927 0.0000000000000000 -199501.5087046779808588 / -0.5433742788 -4.7293263997 -1664.2795669022
// TOPO, JPL:   1.0365074888828785 209.2107463691459657 795098.6519823583075777 / -148.9   17.7 12497.5

  static final double SURYA_MIN_TOPO_LON_SPEED = 0.93;
// TOPO, SWI:   0.9349095448292457 0.0000000000000000 -224529.9592720646178350 -16.3604237359 -3.3169784104 3529.4848477192
// TOPO, JPL:   0.9365203548203047 30.4143819284346542 717121.0431665068026632 /  -79.7    7.4 -48617.2

  static final double SURYA_MAX_TOPO_LON_ACCEL = 0.06;
// TOPO, SWI:   0.0593799785863376
// TOPO, JPL:   0.0583456448574779 275.0416878063256263 2700635.1911227395758033 2700635.2918350920081139 /   11.0   52.2 -110000.0

  static final double SURYA_MIN_TOPO_LON_ACCEL = -0.06;
// TOPO, SWI:   -0.0594559646638496
// TOPO, JPL:   -0.0584748042751905 271.9731910425273895 1139219.1189967475365847 1139219.2191002487670630 /   11.0   52.2 -110000.0

  static final double SURYA_MAX_HELIO_LON_SPEED = 0;
  static final double SURYA_MIN_HELIO_LON_SPEED = 0;
  static final double SURYA_MAX_HELIO_LON_ACCEL = 0;
  static final double SURYA_MIN_HELIO_LON_ACCEL = 0;


  static final double SURYA_MAX_LAT_SPEED = 0.0000620;
// NOTOPO, JPL: 0.0000618025182438 241.4261311889077604 1113622.1226309132762253 /    nan    nan    nan

  static final double SURYA_MIN_LAT_SPEED = -0.0000618;
// NOTOPO, JPL: -0.0000614244567336 299.9816306303840747 1156413.5820919747930020 /    nan    nan    nan

  static final double SURYA_MAX_LAT_ACCEL = 0.0000203;
// NOTOPO, JPL: 0.0000200049293864 85.4713554114340468 1067082.5648221261799335 1067082.6565259261988103 /    nan    nan    nan

  static final double SURYA_MIN_LAT_ACCEL = -0.0000204;
// NOTOPO, JPL: -0.0000202677724199 267.1036516425933200 836064.9195209722965956 836065.0112247723154724 /    nan    nan    nan

  static final double SURYA_MAX_TOPO_LAT_SPEED = 0.0066;
// TOPO, SWI:   0.0064145372870949
// TOPO, JPL:   0.0063447811040511 167.6535710049226680 943711.7743394003482535 /  129.0    4.8 10365.7

  static final double SURYA_MIN_TOPO_LAT_SPEED = -0.0065;
// TOPO, SWI:   -0.0064584410123400
// TOPO, JPL:   -0.0063137486844727 183.6555443690479876 1222042.6236723833717406 /  -94.5   -3.3 33636.2

  static final double SURYA_MAX_TOPO_LAT_ACCEL = 0.025;
// TOPO, SWI:   0.0244212760934252
// TOPO, JPL:   0.0238296790897776 192.2272313218551290 632914.0236237654462457 632914.1249053360661492 /   11.0   52.2 -110000.0

  static final double SURYA_MIN_TOPO_LAT_ACCEL = -0.025;
// TOPO, SWI:   -0.0244146697145761
// TOPO, JPL:   -0.0238413888237050 204.3178283029897102 638404.4897474966710433 638404.5898247783770785 /   11.0   52.2 -110000.0

  static final double SURYA_MAX_HELIO_LAT_SPEED = 0;
  static final double SURYA_MIN_HELIO_LAT_SPEED = 0;
  static final double SURYA_MAX_HELIO_LAT_ACCEL = 0;
  static final double SURYA_MIN_HELIO_LAT_ACCEL = 0;


  static final double SURYA_MAX_DIST_SPEED = 0.000328;
// NOTOPO, JPL: 0.0003251647876611 285.1359892485851901 630451.5194200477562845 /    nan    nan    nan

  static final double SURYA_MIN_DIST_SPEED = -0.000327;
// NOTOPO, JPL: -0.0003247521770552 108.3678967045579498 669357.4068008563481271 /    nan    nan    nan

  static final double SURYA_MAX_DIST_ACCEL = 0.00000734;
// NOTOPO, JPL: 0.0000073151160377 197.0004801545529460 647895.7830748385749757 647895.8747786385938525 /    nan    nan    nan

  static final double SURYA_MIN_DIST_ACCEL = -0.00000694;
// NOTOPO, JPL: -0.0000069158807111 15.5783679317648520 641502.5609527225606143 641502.6526565225794911 /    nan    nan    nan

  static final double SURYA_MAX_TOPO_DIST_SPEED = 0.00059;
// TOPO, SWI:   0.0005789367418679
// TOPO, JPL:   0.0005633150154512 318.6451137771567801 1329557.3832753794267774 /   84.1    1.8 -19441.6

  static final double SURYA_MIN_TOPO_DIST_SPEED = -0.00058;
// TOPO, SWI:   -0.0005724228279118
// TOPO, JPL:   -0.0005647002245768 174.5410821021679340 2142079.3515738314017653 /  143.7    1.1 -26129.6

  static final double SURYA_MAX_TOPO_DIST_ACCEL = 0.00104;
// TOPO, SWI:   0.0010219054361193
// TOPO, JPL:   0.0010043877043150 178.6859059007219059 713984.7248655840521678 713984.8256328357383609 /   11.0   52.2 -110000.0

  static final double SURYA_MIN_TOPO_DIST_ACCEL = -0.0013;
// TOPO, SWI:   -0.0012818853764991
// TOPO, JPL:   -0.0010042541999776 357.1345657907744453 833598.1178349015535787 833598.2180397533811629 /   11.0   52.2 -110000.0

  static final double SURYA_MAX_HELIO_DIST_SPEED = 0;
  static final double SURYA_MIN_HELIO_DIST_SPEED = 0;
  static final double SURYA_MAX_HELIO_DIST_ACCEL = 0;
  static final double SURYA_MIN_HELIO_DIST_ACCEL = 0;



///////////////////////////////////////////////////////////////
// CHANDRA: ///////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double CHANDRA_MAX_LON_SPEED = 15.41;
// NOTOPO, JPL: 15.4041164556993593 180.5585719899691526 867780.5870537008158863 /    nan    nan    nan

  static final double CHANDRA_MIN_LON_SPEED = 11.75;
// NOTOPO, JPL: 11.7572903229686911 48.7868453140692111 1045632.5874787108041346 /    nan    nan    nan

  static final double CHANDRA_MAX_LON_ACCEL = 0.522;
// NOTOPO, JPL: 0.5186414758242096 126.4203023968987338 1065011.4344986998476088 1065011.5262024998664856 /    nan    nan    nan

  static final double CHANDRA_MIN_LON_ACCEL = -0.520;
// NOTOPO, JPL: -0.5185377158655800 124.9880532266025597 1139170.4634979651309550 1139170.5552017651498318 /    nan    nan    nan

  static final double CHANDRA_MAX_TOPO_LON_SPEED = 22.0;
// TOPO, SWI:   21.4309682969720328 179.1777778485675867 3558401.0245797489769757 / 123.7452556088 1.2763677912 -9647.8126131759
// TOPO, JPL:   21.1149235251773284 21.1660559007296314 2077012.0076510021463037 /  167.6    1.2 -56742.6

  static final double CHANDRA_MIN_TOPO_LON_SPEED = 6.0;
// TOPO, SWI:   6.2043978283097267 91.2062770401382892 110594.4898514153319411 -82.1318313870 -2.2805770007 3320.8680109613
// TOPO, JPL:   6.3597932870754974 7.2417677341565536 2248084.8536576554179192 /   72.4   -4.6 18046.7

  static final double CHANDRA_MAX_TOPO_LON_ACCEL = 23.5;
// TOPO, SWI:   22.9729155357766466
//              22.5191319837460533 189.8858251817875384 2303261.6343037686310709 2303261.7453831625171006 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   22.5728018782278816 188.2658986628977686 1030021.1688936793943867 1030021.2732220485340804 /   11.0   52.2 -110000.0

  static final double CHANDRA_MIN_TOPO_LON_ACCEL = -23.2;
// min topo3:   -38.1716335
// TOPO, SWI:   -22.9387038817123141
//              -22.5127674732828922 160.2778837680125719 218788.6020565493090544 218788.7164031058782712 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   -22.5391436800995280 164.1286691196248171 2558171.2196601303294301 2558171.3217258220538497 /   11.0   52.2 -110000.0

  static final double CHANDRA_MAX_HELIO_LON_SPEED = 1.0584;
// HELIO, SWI:   1.0582731664012499 340.9315601866028942 -198775.0513440131617244 / 

  static final double CHANDRA_MIN_HELIO_LON_SPEED = 0.9155;
// HELIO, SWI:   0.9157102465868880 159.3985924130032288 -205168.3651679001632147 / 

  static final double CHANDRA_MAX_HELIO_LON_ACCEL = 0.007875;
// HELIO, SWI:   0.0078730294316827 277.3484374693355790 203659.9220483523386065 203660.0137521523283795 / 

  static final double CHANDRA_MIN_HELIO_LON_ACCEL = -0.007888;
// HELIO, SWI:   -0.0078862144639317 62.5339410468777928 -71224.9695591411000350 -71224.8778553410957102 / 


  static final double CHANDRA_MAX_LAT_SPEED = 1.44;
// NOTOPO, JPL: 1.4161178854830674 179.4697049090585210 2804426.0038991500623524 /    nan    nan    nan

  static final double CHANDRA_MIN_LAT_SPEED = -1.44;
// NOTOPO, JPL: -1.4172129253432328 178.3605766215862332 628523.9972474509850144 /    nan    nan    nan

  static final double CHANDRA_MAX_LAT_ACCEL = 0.366;
// NOTOPO, JPL: 0.3639886778563629 178.7949269887757282 1886142.7578099258244038 1886142.8495137258432806 /    nan    nan    nan

  static final double CHANDRA_MIN_LAT_ACCEL = -0.366;
// NOTOPO, JPL: -0.3636913084572940 180.6303963665253036 912666.9377527404576540 912667.0294565404765308 /    nan    nan    nan

  static final double CHANDRA_MAX_TOPO_LAT_SPEED = 4.2;
// TOPO, SWI:   4.0196744317594568
// TOPO, JPL:   3.8905318518976895 4.1726025186527806 1045864.4757649956736714 /  -49.8    1.0 -330810.4

  static final double CHANDRA_MIN_TOPO_LAT_SPEED = -4.7;
// TOPO, SWI:   -4.1184649007547964
// TOPO, JPL:   -3.9483356515061541 8.3800829312503424 944132.7195180986309424 /  -82.7   16.8 -54378.5

  static final double CHANDRA_MAX_TOPO_LAT_ACCEL = 12.5;
// TOPO, SWI:   12.3783195665162751
// TOPO, JPL:   12.0090702595465828 156.9810838245764160 1658430.5072499848902225 1658430.6155795308295637 /   11.0   52.2 -110000.0

  static final double CHANDRA_MIN_TOPO_LAT_ACCEL = -12.5;
// TOPO, SWI:   -12.0415108646951037
// TOPO, JPL:   -11.8365401411952877 18.3511634305493487 713555.6669830741593614 713555.7701688770903274 /   11.0   52.2 -110000.0

  static final double CHANDRA_MAX_HELIO_LAT_SPEED = 0.003415;
// HELIO, SWI:   0.0034101386545078 126.4693244384440476 3019157.7850323482416570 / 

  static final double CHANDRA_MIN_HELIO_LAT_SPEED = -0.0034187;
// HELIO, SWI:   -0.0034163978380770 54.5835286233875010 1079647.8165857093408704 / 

  static final double CHANDRA_MAX_HELIO_LAT_ACCEL = 0.0008119;
// HELIO, SWI:   0.0008116345691465 81.4557765725807883 1916810.8899200353771448 1916810.9816238353960216 / 

  static final double CHANDRA_MIN_HELIO_LAT_ACCEL = -0.0008069;
// HELIO, SWI:   -0.0008067042857947 37.6793496389577811 963118.6057523223571479 963118.6974561223760247 / 


  static final double CHANDRA_MAX_DIST_SPEED = 0.000044;
// NOTOPO, JPL: 0.0000430106329181 118.0467546874002380 857921.8783288714475930 /    nan    nan    nan

  static final double CHANDRA_MIN_DIST_SPEED = -0.0000434;
// NOTOPO, JPL: -0.0000430670864277 117.1142513980806257 751632.3483938642311841 /    nan    nan    nan

  static final double CHANDRA_MAX_DIST_ACCEL = 0.0000140;
// NOTOPO, JPL: 0.0000137704986304 179.2396768958410860 867780.5870537008158863 867780.6787575008347631 /    nan    nan    nan

  static final double CHANDRA_MIN_DIST_ACCEL = -0.00000898;
// NOTOPO, JPL: -0.0000089378018376 90.1277326204999270 784496.9382487572729588 784497.0299525572918355 /    nan    nan    nan

  static final double CHANDRA_MAX_TOPO_DIST_SPEED = 0.00030;
// TOPO, SWI:   0.0002987444506570
// TOPO, JPL:   0.0002909664964957 284.8643480099901808 1080096.5486003318801522 /  144.6   -2.3 4895.6

  static final double CHANDRA_MIN_TOPO_DIST_SPEED = -0.00031;
// TOPO, SWI:   -0.0002975759131239
// TOPO, JPL:   -0.0002895923864196 55.7017996303879528 1362930.4575669008772820 /  167.6   -2.3 17165.7

  static final double CHANDRA_MAX_TOPO_DIST_ACCEL = 0.00099;
// TOPO, SWI:   0.0009695039477059
// TOPO, JPL:   0.0009507373452100 177.1836363491260897 827412.1154932569479570 827412.2165193189866841 /   11.0   52.2 -110000.0

  static final double CHANDRA_MIN_TOPO_DIST_ACCEL = -0.00098;
// TOPO, SWI:   -0.0009611955640193
// TOPO, JPL:   -0.0009452968840833 241.9355511752623897 733411.5362529422855005 733411.6373956773895770 /   11.0   52.2 -110000.0

  static final double CHANDRA_MAX_HELIO_DIST_SPEED = 0.0008899;
// HELIO, SWI:   0.0008894035707012 72.3250923160331212 -201971.5707002566778101 / 

  static final double CHANDRA_MIN_HELIO_DIST_SPEED = -0.000889;
// HELIO, SWI:   -0.0008886720697406 249.4270859464915020 -195578.6236915696354117 / 

  static final double CHANDRA_MAX_HELIO_DIST_ACCEL = 0.0001394;
// HELIO, SWI:   0.0001393197780529 338.4548057402580525 -210100.1038275501632597 -210100.0121237501734868 / 

  static final double CHANDRA_MIN_HELIO_DIST_ACCEL = -0.00013959;
// HELIO, SWI:   -0.0001395759805093 165.4174725364829044 -132478.9812908066669479 -132478.8895870066771749 / 



///////////////////////////////////////////////////////////////
// BUDHA: /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double BUDHA_MAX_LON_SPEED = 2.23;
// NOTOPO, SWI: 2.2121426791396726
//              2.2118740410345783 2.0229662866546647 3632579.7922155149281025
// NOTOPO, JPL: 2.1964845502320962 3.0367044971105202 2816224.3305718521587551 / 

  static final double BUDHA_MIN_LON_SPEED = -1.40;
// NOTOPO, SWI: -1.3908298594148474
//              -1.3898959805347326 0.5092469431197060 3682809.9214275842532516
// NOTOPO, JPL: -1.3521147816768901 3.0331619351929362 2777343.6256446754559875 / 

  static final double BUDHA_MAX_LON_ACCEL = 0.20;
// NOTOPO, SWI: 0.1967914822899190 14.2061443309504511
//              0.1968017050259578 14.4414680144461727 -175436.4430393589718733 -175436.0775205177196767
// NOTOPO, JPL: 0.1965936384404356 14.3754648083684629 643469.9357961784116924 643470.2695755218155682 / 

  static final double BUDHA_MIN_LON_ACCEL = -0.199;
// NOTOPO, JPL: -0.1986619469289480 14.0525985387717469 2385435.3617391046136618 2385435.5139587139710784 / 

  static final double BUDHA_MAX_TOPO_LON_SPEED = 2.3;
// TOPO, SWI:   2.2212980742115511 2.1541861391796004 3632579.8976156003773212 / 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   2.2019660581364016 3.0549461351521785 2794671.4474170133471489 /   11.0   52.2 -110000.0


  static final double BUDHA_MIN_TOPO_LON_SPEED = -1.49;
// TOPO, SWI:   -1.4063442078716697 0.1278834320364695 3606099.4173800637945533 25.4514719644 3.6416897111 -8080.5345996378
// TOPO, JPL:   -1.3655028210686915 3.0368029001502350 2726937.0293830074369907 /   11.0   52.2 -110000.0

  static final double BUDHA_MAX_TOPO_LON_ACCEL = 0.281;
// TOPO, SWI:   0.2720747632986203
//              0.2702626383612824 14.4371256403208434 -134531.0275387382425833 -134530.9010568788216915 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   0.2675637274842573 13.7209457445615612 2597974.1161503684706986 2597974.2541675390675664 /   11.0   52.2 -110000.0

  static final double BUDHA_MIN_TOPO_LON_ACCEL = -0.282;
// TOPO, JPL:   -0.2730133058585249 13.0135107334394888 2267820.7196086999028921 2267820.8311376208439469 /   11.0   52.2 -110000.0

  static final double BUDHA_MAX_HELIO_LON_SPEED = 6.358;
// HELIO, SWI:   6.3531535305329898 133.1008594391232975 3693190.0689586945809424 / 

  static final double BUDHA_MIN_HELIO_LON_SPEED = 2.743;
// HELIO, SWI:   2.7419144691190489 204.6191384842340995 1223669.8266647555865347 / 

  static final double BUDHA_MAX_HELIO_LON_ACCEL = 0.1547;
// HELIO, SWI:   0.1545118574744947 69.4456644722211678 3691507.8544511483050883 3691507.9461549483239651 / 

  static final double BUDHA_MIN_HELIO_LON_ACCEL = -0.1654;
// HELIO, SWI:   -0.1650067987113518 195.9518154132125858 3693288.5588399148546159 3693288.6505437148734927 / 


  static final double BUDHA_MAX_LAT_SPEED = 0.35;
// NOTOPO, SWI: 0.3461375049101383
// NOTOPO, JPL: 0.3459340957539888 3.1275672465673381 2046046.1421363854315132 / 

  static final double BUDHA_MIN_LAT_SPEED = -0.31;
// NOTOPO, SWI: -0.3029605350228085
// NOTOPO, JPL: -0.2959580096865397 4.5857649974633290 2786261.3525251694954932 / 

  static final double BUDHA_MAX_LAT_ACCEL = 0.036;
// NOTOPO, JPL: 0.0348286193410149 6.1558577433976609 656209.0999486010987312 656209.3120646663010120 / 

  static final double BUDHA_MIN_LAT_ACCEL = -0.044;
// NOTOPO, JPL: -0.0431614487026422 3.7132593670662573 2795997.5029838741756976 2795997.6633058190345764 / 

  static final double BUDHA_MAX_TOPO_LAT_SPEED = 0.37;
// TOPO, SWI:   0.3535327026595066
// TOPO, JPL:   0.3516211846308093 4.3248275513309125 2127856.8769019907340407 / -112.4   20.8 -471130.3

  static final double BUDHA_MIN_TOPO_LAT_SPEED = -0.34;
// TOPO, SWI:   -0.3110366765430237
// TOPO, JPL:   -0.3024348731924316 3.4445804868699952 2815115.3181047569960356 /   11.0   52.2 -110000.0

  static final double BUDHA_MAX_TOPO_LAT_ACCEL = 0.078;
// TOPO, SWI:   0.0709869852337391
// TOPO, JPL:   0.0681552201699322 5.8364023444659665 2681169.2107728449627757 2681169.3127622539177537 /   11.0   52.2 -110000.0

  static final double BUDHA_MIN_TOPO_LAT_ACCEL = -0.10;
// TOPO, SWI:   -0.0922493674654878
// TOPO, JPL:   -0.0729233751466286 3.0273764042146354 2815000.2646535192616284 2815000.4375549573451281 /   11.0   52.2 -110000.0

  static final double BUDHA_MAX_HELIO_LAT_SPEED = 0.7557;
// HELIO, SWI:   0.7553703671754021 16.3688380351721925 1325492.4990891152992845 / 

  static final double BUDHA_MIN_HELIO_LAT_SPEED = -0.4114;
// HELIO, SWI:   -0.4111362907117068 246.4339115609588760 3693212.3529820991680026 / 

  static final double BUDHA_MAX_HELIO_LAT_ACCEL = 0.05938;
// HELIO, SWI:   0.0593445105889032 270.4030522587243581 -249781.5302325247903354 -249781.4385287248005625 / 

  static final double BUDHA_MIN_HELIO_LAT_ACCEL = -0.07986;
// HELIO, SWI:   -0.0798194690969669 158.4460452903338989 3693194.0122220953926444 3693194.1039258954115212 / 


  static final double BUDHA_MAX_DIST_SPEED = 0.0286;
// NOTOPO, SWI: 0.0285361509872121
// NOTOPO, JPL: 0.0284435836536158 17.8220744613078921 2813056.3789104702882469 / 

  static final double BUDHA_MIN_DIST_SPEED = -0.0285;
// NOTOPO, SWI: -0.0283017805993105
// NOTOPO, JPL: -0.0282165685365427 341.9215268668302770 2782882.9571671239100397 / 

  static final double BUDHA_MAX_DIST_ACCEL = 0.00325;
// NOTOPO, SWI: 0.0032332968656052
// NOTOPO, JPL: 0.0032071536310416 3.0073281498403617 1478471.6755875691305846 1478474.2478824988938868 / 

  static final double BUDHA_MIN_DIST_ACCEL = -0.00150;
// NOTOPO, SWI: -0.0014746281509695
// NOTOPO, JPL: -0.0014443126861754 3.0209131307652735 1212364.5652429726906121 1212365.4193637575954199 / 

  static final double BUDHA_MAX_TOPO_DIST_SPEED = 0.031;
// TOPO, SWI:   0.0287123956183378
// TOPO, JPL:   0.0285904873909507 17.8171901085420359 2779452.2660587546415627 /   11.0   52.2 -110000.0

  static final double BUDHA_MIN_TOPO_DIST_SPEED = -0.031;
// TOPO, SWI:   -0.0284478735129602
// TOPO, JPL:   -0.0283720842286670 341.9244805616797294 2720424.8167121694423258 /   11.0   52.2 -110000.0

  static final double BUDHA_MAX_TOPO_DIST_ACCEL = 0.0045;
// TOPO, SWI:   0.0042518661363709
// TOPO, JPL:   0.0041135772523493 3.5253503113738702 823188.5811508881160989 823188.6866559227928519 /   11.0   52.2 -110000.0

  static final double BUDHA_MIN_TOPO_DIST_ACCEL = -0.0026;
// TOPO, SWI:   -0.0024527311665292 0.5167782633536149 -5744.8122126676598782
// TOPO, JPL:   -0.0024167702503400 3.3085032796661267 912476.0649550299858674 912476.1788295382866636 /   11.0   52.2 -110000.0

  static final double BUDHA_MAX_HELIO_DIST_SPEED = 0.005831;
// HELIO, SWI:   0.0058292395555195 220.7147987391139452 3689159.3201326648704708 / 

  static final double BUDHA_MIN_HELIO_DIST_SPEED = -0.005831;
// HELIO, SWI:   -0.0058292162358244 40.8008633501085569 3689566.6684123487211764 / 

  static final double BUDHA_MAX_HELIO_DIST_ACCEL = 0.00064693;
// HELIO, SWI:   0.0006468760807897 130.8217801248015064 3692837.7429590220563114 3692837.8346628220751882 / 

  static final double BUDHA_MIN_HELIO_DIST_ACCEL = -0.0002801;
// HELIO, SWI:   -0.0002799658485144 310.3739292524310827 3689626.8261051611043513 3689626.9178089611232281 / 



///////////////////////////////////////////////////////////////
// SHUKRA: ////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double SHUKRA_MAX_LON_SPEED = 1.266;
// NOTOPO, SWI: 1.2647832575015769 8.0946758136625334 -223273.6698087960830890
// NOTOPO, JPL: 1.2626880451301978 6.8592131288181690 655532.6087605641223490 / 

  static final double SHUKRA_MIN_LON_SPEED = -0.65;
// NOTOPO, SWI: -0.6442598039379197
//              -0.6433716551442837 0.1763535479380494 -92731.2864470719941892
// NOTOPO, JPL: -0.6342143262436917 3.0671365776595962 786068.8421976494137198 / 

  static final double SHUKRA_MAX_LON_ACCEL = 0.0427;
// NOTOPO, SWI: 0.0424074627825448 24.8562467442907575 -233439.0194156236830167 -233438.6142852465854958
// NOTOPO, JPL: 0.0422089427157020 25.5555337892983800 648281.9859329168684781 648282.5466118947369978 / 

  static final double SHUKRA_MIN_LON_ACCEL = -0.0432;
// NOTOPO, SWI: -0.0431008459219351
//              -0.0430347501870898 25.2030500717861798 -114352.8623767224780750 -114352.3139205740008038
// NOTOPO, JPL: -0.0428785353088984 25.7126449364186271 764448.4358926375862211 764448.7770163168897852 / 

  static final double SHUKRA_MAX_TOPO_LON_SPEED = 1.28;
// TOPO, SWI:   1.2730954589558330 5.3700635638143410 -119909.2988172726909397 / -134.0001301493 1.8017167065 -8673.2746795623
// TOPO, JPL:   1.2703027775692810 5.4922725269008765 661377.0886009712703526 /   94.5   -6.2 -491257.9

  static final double SHUKRA_MIN_TOPO_LON_SPEED = -0.70;
// TOPO, SWI:   -0.6936977087256924 1.2466270148142939 445643.9324010963318869 53.4798848587 -4.4726827850 -7886.1605683664
// TOPO, JPL:   -0.6676040834690141 3.6769337485729210 2802347.7158071650192142 /  117.3    9.6 -79312.5

  static final double SHUKRA_MAX_TOPO_LON_ACCEL = 0.246;
// TOPO, SWI:   0.2433226750300663
// TOPO, JPL:   0.2394634181851154 15.7214745858053107 2391279.1253627552650869 2391279.2436700705438852 /   11.0   52.2 -110000.0

  static final double SHUKRA_MIN_TOPO_LON_ACCEL = -0.245;
// TOPO, SWI:   -0.2440019874759702
//              -0.2392102393704883 17.8923225230373077 1870399.8055008733645082 1870399.9183341816533357 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   -0.2390424284021380 14.9008573529047226 2136669.7269426635466516 2136669.8495701653882861 /   11.0   52.2 -110000.0

  static final double SHUKRA_MAX_HELIO_LON_SPEED = 1.635;
// HELIO, SWI:   1.6345969963429665 28.5411734631320897 -246469.8309034941194113 / 

  static final double SHUKRA_MIN_HELIO_LON_SPEED = 1.565;
// HELIO, SWI:   1.5657235503354836 200.4625169758045615 -249508.2529085552669130 / 

  static final double SHUKRA_MAX_HELIO_LON_ACCEL = 0.0009600;
// HELIO, SWI:   0.0009598572231919 280.9144592768616917 -244738.7382710871752352 -244738.6465672871854622 / 

  static final double SHUKRA_MIN_HELIO_LON_ACCEL = -0.001066;
// HELIO, SWI:   -0.0010643800494512 123.9582701334205410 -243939.4479503763141111 -243939.3562465763243381 / 


  static final double SHUKRA_MAX_LAT_SPEED = 0.264;
// NOTOPO, SWI: 0.2626687595047291
// NOTOPO, JPL: 0.2624782757931561 11.9262022773096987 2731687.9197727106511593 / 

  static final double SHUKRA_MIN_LAT_SPEED = -0.251;
// NOTOPO, SWI: -0.2497768135289706
// NOTOPO, JPL: -0.2433475539005757 16.5902349882487457 2771998.1607629279606044 / 

  static final double SHUKRA_MAX_LAT_ACCEL = 0.0167;
// NOTOPO, SWI: 0.0165804236663561
//              0.0165804236663561 0.3206358128090869 -237545.8259068329643924
//              0.0165666745904057 1.1351846329151130 -237546.7287194099626504
// NOTOPO, JPL: 0.0162686363775788 3.2561579239047944 647092.7725445065880194 647096.1254414529539645 / 

  static final double SHUKRA_MIN_LAT_ACCEL = -0.0170;
// NOTOPO, SWI: -0.0168485103248528 0.9333608749641940 2927894.9631067705340683
// NOTOPO, JPL: -0.0166690055753542 3.1949847660659429 2750381.4620271674357355 2750384.3717524991370738 / 

  static final double SHUKRA_MAX_TOPO_LAT_SPEED = 0.29;
// TOPO, SWI:   0.2831649021588232
// TOPO, JPL:   0.2807925180336351 4.8540417206386053 1867489.0201850079465657 /  155.1    5.2 -228627.5

  static final double SHUKRA_MIN_TOPO_LAT_SPEED = -0.27;
// TOPO, SWI:   -0.2679560347521213
// TOPO, JPL:   -0.2575136019376459 11.7339008245196439 2662801.1060125296935439 /   98.9   35.9 -67809.4

  static final double SHUKRA_MAX_TOPO_LAT_ACCEL = 0.13;
// TOPO, SWI:   0.1378583409260294 46.1909521927493358 107038.4291893199551851 ???
// TOPO, JPL:   0.1097291552617890 6.1041719535868992 2541331.0570884267799556 2541331.1783968498930335 /   11.0   52.2 -110000.0

  static final double SHUKRA_MIN_TOPO_LAT_ACCEL = -0.113;
// TOPO, JPL:   -0.1096757005292673 4.5047168297550897 2798261.1054993667639792 2798261.2056133821606636 /   11.0   52.2 -110000.0

  static final double SHUKRA_MAX_HELIO_LAT_SPEED = 0.096175;
// HELIO, SWI:   0.0961600523665297 108.2438555838370746 3690694.4417449808679521 / 

  static final double SHUKRA_MIN_HELIO_LAT_SPEED = -0.09549;
// HELIO, SWI:   -0.0954633604190603 287.0851157642126736 3690355.9630191111937165 / 

  static final double SHUKRA_MAX_HELIO_LAT_ACCEL = 0.002635;
// HELIO, SWI:   0.0026336493450001 18.3791011964134228 3690638.0439079692587256 3690638.1356117692776024 / 

  static final double SHUKRA_MIN_HELIO_LAT_ACCEL = -0.00275;
// HELIO, SWI:   -0.0027399608503963 196.5127385813333944 3671649.8550760606303811 3671649.9467798606492579 / 


  static final double SHUKRA_MAX_DIST_SPEED = 0.00806;
// NOTOPO, SWI: 0.0080571513631017
// NOTOPO, JPL: 0.0080535495091922 45.7633608410767465 2709578.0732003846205771 / 

  static final double SHUKRA_MIN_DIST_SPEED = -0.0083;
// NOTOPO, SWI: -0.0082727691197702
// NOTOPO, JPL: -0.0082468779032532 45.1463900807501659 702493.7312306788517162 / 

  static final double SHUKRA_MAX_DIST_ACCEL = 0.000316;
// NOTOPO, SWI: 0.0003155080110194 0.2863655720027083 2456084.3681465862318873
// NOTOPO, JPL: 0.0003148617982150 3.3090977992377191 2459003.4718500413000584 2459006.3288830956444144 / 

  static final double SHUKRA_MIN_DIST_ACCEL = -0.0000625;
// NOTOPO, JPL: -0.0000621028061790 3.3456973295425030 628716.0880901443306357 628716.5565334432758391 / 

  static final double SHUKRA_MAX_TOPO_DIST_SPEED = 0.0084;
// TOPO, SWI:   0.0082875554200721
// TOPO, JPL:   0.0082556409498835 45.6687320289578338 1993688.0229605080094188 /   58.8   10.4 -195796.3

  static final double SHUKRA_MIN_TOPO_DIST_SPEED = -0.0086;
// TOPO, SWI:   -0.0085208451408857
// TOPO, JPL:   -0.0084076102734088 45.1293851548699507 885846.4561085053719580 /   23.5  -20.4 -1514448.1

  static final double SHUKRA_MAX_TOPO_DIST_ACCEL = 0.0015;
// TOPO, SWI:   0.0016133029911976 37.5183635742056012 1578004.9928161685820669
//              0.0015287997796808 34.0913638843335960 173686.5690354531398043
//              0.0013268597184979 0.4098277826846652 77186.5576645124237984
//              0.0013197716218647 2.7821530204166303 68429.5604983622906730
//              0.0013188910532682 2.6655471745887542 -117845.1594293188245501
//              0.0013187923505480 4.4488933416622478 -203677.0819703953166027
// TOPO, JPL:   0.0013027897288363 352.7189377535082713 996869.4578490457497537 996869.5620547852013260 /   11.0   52.2 -110000.0

  static final double SHUKRA_MIN_TOPO_DIST_ACCEL = -0.00108;
// TOPO, SWI:   -0.0010817151373617
// TOPO, JPL:   -0.0010497207173777 10.8307320066870307 959247.0450016697868705 959247.1561946503352374 /   11.0   52.2 -110000.0

  static final double SHUKRA_MAX_HELIO_DIST_SPEED = 0.0002173;
// HELIO, SWI:   0.0002170449137930 113.7931882800586578 -243721.0094988006749190 / 

  static final double SHUKRA_MIN_HELIO_DIST_SPEED = -0.0002172;
// HELIO, SWI:   -0.0002171265779028 293.5250849778951192 -249449.3790689618326724 / 

  static final double SHUKRA_MAX_HELIO_DIST_ACCEL = 0.000006264;
// HELIO, SWI:   0.0000062615247364 24.2892668796857656 -245124.3527500441705342 -245124.2610462441807613 / 

  static final double SHUKRA_MIN_HELIO_DIST_ACCEL = -0.000005947;
// HELIO, SWI:   -0.0000059448605507 203.6213932657772432 -249506.3271287554816809 -249506.2354249554919079 / 



///////////////////////////////////////////////////////////////
// MANGALA: ///////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double MANGALA_MAX_LON_SPEED = 0.794;
// NOTOPO, SWI: 0.7924011034802300
//              0.7923999077785300 11.1435914022693989 3637945.7966404478065670
// NOTOPO, JPL: 0.7916988325596889 6.9167119757790374 2801868.8330281274393201 / 

  static final double MANGALA_MIN_LON_SPEED = -0.404;
// NOTOPO, SWI: -0.4035876030446059 181.1075756175283971 -133381.5106629475776572
// NOTOPO, JPL: -0.4030886924891714 178.7517637163851987 765886.5689680018695071 / 

  static final double MANGALA_MAX_LON_ACCEL = 0.0146;
// NOTOPO, SWI: 0.0144201733055495 138.9408217217996935 3674267.4152489653788507 3674267.7395811337046325
// NOTOPO, JPL: 0.0143482099752648 140.2555642042337070 2775001.6652576737105846 2775002.1903921556659043 / 

  static final double MANGALA_MIN_LON_ACCEL = -0.0152;
// NOTOPO, SWI: -0.0151951611243569 139.3789158418101692 2995705.9497467507608235 2995706.3421629047952592
// NOTOPO, JPL: -0.0151820773782104 139.4438975414638549 2701669.7693393989466131 2701670.3199220290407538 / 

  static final double MANGALA_MAX_TOPO_LON_SPEED = 0.81;
// TOPO, SWI:   0.7978851329427278 10.6081894629459370 3637948.2466299664229155 / -73.1792811466 0.3048884826 -2277.6546379790
// TOPO, JPL:   0.7960217543847412 8.4886529063329021 2375236.6571041969582438 /  -55.8  -29.9 -148873.0

  static final double MANGALA_MIN_TOPO_LON_SPEED = -0.425;
// TOPO, SWI:   -0.4251354442483760 178.7310683058734924 910171.7125146181788296 164.9964835365 -3.6069752029 -1770.8396081481
// TOPO, JPL:   -0.4217527221879939 177.4278470210484215 1624600.6255326191894710 / -172.9    6.1 -11919880.7

  static final double MANGALA_MAX_TOPO_LON_ACCEL = 0.16;
// TOPO, SWI:   0.1594830996296811
// TOPO, JPL:   0.1581185147318458 164.8598694285395254 1587935.7841508002020419 1587935.8985285095404834 /   11.0   52.2 -110000.0

  static final double MANGALA_MIN_TOPO_LON_ACCEL = -0.159;
// TOPO, SWI:   -0.1600745968788799
// TOPO, JPL:   -0.1575627566541741 195.6087128096599201 1011543.7506678751669824 1011543.8712390246801078 /   11.0   52.2 -110000.0

  static final double MANGALA_MAX_HELIO_LON_SPEED = 0.6390;
// HELIO, SWI:   0.6389722961369398 38.5888496237665564 3692221.7685342952609062 / 

  static final double MANGALA_MIN_HELIO_LON_SPEED = 0.4337;
// HELIO, SWI:   0.4338204904498673 219.8718624697718553 3692568.0420831665396690 / 

  static final double MANGALA_MAX_HELIO_LON_ACCEL = 0.0010154;
// HELIO, SWI:   0.0010153217397727 321.7780423771454252 3644009.9629351710900664 3644010.0546389711089432 / 

  static final double MANGALA_MIN_HELIO_LON_ACCEL = -0.0010040;
// HELIO, SWI:   -0.0010038374801163 111.8068234376216026 3623648.4179941797628999 3623648.5096979797817767 / 


  static final double MANGALA_MAX_LAT_SPEED = 0.084;
// NOTOPO, SWI: 0.0838791710904641
// NOTOPO, JPL: 0.0826741249250192 149.2256722049210964 2775802.2559480732306838 / 

  static final double MANGALA_MIN_LAT_SPEED = -0.0839;
// NOTOPO, SWI: -0.0839678022834778
// NOTOPO, JPL: -0.0835340883879389 212.7210446501029537 642620.7923325931187719 / 

  static final double MANGALA_MAX_LAT_ACCEL = 0.0035;
// TOPO, SWI:   0.0150844307385327
// NOTOPO, JPL: 0.0034312254609595 179.0833441786972458 1864807.3567141420207918 1864807.9489276432432234 / 

  static final double MANGALA_MIN_LAT_ACCEL = -0.00209;
// NOTOPO, JL:  -0.0020809749032211 181.0128907777466907 641061.4951947031076998 641062.4194994299905375 / 

  static final double MANGALA_MAX_TOPO_LAT_SPEED = 0.095;
// TOPO, SWI:   0.0946720976575474
// TOPO, JPL:   0.0934035953265691 141.4811497310967923 2452914.9284494239836931 / -167.4   -2.0 -138827.1

  static final double MANGALA_MIN_TOPO_LAT_SPEED = -0.099;
// TOPO, SWI:   -0.0987979399086970
// TOPO, JPL:   -0.0983824901801166 215.6813984319298356 671476.8615393596701324 /  148.2   -4.8 -163423.1

  static final double MANGALA_MAX_TOPO_LAT_ACCEL = 0.0805;
// TOPO, SWI:   0.0815886852824428
// TOPO, JPL:   0.0790804782253402 180.4389968986509984 1968536.3902757749892771 1968536.4967305311001837 /   11.0   52.2 -110000.0

  static final double MANGALA_MIN_TOPO_LAT_ACCEL = -0.074;
// TOPO, SWI:   -0.0743551255625984 182.0980439241689623 1467039.2266495153307915
//              -0.0740879859432727 176.2125902326463347 1247878.3800865092780441
//              -0.0737518990689433 173.0047672387801754 1011562.5490168932592496
//              -0.0737143543505757 180.5839243595314088 965544.5294687077403069
// TOPO, JPL:   -0.0724526307717358 175.4123787295656030 1069278.4057305362075567 1069278.5368578748311847 /   11.0   52.2 -110000.0

  static final double MANGALA_MAX_HELIO_LAT_SPEED = 0.01994;
// HELIO, SWI:   0.0199363918750256 70.7836160760459450 3688837.9900173987261951 / 

  static final double MANGALA_MIN_HELIO_LAT_SPEED = -0.02097;
// HELIO, SWI:   -0.0209531861088103 175.4596345000853717 -247053.7089980290038511 / 

  static final double MANGALA_MAX_HELIO_LAT_ACCEL = 0.00023610;
// HELIO, SWI:   0.0002360833916200 297.3654306829167808 1563918.6192823941819370 1563918.7109861942008138 / 

  static final double MANGALA_MIN_HELIO_LAT_ACCEL = -0.0001698;
// HELIO, SWI:   -0.0001696921085373 111.0114103765569524 -238922.2413491358456668 -238922.1496453358558938 / 


  static final double MANGALA_MAX_DIST_SPEED = 0.0101;
// NOTOPO, SWI: 0.0100696780219029
// NOTOPO, JPL: 0.0100643683479973 269.1737141447110844 1168446.4021066790446639 / 

  static final double MANGALA_MIN_DIST_SPEED = -0.01028;
// NOTOPO, SWI: -0.0102784274030799
// NOTOPO, JPL: -0.0102749478825399 89.3012469145790249 2768620.8741885176859796 / 

  static final double MANGALA_MAX_DIST_ACCEL = 0.000234;
// NOTOPO, JPL: 0.0002316456520849 179.5008629993195086 627831.8675719088641927 627832.2966464573983103 / 

  static final double MANGALA_MIN_DIST_ACCEL = -0.0000695;
// NOTOPO, JPL: -0.0000691512115045 11.0863619757200809 2717708.7934102085418999 2717709.6335888337343931 / 

  static final double MANGALA_MAX_TOPO_DIST_SPEED = 0.0103;
// TOPO, SWI:   0.0102954964561265
// TOPO, JPL:   0.0102750877650412 268.7006393613465889 1006998.9210776721592993 /   73.4  -18.6 -558591.5

  static final double MANGALA_MIN_TOPO_DIST_SPEED = -0.0105;
// TOPO, SWI:   -0.0104995980338152
// TOPO, JPL:   -0.0104858185492511 87.8865272461379448 1857654.5719206309877336 /   -6.4  -17.5 -118807.5

  static final double MANGALA_MAX_TOPO_DIST_ACCEL = 0.00123;
// TOPO, SWI:   0.0131818153230207 284.9959789257900411 2332152.0145044443197548 ???
//              0.0012887713662012 66.6736237261732754 -199097.2332733191724401
//              0.0012319051338675 186.5730858460568982 -219956.4541361356095877
//              0.0012209446543432 191.8766370799966694 -237121.3987246403994504
// TOPO, JPL:   0.0012161423072440 177.4947770238408111 2709471.4839383927173913 2709471.5907205441035330 /   11.0   52.2 -110000.0

  static final double MANGALA_MIN_TOPO_DIST_ACCEL = -0.0011;
// TOPO, SWI:   -0.0011484037922081
// TOPO, JPL:   -0.0010620822452651 6.5326082583946175 2458748.4108516005799174 2458748.5186086511239409 /   11.0   52.2 -110000.0

  static final double MANGALA_MAX_HELIO_DIST_SPEED = 0.0013516;
// HELIO, SWI:   0.0013512901958924 128.7421869245407891 3692372.7129891263321042 / 

  static final double MANGALA_MIN_HELIO_DIST_SPEED = -0.0013516;
// HELIO, SWI:   -0.0013511444563732 308.7302742910854363 3692071.3743022643029690 / 

  static final double MANGALA_MAX_HELIO_DIST_ACCEL = 0.000015148;
// HELIO, SWI:   0.0000151459885774 38.5783203257149481 3688100.0495386468246579 3688100.1412424468435347 / 

  static final double MANGALA_MIN_HELIO_DIST_ACCEL = -0.000010287;
// HELIO, SWI:   -0.0000102844622590 204.9344476307170453 3488519.7507371641695499 3488519.8424409641884267 / 



///////////////////////////////////////////////////////////////
// GURU: //////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double GURU_MAX_LON_SPEED = 0.244;
// NOTOPO, SWI: 0.2440421007508337
//              0.2440259758282694 2.4045041461050332 3673053.9168258565478027
// NOTOPO, JPL: 0.2428335951258063 3.5461868267948500 2789118.9510614373721182 / 

  static final double GURU_MIN_LON_SPEED = -0.1369;
// NOTOPO, SWI: -0.1368829493523590
//              -0.1368820455359945 180.5832645904395974 -126113.4864928905444685
// NOTOPO, JPL: -0.1368635903173349 180.2193463784294352 692797.0914358530426398 / 

  static final double GURU_MAX_LON_ACCEL = 0.00354;
// NOTOPO, SWI: 0.0035312724306166 118.2817491102233305 943749.3540715674171224 943749.9294602031586692
// NOTOPO, JPL: 0.0035309507851668 118.5755994645865883 1502585.2467730506323278 1502585.3801854311022907 / 

  static final double GURU_MIN_LON_ACCEL = -0.00341;
// NOTOPO, SWI: -0.0034097053893441 119.9554019791229251 1983930.3803575735073537 1983931.0591147949453443
// NOTOPO, JPL: -0.0034095472991935 120.0438930832596185 1983930.2414474771358073 1983931.1471178678330034 / 

  static final double GURU_MAX_TOPO_LON_SPEED = 0.247;
// TOPO, SWI:   0.2460278822288060 2.1064740906293338 3322029.5618714890442789 / 96.3836141934 -9.9928840953 1721.5766618645
// TOPO, JPL:   0.2442154523229398 3.3737604511064614 2754425.1945888693444431 /  122.8   25.8 -897076.0

  static final double GURU_MIN_TOPO_LON_SPEED = -0.1405;
// TOPO, SWI:   -0.1403693939861765 179.9408142246988405 25463.4141226465580985 -91.5628546501 10.5366468238 -9284.9218899931
// TOPO, JPL:   -0.1396304331965231 180.0090680002970203 2248445.7305190265178680 /  -84.7    6.2 -317954.6

  static final double GURU_MAX_TOPO_LON_ACCEL = 0.0167;
// TOPO, SWI:   0.0166640244576276 233.6485834274197657 3647377.9916880093514919 3647378.0923984586261213 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   0.0166038808349592 139.5821134077839929 627013.4600588139146566 627013.5647328060586005 /   11.0   52.2 -110000.0

  static final double GURU_MIN_TOPO_LON_ACCEL = -0.0167;
// TOPO, SWI:   -0.2986882995560264
//              -0.0167151480688178 133.2242486904405609 3595432.6970099876634777 3595432.8167069852352142 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   -0.0164094314567562 143.2682748867993894 2768159.3273530141450465 2768159.4401315618306398 /   11.0   52.2 -110000.0

  static final double GURU_MAX_HELIO_LON_SPEED = 0.09287;
// HELIO, SWI:   0.0928627009268541 66.9911679618450080 3677495.4221044639125466 / 

  static final double GURU_MIN_HELIO_LON_SPEED = 0.074689;
// HELIO, SWI:   0.0746943113920974 250.5956808555321800 3675371.6537998267449439 / 

  static final double GURU_MAX_HELIO_LON_ACCEL = 0.000036229;
// HELIO, SWI:   0.0000362251116003 328.8083053523092758 3650403.1850572871044278 3650403.2767610871233046 / 

  static final double GURU_MIN_HELIO_LON_ACCEL = -0.000036650;
// HELIO, SWI:   -0.0000366474238688 109.3278113170298411 3093308.6523934118449688 3093308.7440972118638456 / 


  static final double GURU_MAX_LAT_SPEED = 0.0063;
// NOTOPO, SWI: 0.0079894240821371 0.0601560551081519 78316.4185760746622691
//              0.0066476398233534 110.1376464895660945 -221383.3737826585129369
//              0.0066473160629214 110.6666841914722283 -221383.9030312743270770
//              0.0066457814709434 111.5006250978595972 -221384.7351701248844620
// NOTOPO, JPL: 0.0061908432229009 112.4269545307679437 649380.0055553948041052 / 

  static final double GURU_MIN_LAT_SPEED = -0.0062;
// NOTOPO, SWI: -0.0082475742115319 0.0446656653053310 2372287.4256182522512972
//              -0.0081679544726280 0.0566917774685862 1999729.6744490496348590
//              -0.0078159575125308 0.0314825326859705 1284929.4563959073275328
//              -0.0071024444607525 0.0636199730191720 1038020.3583645855542272
//              -0.0066793857937898 0.0852753287601900 -205301.8630813817726448
//              -0.0066175032562629 246.6068273788177123 -221909.5236041555763222
//              -0.0066170859380376 247.3438921056017250 -221910.2942210272594821
//              -0.0066158312691210 248.0264418159172806 -221911.0099419929028954
//              -0.0066137971865199 248.7655093363266019 -221911.7872256411646958
// NOTOPO, JPL: -0.0061251895775237 248.6116143133203593 644464.3267154396744445 / 

  static final double GURU_MAX_LAT_ACCEL = 0.000164;
// NOTOPO, JPL: 0.0001631012173349 172.8998017132045675 688014.7479439852759242 688015.2237591258017346 / 

  static final double GURU_MIN_LAT_ACCEL = -0.000144;
// NOTOPO, JPL: -0.0001428277204568 180.4011236746345617 660078.9308878154261038 660079.5882852224167436 / 

  static final double GURU_MAX_TOPO_LAT_SPEED = 0.0074;
// TOPO, SWI:   0.0080521928636294 0.0566192805632610 918765.6333176256157458
//              0.0074940630316397 114.0953024122408124 -247314.5005948057223577
//              0.0074740423582702 117.1124623989528573 -247317.4677769242262002
//              0.0073365824436177 124.3399166578952872 -247324.4473215647449251
// TOPO, JPL:   0.0072166314932738 109.0304781092945063 701237.9247726293979213 /  -42.0    9.3 -11969401.6

  static final double GURU_MIN_TOPO_LAT_SPEED = -0.0074;
// TOPO, SWI:   -0.0080876975949050 0.0340482972944187 877668.4739827105076984
//              -0.0079257941735561 0.0548291341236222 353535.4688255244982429
//              -0.0074868031086838 244.7003594482700066 -195980.6305575540463906
//              -0.0074791206548048 239.8774896996048938 -226290.6132767098606564
//              -0.0074452255799583 252.2918423249091120 -226303.5950242244580295
//              -0.0074393971860641 253.1862647845265144 -226304.5564436963759363
// TOPO, JPL:   -0.0072441693905558 249.4712924749894398 648851.6447883903747424 /  178.5    4.1 -175983.9

  static final double GURU_MAX_TOPO_LAT_ACCEL = 0.0064;
// TOPO, SWI:   0.0064370403082856 160.9893348765497763 -243369.5462068344349973
// TOPO, JPL:   0.0062836812390572 173.4311152344720313 804886.0647488388931379 804886.1658009625971317 /   11.0   52.2 -110000.0

  static final double GURU_MIN_TOPO_LAT_ACCEL = -0.00601;
// TOPO, SWI:   -0.1037547091237699 0.0125813165357158 505110.7392954186070710
//              -0.0378655962663130 0.1083443186038267 -138278.1849216190457810
//              -0.0360539293255533 0.1266684501299267 -240004.5811667661473621
//              -0.0061777644919788 168.4064816875281565 -243376.0363520069804508
//              -0.0060227498357402 173.1109147544705138 -245394.4910242093901616
//              -0.0058877265072794 206.9527394385040679 -247797.8501246784289833
//              -0.0058695732378666 222.0752014979657929 -247811.8569919402361847
// TOPO, JPL:   -0.0060022250346072 176.9020558316282461 960847.4024146875599399 960847.5054992398945615 /   11.0   52.2 -110000.0

  static final double GURU_MAX_HELIO_LAT_SPEED = 0.0024277;
// HELIO, SWI:   0.0024274075351303 24.1982071435144270 -242259.2509269636939280 / 

  static final double GURU_MIN_HELIO_LAT_SPEED = -0.002620;
// HELIO, SWI:   -0.0026180011024933 209.3152760572297666 -231289.4589645870728418 / 

  static final double GURU_MAX_HELIO_LAT_ACCEL = 0.000013982;
// HELIO, SWI:   0.0000139791156248 290.1337720231981052 -156753.1605556995491497 -156753.0688518995593768 / 

  static final double GURU_MIN_HELIO_LAT_ACCEL = -0.000013189;
// HELIO, SWI:   -0.0000131838416505 100.2099435249254356 -163337.8602101652068086 -163337.7685063652170356 / 


  static final double GURU_MAX_DIST_SPEED = 0.0163;
// NOTOPO, SWI: 0.0162313440373101
// NOTOPO, JPL: 0.0162125062673481 269.9885757091312826 2746737.7407946651801467 / 

  static final double GURU_MIN_DIST_SPEED = -0.0164;
// NOTOPO, SWI: -0.0163119973755655
// NOTOPO, JPL: -0.0162962764487217 89.9528066433123001 2813565.0229882504791021 / 

  static final double GURU_MAX_DIST_ACCEL = 0.000325; // ???
// NOTOPO, SWI: 0.0028131695540130 252.0199342955070279 3389970.8170315762981772
//              0.0022264700183521 78.0262633819467624 2959356.3896456728689373
//              0.0021058202921303 56.3220986050345331 689082.5046896804124117
//              0.0014148556073934 312.1296276860581997 138881.9097125186235644
//              0.0003629278483912 175.2126664382685988 103648.3659716135007329
//              0.0003215421089300 179.8650599366537790 -130102.0682320412161062
//              0.0003215231118657 180.5493323734873172 -130102.6579265795007814
//              0.0003214350810835 180.8083546044778416 -130102.8811461286386475
// NOTOPO, JPL: 0.0003212791490395 179.1139733917144667 749437.0917171647306532 749437.5507154314545915 / 

  static final double GURU_MIN_DIST_ACCEL = -0.000225;
// NOTOPO, SWI: -0.0026706423885953 54.9988325446786490 2244330.1662299656309187
//              -0.0011107400422637 240.5622614243510213 1324971.5582129028625786
//              -0.0010463882202215 46.6627522885998758 -45687.3579329831190989
//              -0.0007706904056781 37.7983780909854090 -80098.6155146874953061
//              -0.0002399030274792 1.4728896000519569 -102383.2875191967032151
//              -0.0002340892813117 37.6730895540927406 -214825.2211170222435612
//              -0.0002202596930024 0.6216123376105145 -236411.7266815737239085
// NOTOPO, JPL: -0.0002200487479365 3.0727983914445929 820633.5672682302538306 820635.0164746360387653 / 

  static final double GURU_MAX_TOPO_DIST_SPEED = 0.0165;
// TOPO, SWI:   0.0164463865294178
// TOPO, JPL:   0.0163933358236029 269.7074039544052084 2798591.6030700867995620 /  -32.5  -27.2 -252818.2

  static final double GURU_MIN_TOPO_DIST_SPEED = -0.0166;
// TOPO, SWI:   -0.0165316055601204
// TOPO, JPL:   -0.0164783521489150 90.7489162720576417 2354449.6322963917627931 /  -52.4   -5.9 -559160.2

  static final double GURU_MAX_TOPO_DIST_ACCEL = 0.00133; // ???
// TOPO, SWI:   0.0207137582627566 173.7974512158892821 3371308.6819511819630861
//              0.0095682916573331 98.6288452876610506 2352478.9396295030601323
//              0.0017434341399401 3.7222567351049491 1672652.3170623441692442
//              0.0013784181224652 262.1285954707602173 385732.5318781036767177
//              0.0013364439220739 175.2229360370665177 220911.8912446679605637
//              0.0013343946830275 188.1894899974843725 -207878.5227978868060745
// TOPO, JPL:   0.0013140810305337 183.5053747524114840 1177835.8770452847238630 1177835.9799993557389826 /   11.0   52.2 -110000.0

  static final double GURU_MIN_TOPO_DIST_ACCEL = -0.00122;
// TOPO, SWI:   -0.0344816332659920 53.5806245234392833 -59632.7241606430397951
//              -0.0012291085316648 11.8839758867454179 -110381.6067325769108720
//              -0.0012237729790972 6.0617096993218524 -218870.4614361103449482
//              -0.0012218538662633 17.5817593377373669 -231605.5168245942331851
//              -0.0012137029216628 18.3605833587742779 -248803.3674780579749495
//              -0.0012040965556822 20.9413774401508306 -249151.5155578464036807
// TOPO, JPL:   -0.0012179154714779 8.0924125333128529 1401019.6981153180822730 1401019.8004333155695349 /   11.0   52.2 -110000.0

  static final double GURU_MAX_HELIO_DIST_SPEED = 0.00040998;
// HELIO, SWI:   0.0004099313964266 159.2065436807666003 3678526.9064470762386918 / 

  static final double GURU_MIN_HELIO_DIST_SPEED = -0.00040970;
// HELIO, SWI:   -0.0004096271887829 339.9366797673709470 3676519.6936722630634904 / 

  static final double GURU_MAX_HELIO_DIST_ACCEL = 0.00000077866;
// HELIO, SWI:   0.0000007786535735 63.4473366088961370 3504225.8605663971975446 3504225.9522701972164214 / 

  static final double GURU_MIN_HELIO_DIST_ACCEL = -0.0000006786;
// HELIO, SWI:   -0.0000006785337605 239.2603627683639331 3679550.5042628869414330 3679550.5959666869603097 / 



///////////////////////////////////////////////////////////////
// SHANI: /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double SHANI_MAX_LON_SPEED = 0.13404;
// NOTOPO, SWI: 0.1340290794104446
//              0.1340109648692031 2.1226092234817315 -163206.2606100863777101
// NOTOPO, JPL: 0.1327805183874537 3.0429635221465219 644396.1415654856245965 / 

  static final double SHANI_MIN_LON_SPEED = -0.084;
// NOTOPO, SWI: -0.0843874858704462
//              -0.0843863197679707 180.0316197536598963 -119529.3726371085940627
// NOTOPO, JPL: -0.0839205001027148 179.7538351952555615 634005.4940949525916949 / 

  static final double SHANI_MAX_LON_ACCEL = 0.00199;
// NOTOPO, SWI: 0.0019860635653615 108.7583081509525584 -238564.3131895941623952 -238563.9070349260582589
// NOTOPO, JPL: 0.0019704643133465 107.7955867333490403 773209.0539155729347840 773209.4716971723828465 / 

  static final double SHANI_MIN_LON_ACCEL = -0.00195;
// NOTOPO, SWI: -0.0019461144643805 250.6294677312978081 -162317.6448787293047644 -162317.4296173398906831
// NOTOPO, JPL: -0.0019411597276414 107.9127693051768802 881969.6117141979048029 881969.9048477461328730 / 

  static final double SHANI_MAX_TOPO_LON_SPEED = 0.134;
// TOPO, SWI:   0.1352241917838550 2.6437337111698298 -120105.1467321325326338 / -135.7469844874 -1.5235966413 -9149.1494438681
// TOPO, JPL:   0.1335384540876906 356.4228793916646509 859531.2081036102026701 /   11.0   52.2 -110000.0

  static final double SHANI_MIN_TOPO_LON_SPEED = -0.0855;
// TOPO, SWI:   -0.0857898683346270
//              -0.0857859482664416 180.4511195292874675 -205733.7354889601992909 57.1340338590 -6.0390360608 2936.3009470154
// TOPO, JPL:   -0.0849641804905260 180.3456957179522249 956896.5353130036965013 / -131.2  -32.9 -486057.8

  static final double SHANI_MAX_TOPO_LON_ACCEL = 0.0086;
// TOPO, SWI:   0.0088537626365099 (Problems up to 0.5749467950953074 observed...)
//              0.0086874752939179 130.3835869430225216 -228378.3960538489336614 -228378.2941615929012187 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   0.0085688265882089 235.0153479090199369 2399366.5584685457870364 2399366.6685493290424347 /   11.0   52.2 -110000.0

  static final double SHANI_MIN_TOPO_LON_ACCEL = -0.00864;
// TOPO, SWI:   -0.0086350102928645 240.9329383039785171 -217516.6292963425803464 -217516.5270764300366864 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   -0.0086289532791422 120.5645061952920400 1850273.4720761652570218 1850273.5765058014076203 /   11.0   52.2 -110000.0

  static final double SHANI_MAX_HELIO_LON_SPEED = 0.03929;
// HELIO, SWI:   0.0392863193240564 317.5875186572542361 -141323.4459846203099005 / 

  static final double SHANI_MIN_HELIO_LON_SPEED = 0.028729;
// HELIO, SWI:   0.0287253130874837 138.1279528643018466 -125169.3630964851909084 / 

  static final double SHANI_MAX_HELIO_LON_ACCEL = 0.000026497;
// HELIO, SWI:   0.0000264905932645 256.8403404043374394 -13884.8760147858520213 -13884.7843109858513344 / 

  static final double SHANI_MIN_HELIO_LON_ACCEL = -0.000026590;
// HELIO, SWI:   -0.0000265885415246 29.3553038569937002 -203927.2459388385759667 -203927.1542350385861937 / 


  static final double SHANI_MAX_LAT_SPEED = 0.0055;
// NOTOPO, SWI: 0.0088659593013574 0.0357855361262125 1216463.8803999235387892
//              0.0081800060242820 0.0636244767979335 -9686.2452881572171464
//              0.0055101641996105 103.1816729109932567 -248384.6794485895079561
//              0.0055092577650856 103.9915755785259250 -248385.4973858597222716
//              0.0055085351164070 104.2998464057047556 -248385.8082728039298672
//              0.0055061985781587 104.9731251070553526 -248386.4864187667553779
// NOTOPO, JPL: 0.0054479762180281 101.5087719957672618 633699.7182570304721594 / 

  static final double SHANI_MIN_LAT_SPEED = -0.0054;
// NOTOPO, SWI: -0.0093448258414916 0.0480108040459299 2405172.1235335594974458
//              -0.0091669774974187 0.0437628531739165 1017947.0968454070389271
//              -0.0082309467247685 0.0735537640593975 -46761.3712922931881621
//              -0.0059085247284603 0.0737067784886278 -186653.2304984880902339
//              -0.0054935401134247 256.1125920323701166 -227737.3836737677629571
//              -0.0054924209794990 256.8583947276435424 -227738.1576579157263041
//              -0.0054893589421577 257.5657401830940216 -227738.8932042158266995
//              -0.0054866869674104 257.9952243323996868 -227739.3405110478342976
//              -0.0054846770087000 258.2735656374735527 -227739.6306852521665860
// NOTOPO, JPL: -0.0052759566378740 255.1213087279579099 632794.2191756315296516 / 

  static final double SHANI_MAX_LAT_ACCEL = 0.000123;
// NOTOPO, JPL: 0.0001228331245459 182.3412334534269803 730035.7467638771049678 730036.3191362058278173 / 

  static final double SHANI_MIN_LAT_ACCEL = -0.000104;
// NOTOPO, JPL: -0.0001036095956202 181.2808113227449383 2541859.8319580527022481 2541860.2949275760911405 / 

  static final double SHANI_MAX_TOPO_LAT_SPEED = 0.006;
// TOPO, JPL:   0.0059829280424917 254.7257709873013880 1203859.3423178326338530 /  120.7    8.1 -268428.1

  static final double SHANI_MIN_TOPO_LAT_SPEED = -0.0059;
// TOPO, SWI:   -0.0092855309799147
// TOPO, JPL:   -0.0057956247321725 253.1921945803524636 632796.2324350061826408 / -170.8  -37.9 -11959137.5

  static final double SHANI_MAX_TOPO_LAT_ACCEL = 0.0032;
// TOPO, SWI:   0.1291812952134777 0.0193139412162679 652331.3204417930683121
//              0.1103411440697414 48.3201736850982115 337716.2472735045594163 ???
//              0.0406681081950653 0.1330846070859195 140796.5907405762118287
//              0.0248291370689390 0.1817467500329428 -25209.8627429512453091
//              0.0192489692315691 0.3364410508429501 -208203.9115095509332605
//              0.0154213763216727 0.0787234050482084 -229755.7019914422999136
//              0.0106410980662519 0.0625985933783042 -246369.5177199522149749
//              0.0033936272027591 196.6164942212680273 -249231.4910817339550704
//              0.0033477521784859 184.6683619648643742 -249600.4166902992583346
//              0.0032692627409362 158.9229430463847450 -249956.4608254602062516
//              0.0032065821914758 188.1027910938801142 -249983.3395146315742750
// TOPO, JPL:   0.0031905232971144 163.4044039250840399 665019.1348916188580915 665019.2585872148629278 /   11.0   52.2 -110000.0

  static final double SHANI_MIN_TOPO_LAT_ACCEL = -0.00301;
// TOPO, SWI:   -0.1943805609996636 0.0254947304431425 3093302.9852960119023919
//              -0.1535901747923263 0.0044428449655527 399030.9463442072155885
//              -0.0967942061450560 0.0375247351963210 33416.6073811288442812
//              -0.0244403526037960 0.1095505791075055 -63374.4509422093688045
//              -0.0222436811141467 0.0710847034876565 -208204.2186171786452178
//              -0.0105777641070009 0.4226321633859698 -229755.1313364572997671
//              -0.0076972631775804 0.8873846478899594 -246368.5475377420661971
//              -0.0031570907055125 133.9147902428757675 -249174.1276894060720224
//              -0.0031355393451151 160.1263956863335522 -249577.9961592703766655
//              -0.0031248092521445 146.5321463786839047 -249945.0155428809521254
//              -0.0030320551971996 215.1038187030328004 -250008.7760764319973532
// TOPO, JPL:   -0.0029976150401222 175.5931959224585910 643456.6917577013373375 643456.7943882376421243 /   11.0   52.2 -110000.0

  static final double SHANI_MAX_HELIO_LAT_SPEED = 0.0016789;
// TOPO, SWI:   0.0016787509915327 86.8382273056848675 1603490.4596589398570359 / 

  static final double SHANI_MIN_HELIO_LAT_SPEED = -0.001653;
// TOPO, SWI:   -0.0016511099048983 237.1846542050762139 -218721.8199911886476912 / 

  static final double SHANI_MAX_HELIO_LAT_ACCEL = 0.00001127;
// TOPO, SWI:   0.0000112505215212 280.4320180801719857 40481.4467037630238337 40481.5384075630208827 / 

  static final double SHANI_MIN_HELIO_LAT_ACCEL = -0.000011128;
// TOPO, SWI:   -0.0000111203157507 94.9581807129803082 13091.7225350638673262 13091.8142388638680131 / 



  static final double SHANI_MAX_DIST_SPEED = 0.0168;
// NOTOPO, SWI: 0.0167980101137831
// NOTOPO, JPL: 0.0167470550342229 270.1922148977790812 775126.5858114481670782 / 

  static final double SHANI_MIN_DIST_SPEED = -0.0169;
// NOTOPO, SWI: -0.0168541607915517
// NOTOPO, JPL: -0.0168033574476849 90.2359820156960382 887610.1793931820429862 / 

  static final double SHANI_MAX_DIST_ACCEL = 0.000322;
// NOTOPO, JPL: 0.0003217576664089 180.6124093899778131 924759.4654094257857651 924760.1071097153471783 / 

  static final double SHANI_MIN_DIST_ACCEL = -0.00027;
// NOTOPO, JPL: -0.0002649687841804 3.1537517381507030 940823.5889109726995230 940828.3583899141522124 / 

  static final double SHANI_MAX_TOPO_DIST_SPEED = 0.017;
// TOPO, SWI:   0.0170041976808882
// TOPO, JPL:   0.0168998454699344 272.9172717291329491 784956.1169768150430173 /   83.1   20.2 -559218.8

  static final double SHANI_MIN_TOPO_DIST_SPEED = -0.01702;
// TOPO, SWI:   -0.0170839780153652
// TOPO, JPL:   -0.0170159989383753 90.6219157816285019 929959.2261485378257930 /  -34.6   16.0 -275006.2

  static final double SHANI_MAX_TOPO_DIST_ACCEL = 0.00133;
// TOPO, JPL:   0.0013147485636233 187.2595322712119810 773528.1895404278766364 773528.3051549824886024 /   11.0   52.2 -110000.0

  static final double SHANI_MIN_TOPO_DIST_ACCEL = -0.00127;
// TOPO, JPL:   -0.0012570696593106 5.8823054507581105 1155577.9214635647367686 1155578.0259339711628854 /   11.0   52.2 -110000.0

  static final double SHANI_MAX_HELIO_DIST_SPEED = 0.00043914;
// HELIO, SWI:   0.0004391103911836 46.9611293867110717 -138912.4613790891889948 / 

  static final double SHANI_MIN_HELIO_DIST_SPEED = -0.00044091;
// HELIO, SWI:   -0.0004408927261835 227.7000305924591714 -122231.1733443466218887 / 

  static final double SHANI_MAX_HELIO_DIST_ACCEL = 0.00000043248;
// HELIO, SWI:   0.0000004324331078 308.5743196638426298 -109287.1819737361656735 -109287.0902699361613486 / 

  static final double SHANI_MIN_HELIO_DIST_ACCEL = -0.00000041039;
// HELIO, SWI:   -0.0000004103761552 171.0750927467988731 681864.8851704276166856 681864.9768742276355624 / 



///////////////////////////////////////////////////////////////
// URANUS: ////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double URANUS_MAX_LON_SPEED = 0.067;
// NOTOPO, SWI: 0.0672787417212825 2.2044883144310603 -198847.3157617567048874
// NOTOPO, JPL: 0.0635219827469326 3.0865801839384801 1120454.5702892334666103 / 

  static final double URANUS_MIN_LON_SPEED = -0.044;
// NOTOPO, SWI: -0.0439753677256215
//              -0.0439749353957933 179.1371858363940532 2805890.5954912416636944
// NOTOPO, JPL: -0.0439737691898081 179.7845571918695100 2805891.2095267488621175 / 

  static final double URANUS_MAX_LON_ACCEL = 0.000929;
// NOTOPO, SWI: 0.0009287961354995 96.5197421388259897 3663572.4564131293445826 3663573.4440292418003082
// NOTOPO, JPL: 0.0009282638132935 97.8842174477335902 2529097.6063587637618184 2529098.3723707860335708 / 

  static final double URANUS_MIN_LON_ACCEL = -0.000975;
// NOTOPO, SWI: -0.0009749151187470 99.5153225338921601 74425.5413598613231443 74426.1704895895527443
// NOTOPO, JPL: -0.0009743654979471 101.0515095115334816 2501959.5002480042167008 2501960.0762184909544885 / 

  static final double URANUS_MAX_TOPO_LON_SPEED = 0.067;
// TOPO, SWI:   0.0678142990549242
//              0.0659933143859741 2.6624668048619782 -229528.4862648595299106 / 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   0.0639666873114370 3.7716406512730885 1181818.1529458123259246 /  -36.6  -13.9 -1936737.7

  static final double URANUS_MIN_TOPO_LON_SPEED = -0.045;
// TOPO, SWI:   -0.0446931660419553 181.3720736420628157 995316.5729154800064862 -148.1483065444 23.8884500241 -8408.4451827214
// TOPO, JPL:   -0.0445080603496004 177.0986226535454193 2558587.0008950615301728 / -146.4    7.0 -302922.1

  static final double URANUS_MAX_TOPO_LON_ACCEL = 0.00408;
// TOPO, SWI:   0.0040746860036361 250.1776503311332363 995014.1325893194880337 995014.2447810187004507 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   0.0040768658697398 258.9330392610905847 688949.3911929061869159 688949.4914812404895201 /   11.0   52.2 -110000.0

  static final double URANUS_MIN_TOPO_LON_ACCEL = -0.00414;
// TOPO, SWI:   -0.0041389274636002 108.3810328551985265 -229420.5110600728949066 -229420.4092381796508562 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   -0.0041032458702222 111.1018605931466396 1149396.9018011584412307 1149397.0059658905956894 /   11.0   52.2 -110000.0

  static final double URANUS_MAX_HELIO_LON_SPEED = 0.013090;
// HELIO, SWI:   0.0130882638262029 111.5468703607783283 1088462.0190283237025142 / 

  static final double URANUS_MIN_HELIO_LON_SPEED = 0.010609;
// HELIO, SWI:   0.0106057318592638 247.7111524234007902 -246053.6790591405297164 / 

  static final double URANUS_MAX_HELIO_LON_ACCEL = 0.000023908;
// HELIO, SWI:   0.0000239057128440 55.1741574780599464 2338284.2142169936560094 2338284.3059207936748862 / 

  static final double URANUS_MIN_HELIO_LON_ACCEL = -0.000024088;
// HELIO, SWI:   -0.0000240835966127 268.6367915745514097 2936605.7491439552977681 2936605.8408477553166449 / 



  static final double URANUS_MAX_LAT_SPEED = 0.00082;
// NOTOPO, JPL: 0.0008167139359186 101.7249222392620567 630392.2795268078334630 / 

  static final double URANUS_MIN_LAT_SPEED = -0.00079;
// NOTOPO, JPL: -0.0007872844416086 94.5979876900013466 632406.4064464361872524 / 

  static final double URANUS_MAX_LAT_ACCEL = 0.000073;
// NOTOPO, JPL: 0.0000725796777657 3.0532664846880948 2473394.5464777238667011 2473397.1248878035694361 / 

  static final double URANUS_MIN_LAT_ACCEL = -0.000078;
// NOTOPO, JPL: -0.0000770026994627 3.0639491173097326 2603143.1314133340492845 2603145.6577144251205027 / 

  static final double URANUS_MAX_TOPO_LAT_SPEED = 0.0011;
// TOPO, JPL:   0.0010938727239962 86.5558131871995897 967133.4299628505250439 / -119.3  -19.8 -139450.6

  static final double URANUS_MIN_TOPO_LAT_SPEED = -0.0011;
// TOPO, JPL:   -0.0010622759299074 96.7133449758128023 2255928.0951205361634493 /  111.7   -5.9 -34208.6

  static final double URANUS_MAX_TOPO_LAT_ACCEL = 0.0018;
// TOPO, JPL:   0.0017903892764677 149.1340385089452809 2389696.5752421738579869 2389696.6956723732873797 /  -32.4  -63.4 -1536076.6

  static final double URANUS_MIN_TOPO_LAT_ACCEL = -0.0014;
// TOPO, JPL:   -0.0013941980551326 203.0822592660931605 813099.1251212942879647 813099.2264039237052202 /   11.0   52.2 -110000.0

  static final double URANUS_MAX_HELIO_LAT_SPEED = 0.00022338;
// HELIO, JPL:   0.0002233250140170 41.8609649530837373 -232778.2701574210368562 / 

  static final double URANUS_MIN_HELIO_LAT_SPEED = -0.00020480;
// HELIO, JPL:   -0.0002047722620604 266.4268762187493280 3670764.7299982784315944 / 

  static final double URANUS_MAX_HELIO_LAT_ACCEL = 0.0000105550;
// HELIO, JPL:   0.0000105547883555 264.3991595674906421 113.7090552419799820 113.8007590419799868 / 

  static final double URANUS_MIN_HELIO_LAT_ACCEL = -0.000010525;
// HELIO, JPL:   -0.0000105121516815 261.6553900943002873 183379.9934958140074741 183380.0851996139972471 / 



  static final double URANUS_MAX_DIST_SPEED = 0.0174;
// NOTOPO, SWI: 0.0173920870984149
// NOTOPO, JPL: 0.0173585770210396 90.0711143387830475 703751.9874883674783632 / 

  static final double URANUS_MIN_DIST_SPEED = -0.0174;
// NOTOPO, SWI: -0.0173768671135560
// NOTOPO, JPL: -0.0173396482859767 90.1712916619785716 625941.9552030125632882 / 

  static final double URANUS_MAX_DIST_ACCEL = 0.00032;
// NOTOPO, SWI: 0.0124048986737664 20.5447553654863668 697587.8714966527186334
//              0.0005308301000862 194.0508279385882133 89653.0467164388392121
//              0.0004054523102576 231.6225436385040837 -237907.2030542625288945
//              0.0003186821836528 178.6186060500050701 -238595.9672204693779349
//              0.0003184016477014 178.6329745040906971 -238595.9806884480349254
//              0.0003183838157893 179.5486894765174952 -238596.8390383592632134
// NOTOPO, JPL: 0.0003182930717874 180.4026778810304563 898832.5701296664774418 898833.3199369597714394 / 

  static final double URANUS_MIN_DIST_ACCEL = -0.00029;
// NOTOPO, SWI: -0.0070443778023334 56.5696520951671431 1915268.8080441316124052
//              -0.0024268224701898 222.2131202933724694 1622588.7918466471601278
//              -0.0017978805103116 112.0036669852078717 1034069.5693735613022000
//              -0.0017711586866005 299.6443816880482132 316745.1417552463826723
//              -0.0009565967124733 34.2481328372568896 -97158.9052647117496235
//              -0.0002965673693959 3.1728844936351379 -126771.9740064809302567
//              -0.0002953008853553 16.8151157502424269 -220272.7407736064051278
//              -0.0002870073111414 2.3807250107649054 -223242.7754700276127551
//              -0.0002869421133855 1.4524556291287922 -223243.7389360640954692
//              -0.0002868014122837 1.1682960365388055 -223244.0338751582312398
//              -0.0002867361242725 3.7817533448034055 -223980.3368454804876819
//              -0.0002865876339975 2.4346127875054151 -223981.7355972216755617
// NOTOPO, JPL: -0.0002869171845722 3.2030561927724648 760035.8014352507889271 760040.9284781528403983 / 

  static final double URANUS_MAX_TOPO_DIST_SPEED = 0.0177;
// TOPO, SWI:   0.0176107889477238
// TOPO, JPL:   0.0175545304775976 92.9313722310350556 1440106.4267600025050342 /  168.4   10.7 -96661.6

  static final double URANUS_MIN_TOPO_DIST_SPEED = -0.0176;
// TOPO, SWI:   -0.0175993482429765
// TOPO, JPL:   -0.0175275406010507 89.7400205375481050 964177.0357202672166750 /   40.8   16.0 -877247.0

  static final double URANUS_MAX_TOPO_DIST_ACCEL = 0.0014;
// TOPO, SWI:   0.0189433989824949 174.5079152323185099 657074.3099226328777149
//              0.0183572432261317 224.5189864726799556 63373.2618242262324202
//              0.0013319739502499 182.7145275240009425 -174644.4776922487071715
//              0.0013240294434584 168.9088235694555067 -174657.4400828294456005
//              0.0013224702513523 167.7986954449400230 -175744.5029267666395754
//              0.0013215195981625 183.3128958273755984 -205701.3786467498575803
// TOPO, JPL:   0.0013896236227717 149.1340385089452809 2389696.5752421738579869 2389696.6956723732873797 /  -32.4  -63.4 -1536076.6

  static final double URANUS_MIN_TOPO_DIST_ACCEL = -0.0013;
// TOPO, SWI:   -0.0074983375520822 237.2702478815059806 2190097.4634127663448453
//              -0.0036695677976724 95.1997580518125233 318393.4452091892017052
//              -0.0015032462816689 29.4131290187358729 -153420.1933402899012435
//              -0.0012987197092415 8.8866741555319493 -159656.5122229879780207
//              -0.0012951371415311 5.1144519034210418 -161148.4825953901745379
//              -0.0012921027532530 10.9717383066954142 -222148.3436549269245006
//              -0.0012787761964680 6.4137141371829784 -223621.4039706184703391
// TOPO, JPL:   -0.0012774206853281 3.0570588538432162 1278670.8627330390736461 1278670.9655325952917337 /   11.0   52.2 -110000.0

  static final double URANUS_MAX_HELIO_DIST_SPEED = 0.00020103;
// HELIO, SWI:   0.0002010212034231 153.3372547826185439 -223983.7840346018201672 / 

  static final double URANUS_MIN_HELIO_DIST_SPEED = -0.00020132;
// HELIO, SWI:   -0.0002013124794718 337.3898947707736511 -146220.1537926742166746 / 

  static final double URANUS_MAX_HELIO_DIST_ACCEL = 0.00000028679;
// HELIO, SWI:   0.0000002867524483 182.7399978283868620 3664209.6506691290996969 3664209.7423729291185737 / 

  static final double URANUS_MIN_HELIO_DIST_ACCEL = -0.000000229;
// HELIO, SWI:   -0.0000002281013543 284.1433658391011363 552562.9856628114357591 552563.0773666114546359 / 



///////////////////////////////////////////////////////////////
// NEPTUNE: ///////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double NEPTUNE_MAX_LON_SPEED = 0.040;
// NOTOPO, SWI: 0.0435201332499242
//              0.0396972276200028 2.0827344696075443 2575780.0351443360559642
// NOTOPO, JPL: 0.0380456461242105 3.1532708267034764 2514772.0896095521748066 / 

  static final double NEPTUNE_MIN_LON_SPEED = -0.0286;
// NOTOPO, SWI: -0.0285951074753113 179.8185040704009623 -114773.5779159839439671
// NOTOPO, JPL: -0.0285175042960974 180.4726995259502189 789980.0941408453509212 / 

  static final double NEPTUNE_MAX_LON_ACCEL = 0.000612;
// NOTOPO, SWI: 0.0006117892571967 95.0693851270330867 1141011.6886422061361372 1141011.9912163538392633
// NOTOPO, JPL: 0.0006117853683019 94.6052391940140183 659604.8761492961784825 659605.1621642899699509 / 

  static final double NEPTUNE_MIN_LON_ACCEL = -0.000606;
// NOTOPO, SWI: -0.0006059351401622 95.1618440250847897 196771.1343181393167470 196771.7955272420076653
// NOTOPO, JPL: -0.0006003368094838 98.0787203190911896 917049.5164440356893465 917049.9205574790248647 / 

  static final double NEPTUNE_MAX_TOPO_LON_SPEED = 0.043; // ???
// TOPO, SWI:   0.0422970690081757 2.2898781842913536 2453407.6579371863044798 / 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   0.0383563887565795 3.0390931791095852 826906.0045657418668270 /  135.2    5.9 -547814.0

  static final double NEPTUNE_MIN_TOPO_LON_SPEED = -0.0295;
// TOPO, SWI:   -0.0290291625574319 180.5744992676552840 426167.0060721903573722
//              -0.0290038106992851 178.5349119796019011 188768.7348955178749748 112.9643788335 -12.4859860679 4158.5890999517
// TOPO, JPL:   -0.0288775621192141 177.7015335690367692 1088009.2940130003262311 /  -44.5    2.8 -84124.2

  static final double NEPTUNE_MAX_TOPO_LON_ACCEL = 0.00253;
// TOPO, SWI:   0.0025292120034634 (SY problem up to 0.2261463302930795 observed)
//              0.0042628483667480 122.0246905452054591 3521196.7267022081650794 3493290.0288146338425577 -133.4574916488 45.5312312476 -3817.1061038599
//              0.0025187380665741 260.4326793894730372 3493289.9254662604071200 55089.2956650374981109 11.0000000000 52.2400000000 -110000.0000000000
//              0.0025184397438746 93.8376591582873800 55089.1874535102106165 -125715.4170647663704585 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   0.0025131255216818 95.6708957219361480 892959.2571875500725582 892959.3594027562066913 /   11.0   52.2 -110000.0

  static final double NEPTUNE_MIN_TOPO_LON_ACCEL = -0.00252;
// TOPO, SWI:   -0.0025161885478298 (SY problem down to -0.3324043321743462 observed)
//              -0.0025049885835764 97.7823583964682399 2414925.5690259789116681 2414925.6727004703134298 11.0000000000 52.2400000000 -110000.0000000000
// TOPO, JPL:   -0.0025029416562368 100.6905068192704391 1577057.7301410164218396 1577057.8535416696686298 /   11.0   52.2 -110000.0

  static final double NEPTUNE_MAX_HELIO_LON_SPEED = 0.006223;
// HELIO, SWI:   0.0062210422773312 70.1380457739352892 3010726.3542510126717389 / 

  static final double NEPTUNE_MIN_HELIO_LON_SPEED = 0.00584;
// HELIO, SWI:   0.0058488995461196 237.4227749445460915 2859057.8062149924226105 / 

  static final double NEPTUNE_MAX_HELIO_LON_ACCEL = 0.000023804;
// HELIO, SWI:   0.0000237971572304 127.6252871364863921 3677792.9092317251488566 3677793.0009355251677334 / 

  static final double NEPTUNE_MIN_HELIO_LON_ACCEL = -0.000023845;
// HELIO, SWI:   -0.0000238415559796 342.9175515044154849 2936605.7491439552977681 2936605.8408477553166449 / 



  static final double NEPTUNE_MAX_LAT_SPEED = 0.0013;
// NOTOPO, JPL: 0.0012992698973563 94.8672612292906479 666219.2212012477684766 / 

  static final double NEPTUNE_MIN_LAT_SPEED = -0.0013;
// NOTOPO, JPL: -0.0012783972113913 268.1060882042605158 663109.7084374728146940 / 

  static final double NEPTUNE_MAX_LAT_ACCEL = 0.000069;
// NOTOPO, JPL: 0.0000688858521642 3.0106510603266088 2269663.3859712700359523 2269665.7029609824530780 / 

  static final double NEPTUNE_MIN_LAT_ACCEL = -0.000065;
// NOTOPO, JPL: -0.0000645053184318 3.1813985225708450 2059463.7634919909760356 2059466.4900546479038894 / 

  static final double NEPTUNE_MAX_TOPO_LAT_SPEED = 0.00156;
// TOPO, SWI:   0.0090000517239580 0.0524548520168651 1972364.6034868198912591
//              0.0089956406518853 0.0582866623987570 1491690.9895345694385469
//              0.0089730249324625 0.0600284356005858 1341026.7986733743455261
//              0.0080895274797669 0.0723554736281216 -161993.2757087929057889
//              0.0060016807506635 0.0288506759888136 -221526.1047314178140368
//              0.0035285398313926 0.0632601727365483 -221893.4920628319960088
//              0.0015526225326993 98.6415321471926347 -235230.4668798064230941
//              0.0015499860150981 88.2389236872085405 -235587.4842110734607559
//              0.0015467816098779 91.2033835105225421 -236325.4807206140249036
//              0.0015466858680102 92.1773040803388710 -236326.4611918719019741
// TOPO, JPL:   0.0014551000399715 95.4889062662710444 785651.9289954347768798 /   93.5   11.4 -889863.7

  static final double NEPTUNE_MIN_TOPO_LAT_SPEED = -0.00143;
// TOPO, JPL:   -0.0014127851155073 96.1163954950283568 755520.3564604987623170 /  133.6   16.3 -11928444.7

  static final double NEPTUNE_MAX_TOPO_LAT_ACCEL = 0.00087;
// TOPO, JPL:   0.0008698934809757 151.6828949764235404 659917.2505363596137613 659917.3554017660208046 /   11.0   52.2 -110000.0

  static final double NEPTUNE_MIN_TOPO_LAT_ACCEL = -0.000854;
// TOPO, JPL:   -0.0008534031453892 170.1151339811219145 807974.2306540678255260 807974.3415011959150434 /   11.0   52.2 -110000.0

  static final double NEPTUNE_MAX_HELIO_LAT_SPEED = 0.0002670;
// HELIO, SWI:   0.0002669265664204 61.2047535648150500 18880.4332063072251913 / 

  static final double NEPTUNE_MIN_HELIO_LAT_SPEED = -0.0002728;
// HELIO, SWI:   -0.0002726129273091 237.4938887399886198 -190757.8466299072606489 / 

  static final double NEPTUNE_MAX_HELIO_LAT_ACCEL = 0.0000106092;
// HELIO, SWI:   0.0000106088151780 266.6996026887903213 292495.4105916777625680 292495.5022954777814448 / 

  static final double NEPTUNE_MIN_HELIO_LAT_ACCEL = -0.000010590;
// HELIO, SWI:   -0.0000105890480006 93.8859591550667005 203741.5384303432365414 203741.6301341432263143 / 



  static final double NEPTUNE_MAX_DIST_SPEED = 0.0175;
// NOTOPO, SWI: 0.0174167945328918
// NOTOPO, JPL: 0.0174065088712856 90.0141956230224594 716570.6086513907648623 / 

  static final double NEPTUNE_MIN_DIST_SPEED = -0.0175;
// NOTOPO, SWI: -0.0174181120306995
// NOTOPO, JPL: -0.0174082572247792 90.1133447416499962 864489.7592409640783444 / 

  static final double NEPTUNE_MAX_DIST_ACCEL = 0.000316;
// NOTOPO, SWI: 0.0135819670381752 48.2733891582497563 5525.0933320791637016
//              0.0029873866850574 69.0549169938272769 -192795.6600356508279219
//              0.0004085467817404 165.5440851032710725 -235295.4374565259495284
//              0.0003252402971657 163.9956620539999506 -235661.4083584317122586
//              0.0003154919293185 177.7271030118340036 -235674.4588167968322523
//              0.0003154876427962 179.4769426327440272 -236411.0038810773694422
//              0.0003154687802688 180.1591877981425398 -236411.6524607480387203
// NOTOPO, JPL: 0.0003155423489853 181.7260481566145245 730447.6796687617897987 730448.2887378348968923 / 

  static final double NEPTUNE_MIN_DIST_ACCEL = -0.0003;
// NOTOPO, SWI: -0.0926625037231506 173.2327775500569942 708404.3574317961465567
//              -0.0051669956985789 111.0832620716790444 -227659.2020879369229078
//              -0.0003041835232219 7.0299840806517295 -234383.0605990467884112
//              -0.0002863472168228 2.3091629537422023 -250198.7555277845531236
//              -0.0002862723385372 3.1424049270648595 -250199.6271795822540298
//              -0.0002862542929178 3.4005205436072288 -250199.8970782387768850
//              -0.0002861746751199 4.0429712268202422 -250200.5686231650470290
// NOTOPO, JPL: -0.0002952785868367 3.2715414145909278 639491.6505929509876296 639495.8581704762764275 / 

  static final double NEPTUNE_MAX_TOPO_DIST_SPEED = 0.0177;
// TOPO, SWI:   0.0176337286177421
// TOPO, JPL:   0.0175995232752972 88.9667806227172662 778309.2456948457984254 /   42.3    6.9 -489807.4

  static final double NEPTUNE_MIN_TOPO_DIST_SPEED = -0.0177;
// TOPO, SWI:   -0.0176367861495518
// TOPO, JPL:   -0.0176267292572482 87.5072744454238318 1890876.3556474931538105 /  148.4    4.0 -106588.7

  static final double NEPTUNE_MAX_TOPO_DIST_ACCEL = 0.00135;
// TOPO, SWI:   0.6461977268067690 25.3701797814048433 1939634.5921939297113568
//              0.0041164964926524 206.4912262049541027 480897.9479083669139072
//              0.0037451465792928 136.6200955115339752 441925.1899133427650668
//              0.0014718970994787 93.5523667367900771 44993.4780828971197479
//              0.0013515382920695 211.2758559578730058 -162885.4319869252503850
//              0.0013232817060093 189.9636687918127222 -231644.2943363734520972
//              0.0013096974841549 189.6233126453089426 -232746.2574978842749260
// TOPO, JPL:   0.0013092533141867 189.5421929498741918 1087653.0362668419256806 1087653.1421054021921009 /   11.0   52.2 -110000.0

  static final double NEPTUNE_MIN_TOPO_DIST_ACCEL = -0.00129;
// TOPO, SWI:   -0.1132083825141817 142.5236047281373715 1681538.3904155539348722
//              -0.0792670482834736 154.3516542613503475 821240.9412590151187032
//              -0.0035286930591954 8.2707438707448304 434060.6570531763718463
//              -0.0020499282815566 327.4975658185502994 368987.5497646926087327
//              -0.0018412778091957 66.0445618612218794 -210436.4600420471979305
//              -0.0012986500971886 2.5730292615316017 -217119.1991163263737690
//              -0.0012882855151135 0.7261626876730247 -232184.3240317180461716
//              -0.0012688484178225 14.7256797835751740 -232201.2589514517167117
//              -0.0012600964431873 13.3128784618060649 -232567.3151242690801155
// TOPO, JPL:   -0.0012849455246221 5.7304803388833534 997431.1147520339582115 997431.2203086471417919 /   11.0   52.2 -110000.0

  static final double NEPTUNE_MAX_HELIO_DIST_SPEED = 0.000038700;
// HELIO, SWI:   0.0000386974135181 154.8074701018816199 2785346.2917598192580044 / 

  static final double NEPTUNE_MIN_HELIO_DIST_SPEED = -0.000038379;
// HELIO, SWI:   -0.0000383762733639 345.2953618997685226 2936999.6169650363735855 / 

  static final double NEPTUNE_MAX_HELIO_DIST_ACCEL = 0.00000022853;
// HELIO, SWI:   0.0000002284812407 46.7912725459401528 1212586.9639134742319584 1212587.0556172742508352 / 

  static final double NEPTUNE_MIN_HELIO_DIST_ACCEL = -0.00000023012;
// HELIO, SWI:   -0.0000002300982060 44.5153582367412142 3664209.6506691290996969 3664209.7423729291185737 / 



///////////////////////////////////////////////////////////////
// PLUTO: /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double PLUTO_MAX_LON_SPEED = 0.041;
// NOTOPO, SWI: 0.0409947189148399
// NOTOPO, JPL: 0.0408338960827420 3.1371236364667254 732954.4751370932208374 / 

  static final double PLUTO_MIN_LON_SPEED = -0.0284;
// NOTOPO, SWI: -0.0283698947779465
// NOTOPO, JPL: -0.0283272575709131 179.1674723407538181 1632754.8288194262422621 / 

  static final double PLUTO_MAX_LON_ACCEL = 0.000601;
// NOTOPO, JPL: 0.0005990791437332 97.3066735347333349 822701.2720944840693846 822702.0496401527198032 / 

  static final double PLUTO_MIN_LON_ACCEL = -0.00065; // ????
// NOTOPO, SWI: -0.0007143739642233 (SY problem down to -0.1089928395917400 observed)
// NOTOPO, JPL: -0.0006327247387071 94.8617743602447092 1632669.1280191596597433 1632669.6611433816142380 / 

  static final double PLUTO_MAX_TOPO_LON_SPEED = 0.0413;
// TOPO, SWI:   0.0412884373492034
// TOPO, JPL:   0.0411060581436741 3.1111305873843946 643830.5274781107436866 /   11.0   52.2 -110000.0

  static final double PLUTO_MIN_TOPO_LON_SPEED = -0.0288;
// TOPO, SWI:   -0.0286905230717167
// TOPO, JPL:   -0.0286678286669824 176.7873496422886319 2718300.2481787498109043 /  -23.0   -6.5 -11682194.0

  static final double PLUTO_MAX_TOPO_LON_ACCEL = 0.00253;
// TOPO, JPL:   0.0025178590195568 104.4522615939965249 2809692.6709229107946157 2809692.8023088881745934 /   11.0   52.2 -110000.0

  static final double PLUTO_MIN_TOPO_LON_ACCEL = -0.0026; // ????
// TOPO, SWI:   -0.0372004141085517 (SY problem down to -0.4008096521768991 observed)
// TOPO, JPL:   -0.0025588306695524 99.9199502376179680 2720792.5705627049319446 2720792.6829605293460190 /   11.0   52.2 -110000.0

  static final double PLUTO_MAX_HELIO_LON_SPEED = 0.0072091;
// HELIO, SWI:   0.0072088030257401 141.4754733876560522 374029.9928188612684608 / 

  static final double PLUTO_MIN_HELIO_LON_SPEED = 0.0025030;
// HELIO, SWI:   0.0025038612299076 100.0560887010465336 3675727.0060248998925090 / 

  static final double PLUTO_MAX_HELIO_LON_ACCEL = 0.000024137;
// HELIO, JPL:   0.0000241301797422 165.8455639910309571 2528934.2135650380514562 2528934.3052688380703330 / 

  static final double PLUTO_MIN_HELIO_LON_ACCEL = -0.00002406;
// HELIO, SWI:   -0.0000240489865306 286.6552384956450510 2997969.9888531868346035 2997970.0805569868534803 / 



  static final double PLUTO_MAX_LAT_SPEED = 0.0101;
// NOTOPO, SWI: 0.0099918860824316
// NOTOPO, JPL: 0.0099791426368035 94.4854202402405292 639883.3305302684893832 / 

  static final double PLUTO_MIN_LAT_SPEED = -0.00998;
// NOTOPO, SWI: -0.0099656330945712
// NOTOPO, JPL: -0.0099307674698353 93.1252446492206047 732853.5206388467922807 / 

  static final double PLUTO_MAX_LAT_ACCEL = 0.000159;
// NOTOPO, JPL: 0.0001577503032733 5.4037598154724265 641999.4772995261009783 642000.1200399320805445 / 

  static final double PLUTO_MIN_LAT_ACCEL = -0.000188;
// NOTOPO, JPL: -0.0001858085104703 177.6618672571143804 1000479.4034898622194305 1000480.3014068943448365 / 

  static final double PLUTO_MAX_TOPO_LAT_SPEED = 0.0102;
// TOPO, SWI:   0.0101887620952181
// TOPO, JPL:   0.0101587910721185 93.3203292923736569 729735.3805221099173650 /   11.0   52.2 -110000.0

  static final double PLUTO_MIN_TOPO_LAT_SPEED = -0.011;
// TOPO, SWI:   -0.0109564169565936
// TOPO, JPL:   -0.0101079839297460 92.3334029317985596 733222.3447666474385187 /   11.0   52.2 -110000.0

  static final double PLUTO_MAX_TOPO_LAT_ACCEL = 0.0013;
// TOPO, SWI:   0.1146408060915522 0.0754882456864365 713120.5580753037938848
//              0.0941206511202854 49.4010660634788081 456088.8688647721428424
//              0.0255255252969479 0.1806868458375845 116473.0549504257651279
//              0.0253178489595343 0.2471611952441393 -4971.5581980942633891
//              0.0121348936844913 0.1709038475643752 -62866.7451490048188134
//              0.0095585608319143 0.0073487506721790 -62866.9096804023429286
//              0.0045413279302522 0.5515540013628879 -152719.6797022641985677
//              0.0040083267072832 0.5350913166472111 -184677.7962954391550738
//              0.0023768429757906 0.2974980519578878 -242574.1132811341085471
//              0.0011173870417524 56.2797968672246895 -250713.2092755420599133
//              0.0010944966591291 64.0983224175128328 -250721.2586086901428644
//              0.0009852994797639 129.8867192572130307 -250891.6895662871829700
// TOPO, JPL:   0.0012931870141345 12.5130488940067437 640168.3879828155040741 640168.4985908751841635 /   11.0   52.2 -110000.0

  static final double PLUTO_MIN_TOPO_LAT_ACCEL = -0.0014;
// TOPO, SWI:   -0.1323288495285307 0.0571969808381283 1883765.3306468296796083
//              -0.0743827345599630 0.1194495083565243 713120.6057449358049780
//              -0.0347908909623849 0.1204501519061694 -152720.3629573613288812
//              -0.0088254384157201 0.1686240986828693 -152720.4120519654243253
//              -0.0033765420206368 0.1258497784927819 -184678.5095836789405439
//              -0.0017693116405143 0.4127381851168934 -242573.3918600576289464
//              -0.0012369578816304 188.1500182824425451 -250464.4232595347566530
//              -0.0011875762707375 171.6292642547027185 -250481.3294816084962804
//              -0.0011793623663488 171.5160188829716787 -250849.2928314248274546
//              -0.0011041529654153 131.2960704322420895 -250890.2601939455198590
// TOPO, JPL:   -0.0013933132467849 197.2859828842642855 641088.3418429015437141 641088.4793755571590737 /   11.0   52.2 -110000.0

  static final double PLUTO_MAX_HELIO_LAT_SPEED = 0.0012607;
// HELIO, SWI:   0.0012600819392323 57.2872964838035443 270894.4887934313155711 / 

  static final double PLUTO_MIN_HELIO_LAT_SPEED = -0.00170212;
// HELIO, SWI:   -0.0017020708716681 259.3240138417087337 2093270.8266607588157058 / 

  static final double PLUTO_MAX_HELIO_LAT_ACCEL = 0.000010674;
// HELIO, SWI:   0.0000106729980166 268.7168290608726124 754530.7011939855292439 754530.7928977855481207 / 

  static final double PLUTO_MIN_HELIO_LAT_ACCEL = -0.000010758;
// HELIO, SWI:   -0.0000107544293760 87.6044789431522020 -169539.6964996735623572 -169539.6047958735725842 / 



  static final double PLUTO_MAX_DIST_SPEED = 0.01805;
// NOTOPO, SWI: 0.0180201864709247
// NOTOPO, JPL: 0.0179673538522285 89.7263334479476384 747190.6329123422037810 / 

  static final double PLUTO_MIN_DIST_SPEED = -0.01805;
// NOTOPO, SWI: -0.0180372446419509
// NOTOPO, JPL: -0.0180007004030953 90.0245545393799773 626294.2538914401084185 / 

  static final double PLUTO_MAX_DIST_ACCEL = 0.000315;
// NOTOPO, SWI: 0.0407853605615538 83.8263720967590871 3624026.5748034995049238
//              0.0069468201512656 196.2677638094518784 1815013.3748994071502239
//              0.0048377509693545 47.2315784566411594 -143964.7589193212625105
//              0.0006369295143076 196.0402002069912157 -234332.2497064112685621
//              0.0003005188008673 176.0412684223048814 -241282.3776702757168096
//              0.0002952326969226 176.8597734140736861 -242751.7179506011016201
//              0.0002935577048952 177.7294647668737753 -243854.2899573702889029
//              0.0002935450072931 177.8110411867463938 -243854.3732949701952748
// NOTOPO, JPL: 0.0003136979868652 179.6743020621852907 1341170.5058408293407410 1341171.2995680202730000 / 

  static final double PLUTO_MIN_DIST_ACCEL = -0.000296;
// NOTOPO, SWI: -0.0152198272306129 237.8828584819669913 690902.4017224303679541
//              -0.0096311018334681 1.4497561645164865 307184.0997986468719319
//              -0.0026457749260651 331.2636077184097871 73186.7185329681087751
//              -0.0019568281177972 40.5484034124101242 -136261.9220611743803602
//              -0.0006521190722939 30.9038516469837532 -223109.5922839867707808
//              -0.0003360489734281 17.5393798737692634 -245493.2611005441867746
//              -0.0002946613707863 2.5375739709260188 -245508.5060571530484594
//              -0.0002946504435585 1.7204731079822864 -245509.3345663794898428
//              -0.0002946048677604 1.5721621402714163 -245509.4849347961135209
//              -0.0002944878278406 1.0907226602467972 -245509.9730266212136485
// NOTOPO, JPL: -0.0002959509564196 3.2369661234292266 1645067.6523841423913836 1645072.8514915483538061 / 

  static final double PLUTO_MAX_TOPO_DIST_SPEED = 0.0183;
// TOPO, SWI:   0.0182120589472379
// TOPO, JPL:   0.0181415307873287 89.7000340036246655 1108803.2886870261281729 /  -58.1    8.6 -108903.9

  static final double PLUTO_MIN_TOPO_DIST_SPEED = -0.0183;
// TOPO, SWI:   -0.0182358280933419
// TOPO, JPL:   -0.0181426062874089 88.6500692581212064 625559.5932220611721277 /   11.0   52.2 -110000.0

  static final double PLUTO_MAX_TOPO_DIST_ACCEL = 0.00135;
// TOPO, SWI:   0.0130128963192127 17.1368763588973749 1241262.9272272512316704
//              0.0023151043479321 111.4547636320583877 52165.7623227584044798
//              0.0017030775099116 178.4354706217193325 -175329.3589742311451118
//              0.0016646685105212 238.7184089560146276 -227044.6033776346594095
//              0.0014068279408472 55.1948022699443754 -240060.5752828968106769
//              0.0012963542904493 191.5096459801829099 -241665.2621815337915905
//              0.0012948705921776 169.6181203906081123 -244213.2961760257894639
// TOPO, JPL:   0.0013027104602608 180.1840886067463998 793263.3965677092783153 793263.5139706216286868 /   11.0   52.2 -110000.0

  static final double PLUTO_MIN_TOPO_DIST_ACCEL = -0.0013;
// TOPO, SWI:   -0.0179021842533406 214.6365146216283222 1198529.3581569930538535
//              -0.0032151436390044 3.9705683390313311 -20364.6199331984498713
//              -0.0028143398711598 252.9002190420136458 -35995.5853714871991542
//              -0.0013100334546386 2.1773699952934749 -154186.4357591727748513
//              -0.0013036739026851 3.6193122178814860 -156028.3848112957202829
//              -0.0013024841249698 13.3133296954911486 -242927.3159189936995972
//              -0.0012885072393509 17.9576457466834825 -243693.2539283887890633
//              -0.0012856628157103 13.0601184579426786 -244763.3268022972624749
//              -0.0012845931611976 2.0770303236098471 -246978.2600213123077992
//              -0.0012587293344394 12.3076703741073743 -247335.2735762960510328
//              -0.0012440334269146 19.5256853756665123 -248430.3081937007373199
//              -0.0012362014952662 13.8258049766299678 -249199.2258719038800336
//              -0.0012140398754897 15.1842583574879768 -249568.1970763951831032
// TOPO, JPL:   -0.0012825097800167 4.0535447294597020 830888.3153882571496069 830888.4365303290542215 /   11.0   52.2 -110000.0

  static final double PLUTO_MAX_HELIO_DIST_SPEED = 0.00071348;
// HELIO, SWI:   0.0007134175023050 324.8716158612946288 2735406.4197531393729150 / 

  static final double PLUTO_MIN_HELIO_DIST_SPEED = -0.00071142;
// HELIO, SWI:   -0.0007113947288229 145.8224897655158827 2704813.3901402419432998 / 

  static final double PLUTO_MAX_HELIO_DIST_ACCEL = 0.0000002773;
// HELIO, SWI:   0.0000002770034822 202.0136437752347263 1545703.6768922447226942 1545703.7685960447415709 / 

  static final double PLUTO_MIN_HELIO_DIST_ACCEL = -0.00000022049;
// HELIO, SWI:   -0.0000002204703871 62.1682780441932366 1340427.7467753896489739 1340427.8384791896678507 / 



///////////////////////////////////////////////////////////////
// MNODE: /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double MNODE_MAX_LON_SPEED = -0.0528;
// NOTOPO, JPL: -0.0528841758228763 87.4506108213789730 2800705.2652022368274629 / 

  static final double MNODE_MIN_LON_SPEED = -0.0531;
// NOTOPO, SWI: -0.0530037505698459
// NOTOPO, JPL: -0.0530021964831903 124.0050853633128298 644588.8616734195966274 / 

  static final double MNODE_MAX_LON_ACCEL = 0.0000249;
// NOTOPO, JPL: 0.0000248040638846 201.9963197288654442 1977761.7032133250031620 1977761.8148180888965726 / 

  static final double MNODE_MIN_LON_ACCEL = -0.0000244;
// NOTOPO, JPL: -0.0000242121990862 268.1333251052160449 2773317.7025739247910678 2773317.8079387117177248 / 

  
  static final double MNODE_MAX_TOPO_LON_SPEED = -0.0528;
// TOPO, JPL:   -0.0528842254910542 87.4505199997736327 2800705.2666699616238475 /   11.0   52.2 -110000.0

  static final double MNODE_MIN_TOPO_LON_SPEED = -0.0531;
// TOPO, SWI:   -0.0530037595813937
// TOPO, JPL:   -0.0530022464081250 123.9781716707397123 644588.8357337675988674 /  176.5  -37.7 -10953765.3

  static final double MNODE_MAX_TOPO_LON_ACCEL = 0.0000247;
// TOPO, JPL:   0.0000243945457281 63.5362877416933571 1291321.3731930041685700 1291321.4759153190534562 /   11.0   52.2 -110000.0

  static final double MNODE_MIN_TOPO_LON_ACCEL = -0.0000252;
// TOPO, JPL:   -0.0000251435327552 136.9860162044397498 2480991.0153021169826388 2480991.1231008274480700 /   11.0   52.2 -110000.0

// No heliocentric positions for the mean node...
  static final double MNODE_MAX_HELIO_LON_SPEED = 1./0.;
  static final double MNODE_MIN_HELIO_LON_SPEED = 1./0.;
  static final double MNODE_MAX_HELIO_LON_ACCEL = 1./0.;
  static final double MNODE_MIN_HELIO_LON_ACCEL = 1./0.;



  static final double MNODE_MAX_LAT_SPEED = 0.;
// NOTOPO, JPL: 0.0000000000000000 42.7373829367315352 625361.7029183002887294 / 

  static final double MNODE_MIN_LAT_SPEED = 0.;
// NOTOPO, JPL: 0.0000000000000000 42.7373829367315352 625361.7029183002887294 / 

  static final double MNODE_MAX_LAT_ACCEL = 0.;
// NOTOPO, JPL: 0.0000000000000000 42.7373829367315352 625361.5000000000000000 625361.7029183002887294 / 

  static final double MNODE_MIN_LAT_ACCEL = 0.;
// NOTOPO, JPL: 0.0000000000000000 42.7373829367315352 625361.5000000000000000 625361.7029183002887294 / 

  static final double MNODE_MAX_TOPO_LAT_SPEED = 0.;
// TOPO, JPL:   0.0000000000000000 42.5366762476106146 625361.8994183215545490 /   11.0   52.2 -110000.0

  static final double MNODE_MIN_TOPO_LAT_SPEED = 0.;
// TOPO, JPL:   0.0000000000000000 42.5366762476106146 625361.8994183215545490 /   11.0   52.2 -110000.0

  static final double MNODE_MAX_TOPO_LAT_ACCEL = 0.;
// TOPO, SWI:   0.0000000000000000 42.5366762476106146 625361.5000000000000000 625361.8994183215545490 /   11.0   52.2 -110000.0

  static final double MNODE_MIN_TOPO_LAT_ACCEL = 0.;
// TOPO, JPL:   0.0000000000000000 42.5366762476106146 625361.5000000000000000 625361.8994183215545490 /   11.0   52.2 -110000.0

// No heliocentric positions for the mean node...
  static final double MNODE_MAX_HELIO_LAT_SPEED = 1./0.;
  static final double MNODE_MIN_HELIO_LAT_SPEED = 1./0.;
  static final double MNODE_MAX_HELIO_LAT_ACCEL = 1./0.;
  static final double MNODE_MIN_HELIO_LAT_ACCEL = 1./0.;



  static final double MNODE_MAX_DIST_SPEED = 0.;
// NOTOPO, JPL: 0.0000000000000000 42.7373829367315352 625361.7029183002887294 / 

  static final double MNODE_MIN_DIST_SPEED = 0.;
// NOTOPO, JPL: 0.0000000000000000 42.7373829367315352 625361.7029183002887294 / 

  static final double MNODE_MAX_DIST_ACCEL = 0.;
// NOTOPO, JPL: 0.0000000000000000 42.7373829367315352 625361.5000000000000000 625361.7029183002887294 / 

  static final double MNODE_MIN_DIST_ACCEL = 0.;
// NOTOPO, JPL: 0.0000000000000000 42.7373829367315352 625361.5000000000000000 625361.7029183002887294 / 

  static final double MNODE_MAX_TOPO_DIST_SPEED = 0.;
// TOPO, JPL:   0.0000000000000000 42.5366762476106146 625361.8994183215545490 /   11.0   52.2 -110000.0

  static final double MNODE_MIN_TOPO_DIST_SPEED = 0.;
// TOPO, JPL:   0.0000000000000000 42.5366762476106146 625361.8994183215545490 /   11.0   52.2 -110000.0

  static final double MNODE_MAX_TOPO_DIST_ACCEL = 0.;
// TOPO, JPL:   0.0000000000000000 42.5366762476106146 625361.5000000000000000 625361.8994183215545490 /   11.0   52.2 -110000.0

  static final double MNODE_MIN_TOPO_DIST_ACCEL = 0.;
// TOPO, JPL:   0.0000000000000000 42.5366762476106146 625361.5000000000000000 625361.8994183215545490 /   11.0   52.2 -110000.0

// No heliocentric positions for the mean node...
  static final double MNODE_MAX_HELIO_DIST_SPEED = 1./0.;
  static final double MNODE_MIN_HELIO_DIST_SPEED = 1./0.;
  static final double MNODE_MAX_HELIO_DIST_ACCEL = 1./0.;
  static final double MNODE_MIN_HELIO_DIST_ACCEL = 1./0.;



///////////////////////////////////////////////////////////////
// TNODE: /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double TNODE_MAX_LON_SPEED = 0.0328;
// NOTOPO, JPL: 0.0326855962208268 28.5243572070390314 722775.8339081415906549 / 

  static final double TNODE_MIN_LON_SPEED = -0.261;
// NOTOPO, JPL: -0.2601780541622186 87.0307941091399471 871073.2885009105084464 / 

  static final double TNODE_MAX_LON_ACCEL = 0.054;
// NOTOPO, JPL: 0.0539136658625242 96.3340571413317832 1139185.0864348253235221 1139185.4419494222383946 / 

  static final double TNODE_MIN_LON_ACCEL = -0.054;
// NOTOPO, JPL: -0.0539712493483143 92.9162103985022156 687359.6763768544187769 687359.7991852302802727 / 

  static final double TNODE_MAX_TOPO_LON_SPEED = 0.0328;
// TOPO, SWI:   0.0327411094922690 (maybe much more, e.g. 0.4216115680677051)
//              0.4216115680677051 13.8633424027789545 3585899.6871486338786781
//              0.3996447565119488 191.6855534133834738 1843240.2456777647603303
//              0.2235892399173331 148.7626066628442913 30120.7841977981188393
//              0.0327411094922690 30.7612542764135526 -146545.2495332568651065
//              0.0325982260105773 208.4145973857591798 -224358.2317474005394615
//              0.0323529232146644 30.5854516341142357 -247697.1525798988586757
// TOPO, JPL:   0.0327082146129712 28.6110973826417876 722775.7452402360504493 /   11.0   52.2 -110000.0

  static final double TNODE_MIN_TOPO_LON_SPEED = -0.261;
// TOPO, SWI:   -0.2607482296372162 maybe much less, e.g. -0.5493115235934243)
//              -0.5493115235934243 42.7298002047974705 250061.6466701690806076
//              -0.5077009885677132 241.4997864307243276 39158.6958460557289072
//              -0.2607482296372162 93.1224119348595707 -69475.6147848475084174
//              -0.2605016817789270 93.1145743769104968 -76060.9473834989621537
//              -0.2594970823080265 84.6379656825472466 -140703.5355969415395521
//              -0.2594213076977080 84.6888169562490134 -140703.5749870793370064
//              -0.2581229158578309 91.1754560203589222 -168092.5823965377057903
// TOPO, JPL:   -0.2603922043003269 87.2476101631761765 864487.7687863860046491 /   -9.6  -71.6 -451209.5

  static final double TNODE_MAX_TOPO_LON_ACCEL = 0.054;
// TOPO, SWI:   0.0563873394044947 (maybe much more, e.g. 4.7468566498283602)
//              4.7468566498283602 241.5981374622122644 39158.7957134488242446
//              0.3122228876570153 148.7626066628442913 30120.7841977981188393
//              0.0563873394044947 164.3187040187730190 -140084.0362958694167901
//              0.0537976700912474 87.6324656033127383 -154224.3777706396358553
//              0.0537427144570444 87.6659956936547076 -154224.4070253355603199
//              0.0536532049411242 94.8920470111433900 -212281.3224629964388441
// TOPO, JPL:   0.0538962795836710 86.2171194267930332 2066563.6492133960127831 2066563.8136807992123067 /   11.0   52.2 -110000.0

  static final double TNODE_MIN_TOPO_LON_ACCEL = -0.054;
// TOPO, SWI:   -0.0539831464262423 maybe much less, e.g. -5.6865435545693899)
//              -5.6865435545693899 148.7128969225232140 30120.8330104324704735
//              -0.0539831464262423 94.8056785030036338 -195131.4903258501726668
//              -0.0536432799836339 95.3676455106551941 -201717.3139034592604730
//              -0.0536428549665791 87.1500816759324408 -240018.2256629223702475
//              -0.0535586258892041 87.2176697339374840 -246603.5270144374808297
// TOPO, JPL:   -0.0539120620264503 84.8636084025309998 738831.5274397874018177 738831.8096256844000891 /   11.0   52.2 -110000.0

// No heliocentric positions for the true node...
  static final double TNODE_MAX_HELIO_LON_SPEED = 1./0.;
  static final double TNODE_MIN_HELIO_LON_SPEED = 1./0.;
  static final double TNODE_MAX_HELIO_LON_ACCEL = 1./0.;
  static final double TNODE_MIN_HELIO_LON_ACCEL = 1./0.;



  static final double TNODE_MAX_LAT_SPEED = 0.;
// NOTOPO, JPL: 0.0000000000000000 41.0794032263436293 625361.7998687432846054 / 

  static final double TNODE_MIN_LAT_SPEED = 0.;
// NOTOPO, JPL: 0.0000000000000000 41.0794032263436293 625361.7998687432846054 / 

  static final double TNODE_MAX_LAT_ACCEL = 0.;
// NOTOPO, JPL: 0.0000000000000000 41.0794032263436293 625361.5000000000000000 625361.7998687432846054 / 

  static final double TNODE_MIN_LAT_ACCEL = 0.;
// NOTOPO, JPL: 0.0000000000000000 41.0794032263436293 625361.5000000000000000 625361.7998687432846054 / 

  static final double TNODE_MAX_TOPO_LAT_SPEED = 0.;
// TOPO, JPL:   0.0000000000000000 40.3789042855210027 625362.4439763929694891 /   11.0   52.2 -110000.0

  static final double TNODE_MIN_TOPO_LAT_SPEED = 0.;
// TOPO, JPL:   0.0000000000000000 40.3789042855210027 625362.4439763929694891 /   11.0   52.2 -110000.0

  static final double TNODE_MAX_TOPO_LAT_ACCEL = 0.;
// TOPO, JPL:   0.0000000000000000 40.3789042855210027 625361.5000000000000000 625362.4439763929694891 /   11.0   52.2 -110000.0

  static final double TNODE_MIN_TOPO_LAT_ACCEL = 0.;
// TOPO, JPL:   0.0000000000000000 40.3789042855210027 625361.5000000000000000 625362.4439763929694891 /   11.0   52.2 -110000.0

// No heliocentric positions for the true node...
  static final double TNODE_MAX_HELIO_LAT_SPEED = 1./0.;
  static final double TNODE_MIN_HELIO_LAT_SPEED = 1./0.;
  static final double TNODE_MAX_HELIO_LAT_ACCEL = 1./0.;
  static final double TNODE_MIN_HELIO_LAT_ACCEL = 1./0.;



  static final double TNODE_MAX_DIST_SPEED = 0.0000228;
// NOTOPO, SWI: 0.0000227657371966
// NOTOPO, JPL: 0.0000213536998323 120.1149812893362423 754925.7251749879214913 / 

  static final double TNODE_MIN_DIST_SPEED = -0.0000216;
// NOTOPO, SWI: -0.0000215585382077
// NOTOPO, JPL: -0.0000213990807928 114.3803667754305309 861213.9748676187591627 / 

  static final double TNODE_MAX_DIST_ACCEL = 0.00000835;
// NOTOPO, SWI: 0.0000750703538360 33.0382069743494640 1046857.9201584004331380
//              0.0000295730661174 132.1285899593370914 751004.2467315234243870
//              0.0000229566919869 6.1158485301780985 277754.1283083962043747
//              0.0000131148016195 196.2613424548156615 -14958.5557277744010207
//              0.0000083076652793 99.7438212565191975 -15397.8175420094139554
//              0.0000083031871586 98.6244788123381824 -225448.4339384726190474
//              0.0000082342371095 98.9047249793631238 -238618.8604936520860065
// NOTOPO, JPL: 0.0000083367008151 88.5064147393362077 674539.7194071344565600 674540.0587246073409915 / 

  static final double TNODE_MIN_DIST_ACCEL = -0.0000086;
// NOTOPO, SWI: -0.0002872607354344 106.8098325992096846 655114.2552040057489648
//              -0.0000161941268880 76.5510956058315912 347687.6100133685395122
//              -0.0000088751590264 169.1897512402919688 238764.2694866273377556
//              -0.0000085451497521 181.7548695594740877 197156.1960955614340492
//              -0.0000085156406539 177.1760048851402587 61286.1568801726316451
//              -0.0000084695707129 189.9098971100671918 -78.2180907315612757
//              -0.0000084538261730 1.7385989643092614 -30746.1787060799397295
//              -0.0000084417926183 173.1584750134485660 -67999.0639539538824465
//              -0.0000084251014809 174.0109261711857016 -129363.5261933571891859
//              -0.0000084210976167 3.0071993379622199 -247382.2838002044882160
// NOTOPO, JPL: -0.0000085231218245 179.9598301820871882 1073062.1182626546360552 1073062.7212474753614515 / 

  static final double TNODE_MAX_TOPO_DIST_SPEED = 0.000022; // ????
// TOPO, SWI:   0.0000320574867052
// TOPO, JPL:   0.0000213717861342 115.0970956228481725 1284910.9963867058977485 /   11.0   52.2 -110000.0

  static final double TNODE_MIN_TOPO_DIST_SPEED = -0.000022; // ????
// TOPO, SWI:   -0.0000332648162204
// TOPO, JPL:   -0.0000214083084746 114.3533718935811976 854628.5975370522355661 /   11.0   52.2 -110000.0

  static final double TNODE_MAX_TOPO_DIST_ACCEL = 0.00000835;
// TOPO, SWI:   0.0001074598743278 271.3472021376313705 2657201.8088382319547236
//              0.0000634652596772 193.5558352806767743 1221774.3783414242789149
//              0.0000538869946502 73.4934083541807581 31.3934498392767622
//              0.0000094186598250 173.4454735818177369 -92606.7031143940985203
//              0.0000083076607859 90.8051476176185872 -194780.8783414751815144
//              0.0000083008875115 98.4001552972325442 -225448.6528204880887643
//              0.0000082571491516 98.8692616102437398 -232033.5335670034401119
//              0.0000082542040884 98.3977016616702684 -232033.9945917097211350
//              0.0000082231815334 98.3834756777576303 -238619.3730163456057198
//              0.0000082187722697 98.9192470588687058 -245204.2546059744490776
// TOPO, JPL:   0.0000083343622490 92.4754649371095070 1027046.1513708923012018 1027046.5722648203372955 /   11.0   52.2 -110000.0

  static final double TNODE_MIN_TOPO_DIST_ACCEL = -0.00000856;
// TOPO, SWI:   -0.0001068121184233 79.6861647504438793 1764819.9418648579157889
//              -0.0000784099630606 109.2705757601478638 323742.6587682426907122
//              -0.0000433144853973 58.9190511727564825 87048.6964661899837665
//              -0.0000110202297946 32.7308601455830797 72582.4401404987002024
//              -0.0000085451174671 177.4027674611190264 61285.9358465782570420
//              -0.0000085190648985 177.2361821151802133 54700.7609249259112403
//              -0.0000084900566429 177.5682195794680638 48115.0708514538491727
//              -0.0000084618897872 1.6125954998670124 -30746.0549506582174217
//              -0.0000084498993674 173.1389537705036332 -67999.0444112504046643
//              -0.0000084444766972 2.9733688488841779 -240796.9001949433586560
// TOPO, JPL:   -0.0000085540381454 179.8284028667385996 1073062.4194052561651915 1073062.5930666599888355 /   11.0   52.2 -110000.0

// No heliocentric positions for the true node...
  static final double TNODE_MAX_HELIO_DIST_SPEED = 1./0.;
  static final double TNODE_MIN_HELIO_DIST_SPEED = 1./0.;
  static final double TNODE_MAX_HELIO_DIST_ACCEL = 1./0.;
  static final double TNODE_MIN_HELIO_DIST_ACCEL = 1./0.;



///////////////////////////////////////////////////////////////
// MEAN APOGEE (Lilith): //////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double MAPOGEE_MAX_LON_SPEED = 0.114;
// NOTOPO, SWI: 0.1121653709615447 171.4183485768921855 -20247.9275854335137410 /

  static final double MAPOGEE_MIN_LON_SPEED = 0.113;
// NOTOPO, SWI: 0.1106781849512775 155.0229802098288587 3691627.6196139729581773 /

  static final double MAPOGEE_MAX_LON_ACCEL = 0.000031;
// NOTOPO, SWI: 0.0000298963063733 176.2375763415385279 2052295.3679211242124438 2052295.4596249242313206 /

  static final double MAPOGEE_MIN_LON_ACCEL = -0.000031;
// NOTOPO, SWI: -0.0000295882829889 175.2747769062336261 3351880.2633748375810683 3351880.3550786375999451 /

  
  static final double MAPOGEE_MAX_TOPO_LON_SPEED = 0.12;
// TOPO, SWI:   0.1121653709615447 171.4193176938157990 -20247.9275854335137410 /   11.0   52.2 -110000.0

  static final double MAPOGEE_MIN_TOPO_LON_SPEED = 0.12;
// TOPO, SWI:   0.1106781849512775 155.0249784415171632 3691627.6196139729581773 /   11.0   52.2 -110000.0

  static final double MAPOGEE_MAX_TOPO_LON_ACCEL = 0.000031;
// TOPO, SWI:   0.0000298963063733 176.2375550073117836 2052295.3679211242124438 2052295.4596249242313206 /   11.0   52.2 -110000.0

  static final double MAPOGEE_MIN_TOPO_LON_ACCEL = 0.000031;
// TOPO, SWI:   -0.0000295882829889 175.2733719410060758 3351880.2633748375810683 3351880.3550786375999451 /   11.0   52.2 -110000.0

// No heliocentric positions for the mean apogee...
  static final double MAPOGEE_MAX_HELIO_LON_SPEED = 1./0;
  static final double MAPOGEE_MIN_HELIO_LON_SPEED = 1./0;
  static final double MAPOGEE_MAX_HELIO_LON_ACCEL = 1./0;
  static final double MAPOGEE_MIN_HELIO_LON_ACCEL = 1./0;



  static final double MAPOGEE_MAX_LAT_SPEED = 0.0155;
// NOTOPO, SWI: 0.0147669600244497 35.7349613823479899 21906.1083835298886697 /

  static final double MAPOGEE_MIN_LAT_SPEED = -0.016;
// NOTOPO, SWI: -0.0147667204296584 65.1007928354346177 -202554.1649415917054284 /

  static final double MAPOGEE_MAX_LAT_ACCEL = 0.000052;
// NOTOPO, SWI: 0.0000509580837833 37.3869576813376341 -217351.3984041414805688 -217351.3067003414907958 /

  static final double MAPOGEE_MIN_LAT_ACCEL = -0.0000525;
// NOTOPO, SWI: -0.0000509600661787 118.7068399888771921 -183404.4857239273260348 -183404.3940201273362618 /

  static final double MAPOGEE_MAX_TOPO_LAT_SPEED = 0.0156;
// TOPO, SWI:   0.0147669600244497 35.7347328272297773 21906.1083835298886697 /   11.0   52.2 -110000.0

  static final double MAPOGEE_MIN_TOPO_LAT_SPEED = -0.0156;
// TOPO, SWI:   -0.0147667204296584 65.1005044490689500 -202554.1649415917054284 /   11.0   52.2 -110000.0

  static final double MAPOGEE_MAX_TOPO_LAT_ACCEL = 0.000052;
// TOPO, SWI:   0.0000509580837833 37.3849474793524905 -217351.3984041414805688 -217351.3067003414907958 /   11.0   52.2 -110000.0

  static final double MAPOGEE_MIN_TOPO_LAT_ACCEL = -0.000052;
// TOPO, SWI:   -0.0000509600661787 118.7088490938103007 -183404.4857239273260348 -183404.3940201273362618 /   11.0   52.2 -110000.0

// No heliocentric positions for the mean apogee...
  static final double MAPOGEE_MAX_HELIO_LAT_SPEED = 1./0.;
  static final double MAPOGEE_MIN_HELIO_LAT_SPEED = 1./0.;
  static final double MAPOGEE_MAX_HELIO_LAT_ACCEL = 1./0.;
  static final double MAPOGEE_MIN_HELIO_LAT_ACCEL = 1./0.;



  static final double MAPOGEE_MAX_DIST_SPEED = 0.0;
// NOTOPO, SWI: 0.0000000000000000 153.9140009625195944 -250900.4082962000102270 /

  static final double MAPOGEE_MIN_DIST_SPEED = 0.0;
// NOTOPO, SWI: 0.0000000000000000 153.9140009625195944 -250900.4082962000102270 /

  static final double MAPOGEE_MAX_DIST_ACCEL = 0.0;
// NOTOPO, SWI: 0.0000000000000000 153.9140009625195944 -250900.5000000000000000 -250900.4082962000102270 /

  static final double MAPOGEE_MIN_DIST_ACCEL = 0.0;
// NOTOPO, SWI: 0.0000000000000000 153.9140009625195944 -250900.5000000000000000 -250900.4082962000102270 /

  static final double MAPOGEE_MAX_TOPO_DIST_SPEED = 0.0;
// TOPO, SWI:   0.0000000000000000 153.9145909096549758 -250900.4082962000102270 /   11.0   52.2 -110000.0

  static final double MAPOGEE_MIN_TOPO_DIST_SPEED = 0.0;
// TOPO, SWI:   0.0000000000000000 153.9145909096549758 -250900.4082962000102270 /   11.0   52.2 -110000.0

  static final double MAPOGEE_MAX_TOPO_DIST_ACCEL = 0.0;
// TOPO, SWI:   0.0000000000000000 153.9145909096549758 -250900.5000000000000000 -250900.4082962000102270 /   11.0   52.2 -110000.0

  static final double MAPOGEE_MIN_TOPO_DIST_ACCEL = 0.0;
// TOPO, SWI:   0.0000000000000000 153.9145909096549758 -250900.5000000000000000 -250900.4082962000102270 /   11.0   52.2 -110000.0

// No heliocentric positions for the mean apogee...
  static final double MAPOGEE_MAX_HELIO_DIST_SPEED = 1./0.;
  static final double MAPOGEE_MIN_HELIO_DIST_SPEED = 1./0.;
  static final double MAPOGEE_MAX_HELIO_DIST_ACCEL = 1./0.;
  static final double MAPOGEE_MIN_HELIO_DIST_ACCEL = 1./0.;



///////////////////////////////////////////////////////////////
// OSCULATING APOGEE: /////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double OAPOGEE_MAX_LON_SPEED = 6.5; // ???
// NOTOPO, SWI: 6.4501881852206120 51.4501951186205417 -192938.6546974640514236 / 

  static final double OAPOGEE_MIN_LON_SPEED = -3.9; // ???
// NOTOPO, SWI: -3.8568329741612786 327.1051657192288644 952676.2940441728569567 / 

  static final double OAPOGEE_MAX_LON_ACCEL = 2.12; // ???
// NOTOPO, SWI: 2.1151738152920152 143.6690056903030097 -245174.6981362385558896 -245174.6064324385661166 / 
// NOTOPO, SWI: 68.8787395144798609 3.8564123971073627 3023084.6334529565647244 3023084.7251567565836012 / 

  static final double OAPOGEE_MIN_LON_ACCEL = -2.2; // ???
// NOTOPO, SWI: -2.1096024893535170 143.4068176495207751 -249560.7074821494170465 -249560.6157783494272735 / 
// NOTOPO, SWI: -68.7513727700735160 4.0511925710936225 3023084.5417491565458477 3023084.6334529565647244 / 


  static final double OAPOGEE_MAX_TOPO_LON_SPEED = 6.48;
// TOPO, SWI:   6.4501881852206120 51.4502023281719403 -192938.6546974640514236 /   11.0   52.2 -110000.0

  static final double OAPOGEE_MIN_TOPO_LON_SPEED = -7.12;
// TOPO, SWI:   -7.0806304799046380 143.8027715810329141 1558491.3132858769968152 /   11.0   52.2 -110000.0

  static final double OAPOGEE_MAX_TOPO_LON_ACCEL = 5; // ???
// TOPO, SWI:   68.8787395144798609 3.8580903985037480 3023084.6334529565647244 3023084.7251567565836012 /   11.0   52.2 -110000.0
//              63.9872302885751765 144.0092304116939772 1558491.3132858769968152 1558491.4049896770156920 /   11.0   52.2 -110000.0
//              39.3377041951937372 228.1266855756707344 283568.0456598401069641 283568.1373636401258409 /   11.0   52.2 -110000.0
//              27.1259498225640598 139.0024744868594553 4522.5526478360743567 4522.6443516360741341 /   11.0   52.2 -110000.0
//              16.6192118670799154 70.6530432475572070 -232639.9808270364592317 -232639.8891232364694588 /   11.0   52.2 -110000.0
//              6.2484834256332844 162.4015420783792933 -244323.2283533335139509 -244323.1366495335241780 /   11.0   52.2 -110000.0
//              2.1151738152920152 143.6687348149947070 -245174.6981362385558896 -245174.6064324385661166 /   11.0   52.2 -110000.0
//              2.1140625042967844 40.3462406699342750 -249914.3173349099815823 -249914.2256311099918094 /   11.0   52.2 -110000.0

  static final double OAPOGEE_MIN_TOPO_LON_ACCEL = -6; // ???
// TOPO, SWI:   -68.7513727700735160 4.0522117857734941 3023084.5417491565458477 3023084.6334529565647244 /   11.0   52.2 -110000.0
//              -63.1344312027849526 143.8027715810329141 1558491.2215820769779384 1558491.3132858769968152 /   11.0   52.2 -110000.0
//              -38.3539882176728710 228.2301401740423046 283567.9539560400880873 283568.0456598401069641 /   11.0   52.2 -110000.0
//              -28.2206339938587618 139.1529738354334995 4522.4609440360745793 4522.5526478360743567 /   11.0   52.2 -110000.0
//              -15.6219121723360033 70.5833973243496189 -232640.0725308364490047 -232639.9808270364592317 /   11.0   52.2 -110000.0
//              -6.8065556784793078 162.6669361211922933 -244323.1366495335241780 -244323.0449457335344050 /   11.0   52.2 -110000.0
//              -2.1096024893535170 143.4072179488592269 -249560.7074821494170465 -249560.6157783494272735 /   11.0   52.2 -110000.0
//              -2.1063563353104215 143.2649365032625894 -249560.7991859494068194 -249560.7074821494170465 /   11.0   52.2 -110000.0
//              -2.0971288046634711 143.1044706967556976 -249560.8908897493965924 -249560.7991859494068194 /   11.0   52.2 -110000.0
//              -2.0820170020217095 142.9259022058182040 -249560.9825935493863653 -249560.8908897493965924 /   11.0   52.2 -110000.0

// No heliocentric positions for the osculating apogee...
  static final double OAPOGEE_MAX_HELIO_LON_SPEED = 1./0.;
  static final double OAPOGEE_MIN_HELIO_LON_SPEED = 1./0.;
  static final double OAPOGEE_MAX_HELIO_LON_ACCEL = 1./0.;
  static final double OAPOGEE_MIN_HELIO_LON_ACCEL = 1./0.;



  static final double OAPOGEE_MAX_LAT_SPEED = 0.595;
// NOTOPO, SWI: 0.5893596598716220 143.8036338266929306 1558491.3132858769968152 / 

  static final double OAPOGEE_MIN_LAT_SPEED = -0.592;
// NOTOPO, SWI: -0.5870851313647680 49.7434145533308083 1018.1836346420270729 / 

  static final double OAPOGEE_MAX_LAT_ACCEL = 0.198;
// NOTOPO, SWI: 5.2379339742474871 143.8036338266929306 1558491.2215820769779384 1558491.3132858769968152 / 
// NOTOPO, SWI: 0.1916322763674306 143.5136355060204210 -245174.6064324385661166 -245174.5147286385763437 / 

  static final double OAPOGEE_MIN_LAT_ACCEL = -0.184;
// NOTOPO, SWI: -5.3074179738566309 144.0103775442132132 1558491.3132858769968152 1558491.4049896770156920 / 
// NOTOPO, SWI: -0.1809284876020955 28.3181513796215825 -247714.8016921552771237 -247714.7099883552873507 / 

  static final double OAPOGEE_MAX_TOPO_LAT_SPEED = 0.595;
// TOPO, SWI:   0.5893596598716220 143.8027715810329141 1558491.3132858769968152 /   11.0   52.2 -110000.0

  static final double OAPOGEE_MIN_TOPO_LAT_SPEED = -0.593;
// TOPO, SWI:   -0.5870851313647680 49.7445176215321965 1018.1836346420270729 /   11.0   52.2 -110000.0

  static final double OAPOGEE_MAX_TOPO_LAT_ACCEL = 0.22; // ???
// TOPO, SWI:   5.2379339742474871 143.8027715810329141 1558491.2215820769779384 1558491.3132858769968152 /   11.0   52.2 -110000.0
//              3.0200105792156928 228.2301401740423046 283567.9539560400880873 283568.0456598401069641 /   11.0   52.2 -110000.0
//              1.5421732353411270 139.0024744868594553 4522.5526478360743567 4522.6443516360741341 /   11.0   52.2 -110000.0
//              1.3399341407278487 25.9927360270757504 -123771.7054806192754768 -123771.6137768192711519 /   11.0   52.2 -110000.0
//              0.8791241418544614 3.6129702330721898 -158821.2646530689089559 -158821.1729492689191829 /   11.0   52.2 -110000.0
//              0.6174781877730624 25.3356290167430700 -220956.8250045393942855 -220956.7333007394045126 /   11.0   52.2 -110000.0
//              0.5180504015512793 162.6669361211922933 -244323.1366495335241780 -244323.0449457335344050 /   11.0   52.2 -110000.0
//              0.1916322763674306 143.5140928603327950 -245174.6064324385661166 -245174.5147286385763437 /   11.0   52.2 -110000.0
//              0.1913092612021543 143.6687348149947070 -245174.6981362385558896 -245174.6064324385661166 /   11.0   52.2 -110000.0
//              0.1904665318092549 143.8058931802814300 -245174.7898400385456625 -245174.6981362385558896 /   11.0   52.2 -110000.0

  static final double OAPOGEE_MIN_TOPO_LAT_ACCEL = -0.2; // ???
// TOPO, SWI:   -5.3074179738566309 144.0092304116939772 1558491.3132858769968152 1558491.4049896770156920 /   11.0   52.2 -110000.0
//              -3.0984889620765821 228.1266855756707344 283568.0456598401069641 283568.1373636401258409 /   11.0   52.2 -110000.0
//              -1.6106363493553451 139.1529738354334995 4522.4609440360745793 4522.5526478360743567 /   11.0   52.2 -110000.0
//              -1.3214413016746980 25.7427903268498994 -123771.7971844192798017 -123771.7054806192754768 /   11.0   52.2 -110000.0
//              -0.9177284313575792 3.8646709050026971 -158821.1729492689191829 -158821.0812454689294100 /   11.0   52.2 -110000.0
//              -0.6359196220717301 25.0807399124825565 -220956.9167083393840585 -220956.8250045393942855 /   11.0   52.2 -110000.0
//              -0.4832935516415320 162.4015420783792933 -244323.2283533335139509 -244323.1366495335241780 /   11.0   52.2 -110000.0
//              -0.1809284876020955 28.3175426999310389 -247714.8016921552771237 -247714.7099883552873507 /   11.0   52.2 -110000.0
//              -0.1809136636167950 28.4003784255750134 -247714.8933959552668966 -247714.8016921552771237 /   11.0   52.2 -110000.0
//              -0.1803819052966495 28.5008495027587117 -247714.9850997552566696 -247714.8933959552668966 /   11.0   52.2 -110000.0

// No heliocentric positions for the osculating apogee...
  static final double OAPOGEE_MAX_HELIO_LAT_SPEED = 1./0.;
  static final double OAPOGEE_MIN_HELIO_LAT_SPEED = 1./0.;
  static final double OAPOGEE_MAX_HELIO_LAT_ACCEL = 1./0.;
  static final double OAPOGEE_MIN_HELIO_LAT_ACCEL = 1./0.;



  static final double OAPOGEE_MAX_DIST_SPEED = 0.0000336;
// NOTOPO, SWI: 0.0000331796025315 162.0559695927080668 452119.5383907356299460 / 

  static final double OAPOGEE_MIN_DIST_SPEED = -0.0000388;
// NOTOPO, SWI: -0.0000383564726112 143.8036338266929306 1558491.3132858769968152 / 

  static final double OAPOGEE_MAX_DIST_ACCEL = 0.000320;
// NOTOPO, SWI: 0.0003181723806385 169.5186135516686647 2652297.0998720317147672 2652297.1915758317336440 / 
// NOTOPO, SWI: 0.0002526325991030 144.0103775442132132 1558491.3132858769968152 1558491.4049896770156920 / 

  static final double OAPOGEE_MIN_DIST_ACCEL = -0.000332;
// NOTOPO, SWI: -0.0003276915355732 169.7783440308482739 2652297.0081682316958904 2652297.0998720317147672 / 
//              -0.0002657804181765 182.5429926387725459 2509784.9928602962754667 2509785.0845640962943435 / 
//              -0.0002592273381945 172.6663900642790281 1523992.8939415756613016 1523992.9856453756801784 / 
//              -0.0002362703260975 168.7598572310744771 790186.7893097251653671 790186.8810135251842439 / 
//              -0.0001845736992394 5.6648800904843659 268220.1308734808117151 268220.2225772808305919 / 
//              -0.0001843270910099 7.6690589634641526 31029.9945569982301095 31030.0862607982307964 / 
//              -0.0001371165189919 23.9210545917084403 17776.2277504989542649 17776.3194542989549518 / 
//              -0.0001314032632600 181.2666291901276168 -112088.6413600682863034 -112088.5496562682819786 / 
//              -0.0001294350298969 288.3207414549888767 -135454.9530080747790635 -135454.8613042747892905 / 

  static final double OAPOGEE_MAX_TOPO_DIST_SPEED = 0.0000348;
// TOPO, SWI:   0.0000331796025315 162.0554913950485059 452119.5383907356299460 /   11.0   52.2 -110000.0

  static final double OAPOGEE_MIN_TOPO_DIST_SPEED = -0.0000389;
// TOPO, SWI:   -0.0000383564726112 143.8027715810329141 1558491.3132858769968152 /   11.0   52.2 -110000.0
//              -0.0000315798154516 23.9192331902883808 17776.3194542989549518 /   11.0   52.2 -110000.0
//              -0.0000241174282212 155.6392038260355548 -53672.7705354545687442 /   11.0   52.2 -110000.0
//              -0.0000211044112260 121.5534461342293469 -122065.7396891388198128 /   11.0   52.2 -110000.0
//              -0.0000211036580721 125.5142614515566066 -128651.0812712493934669 /   11.0   52.2 -110000.0
//              -0.0000211016670089 125.4218652089164294 -128651.1729750493977917 /   11.0   52.2 -110000.0
//              -0.0000210813177137 126.7646050449078530 -248072.7216235153609887 /   11.0   52.2 -110000.0

  static final double OAPOGEE_MAX_TOPO_DIST_ACCEL = 0.00033; // ???
// TOPO, SWI:   0.0003181723806385 169.5192878024524816 2652297.0998720317147672 2652297.1915758317336440 /   11.0   52.2 -110000.0
//              0.0002526325991030 144.0092304116939772 1558491.3132858769968152 1558491.4049896770156920 /   11.0   52.2 -110000.0
//              0.0002502732154425 85.7828267135280811 1115992.2334243906661868 1115992.3251281906850636 /   11.0   52.2 -110000.0
//              0.0002284639283837 168.5027117890790578 790186.8810135251842439 790186.9727173252031207 /   11.0   52.2 -110000.0
//              0.0001835563725124 228.1266855756707344 283568.0456598401069641 283568.1373636401258409 /   11.0   52.2 -110000.0
//              0.0001749102115120 7.9453619854307647 31030.0862607982307964 31030.1779645982314833 /   11.0   52.2 -110000.0
//              0.0001441806335868 288.2482328493130694 -135454.8613042747892905 -135454.7696004747995175 /   11.0   52.2 -110000.0
//              0.0000917497105162 70.6530432475572070 -232639.9808270364592317 -232639.8891232364694588 /   11.0   52.2 -110000.0
//              0.0000254462819288 162.6669361211922933 -244323.1366495335241780 -244323.0449457335344050 /   11.0   52.2 -110000.0
//              0.0000087540238561 75.0022159568096640 -247684.8145495586213656 -247684.7228457586315926 /   11.0   52.2 -110000.0

  static final double OAPOGEE_MIN_TOPO_DIST_ACCEL = -0.00033; // ???
// TOPO, SWI:   -0.0003276915355732 169.7786058997761813 2652297.0081682316958904 2652297.0998720317147672 /   11.0   52.2 -110000.0
//              -0.0002657804181765 182.5439230812184519 2509784.9928602962754667 2509785.0845640962943435 /   11.0   52.2 -110000.0
//              -0.0002592273381945 172.6651545647018509 1523992.8939415756613016 1523992.9856453756801784 /   11.0   52.2 -110000.0
//              -0.0002362703260975 168.7615556959068215 790186.7893097251653671 790186.8810135251842439 /   11.0   52.2 -110000.0
//              -0.0001845736992394 5.6647024559301231 268220.1308734808117151 268220.2225772808305919 /   11.0   52.2 -110000.0
//              -0.0001843270910099 7.6692836371472595 31029.9945569982301095 31030.0862607982307964 /   11.0   52.2 -110000.0
//              -0.0001371165189919 23.9192331902883808 17776.2277504989542649 17776.3194542989549518 /   11.0   52.2 -110000.0
//              -0.0001314032632600 181.2675240107135437 -112088.6413600682863034 -112088.5496562682819786 /   11.0   52.2 -110000.0
//              -0.0001294350298969 288.3190436616176271 -135454.9530080747790635 -135454.8613042747892905 /   11.0   52.2 -110000.0
//              -0.0000768871688103 70.5833973243496189 -232640.0725308364490047 -232639.9808270364592317 /   11.0   52.2 -110000.0

// No heliocentric positions for the osculating apogee...
  static final double OAPOGEE_MAX_HELIO_DIST_SPEED = 1./0.;
  static final double OAPOGEE_MIN_HELIO_DIST_SPEED = 1./0.;
  static final double OAPOGEE_MAX_HELIO_DIST_ACCEL = 1./0.;
  static final double OAPOGEE_MIN_HELIO_DIST_ACCEL = 1./0.;



///////////////////////////////////////////////////////////////
// CHIRON: ////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double CHIRON_MAX_LON_SPEED = 0.1481;
// NOTOPO, SWI: 0.1480541138387438 3.0740725914689051 3402199.5112853837199509 / 

  static final double CHIRON_MIN_LON_SPEED = -0.08136;
// NOTOPO, SWI: -0.0813530877869733 180.0686031515706134 3308856.5058411695063114 / 

  static final double CHIRON_MAX_LON_ACCEL = 0.001985;
// NOTOPO, SWI: 0.0019801438410056 109.7728890158056601 3327189.3793181432411075 3327189.4710219432599843 / 

  static final double CHIRON_MIN_LON_ACCEL = -0.002076;
// NOTOPO, SWI: -0.0020747099147952 111.6956737843569840 3309175.6350652351975441 3309175.7267690352164209 / 

  static final double CHIRON_MAX_TOPO_LON_SPEED = 0.1490;
// TOPO, SWI:   0.1489717923918477 3.3015476297053965 3402199.7863967837765813 /   11.0   52.2 -110000.0
//              0.1489000930139661 3.3084944836917316 3383573.7358711496926844 /   11.0   52.2 -110000.0
//              0.1488674087003523 3.1787404119984615 3383565.8493443480692804 /   11.0   52.2 -110000.0
//              0.1488641986878703 3.2546857316454236 3383565.7576405480504036 /   11.0   52.2 -110000.0
//              0.1487769883398207 4.0070844371211933 3383564.8406025478616357 /   11.0   52.2 -110000.0
//              0.1487356870615033 4.0830131173854625 3383564.7488987478427589 /   11.0   52.2 -110000.0
//              0.1486723911311650 3.1677442396438664 3309431.7637786879204214 /   11.0   52.2 -110000.0

  static final double CHIRON_MIN_TOPO_LON_SPEED = -0.0826;
// TOPO, SWI:   -0.0825014372969852 180.3730621099178677 3309239.7360214483924210 /   11.0   52.2 -110000.0
//              -0.0824803407349744 180.8683156676808323 3308855.7722107693552971 /   11.0   52.2 -110000.0
//              -0.0824177489223616 181.9679239843536038 3308854.7634689691476524 /   11.0   52.2 -110000.0
//              -0.0823555145289969 179.7832444562579326 3290976.7408400890417397 /   11.0   52.2 -110000.0
//              -0.0823300256388445 180.8740004754742756 3290975.7320982888340950 /   11.0   52.2 -110000.0
//              -0.0822512864730052 181.9651412905404868 3290974.7233564886264503 /   11.0   52.2 -110000.0

  static final double CHIRON_MAX_TOPO_LON_ACCEL = 0.00892;
// TOPO, SWI:   0.0089131503936917 124.2443559490036051 3402437.8494616327807307 3402437.9411654327996075 /   11.0   52.2 -110000.0
//              0.0089090822815819 128.1161399302476127 3383807.8556725978851318 3383807.9473763979040086 /   11.0   52.2 -110000.0
//              0.0088971243336819 129.1261206601918161 3383806.8469307976774871 3383806.9386345976963639 /   11.0   52.2 -110000.0
//              0.0088769507698403 121.7964641216075279 3365193.8183447662740946 3365193.9100485662929714 /   11.0   52.2 -110000.0
//              0.0088754328039959 126.7151491328518205 3309290.8150380589067936 3309290.9067418589256704 /   11.0   52.2 -110000.0
//              0.0088669302536330 127.7250936822676266 3309289.8062962586991489 3309289.8980000587180257 /   11.0   52.2 -110000.0
//              0.0088605847296487 128.1742917738054643 3291025.8023730991408229 3291025.8940768991596997 /   11.0   52.2 -110000.0
//              0.0088405189631605 126.2570116687934103 3254883.7758210594765842 3254883.8675248594954610 /   11.0   52.2 -110000.0

  static final double CHIRON_MIN_TOPO_LON_ACCEL = -0.0091;
// TOPO, SWI:   -0.0090863634942317 127.9953303268456182 3383709.6409027776680887 3383709.7326065776869655 /   11.0   52.2 -110000.0
//              -0.0090786243171420 124.2419074628229509 3291307.6081505571492016 3291307.6998543571680784 /   11.0   52.2 -110000.0
//              -0.0090687107562786 123.1988879343719532 3291306.5994087569415569 3291306.6911125569604337 /   11.0   52.2 -110000.0
//              -0.0090479052698771 123.2118015100172670 3254778.5915624378249049 3254778.6832662378437817 /   11.0   52.2 -110000.0
//              -0.0090294153326601 122.1702012647674849 3254777.5828206376172602 3254777.6745244376361370 /   11.0   52.2 -110000.0
//              -0.0090047664866320 124.4892293237568310 3236524.5833534803241491 3236524.6750572803430259 /   11.0   52.2 -110000.0
//              -0.0090011195922285 123.4479228112854514 3236523.5746116801165044 3236523.6663154801353812 /   11.0   52.2 -110000.0
//              -0.0089920734222631 116.3014079648567076 3236516.6051228786818683 3236516.6968266787007451 /   11.0   52.2 -110000.0

  static final double CHIRON_MAX_HELIO_LON_SPEED = 0.048572;
// HELIO, SWI:   0.0485696184226494 210.6292818961332500 3402299.8352426043711603 / 

  static final double CHIRON_MIN_HELIO_LON_SPEED = 0.008467;
// HELIO, SWI:   0.0084676412770711 7.9994504859662445 1972799.5418591485358775 / 

  static final double CHIRON_MAX_HELIO_LON_ACCEL = 0.000036235;
// HELIO, SWI:   0.0000362290392015 139.3639511965011764 2609641.5330954394303262 2609641.6247992394492030 / 

  static final double CHIRON_MIN_HELIO_LON_ACCEL = -0.000035949;
// HELIO, SWI:   -0.0000359436743759 236.7714997834970632 1984188.3284872928634286 1984188.4201910928823054 / 



  static final double CHIRON_MAX_LAT_SPEED = 0.01538;
// NOTOPO, SWI: 0.0153624827772349 102.6165618129904260 1961882.4795783013105392 / 

  static final double CHIRON_MIN_LAT_SPEED = -0.01344;
// NOTOPO, SWI: -0.0134015639639669 100.8229034758880971 1960974.0617353143170476 / 

  static final double CHIRON_MAX_LAT_ACCEL = 0.000313;
// NOTOPO, SWI: 0.0003120510640977 180.2079026388219347 1961426.9868036075495183 1961427.0785074075683951 / 

  static final double CHIRON_MIN_LAT_ACCEL = -0.0002607;
// NOTOPO, SWI: -0.0002606661345476 180.9513472004433652 3385660.3641367792151868 3385660.4558405792340636 / 

  static final double CHIRON_MAX_TOPO_LAT_SPEED = 0.01574;
// TOPO, SWI:   0.0157158804791694 103.1350783881219257 1961881.9293555011972785 /   11.0   52.2 -110000.0

  static final double CHIRON_MIN_TOPO_LAT_SPEED =  -0.01368;
// TOPO, SWI:   -0.0136753781839591 100.6408976348296562 1960973.8783277142792940 /   11.0   52.2 -110000.0

  static final double CHIRON_MAX_TOPO_LAT_ACCEL = 0.0033643;
// TOPO, SWI:   0.0033640008466397 187.5099508835257325 3327114.9158325279131532 3327115.0075363279320300 /   11.0   52.2 -110000.0

  static final double CHIRON_MIN_TOPO_LAT_ACCEL = -0.003132;
// TOPO, SWI:   -0.0031313162870054 172.0627858902915932 3309247.3474368499591947 3309247.4391406499780715 /   11.0   52.2 -110000.0

  static final double CHIRON_MAX_HELIO_LAT_SPEED = 0.0066239;
// HELIO, SWI:   0.0066237790923881 216.3748108685314548 3402418.3165522287599742 / 

  static final double CHIRON_MIN_HELIO_LAT_SPEED = -0.0018657;
// HELIO, SWI:   -0.0018655429271156 77.1567753378589742 1958964.8314769007265568 / 

  static final double CHIRON_MAX_HELIO_LAT_ACCEL = 0.000011620;
// HELIO, SWI:   0.0000116182791852 123.0107161248320011 2270556.9202190404757857 2270557.0119228404946625 / 

  static final double CHIRON_MIN_HELIO_LAT_ACCEL = -0.000017098;
// HELIO, SWI:   -0.0000170952824726 236.6709356405359870 1984185.3939656922593713 1984185.4856694922782481 / 



  static final double CHIRON_MAX_DIST_SPEED = 0.01867;
// NOTOPO, SWI: 0.0186687186661194 89.8594372958532404 1965684.1523118838667870 / 

  static final double CHIRON_MIN_DIST_SPEED = -0.018683;
// NOTOPO, SWI: -0.0186798337268007 89.9240497610385319 1959837.3931340803392231 / 

  static final double CHIRON_MAX_DIST_ACCEL = 0.0003195;
// NOTOPO, SWI: 0.0003193379260309 182.3116645050504587 1997516.4670782363973558 1997516.5587820364162326 / 

  static final double CHIRON_MIN_DIST_ACCEL = -0.0002838;
// NOTOPO, SWI: -0.0002836526097651 4.8222989523558191 3410765.1047261469066143 3410765.1964299469254911 / 

  static final double CHIRON_MAX_TOPO_DIST_SPEED = 0.01883;
// TOPO, SWI:   0.0188233620020445 90.3952504368265863 1965683.6020890837535262 /   11.0   52.2 -110000.0

  static final double CHIRON_MIN_TOPO_DIST_SPEED = -0.01884;
// TOPO, SWI:   -0.0188346064034555 90.1041779471860309 1959837.5765416803769767 /   11.0   52.2 -110000.0

  static final double CHIRON_MAX_TOPO_DIST_ACCEL = 0.001324;
// TOPO, SWI:   0.0013219984219904 176.9248835345475186 3143009.6332842307165265 3143009.7249880307354033 /   11.0   52.2 -110000.0

  static final double CHIRON_MIN_TOPO_DIST_ACCEL = -0.001288;
// TOPO, SWI:   -0.0012870584145483 3.8110903955230242 3407815.8188137398101389 3407815.9105175398290157 /   11.0   52.2 -110000.0

  static final double CHIRON_MAX_HELIO_DIST_SPEED = 0.00208240;
// HELIO, SWI:   0.0020823844446079 297.3789092132498695 3404556.1155382688157260 / 

  static final double CHIRON_MIN_HELIO_DIST_SPEED = -0.0020787;
// HELIO, SWI:   -0.0020784488318901 118.8114000790392595 3418967.7345264353789389 / 

  static final double CHIRON_MAX_HELIO_DIST_ACCEL = 0.0000023777;
// HELIO, SWI:   0.0000023775763518 234.3434779952800682 1984118.6335992785170674 1984118.7253030785359442 / 

  static final double CHIRON_MIN_HELIO_DIST_ACCEL = -0.0000012240;
// HELIO, SWI:   -0.0000012238324524 36.2854788469465461 3079932.5499982465989888 3079932.6417020466178656 / 



///////////////////////////////////////////////////////////////
// PHOLUS: ////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double PHOLUS_MAX_LON_SPEED = 0.144;
// NOTOPO, SWI: 0.1430390048688713 3.0018759003319389 1380444.5295483474619687 / 

  static final double PHOLUS_MIN_LON_SPEED = -0.083;
// NOTOPO, SWI: -0.0828157902880158 179.7977542274780092 499611.6481260322034359 / 

  static final double PHOLUS_MAX_LON_ACCEL = 0.00202;
// NOTOPO, SWI: 0.0020122954067407 250.4580115964574247 2644830.9388484153896570 2644831.0305522154085338 / 

  static final double PHOLUS_MIN_LON_ACCEL = -0.00203;
// NOTOPO, SWI: -0.0020284765596128 106.4528548042683269 1380561.7270047715865076 1380561.8187085716053843 / 

  static final double PHOLUS_MAX_TOPO_LON_SPEED = 0.146;
// TOPO, SWI:   0.1439957406349812 3.2250695042433364 1380444.8046597475185990 /   11.0   52.2 -110000.0

  static final double PHOLUS_MIN_TOPO_LON_SPEED = -0.084;
// TOPO, SWI:   -0.0839987813309506 179.2933161401986979 1380247.8248973069712520 /   11.0   52.2 -110000.0

  static final double PHOLUS_MAX_TOPO_LON_ACCEL = 0.009147;
// TOPO, SWI:   0.0091450347895675 239.9890081597793028 2644820.5763190132565796 2644820.6680228132754564 /   11.0   52.2 -110000.0

  static final double PHOLUS_MIN_TOPO_LON_ACCEL = -0.0092;
// TOPO, SWI:   -0.0092168184439935 120.6341533482896864 1380575.6659823744557798 1380575.7576861744746566 /   11.0   52.2 -110000.0
//              -0.0091874059736348 119.5928634512433320 1380574.6572405742481351 1380574.7489443742670119 /   11.0   52.2 -110000.0
//              -0.0091624468224833 113.4872818940185084 1380568.6964935730211437 1380568.7881973730400205 /   11.0   52.2 -110000.0

  static final double PHOLUS_MAX_HELIO_LON_SPEED = 0.0456612;
// HELIO, SWI:   0.0456609358781905 65.7822048348128021 1410993.2662258357740939 / 

  static final double PHOLUS_MIN_HELIO_LON_SPEED = 0.0031847;
// HELIO, SWI:   0.0031842151382474 325.5701466942194315 3275615.5272782593965530 / 

  static final double PHOLUS_MAX_HELIO_LON_ACCEL = 0.000036611;
// HELIO, SWI:   0.0000366087844347 354.7972316220040625 1100835.7000273913145065 1100835.7917311913333833 / 

  static final double PHOLUS_MIN_HELIO_LON_ACCEL = -0.000035427;
// HELIO, SWI:   -0.0000354231241491 193.9198256398891544 3127255.9274583202786744 3127256.0191621202975512 / 



  static final double PHOLUS_MAX_LAT_SPEED = 0.0475;
// NOTOPO, SWI: 0.0473701962087067 101.2407213700385284 414557.9325731243006885 / 

  static final double PHOLUS_MIN_LAT_SPEED = -0.0359;
// NOTOPO, SWI: -0.0357901310934522 260.3881605591503217 413648.1391731370240450 / 

  static final double PHOLUS_MAX_LAT_ACCEL = 0.0008841;
// NOTOPO, SWI: 0.0008840458493128 178.8421732320428248 356766.7480240282602608 356766.8397278282791376 / 

  static final double PHOLUS_MIN_LAT_ACCEL = -0.000759;
// NOTOPO, SWI: -0.0007570203592937 180.6651743873322573 3576610.1414826177060604 3576610.2331864177249372 / 

  static final double PHOLUS_MAX_TOPO_LAT_SPEED = 0.0482;
// TOPO, SWI:   0.0479262918531750 101.6024232723681564 414557.5657579242251813 /   11.0   52.2 -110000.0

  static final double PHOLUS_MIN_TOPO_LAT_SPEED = -0.03636;
// TOPO, SWI:   -0.0363434864549000 260.9139978749386160 413647.5889503369107842 /   11.0   52.2 -110000.0

  static final double PHOLUS_MAX_TOPO_LAT_ACCEL = 0.00490;
// TOPO, SWI:   0.0048908505871406 174.7805307547260441 327546.6160012134350836 327546.7077050134539604 /   11.0   52.2 -110000.0

  static final double PHOLUS_MIN_TOPO_LAT_ACCEL = -0.00485;
// TOPO, SWI:   -0.0048340812417941 177.7122471828694756 753901.2418693765066564 753901.3335731765255332 /   11.0   52.2 -110000.0

  static final double PHOLUS_MAX_HELIO_LAT_SPEED = 0.020809;
// HELIO, SWI:   0.0208062133404151 158.8349313067455739 3669112.3147844588384032 / 

  static final double PHOLUS_MIN_HELIO_LAT_SPEED = -0.0036998;
// HELIO, SWI:   -0.0036986077672756 287.4455222305808775 524014.3961262553930283 / 

  static final double PHOLUS_MAX_HELIO_LAT_ACCEL = 0.000022898;
// HELIO, SWI:   0.0000228925156391 83.2525679446732170 2644221.2919858898967505 2644221.3836896899156272 / 

  static final double PHOLUS_MIN_HELIO_LAT_ACCEL = -0.000020868;
// HELIO, SWI:   -0.0000208633733225 88.5324223296608324 557487.5669863456860185 557487.6586901457048953 / 



  static final double PHOLUS_MAX_DIST_SPEED = 0.01806;
// NOTOPO, SWI: 0.0180349697932286 89.9276577797021730 3232343.9887937521561980 / 

  static final double PHOLUS_MIN_DIST_SPEED = -0.01822;
// NOTOPO, SWI: -0.0182018374571414 269.9133809896678713 1220418.5556976068764925 / 

  static final double PHOLUS_MAX_DIST_ACCEL = 0.0003200;
// NOTOPO, SWI: 0.0003198939404534 181.1007820742507874 2515483.2791445897892118 2515483.3708483898080885 / 

  static final double PHOLUS_MIN_DIST_ACCEL = -0.000297;
// NOTOPO, SWI: -0.0002962981658906 3.0285369280505847 1726161.3446497116237879 1726161.4363535116426647 / 

  static final double PHOLUS_MAX_TOPO_DIST_SPEED = 0.0183;
// TOPO, SWI:   0.0181956127909753 89.2383177748068306 3198371.7658539591357112 /   11.0   52.2 -110000.0

  static final double PHOLUS_MIN_TOPO_DIST_SPEED = -0.0185;
// TOPO, SWI:   -0.0183544820569711 269.6209267595401684 1735800.7185656907968223 /   -6.5   10.0 -36495.0

  static final double PHOLUS_MAX_TOPO_DIST_ACCEL = 0.00133;
// TOPO, SWI:   0.0013199233848670 176.1644418230122824 328681.7256378470920026 328681.8173416471108794 /   11.0   52.2 -110000.0

  static final double PHOLUS_MIN_TOPO_DIST_ACCEL = -0.00131;
// TOPO, SWI:   -0.0012945286051854 5.3012108376544518 341827.8321857531554997 341827.9238895531743765 /   11.0   52.2 -110000.0

  static final double PHOLUS_MAX_HELIO_DIST_SPEED = 0.0026983;
// HELIO, SWI:   0.0026970137849065 235.3099015822475337 3261453.0675147441215813 / 

  static final double PHOLUS_MIN_HELIO_DIST_SPEED = -0.0026987;
// HELIO, SWI:   -0.0026966131696737 55.6846751377110891 3289876.9354419950395823 / 

  static final double PHOLUS_MAX_HELIO_DIST_ACCEL = 0.0000030692;
// HELIO, SWI:   0.0000030688045009 116.5166479772393586 2415496.5167966079898179 2415496.6085004080086946 / 

  static final double PHOLUS_MIN_HELIO_DIST_ACCEL = -0.0000013359;
// HELIO, SWI:   -0.0000013356357022 232.3020067156864457 1206607.5965995639562607 1206607.6883033639751375 / 



///////////////////////////////////////////////////////////////
// CERES: /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double CERES_MAX_LON_SPEED = 0.47778;
// NOTOPO, SWI: 0.4777666356215652 3.0324656934870404 185995.7526867222914007 / 
//              0.4777642988236352 3.0761477279855853 185995.6609829223016277 / 
//              0.4777619074362583 3.1198327283156004 185995.5692791223118547 / 
//              0.4777594307344309 3.1635206984532260 185995.4775753223220818 / 
//              0.4777568808639132 3.2072116422655199 185995.3858715223323088 / 
//              0.4777542508895744 3.2509055634800461 185995.2941677223425359 / 
//              0.4777515768352859 3.2946024657497333 185995.2024639223527629 / 
//              0.4777487789409632 3.3383023526224065 185995.1107601223629899 / 

  static final double CERES_MIN_LON_SPEED = -0.2397;
// NOTOPO, SWI: -0.2394155931521627 180.9535211335031022 -222502.4008495670277625 / 

  static final double CERES_MAX_LON_ACCEL = 0.00784;
// NOTOPO, SWI: 0.0078289390844326 133.4978630172743124 510566.3134061666205525 510566.4051099666394293 / 

  static final double CERES_MIN_LON_ACCEL = -0.007809;
// NOTOPO, SWI: -0.0078072571959892 130.4420718528908196 465234.0988314351998270 465234.1905352352187037 / 

  static final double CERES_MAX_TOPO_LON_SPEED = 0.482;
// TOPO, SWI:   0.4806279624676904 4.3625891276860784 411366.6296802815049887 /  173.1   -6.3 -11378587.8

  static final double CERES_MIN_TOPO_LON_SPEED = -0.2462;
// TOPO, SWI:   -0.2461003811501000 181.4669672059693539 1131117.3308579281438142 / -129.0  -17.8 -828356.8

  static final double CERES_MAX_TOPO_LON_ACCEL = 0.04415;
// TOPO, SWI:   0.0441050298988982 150.3410264648743464 -182363.4641864434233867 -182363.3724826434336137 /   11.0   52.2 -110000.0

  static final double CERES_MIN_TOPO_LON_ACCEL = -0.0434;
// TOPO, SWI:   -0.0433571856487273 207.6654377673990837 -174011.8157137748203240 -174011.7240099748305511 /   11.0   52.2 -110000.0
  static final double CERES_MAX_HELIO_LON_SPEED = 0.27746;
// HELIO, SWI:   0.2774373104493407 344.3180307541163074 328950.0553979817777872 / 

  static final double CERES_MIN_HELIO_LON_SPEED = 0.1684273;
// HELIO, SWI:   0.1684271766463872 114.0812546781709074 -233676.2337669208936859 / 

  static final double CERES_MAX_HELIO_LON_ACCEL = 0.00024858;
// HELIO, SWI:   0.0002485770464934 301.1003542281761725 660015.7211855300702155 660015.8128893300890923 / 

  static final double CERES_MIN_HELIO_LON_ACCEL = -0.00026465;
// HELIO, SWI:   -0.0002646379191784 42.8006609833073668 155992.9287402682821266 155993.0204440682718996 / 



  static final double CERES_MAX_LAT_SPEED = 0.111909;
// NOTOPO, SWI: 0.1119085703807672 230.4962443443751852 944518.8742172936908901 / 

  static final double CERES_MIN_LAT_SPEED = -0.10943;
// NOTOPO, SWI: -0.1094225739941136 229.6607842571642095 73275.5509175217594020 / 

  static final double CERES_MAX_LAT_ACCEL = 0.003567;
// NOTOPO, SWI: 0.0035661165770005 181.2599309066658009 638379.2183128762990236 638379.3100166763179004 / 

  static final double CERES_MIN_LAT_ACCEL = -0.003284;
// NOTOPO, SWI: -0.0032820437433540 181.8053550152060609 2429693.7367416098713875 2429693.8284454098902643 / 

  static final double CERES_MAX_TOPO_LAT_SPEED = 0.1141;
// TOPO, SWI:   0.1140411323414252 230.5901796426277599 944518.9659210937097669 /   11.0   52.2 -110000.0

  static final double CERES_MIN_TOPO_LAT_SPEED = -0.11225;
// TOPO, SWI:   -0.1122208999929153 229.3833179571449818 73275.8260289217723766 /   11.0   52.2 -110000.0

  static final double CERES_MAX_TOPO_LAT_ACCEL = 0.0254;
// TOPO, SWI:   0.0253261491592657 173.9892913208469167 268361.6298369099386036 268361.7215407099574804 /   11.0   52.2 -110000.0

  static final double CERES_MIN_TOPO_LAT_ACCEL = -0.0241;
// TOPO, SWI:   -0.0239939019469919 183.8734151551513776 2318640.3432149500586092 2318640.4349187500774860 /   11.0   52.2 -110000.0

  static final double CERES_MAX_HELIO_LAT_SPEED = 0.049023;
// HELIO, SWI:   0.0490219454332673 81.6032687032516151 1529831.5831849775277078 / 

  static final double CERES_MIN_HELIO_LAT_SPEED = -0.047271;
// HELIO, SWI:   -0.0472702444220485 275.1918003463811715 -226166.9764009583450388 / 

  static final double CERES_MAX_HELIO_LAT_ACCEL = 0.000239747;
// HELIO, SWI:   0.0002397455950067 355.4826630735737467 524032.0076971384696662 524032.0994009384885430 / 

  static final double CERES_MIN_HELIO_LAT_ACCEL = -0.00020807;
// HELIO, SWI:   -0.0002080590305120 162.7032273885286315 2401106.9111617254093289 2401107.0028655254282057 / 



  static final double CERES_MAX_DIST_SPEED = 0.014525;
// NOTOPO, SWI: 0.0145226090702615 269.7300533033773604 51956.8934201937372563 / 

  static final double CERES_MIN_DIST_SPEED = -0.014456;
// NOTOPO, SWI: -0.0144538692662622 90.1670995513909475 668137.8350494019687176 / 

  static final double CERES_MAX_DIST_ACCEL = 0.0003006;
// NOTOPO, SWI: 0.0003005001344585 179.9786405989519267 3150598.4922678046859801 3150598.5839716047048569 / 

  static final double CERES_MIN_DIST_ACCEL = -0.0001636;
// NOTOPO, SWI: -0.0001635521463653 5.9181909524265421 -226934.1703916727856267 -226934.0786878727958538 / 

  static final double CERES_MAX_TOPO_DIST_SPEED = 0.01468;
// TOPO, SWI:   0.0146733008601036 269.8692339596657348 51957.0768277937313542 /   11.0   52.2 -110000.0

  static final double CERES_MIN_TOPO_DIST_SPEED = -0.01462;
// TOPO, SWI:   -0.0146138855659326 86.3103676911969728 531883.0265074669150636 /  177.5  -24.2 -501202.5

  static final double CERES_MAX_TOPO_DIST_ACCEL = 0.001298;
// TOPO, SWI:   0.0012964886413124 182.4703138984704935 2424087.4249274558387697 2424087.5166312558576465 /   11.0   52.2 -110000.0

  static final double CERES_MIN_TOPO_DIST_ACCEL = -0.001166;
// TOPO, SWI:   -0.0011640345749492 3.6983149068529428 721675.2471308223903179 721675.3388346224091947 /   11.0   52.2 -110000.0

  static final double CERES_MAX_HELIO_DIST_SPEED = 0.0012446382;
// HELIO, SWI:   0.0012446378569740 37.4746477943157430 -151710.9188170618726872 / 

  static final double CERES_MIN_HELIO_DIST_SPEED = -0.001241531;
// HELIO, SWI:   -0.0012415292009989 216.0540189475452166 -174287.8441517440369353 / 

  static final double CERES_MAX_HELIO_DIST_ACCEL = 0.0000061;
// HELIO, SWI:   0.0000062671882131 308.0209947368476833 -9142.5057015503298317 -9142.4139977503291448 / 
//               0.0000060920849110 302.5895126988224320 -214292.5264516826136969 -214292.4347478826239239 / 
//               0.0000060672395041 315.0534466719661850 -219292.4927385250048246 -219292.4010347250150517 / 
//               0.0000059913481450 301.0341203922127420 -234476.6245332316320855 -234476.5328294316423126 / 
//               0.0000059913330337 300.9341944843166061 -234476.9913484315911774 -234476.8996446316014044 / 

  static final double CERES_MIN_HELIO_DIST_ACCEL = -0.00000387;
// HELIO, SWI:   -0.0000040561392437 130.6881282588998090 -45292.5104765242504072 -45292.4187727242533583 / 
//               -0.0000039832202638 115.5746221904016693 -151292.5660815085284412 -151292.4743777085386682 / 
//               -0.0000038986028271 117.7361182290603665 -230292.5469548982509878 -230292.4552510982612148 / 
//               -0.0000038776218051 123.4429244133885675 -235301.7753255396091845 -235301.6836217396194115 / 
//               -0.0000036831608444 120.0036776603818538 -242046.8649261873797514 -242046.7732223873899784 / 
//               -0.0000036831246216 119.6478465992768321 -242048.9741135871445294 -242048.8824097871547565 / 



///////////////////////////////////////////////////////////////
// PALLAS: ////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double PALLAS_MAX_LON_SPEED = 0.7687;
// NOTOPO, SWI: 0.7686577156240990 32.6826593275708319 763251.8242795807309449 / 

  static final double PALLAS_MIN_LON_SPEED = -0.3482;
// NOTOPO, SWI: -0.3480103650280001 188.2428820087783663 1553351.3152948189526796 / 

  static final double PALLAS_MAX_LON_ACCEL = 0.01561;
// NOTOPO, SWI: 0.0156058787797183 227.7993455802007361 1127163.0401198901236057 1127163.1318236901424825 / 

  static final double PALLAS_MIN_LON_ACCEL = -0.01499;
// NOTOPO, SWI: -0.0149870229389337 137.0960812067706058 953670.7300515775568783 953670.8217553775757551 / 

  static final double PALLAS_MAX_TOPO_LON_SPEED = 0.7730;
// TOPO, SWI:   0.7727375825263879 32.5338603708758427 763251.1823529805988073 /   11.0   52.2 -110000.0

  static final double PALLAS_MIN_TOPO_LON_SPEED = -0.3570;
// TOPO, SWI:   -0.3568630455363278 187.3672800435400632 1553350.6733682188205421 /   11.0   52.2 -110000.0

  static final double PALLAS_MAX_TOPO_LON_ACCEL = 0.12775;
// TOPO, SWI:   0.1276646150711513 200.2821257335236282 1066540.1339300111867487 1066540.2256338112056255 /   11.0   52.2 -110000.0

  static final double PALLAS_MIN_TOPO_LON_ACCEL = -0.1280;
// TOPO, SWI:   -0.1275523489409923 162.0494099119480325 1036210.7527421680279076 1036210.8444459680467844 /   11.0   52.2 -110000.0

  static final double PALLAS_MAX_HELIO_LON_SPEED = 0.626831;
// HELIO, SWI:   0.6268306846308698 91.1059919192205712 884577.5106691550463438 / 

  static final double PALLAS_MIN_HELIO_LON_SPEED = 0.11145519;
// HELIO, SWI:   0.1114552070211848 279.2994254625075428 974769.6652485206723213 / 

  static final double PALLAS_MAX_HELIO_LON_ACCEL = 0.0026825;
// HELIO, SWI:   0.0026823019091048 47.5470618806543683 945156.5824426249600947 945156.6741464249789715 / 

  static final double PALLAS_MIN_HELIO_LON_ACCEL = -0.0026481;
// HELIO, SWI:   -0.0026480777481555 132.5672826335605521 823992.3864448838867247 823992.4781486839056015 / 


  static final double PALLAS_MAX_LAT_SPEED = 0.54900;
// NOTOPO, SWI: 0.5489987284427638 220.3149710435475583 1341262.7098745615221560 / 

  static final double PALLAS_MIN_LAT_SPEED = -0.5261;
// NOTOPO, SWI: -0.5260505334591784 137.1199630180018687 552576.3744176141917706 / 

  static final double PALLAS_MAX_LAT_ACCEL = 0.013324;
// NOTOPO, SWI: 0.0133170995158400 178.5971431648006558 1058149.1445244839414954 1058149.2362282839603722 / 

  static final double PALLAS_MIN_LAT_ACCEL = -0.008125;
// NOTOPO, SWI: -0.0081208918879644 179.0967761057272867 3650050.1254272144287825 3650050.2171310144476593 / 

  static final double PALLAS_MAX_TOPO_LAT_SPEED = 0.5518;
// TOPO, SWI:   0.5514034636248931 219.7222463949811413 1341262.0679479613900185 /   11.0   52.2 -110000.0

  static final double PALLAS_MIN_TOPO_LAT_SPEED = -0.5288;
// TOPO, SWI:   -0.5283528453731177 137.0348432082705017 552576.2827138141728938 /   11.0   52.2 -110000.0

  static final double PALLAS_MAX_TOPO_LAT_ACCEL = 0.0506;
// TOPO, SWI:   0.0505440495851551 166.1589453476826748 1005919.0618161326274276 1005919.1535199326463044 /   11.0   52.2 -110000.0

  static final double PALLAS_MIN_TOPO_LAT_ACCEL = -0.02938;
// TOPO, SWI:   -0.0293331524448678 126.7981590869007960 945281.7581296507269144 945281.8498334507457912 /   11.0   52.2 -110000.0

  static final double PALLAS_MAX_HELIO_LAT_SPEED = 0.2002976;
// HELIO, SWI:   0.2002970299068924 147.9454562477744446 1642897.0497878515161574 / 

  static final double PALLAS_MIN_HELIO_LAT_SPEED = -0.18542288;
// HELIO, SWI:   -0.1854227988613183 33.8965137331595656 65607.0040497601003153 / 

  static final double PALLAS_MAX_HELIO_LAT_ACCEL = 0.002821069;
// HELIO, SWI:   0.0028210659673938 89.7033526411191957 914902.2149631972424686 914902.3066669972613454 / 

  static final double PALLAS_MIN_HELIO_LAT_ACCEL = -0.00077783;
// HELIO, SWI:   -0.0007778158504460 263.2692245322652980 3683805.9273989629000425 3683806.0191027629189193 / 


  static final double PALLAS_MAX_DIST_SPEED = 0.01780;
// NOTOPO, SWI: 0.0177931137581742 90.2087939680378668 359247.4319596183486283 / 

  static final double PALLAS_MIN_DIST_SPEED = -0.01778;
// NOTOPO, SWI: -0.0177625237907836 90.6665282726177679 1003903.5039955177344382 / 

  static final double PALLAS_MAX_DIST_ACCEL = 0.0003338;
// NOTOPO, SWI: 0.0003335778677097 179.2854886873622888 3582423.4332146937958896 3582423.5249184938147664 / 

  static final double PALLAS_MIN_DIST_ACCEL = -0.000185;
// NOTOPO, SWI: -0.0001830286208040 3.3557067566372609 7275.4090200293921953 7275.5007238293919727 / 

  static final double PALLAS_MAX_TOPO_DIST_SPEED = 0.0180;
// TOPO, SWI:   0.0179770261137918 89.7135420368768024 307019.0560389829333872 /  -84.2   12.8 -1010223.4

  static final double PALLAS_MIN_TOPO_DIST_SPEED = -0.01799;
// TOPO, SWI:   -0.0179277764260068 92.9359376809836562 1138681.0400527711026371 /  -60.5  -28.1 -304337.2

  static final double PALLAS_MAX_TOPO_DIST_ACCEL = 0.001342;
// TOPO, SWI:   0.0013392917835449 177.4530450449256307 3582424.8087716940790415 3582424.9004754940979183 /   11.0   52.2 -110000.0

  static final double PALLAS_MIN_TOPO_DIST_ACCEL = -0.001189;
// TOPO, SWI:   -0.0011860774463715 3.2592270766529623 430242.5881544323638082 430242.6798582323826849 /   11.0   52.2 -110000.0

  static final double PALLAS_MAX_HELIO_DIST_SPEED = 0.004602944;
// HELIO, SWI:   0.0046029420326655 182.0166384844820300 884788.7962243985384703 / 

  static final double PALLAS_MIN_HELIO_DIST_SPEED = -0.004618;
// HELIO, SWI:   -0.0046019064249017 3.0030496706249696 884375.1203825133852661 / 

  static final double PALLAS_MAX_HELIO_DIST_ACCEL = 0.000044661;
// HELIO, SWI:   0.0000446593610039 92.7153166862132423 884579.9866717555560172 884580.0783755555748940 / 

  static final double PALLAS_MIN_HELIO_DIST_ACCEL = -0.0000083;
// HELIO, SWI:   -0.0000083837025426 307.1394614930052285 892457.4347971770912409 892457.5265009771101177 / 
//               -0.0000082714108244 303.8713764766425243 570657.4292597360908985 570657.5209635361097753 / 
//               -0.0000081380835045 229.6195496313166018 566657.4929105127230287 566657.5846143127419055 / 
//               -0.0000081003590577 229.3250482032393336 489157.5110689597204328 489157.6027727597393095 / 
//               -0.0000080489323803 299.2581956488377273 466157.4643938252702355 466157.5560976252891123 / 
//               -0.0000079978719271 237.3447256569042167 420157.4627473563887179 420157.5544511564075947 / 
//               -0.0000079557765155 295.9741661292506478 392007.5140707618556917 392007.6057745618745685 / 
//               -0.0000079212547894 236.3212171589642026 391507.4532492589205503 391507.5449530589394271 / 
//               -0.0000078966543510 283.9911233584992942 370007.4973348332569003 370007.5890386332757771 / 
//               -0.0000078780440678 232.0829097892447237 332507.4292083140462637 332507.5209121140651405 / 
//               -0.0000078235459296 242.9886021314076743 277007.4641026896424592 277007.5558064896613359 / 



///////////////////////////////////////////////////////////////
// JUNO: //////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double JUNO_MAX_LON_SPEED = 0.61473;
// NOTOPO, SWI: 0.6146053027885862 3.0207770033097177 455484.8844438283704221 / 

  static final double JUNO_MIN_LON_SPEED = -0.26366;
// NOTOPO, SWI: -0.2635702314463906 176.4603001677942018 917821.8805481982417405 / 

  static final double JUNO_MAX_LON_ACCEL = 0.00968;
// NOTOPO, SWI: 0.0096521056725605 223.5657354388314388 2775505.5569797935895622 2775505.6486835936084390 / 

  static final double JUNO_MIN_LON_ACCEL = -0.009779;
// NOTOPO, SWI: -0.0097770099496968 134.2071021455841446 2558889.6266564042307436 2558889.7183602042496204 / 

  static final double JUNO_MAX_TOPO_LON_SPEED = 0.6178;
// TOPO, SWI:   0.6177579562282278 3.1242366061235884 455484.6093324283137918 /   11.0   52.2 -110000.0

  static final double JUNO_MIN_TOPO_LON_SPEED = -0.2702;
// TOPO, SWI:   -0.2700462848173433 178.3284778322341708 1994998.4152454445138574 /   10.5    6.2 26183.8

  static final double JUNO_MAX_TOPO_LON_ACCEL = 0.0682;
// TOPO, SWI:   0.0681052448548100 161.4226779983857796 466646.7041669259779155 466646.7958707259967923 /   11.0   52.2 -110000.0

  static final double JUNO_MIN_TOPO_LON_ACCEL = -0.06812;
// TOPO, SWI:   -0.0680295849841816 200.6302232294483474 484149.2914385288022459 484149.3831423288211226 /   11.0   52.2 -110000.0

  static final double JUNO_MAX_HELIO_LON_SPEED = 0.42012063;
// HELIO, SWI:   0.4201205332870313 279.2926544406239486 436374.5461502945981920 / 

  static final double JUNO_MIN_HELIO_LON_SPEED = 0.1363890;
// HELIO, SWI:   0.1363892738361045 128.9178280656598758 838735.4229663186706603 / 

  static final double JUNO_MAX_HELIO_LON_ACCEL = 0.00087833;
// HELIO, SWI:   0.0008783112457574 229.2099143903356548 514309.9376343372277915 514310.0293381372466683 / 

  static final double JUNO_MIN_HELIO_LON_ACCEL = -0.00086738;
// HELIO, SWI:   -0.0008673141411609 328.7655693863320607 297900.9827875904738903 297901.0744913904927671 / 



  static final double JUNO_MAX_LAT_SPEED = 0.2118;
// NOTOPO, SWI: 0.2115232264222861 222.7722963248323254 3377842.6179019818082452 / 

  static final double JUNO_MIN_LAT_SPEED = -0.2069;
// NOTOPO, SWI: -0.2065361586712064 136.6027376454728994 2181175.2465410535223782 / 

  static final double JUNO_MAX_LAT_ACCEL = 0.006619;
// NOTOPO, SWI: 0.0066135614041763 179.1664993515285573 2603458.4987997785210609 2603458.5905035785399377 / 

  static final double JUNO_MIN_LAT_ACCEL = -0.006030;
// NOTOPO, SWI: -0.0060275909794300 181.9945617272934442 484165.3396035321056843 484165.4313073321245611 / 

  static final double JUNO_MAX_TOPO_LAT_SPEED = 0.213;
// TOPO, SWI:   0.2126309502078609 223.4282736786784085 3377843.2598285819403827 /   11.0   52.2 -110000.0

  static final double JUNO_MIN_TOPO_LAT_SPEED = -0.2089;
// TOPO, SWI:   -0.2086688323370115 139.0806473010803472 2163642.0302002443931997 /   11.0   52.2 -110000.0

  static final double JUNO_MAX_TOPO_LAT_ACCEL = 0.02594;
// TOPO, SWI:   0.0258535654741205 198.3318338500047275 1966069.2192849749699235 1966069.3109887749888003 /   11.0   52.2 -110000.0

  static final double JUNO_MIN_TOPO_LAT_ACCEL = -0.02464;
// TOPO, SWI:   -0.0245920430039919 202.0764882154254849 1213967.1061037583276629 1213967.1978075583465397 /   11.0   52.2 -110000.0

  static final double JUNO_MAX_HELIO_LAT_SPEED = 0.09100508;
// HELIO, SWI:   0.0910050500438649 153.8584841083539345 3674260.7539663980714977 / 

  static final double JUNO_MIN_HELIO_LAT_SPEED = -0.09178865;
// HELIO, SWI:   -0.0917886248725829 354.6859336527865594 1597975.7599410046823323 / 

  static final double JUNO_MAX_HELIO_LAT_ACCEL = 0.000645883;
// HELIO, SWI:   0.0006458698334771 78.1937538906792469 2759598.8909399192780256 2759598.9826437192969024 / 

  static final double JUNO_MIN_HELIO_LAT_ACCEL = -0.000592596;
// HELIO, SWI:   -0.0005925862393346 278.6764356039605559 544706.3542999941855669 544706.4460037942044437 / 



  static final double JUNO_MAX_DIST_SPEED = 0.01631;
// NOTOPO, SWI: 0.0162843725535575 269.8813621922874972 231229.7524772776814643 / 

  static final double JUNO_MIN_DIST_SPEED = -0.01649;
// NOTOPO, SWI: -0.0164764537230936 89.9887526575049321 684496.3257119692862034 / 

  static final double JUNO_MAX_DIST_ACCEL = 0.0003149;
// NOTOPO, SWI: 0.0003146412451505 178.6391503901720341 -206763.4610649222740903 -206763.3693611222843174 / 

  static final double JUNO_MIN_DIST_ACCEL = -0.00018013;
// NOTOPO, SWI: -0.0001800895034604 6.5747992238695758 1460177.4116578395478427 1460177.5033616395667195 / 

  static final double JUNO_MAX_TOPO_DIST_SPEED = 0.016457;
// TOPO, SWI:   0.0164458526908689 269.9540185768486822 231229.8441810776712373 /   11.0   52.2 -110000.0

  static final double JUNO_MIN_TOPO_DIST_SPEED = -0.01666;
// TOPO, SWI:   -0.0166376942595072 89.9879486043953989 684496.3257119692862034 /   11.0   52.2 -110000.0

  static final double JUNO_MAX_TOPO_DIST_ACCEL = 0.001315;
// TOPO, SWI:   0.0013139474105691 183.9292561302711704 -249875.5266275143076200 -249875.4349237143178470 /   11.0   52.2 -110000.0

  static final double JUNO_MIN_TOPO_DIST_ACCEL = -0.001185;
// TOPO, SWI:   -0.0011839973541814 3.6642235798218792 1777218.5401971009559929 1777218.6319009009748697 /   11.0   52.2 -110000.0

  static final double JUNO_MAX_HELIO_DIST_SPEED = 0.0029944744;
// HELIO, SWI:   0.0029944742421910 14.0830267598934977 514712.2422050200402737 / 

  static final double JUNO_MIN_HELIO_DIST_SPEED = -0.002995286;
// HELIO, SWI:   -0.0029952820410565 189.5654180917034068 436114.7492848411202431 / 

  static final double JUNO_MAX_HELIO_DIST_ACCEL = 0.00002158148;
// HELIO, SWI:   0.0000215814030565 279.7164455065137076 436375.4631882947869599 436375.5548920948058367 / 

  static final double JUNO_MIN_HELIO_DIST_ACCEL = -0.0000125;
// HELIO, SWI:   -0.0000129385192114 60.6887235114672734 424157.4908003797754645 424157.5825041797943413 / 
//               -0.0000126223274562 51.2769392021547858 268007.4697612370364368 268007.5614650370553136 / 
//               -0.0000118634345139 125.8309285684769492 251007.5110210720158648 251007.6027248720056377 / 
//               -0.0000116633334884 121.5491441573151690 145857.4579501986154355 145857.5496539986052085 / 
//               -0.0000116025216557 41.7419909479435773 111857.4487667413341114 111857.5404705413384363 / 



///////////////////////////////////////////////////////////////
// VESTA: /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double VESTA_MAX_LON_SPEED = 0.5540;
// NOTOPO, SWI: 0.5537145358291486 3.4594766840702391 3691240.5378740932792425 / 

  static final double VESTA_MIN_LON_SPEED = -0.2695;
// NOTOPO, SWI: -0.2681925747406844 178.9036210722504165 -18711.7972316220075299 / 

  static final double VESTA_MAX_LON_ACCEL = 0.00876;
// NOTOPO, SWI: 0.0087089656900730 132.7090084801200476 -235969.1038780651870184 -235969.0121742651972454 / 

  static final double VESTA_MIN_LON_ACCEL = -0.00877;
// NOTOPO, SWI: -0.0087360726786455 136.0235910262570087 -213351.9205751875124406 -213351.8288713875226676 / 

  static final double VESTA_MAX_TOPO_LON_SPEED = 0.5568;
// TOPO, SWI:   0.5564630419112789 4.0953310268746463 3691241.9134310935623944 /   11.0   52.2 -110000.0

  static final double VESTA_MIN_TOPO_LON_SPEED = -0.2770;
// TOPO, SWI:   -0.2768575189637789 180.2074959215284764 -79716.9379980540543329 /   59.1    4.2 -185631.4

  static final double VESTA_MAX_TOPO_LON_ACCEL = 0.05581;
// TOPO, SWI:   0.0557979863799293 153.3262276308298624 2980627.6998240170069039 2980627.7915278170257807 /   11.0   52.2 -110000.0

  static final double VESTA_MIN_TOPO_LON_ACCEL = -0.05541;
// TOPO, SWI:   -0.0553938266966353 204.5059433071201909 2433058.2574605024419725 2433058.3491643024608493 /   11.0   52.2 -110000.0

  static final double VESTA_MAX_HELIO_LON_SPEED = 0.3379980;
// HELIO, SWI:   0.3379979804926766 346.3524783779499785 3687288.7460198798216879 / 

  static final double VESTA_MIN_HELIO_LON_SPEED = 0.22067514;
// HELIO, SWI:   0.2206752048320799 156.3012849424309536 3673335.2792166075669229 / 

  static final double VESTA_MAX_HELIO_LON_ACCEL = 0.00029479;
// HELIO, SWI:   0.0002947717048992 264.7782960565963890 3669802.1152094802819192 3669802.2069132803007960 / 

  static final double VESTA_MIN_HELIO_LON_ACCEL = -0.00033568;
// HELIO, SWI:   -0.0003356340736213 56.5318299251946428 3657020.8980818493291736 3657020.9897856493480504 / 



  static final double VESTA_MAX_LAT_SPEED = 0.09498;
// NOTOPO, SWI: 0.0949061717951902 134.5788001112487393 997159.9733573296107352 / 

  static final double VESTA_MIN_LAT_SPEED = -0.09798;
// NOTOPO, SWI: -0.0978818455277392 221.9589752205408217 3628935.6922880681231618 / 

  static final double VESTA_MAX_LAT_ACCEL = 0.003088;
// NOTOPO, SWI: 0.0030855189558008 180.5228408503361095 3658222.9514924967661500 3658223.0431962967850268 / 

  static final double VESTA_MIN_LAT_ACCEL = -0.003171;
// NOTOPO, SWI: -0.0031687600670683 179.2334880945888358 1723706.6217720857821405 1723706.7134758858010173 / 

  static final double VESTA_MAX_TOPO_LAT_SPEED = 0.09843;
// TOPO, SWI:   0.0983095167802877 136.2849559385317662 1115136.1336578321643174 / -148.8   41.9 -674884.2

  static final double VESTA_MIN_TOPO_LAT_SPEED = -0.1011;
// TOPO, SWI:   -0.1009420346676514 222.0511621045546917 3628935.6005842681042850 /   11.0   52.2 -110000.0

  static final double VESTA_MAX_TOPO_LAT_ACCEL = 0.02671;
// TOPO, SWI:   0.0266237797541972 174.0709493647357249 3639562.6954494556412101 3639562.7871532556600869 /   11.0   52.2 -110000.0

  static final double VESTA_MIN_TOPO_LAT_ACCEL = -0.02858;
// TOPO, SWI:   -0.0285105960855562 188.7065455088097963 854022.9966522655449808 854023.0883560655638576 /   11.0   52.2 -110000.0

  static final double VESTA_MAX_HELIO_LAT_SPEED = 0.0387172;
// HELIO, SWI:   0.0387170156464209 82.7494549858227657 258667.0709152178023942 / 

  static final double VESTA_MIN_HELIO_LAT_SPEED = -0.04107737;
// HELIO, SWI:   -0.0410773444150950 291.7615350016681646 3028336.6017838376574218 / 

  static final double VESTA_MAX_HELIO_LAT_ACCEL = 0.00022967;
// HELIO, SWI:   0.0002296552965727 14.5432114071000864 3691348.1981353154405951 3691348.2898391154594719 / 

  static final double VESTA_MIN_HELIO_LAT_ACCEL = -0.00022729;
// HELIO, SWI:   -0.0002272717071074 190.9356162095806155 1658758.9643733166158199 1658759.0560771166346967 / 



  static final double VESTA_MAX_DIST_SPEED = 0.01421;
// NOTOPO, SWI: 0.0141837555735652 269.6068375203445271 3674450.9476476372219622 / 

  static final double VESTA_MIN_DIST_SPEED = -0.01422;
// NOTOPO, SWI: -0.0140297476891311 89.9781908424814674 3686841.7816985878162086 / 

  static final double VESTA_MAX_DIST_ACCEL = 0.000299;
// NOTOPO, SWI: 0.0002978698252524 180.0039928852636706 2818260.8030701945535839 2818260.8947739945724607 / 

  static final double VESTA_MIN_DIST_ACCEL = -0.0001321;
// NOTOPO, SWI: -0.0001318403868464 8.9533490479961131 -241814.3040894133155234 -241814.2123856133257505 / 

  static final double VESTA_MAX_TOPO_DIST_SPEED = 0.01438;
// TOPO, SWI:   0.0143333054520008 269.6069738247148280 3674450.9476476372219622 /   11.0   52.2 -110000.0

  static final double VESTA_MIN_TOPO_DIST_SPEED = -0.01420;
// TOPO, SWI:   -0.0141862722224344 89.3481771752887255 3686840.9563643876463175 /   11.0   52.2 -110000.0

  static final double VESTA_MAX_TOPO_DIST_ACCEL = 0.001300;
// TOPO, SWI:   0.0012958625593180 180.2574992837387526 1447421.6881866138428450 1447421.7798904138617218 /   11.0   52.2 -110000.0

  static final double VESTA_MIN_TOPO_DIST_ACCEL = -0.001138;
// TOPO, SWI:   -0.0011308958276606 3.9923375021191925 1659420.6072904528118670 1659420.6989942528307438 /   11.0   52.2 -110000.0

  static final double VESTA_MAX_HELIO_DIST_SPEED = 0.001193567;
// HELIO, SWI:   0.0011935629514952 71.1813997280709856 3687558.8137109354138374 / 

  static final double VESTA_MIN_HELIO_DIST_SPEED = -0.001193051;
// HELIO, SWI:   -0.0011930505631128 251.3940719982379903 3686986.2151836175471544 / 

  static final double VESTA_MAX_HELIO_DIST_ACCEL = 0.0000070;
// HELIO, SWI:   0.0000070831126369 339.2996995770586750 3638223.4531539799645543 3638223.5448577799834311 / 
//               0.0000070274330974 339.0703934649927191 3581223.4889914467930794 3581223.5806952468119562 / 
//               0.0000069026704888 333.2435038124803555 3574579.8237914792262018 3574579.9154952792450786 / 
//               0.0000069026669303 333.0894541149062889 3574579.3652724791318178 3574579.4569762791506946 / 
//               0.0000069025930570 333.0586445287072479 3574579.2735686791129410 3574579.3652724791318178 / 
//               0.0000069025901919 332.9970256988889332 3574579.0901610790751874 3574579.1818648790940642 / 
//               0.0000069025421235 332.9354073213774541 3574578.9067534790374339 3574578.9984572790563107 / 

  static final double VESTA_MIN_HELIO_DIST_ACCEL = -0.0000048;
// HELIO, SWI:   -0.0000048393488576 149.0475104580058030 3575223.4927638117223978 3575223.5844676117412746 / 
//               -0.0000047011995439 157.7193670289059355 3526223.4930035253055394 3526223.5847073253244162 / 
//               -0.0000046664596348 136.6765493333416259 3510223.4724952317774296 3510223.5641990317963064 / 
//               -0.0000045970719083 129.9309411371636145 3219932.4341252767480910 3219932.5258290767669678 / 
//               -0.0000045477285294 116.9683110659760246 3011787.4589210310950875 3011787.5506248311139643 / 



///////////////////////////////////////////////////////////////
// INTERPOLATED LUNAR APOGEE: /////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double INTPAPOG_MAX_LON_SPEED = 0.240442;
// NOTOPO, SWI: 0.2404397685248938 89.8053235290185228 -225439.3984518394863699 / 

  static final double INTPAPOG_MIN_LON_SPEED = -0.155670;
// NOTOPO, SWI: -0.1556655965864008 181.3399982738732206 -248811.1206210330128670 / 

  static final double INTPAPOG_MAX_LON_ACCEL = 0.0103163;
// NOTOPO, SWI: 0.0103153290223904 161.0071618862759806 -213377.5059353846590966 -213377.4142315846693236 / 

  static final double INTPAPOG_MIN_LON_ACCEL = -0.0103726;
// NOTOPO, SWI: -0.0103706122872579 200.8631529108065763 -203530.1684848828590475 -203530.0767810828692745 / 

  static final double INTPAPOG_MAX_TOPO_LON_SPEED = 0.240440;
// TOPO, SWI:   0.2404397685248938 89.8070148752872228 -225439.3984518394863699 /   11.0   52.2 -110000.0

  static final double INTPAPOG_MIN_TOPO_LON_SPEED = -0.1556659;
// TOPO, SWI:   -0.1556655965864008 181.3381794957473687 -248811.1206210330128670 /   11.0   52.2 -110000.0

  static final double INTPAPOG_MAX_TOPO_LON_ACCEL = 0.0103158;
// TOPO, SWI:   0.0103153290223904 161.0054436817775922 -213377.5059353846590966 -213377.4142315846693236 /   11.0   52.2 -110000.0

  static final double INTPAPOG_MIN_TOPO_LON_ACCEL = -0.0103707;
// TOPO, SWI:   -0.0103706122872579 200.8622494083237200 -203530.1684848828590475 -203530.0767810828692745 /   11.0   52.2 -110000.0

// No heliocentric positions for the interpolated lunar apogee...
  static final double INTPAPOG_MAX_HELIO_LON_SPEED = 1./0.;
  static final double INTPAPOG_MIN_HELIO_LON_SPEED = 1./0.;
  static final double INTPAPOG_MAX_HELIO_LON_ACCEL = 1./0.;
  static final double INTPAPOG_MIN_HELIO_LON_ACCEL = 1./0.;


  static final double INTPAPOG_MAX_LAT_SPEED = 0.031604;
// NOTOPO, SWI: 0.0315994798603946 87.9936727871609463 113881.2599290367797948 / 

  static final double INTPAPOG_MIN_LAT_SPEED = -0.031613;
// NOTOPO, SWI: -0.0316127256048458 90.0716920369863772 86498.3218401453632396 / 

  static final double INTPAPOG_MAX_LAT_ACCEL = 0.00109429;
// NOTOPO, SWI: 0.0010942503832445 159.2212151742582193 129241.3713183611835120 129241.4630221611878369 / 

  static final double INTPAPOG_MIN_LAT_ACCEL = -0.0010990;
// NOTOPO, SWI: -0.0010988461699215 159.2054935712743031 193893.8341646414774004 193893.9258684414671734 / 

  static final double INTPAPOG_MAX_TOPO_LAT_SPEED = 0.03159950;
// TOPO, SWI:   0.0315994798603946 87.9958094942441136 113881.2599290367797948 /   11.0   52.2 -110000.0

  static final double INTPAPOG_MIN_TOPO_LAT_SPEED = -0.031610;
// TOPO, SWI:   -0.0316127256048458 90.0695815720781354 86498.3218401453632396 /   11.0   52.2 -110000.0

  static final double INTPAPOG_MAX_TOPO_LAT_ACCEL = 0.00109428;
// TOPO, SWI:   0.0010942503832445 159.2203358042442574 129241.3713183611835120 129241.4630221611878369 /   11.0   52.2 -110000.0

  static final double INTPAPOG_MIN_TOPO_LAT_ACCEL = -0.00109888;
// TOPO, SWI:   -0.0010988461699215 159.2044287384800043 193893.8341646414774004 193893.9258684414671734 /   11.0   52.2 -110000.0

// No heliocentric positions for the interpolated lunar apogee...
  static final double INTPAPOG_MAX_HELIO_LAT_SPEED = 1./0.;
  static final double INTPAPOG_MIN_HELIO_LAT_SPEED = 1./0.;
  static final double INTPAPOG_MAX_HELIO_LAT_ACCEL = 1./0.;
  static final double INTPAPOG_MIN_HELIO_LAT_ACCEL = 1./0.;


  static final double INTPAPOG_MAX_DIST_SPEED = 0.00000026577;
// NOTOPO, SWI: 0.0000002657689017 53.6816352061185000 117431.3891386042087106 / 

  static final double INTPAPOG_MIN_DIST_SPEED = -0.00000026575;
// NOTOPO, SWI: -0.0000002657174555 53.4782487399821207 73067.1998839119332843 / 

  static final double INTPAPOG_MAX_DIST_ACCEL = 0.0000000080677;
// NOTOPO, SWI: 0.0000000080672739 90.8251587442524198 -225234.3487550623540301 -225234.2570512623642571 / 

  static final double INTPAPOG_MIN_DIST_ACCEL = -0.000000006945;
// NOTOPO, SWI: -0.0000000069406502 20.5051785050152091 -228442.5144939045712817 -228442.4227901045815088 / 

  static final double INTPAPOG_MAX_TOPO_DIST_SPEED = 0.00000026584;
// TOPO, SWI:   0.0000002657689017 53.6811086900653294 117431.3891386042087106 /   11.0   52.2 -110000.0

  static final double INTPAPOG_MIN_TOPO_DIST_SPEED = -0.00000026578;
// TOPO, SWI:   -0.0000002657174555 53.4794988864201173 73067.1998839119332843 /   11.0   52.2 -110000.0

  static final double INTPAPOG_MAX_TOPO_DIST_ACCEL = 0.0000000080677;
// TOPO, SWI:   0.0000000080672739 90.8246001429053251 -225234.3487550623540301 -225234.2570512623642571 /   11.0   52.2 -110000.0

  static final double INTPAPOG_MIN_TOPO_DIST_ACCEL = -0.0000000069411;
// TOPO, SWI:   -0.0000000069406502 20.5045668379371619 -228442.5144939045712817 -228442.4227901045815088 /   11.0   52.2 -110000.0

// No heliocentric positions for the interpolated lunar apogee...
  static final double INTPAPOG_MAX_HELIO_DIST_SPEED = 1./0.;
  static final double INTPAPOG_MIN_HELIO_DIST_SPEED = 1./0.;
  static final double INTPAPOG_MAX_HELIO_DIST_ACCEL = 1./0.;
  static final double INTPAPOG_MIN_HELIO_DIST_ACCEL = 1./0.;



///////////////////////////////////////////////////////////////
// INTERPOLATED LUNAR PERIGEE: ////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double INTPPERG_MAX_LON_SPEED = 0.583372;
// NOTOPO, SWI: 0.5833691782377636 180.7541537466819648 -195482.2429977803840302 / 

  static final double INTPPERG_MIN_LON_SPEED = -2.33189;
// NOTOPO, SWI: -2.3318574545550006 90.4900510056987173 -225440.0403784394147806 / 

  static final double INTPPERG_MAX_LON_ACCEL = 0.185425;
// NOTOPO, SWI: 0.1854155305874408 75.5854712193087153 -225435.3634846399363596 -225435.2717808399465866 / 

  static final double INTPPERG_MIN_LON_ACCEL = -0.185357;
// NOTOPO, SWI: -0.1853488568522996 105.1872612317180256 -225444.8089760388829745 -225444.7172722388932016 / 

  static final double INTPPERG_MAX_TOPO_LON_SPEED = 0.583371;
// TOPO, SWI:   0.5833691782377636 180.7521396528094044 -195482.2429977803840302 /   11.0   52.2 -110000.0

  static final double INTPPERG_MIN_TOPO_LON_SPEED = -2.33188;
// TOPO, SWI:   -2.3318574545550006 90.4891309374753803 -225440.0403784394147806 /   11.0   52.2 -110000.0

  static final double INTPPERG_MAX_TOPO_LON_ACCEL = 0.185418;
// TOPO, SWI:   0.1854155305874408 75.5833331251805873 -225435.3634846399363596 -225435.2717808399465866 /   11.0   52.2 -110000.0

  static final double INTPPERG_MIN_TOPO_LON_ACCEL = -0.185353;
// TOPO, SWI:   -0.1853488568522996 105.1878730265365505 -225444.8089760388829745 -225444.7172722388932016 /   11.0   52.2 -110000.0

// No heliocentric positions for the interpolated lunar apogee...
  static final double INTPPERG_MAX_HELIO_LON_SPEED = 1./0.;
  static final double INTPPERG_MIN_HELIO_LON_SPEED = 1./0.;
  static final double INTPPERG_MAX_HELIO_LON_ACCEL = 1./0.;
  static final double INTPPERG_MIN_HELIO_LON_ACCEL = 1./0.;


  static final double INTPPERG_MAX_LAT_SPEED = 0.193078;
// NOTOPO, SWI: 0.1930717143394080 90.0115560113064532 113883.4608202368835919 / 

  static final double INTPPERG_MIN_LAT_SPEED = -0.193022;
// NOTOPO, SWI: -0.1930161983476893 89.4196971936011806 86497.8633211453416152 / 

  static final double INTPPERG_MAX_LAT_ACCEL = 0.016642;
// NOTOPO, SWI: 0.0166359116524948 76.2925199859609791 49235.2163400813224143 49235.3080438813194633 / 

  static final double INTPPERG_MIN_LAT_ACCEL = -0.016678;
// NOTOPO, SWI: -0.0166704364156631 102.9727818515069657 21849.5271389294648543 21849.6188427294655412 / 

  static final double INTPPERG_MAX_TOPO_LAT_SPEED = 0.193073;
// TOPO, SWI:   0.1930717143394080 90.0105331109555209 113883.4608202368835919 /   11.0   52.2 -110000.0

  static final double INTPPERG_MIN_TOPO_LAT_SPEED = -0.193018;
// TOPO, SWI:   -0.1930161983476893 89.4192992318445903 86497.8633211453416152 /   11.0   52.2 -110000.0

  static final double INTPPERG_MAX_TOPO_LAT_ACCEL = 0.016639;
// TOPO, SWI:   0.0166359116524948 76.2903781852012628 49235.2163400813224143 49235.3080438813194633 /   11.0   52.2 -110000.0

  static final double INTPPERG_MIN_TOPO_LAT_ACCEL = -0.016674;
// TOPO, SWI:   -0.0166704364156631 102.9735765715234663 21849.5271389294648543 21849.6188427294655412 /   11.0   52.2 -110000.0

// No heliocentric positions for the interpolated lunar apogee...
  static final double INTPPERG_MAX_HELIO_LAT_SPEED = 1./0.;
  static final double INTPPERG_MIN_HELIO_LAT_SPEED = 1./0.;
  static final double INTPPERG_MAX_HELIO_LAT_ACCEL = 1./0.;
  static final double INTPPERG_MIN_HELIO_LAT_ACCEL = 1./0.;


  static final double INTPPERG_MAX_DIST_SPEED = 0.00000143617;
// NOTOPO, SWI: 0.0000014361421628 141.2208548421972978 -170288.1829151900892612 / 

  static final double INTPPERG_MIN_DIST_SPEED = -0.00000143606;
// NOTOPO, SWI: -0.0000014360402824 139.9198637739893059 -162611.6578180461947341 / 

  static final double INTPPERG_MAX_DIST_ACCEL = 0.0000000294169;
// NOTOPO, SWI: 0.0000000294167244 180.4954568523366447 -134123.4138322232756764 -134123.3221284232859034 / 

  static final double INTPPERG_MIN_DIST_ACCEL = -0.00000015879;
// NOTOPO, SWI: -0.0000001587702460 89.4060875782472237 -194761.3594260607787874 -194761.2677222607890144 / 

  static final double INTPPERG_MAX_TOPO_DIST_SPEED = 0.00000143615;
// TOPO, SWI:   0.0000014361421628 141.2194617019951295 -170288.1829151900892612 /   11.0   52.2 -110000.0

  static final double INTPPERG_MIN_TOPO_DIST_SPEED = -0.00000143607;
// TOPO, SWI:   -0.0000014360402824 139.9202523240743119 -162611.6578180461947341 /   11.0   52.2 -110000.0

  static final double INTPPERG_MAX_TOPO_DIST_ACCEL = 0.000000029418;
// TOPO, SWI:   0.0000000294167244 180.4935094803453808 -134123.4138322232756764 -134123.3221284232859034 /   11.0   52.2 -110000.0

  static final double INTPPERG_MIN_TOPO_DIST_ACCEL = -0.00000015880;
// TOPO, SWI:   -0.0000001587702460 89.4081386018435751 -194761.3594260607787874 -194761.2677222607890144 /   11.0   52.2 -110000.0

// No heliocentric positions for the interpolated lunar apogee...
  static final double INTPPERG_MAX_HELIO_DIST_SPEED = 1./0.;
  static final double INTPPERG_MIN_HELIO_DIST_SPEED = 1./0.;
  static final double INTPPERG_MAX_HELIO_DIST_ACCEL = 1./0.;
  static final double INTPPERG_MIN_HELIO_DIST_ACCEL = 1./0.;



///////////////////////////////////////////////////////////////
// SURYA S max notopo:  1.0243864993
// SURYA S min notopo:  0.9486638198
// SURYA S max topo3:   1.0388159322
// SURYA S min topo3:   0.9347718616
// CHANDRA max notopo:  15.4042491124
// CHANDRA min notopo: 11.7571075192
// CHANDRA max topo3:   21.5666962324
// CHANDRA min topo3:  6.1294391379
// CHANDRA max notopo:  0.5186888
// CHANDRA min notopo:  -0.5188292
// CHANDRA max topo3:   38.1641267
// CHANDRA min topo3:   -38.1716335
// BUDHA max notopo:  2.2121102506 //??? 2.2537837349
// BUDHA min notopo:  -1.3908278667
// BUDHA max topo3:   2.2229697247
// BUDHA min topo3:   -1.4125035236
// BUDHA max notopo:  0.1968066, everything beyond seems to be unexact
//                         calculation due to too much nearness to the sun!
// BUDHA min notopo: -0.1986822, everything beyond seems to be unexact
//                         calculation due to too much nearness to the sun!
// BUDHA max topo3: 8.4292471 // SY-Problem? Realistic: 0.3244554
// BUDHA min topo3: -34.4871693 // SY-Problem? Realistic: -0.3282049
// SHUKRA max notopo: 1.2644483889
// SHUKRA max topo3:  1.2733039990
// SHUKRA min notopo: -0.6437175784
// SHUKRA min topo3:  -0.6963885604 // Sy-Problem???
// SHUKRA max notopo:  0.0423762, everything beyond seems to be unexact
//                         calculation due to too much nearness to the sun!
// SHUKRA min notopo: -0.0430388, everything beyond seems to be unexact
//                         calculation due to too much nearness to the sun!
// SHUKRA max topo3: 1.1127520 // SY-Problem? Realistic: 0.3878079
// SHUKRA min topo3: -2.9288472 // SY-Problem? Realistic: -0.3884931
// MANGALA max notopo: 0.7924011226
// MANGALA max topo3:  0.7985878049
// MANGALA min notopo: -0.4035104555
// MANGALA min topo3:  -0.4261278855
// MANGALA max notopo:  0.0144224, everything beyond seems to be unexact
//                     calculation due to too much nearness to the sun!
// MANGALA min notopo: -0.0152010, everything beyond seems to be unexact
//                     calculation due to too much nearness to the sun!
// MANGALA max topo3:   5.3859140 // SY-Problem? Realistic: 0.2652052
// MANGALA min topo3:   -0.7430761 // SY-Problem? Realistic: -0.2653766
// SHANI max notopo: 0.1338471290 // Sy-Problem 0.1342611535?
// SHANI max topo3:  0.1353554794
// SHANI min notopo: -0.0842836027
// SHANI min topo3:  -0.0860881714
// SHANI max notopo:  0.0020007, everything beyond seems to be unexact
//                         calculation due to too much nearness to the sun!
// SHANI min notopo: -0.0019460, everything beyond seems to be unexact
//                         calculation due to too much nearness to the sun!
// SHANI max topo3: 47.8021777 // SY-problem? Realistic: 0.0135465
// SHANI min topo3: -9.9611508 // SY-problem? Realistic: -0.0134697
// GURU S max notopo: 0.2440423861
// GURU S min notopo: -0.1368372415
// GURU S max topo3:  0.2465672865
// GURU S min topo3:  -0.1403921701
// GURU A max notopo:  0.0036155, everything beyond seems to be unexact
//                    calculation due to too much nearness to the sun!
// GURU A min notopo: -0.0034178, everything beyond seems to be unexact
//                    calculation due to too much nearness to the sun!
// GURU A max topo3: 3.6034504 // SY-problem? Realistic: 0.0266245
// GURU A min topo3: -16.4451885 // SY-problem? Realistic: -0.0267212
// URANUS A max notopo:  0.0009501, everything beyond seems to be unexact
//                      calculation due to too much nearness to the sun!
// URANUS A min notopo: -0.0009897, everything beyond seems to be unexact
//                      calculation due to too much nearness to the sun!
// URANUS A max topo3: 8.4594472 // SY-problem? Realistic: 0.0063635
// URANUS A min topo3: -44.1816134 // SY-problem? Realistic: -0.0064026
// URANUS S max notopo: 0.0637152951 // Sy-Problem beyond?
// URANUS S max topo3:  0.0681905640
// URANUS S min notopo: -0.0439752018
// URANUS S min topo3:  -0.0447987374
// NEPTUNE A max notopo:  0.0006291, everything beyond seems to be unexact
//                       calculation due to too much nearness to the sun!
// NEPTUNE A min notopo: -0.0006255, everything beyond seems to be unexact
//                       calculation due to too much nearness to the sun!
// NEPTUNE A max topo3: 5.9498810 // SY-problem? Realistic: 0.0039052
// NEPTUNE A min topo3: -12.7924566 // SY-problem? Realistic: -0.0038898
// NEPTUNE S max notopo: 0.0381288654 // Sy-Problem? 0.0432424224
// NEPTUNE S max topo3:  0.0437376690
// NEPTUNE S min notopo: -0.0285824820
// NEPTUNE S min topo3:  -0.0290549670
// PLUTO A max notopo:  0.0006226, everything beyond seems to be unexact
//                     calculation due to too much nearness to the sun!
// PLUTO A min notopo: -0.0006607, everything beyond seems to be unexact
//                     calculation due to too much nearness to the sun!
// PLUTO A max topo3: 1.2429646 // SY-problem? Realistic: 0.0040215
// PLUTO A min topo3: -1.7390824 // SY-problem? Realistic: -0.0040603
// PLUTO S max notopo: 0.0409935333
// PLUTO S max topo3:  0.0414652881
// PLUTO S min notopo: -0.0283697947
// PLUTO S min topo3:  -0.0289179185
// MNODE A max notopo:  0.0000508
// MNODE A min notopo: -0.0000508
// MNODE A max topo3:  0.0000508
// MNODE A min topo3: -0.0000508
// MNODE S max notopo: -0.0528817186
// MNODE S max topo3:  -0.0528817186
// MNODE S min notopo: -0.0530035225
// MNODE S min topo3:  -0.0530035225
// TNODE A max notopo: 573.1032358  // Errors in calculations???
// TNODE A min notopo: -444.7164997 // Errors in calculations???
// TNODE A max topo3: 695.8627388 // Errors in calculations???
// TNODE A min topo3: -444.6272115 // Errors in calculations???
// TNODE S max notopo: 0.4448616947
// TNODE S max topo3:  0.4448616947
// TNODE S min notopo: -0.5805968771
// TNODE S min topo3:  -0.5805968771
///////////////////////////////////////////////////////////////



  // Speeds and accelerations in longitudinal direction:
  // Maximum geocentric speeds in longitudinal direction:
  static final double[] maxLonSpeed = new double[]
      {SURYA_MAX_LON_SPEED,   CHANDRA_MAX_LON_SPEED, BUDHA_MAX_LON_SPEED,
       SHUKRA_MAX_LON_SPEED,  MANGALA_MAX_LON_SPEED, GURU_MAX_LON_SPEED,
       SHANI_MAX_LON_SPEED,   URANUS_MAX_LON_SPEED,  NEPTUNE_MAX_LON_SPEED,
       PLUTO_MAX_LON_SPEED,   MNODE_MAX_LON_SPEED,   TNODE_MAX_LON_SPEED,
       MAPOGEE_MAX_LON_SPEED, OAPOGEE_MAX_LON_SPEED, 1./0,
       CHIRON_MAX_LON_SPEED,  PHOLUS_MAX_LON_SPEED,  CERES_MAX_LON_SPEED,
       PALLAS_MAX_LON_SPEED,  JUNO_MAX_LON_SPEED,    VESTA_MAX_LON_SPEED,
       INTPAPOG_MAX_LON_SPEED,INTPPERG_MAX_LON_SPEED};
  // Minimum geocentric speeds in longitudinal direction:
  static final double[] minLonSpeed = new double[]
      {SURYA_MIN_LON_SPEED,   CHANDRA_MIN_LON_SPEED, BUDHA_MIN_LON_SPEED,
       SHUKRA_MIN_LON_SPEED,  MANGALA_MIN_LON_SPEED, GURU_MIN_LON_SPEED,
       SHANI_MIN_LON_SPEED,   URANUS_MIN_LON_SPEED,  NEPTUNE_MIN_LON_SPEED,
       PLUTO_MIN_LON_SPEED,   MNODE_MIN_LON_SPEED,   TNODE_MIN_LON_SPEED,
       MAPOGEE_MIN_LON_SPEED, OAPOGEE_MIN_LON_SPEED, 1./0,
       CHIRON_MIN_LON_SPEED,  PHOLUS_MIN_LON_SPEED,  CERES_MIN_LON_SPEED,
       PALLAS_MIN_LON_SPEED,  JUNO_MIN_LON_SPEED,    VESTA_MIN_LON_SPEED,
       INTPAPOG_MIN_LON_SPEED,INTPPERG_MIN_LON_SPEED};

  // Maximum topocentric speeds in longitudinal direction, up to 50000m
  // altitude:
  static final double[] maxTopoLonSpeed = new double[]
      {SURYA_MAX_TOPO_LON_SPEED,   CHANDRA_MAX_TOPO_LON_SPEED,
       BUDHA_MAX_TOPO_LON_SPEED,   SHUKRA_MAX_TOPO_LON_SPEED,
       MANGALA_MAX_TOPO_LON_SPEED, GURU_MAX_TOPO_LON_SPEED,
       SHANI_MAX_TOPO_LON_SPEED,   URANUS_MAX_TOPO_LON_SPEED,
       NEPTUNE_MAX_TOPO_LON_SPEED, PLUTO_MAX_TOPO_LON_SPEED,
       MNODE_MAX_TOPO_LON_SPEED,   TNODE_MAX_TOPO_LON_SPEED,
       MAPOGEE_MAX_TOPO_LON_SPEED, OAPOGEE_MAX_TOPO_LON_SPEED,
       1./0,                       CHIRON_MAX_TOPO_LON_SPEED,
       PHOLUS_MAX_TOPO_LON_SPEED,  CERES_MAX_TOPO_LON_SPEED,
       PALLAS_MAX_TOPO_LON_SPEED,  JUNO_MAX_TOPO_LON_SPEED,
       VESTA_MAX_TOPO_LON_SPEED,   INTPAPOG_MAX_TOPO_LON_SPEED,
       INTPPERG_MAX_TOPO_LON_SPEED};
  // Minimum topocentric speeds in longitudinal direction, up to 50000m
  // altitude:
  static final double[] minTopoLonSpeed = new double[]
      {SURYA_MIN_TOPO_LON_SPEED,   CHANDRA_MIN_TOPO_LON_SPEED,
       BUDHA_MIN_TOPO_LON_SPEED,   SHUKRA_MIN_TOPO_LON_SPEED,
       MANGALA_MIN_TOPO_LON_SPEED, GURU_MIN_TOPO_LON_SPEED,
       SHANI_MIN_TOPO_LON_SPEED,   URANUS_MIN_TOPO_LON_SPEED,
       NEPTUNE_MIN_TOPO_LON_SPEED, PLUTO_MIN_TOPO_LON_SPEED,
       MNODE_MIN_TOPO_LON_SPEED,   TNODE_MIN_TOPO_LON_SPEED,
       MAPOGEE_MIN_TOPO_LON_SPEED, OAPOGEE_MIN_TOPO_LON_SPEED,
       1./0,                       CHIRON_MIN_TOPO_LON_SPEED,
       PHOLUS_MIN_TOPO_LON_SPEED,  CERES_MIN_TOPO_LON_SPEED,
       PALLAS_MIN_TOPO_LON_SPEED,  JUNO_MIN_TOPO_LON_SPEED,
       VESTA_MIN_TOPO_LON_SPEED,   INTPAPOG_MIN_TOPO_LON_SPEED,
       INTPPERG_MIN_TOPO_LON_SPEED};

  // Maximum heliocentric speeds in longitudinal direction:
  static final double[] maxHelioLonSpeed = new double[]
      {SURYA_MAX_HELIO_LON_SPEED,   CHANDRA_MAX_HELIO_LON_SPEED,
       BUDHA_MAX_HELIO_LON_SPEED,   SHUKRA_MAX_HELIO_LON_SPEED,
       MANGALA_MAX_HELIO_LON_SPEED, GURU_MAX_HELIO_LON_SPEED,
       SHANI_MAX_HELIO_LON_SPEED,   URANUS_MAX_HELIO_LON_SPEED,
       NEPTUNE_MAX_HELIO_LON_SPEED, PLUTO_MAX_HELIO_LON_SPEED,
       MNODE_MAX_HELIO_LON_SPEED,   TNODE_MAX_HELIO_LON_SPEED,
       MAPOGEE_MAX_HELIO_LON_SPEED, OAPOGEE_MAX_HELIO_LON_SPEED,
       1./0,                        CHIRON_MAX_HELIO_LON_SPEED,
       PHOLUS_MAX_HELIO_LON_SPEED,  CERES_MAX_HELIO_LON_SPEED,
       PALLAS_MAX_HELIO_LON_SPEED,  JUNO_MAX_HELIO_LON_SPEED,
       VESTA_MAX_HELIO_LON_SPEED,   INTPAPOG_MAX_HELIO_LON_SPEED,
       INTPPERG_MAX_HELIO_LON_SPEED};
  // Minimum heliocentric speeds in longitudinal direction:
  static final double[] minHelioLonSpeed = new double[]
      {SURYA_MIN_HELIO_LON_SPEED,   CHANDRA_MIN_HELIO_LON_SPEED,
       BUDHA_MIN_HELIO_LON_SPEED,   SHUKRA_MIN_HELIO_LON_SPEED,
       MANGALA_MIN_HELIO_LON_SPEED, GURU_MIN_HELIO_LON_SPEED,
       SHANI_MIN_HELIO_LON_SPEED,   URANUS_MIN_HELIO_LON_SPEED,
       NEPTUNE_MIN_HELIO_LON_SPEED, PLUTO_MIN_HELIO_LON_SPEED,
       MNODE_MIN_HELIO_LON_SPEED,   TNODE_MIN_HELIO_LON_SPEED,
       MAPOGEE_MIN_HELIO_LON_SPEED, OAPOGEE_MIN_HELIO_LON_SPEED,
       1./0,                        CHIRON_MIN_HELIO_LON_SPEED,
       PHOLUS_MIN_HELIO_LON_SPEED,  CERES_MIN_HELIO_LON_SPEED,
       PALLAS_MIN_HELIO_LON_SPEED,  JUNO_MIN_HELIO_LON_SPEED,
       VESTA_MIN_HELIO_LON_SPEED,   INTPAPOG_MIN_HELIO_LON_SPEED,
       INTPPERG_MIN_HELIO_LON_SPEED};

  // Maximum geocentric accelerations in longitudinal direction:
  static final double[] maxLonAccel = new double[]
      {SURYA_MAX_LON_ACCEL,   CHANDRA_MAX_LON_ACCEL, BUDHA_MAX_LON_ACCEL,
       SHUKRA_MAX_LON_ACCEL,  MANGALA_MAX_LON_ACCEL, GURU_MAX_LON_ACCEL,
       SHANI_MAX_LON_ACCEL,   URANUS_MAX_LON_ACCEL,  NEPTUNE_MAX_LON_ACCEL,
       PLUTO_MAX_LON_ACCEL,   MNODE_MAX_LON_ACCEL,   TNODE_MAX_LON_ACCEL,
       MAPOGEE_MAX_LON_ACCEL, OAPOGEE_MAX_LON_ACCEL, 1./0,
       CHIRON_MAX_LON_ACCEL,  PHOLUS_MAX_LON_ACCEL,  CERES_MAX_LON_ACCEL,
       PALLAS_MAX_LON_ACCEL,  JUNO_MAX_LON_ACCEL,    VESTA_MAX_LON_ACCEL,
       INTPAPOG_MAX_LON_ACCEL,INTPPERG_MAX_LON_ACCEL};
  // Minimum geocentric accelerations in longitudinal direction:
  static final double[] minLonAccel = new double[]
      {SURYA_MIN_LON_ACCEL,   CHANDRA_MIN_LON_ACCEL, BUDHA_MIN_LON_ACCEL,
       SHUKRA_MIN_LON_ACCEL,  MANGALA_MIN_LON_ACCEL, GURU_MIN_LON_ACCEL,
       SHANI_MIN_LON_ACCEL,   URANUS_MIN_LON_ACCEL,  NEPTUNE_MIN_LON_ACCEL,
       PLUTO_MIN_LON_ACCEL,   MNODE_MIN_LON_ACCEL,   TNODE_MIN_LON_ACCEL,
       MAPOGEE_MIN_LON_ACCEL, OAPOGEE_MIN_LON_ACCEL, 1./0,
       CHIRON_MIN_LON_ACCEL,  PHOLUS_MIN_LON_ACCEL,  CERES_MIN_LON_ACCEL,
       PALLAS_MIN_LON_ACCEL,  JUNO_MIN_LON_ACCEL,    VESTA_MIN_LON_ACCEL,
       INTPAPOG_MIN_LON_ACCEL,INTPPERG_MIN_LON_ACCEL};

  // Maximum topocentric accelerations in longitudinal direction, up to
  // 50000m altitude:
  static final double[] maxTopoLonAccel = new double[]
      {SURYA_MAX_TOPO_LON_ACCEL,   CHANDRA_MAX_TOPO_LON_ACCEL,
       BUDHA_MAX_TOPO_LON_ACCEL,   SHUKRA_MAX_TOPO_LON_ACCEL,
       MANGALA_MAX_TOPO_LON_ACCEL, GURU_MAX_TOPO_LON_ACCEL,
       SHANI_MAX_TOPO_LON_ACCEL,   URANUS_MAX_TOPO_LON_ACCEL,
       NEPTUNE_MAX_TOPO_LON_ACCEL, PLUTO_MAX_TOPO_LON_ACCEL,
       MNODE_MAX_TOPO_LON_ACCEL,   TNODE_MAX_TOPO_LON_ACCEL,
       MAPOGEE_MAX_TOPO_LON_ACCEL, OAPOGEE_MAX_TOPO_LON_ACCEL,
       1./0,                       CHIRON_MAX_TOPO_LON_ACCEL,
       PHOLUS_MAX_TOPO_LON_ACCEL,  CERES_MAX_TOPO_LON_ACCEL,
       PALLAS_MAX_TOPO_LON_ACCEL,  JUNO_MAX_TOPO_LON_ACCEL,
       VESTA_MAX_TOPO_LON_ACCEL,   INTPAPOG_MAX_TOPO_LON_ACCEL,
       INTPPERG_MAX_TOPO_LON_ACCEL};
  // Minimum topocentric accelerations in longitudinal direction, up to
  // 50000m altitude:
  static final double[] minTopoLonAccel = new double[]
      {SURYA_MIN_TOPO_LON_ACCEL,   CHANDRA_MIN_TOPO_LON_ACCEL,
       BUDHA_MIN_TOPO_LON_ACCEL,   SHUKRA_MIN_TOPO_LON_ACCEL,
       MANGALA_MIN_TOPO_LON_ACCEL, GURU_MIN_TOPO_LON_ACCEL,
       SHANI_MIN_TOPO_LON_ACCEL,   URANUS_MIN_TOPO_LON_ACCEL,
       NEPTUNE_MIN_TOPO_LON_ACCEL, PLUTO_MIN_TOPO_LON_ACCEL,
       MNODE_MIN_TOPO_LON_ACCEL,   TNODE_MIN_TOPO_LON_ACCEL,
       MAPOGEE_MIN_TOPO_LON_ACCEL, OAPOGEE_MIN_TOPO_LON_ACCEL,
       1./0,                       CHIRON_MIN_TOPO_LON_ACCEL,
       PHOLUS_MIN_TOPO_LON_ACCEL,  CERES_MIN_TOPO_LON_ACCEL,
       PALLAS_MIN_TOPO_LON_ACCEL,  JUNO_MIN_TOPO_LON_ACCEL,
       VESTA_MIN_TOPO_LON_ACCEL,   INTPAPOG_MIN_TOPO_LON_ACCEL,
       INTPPERG_MIN_TOPO_LON_ACCEL};

  // Maximum heliocentric accelerations in longitudinal direction:
  static final double[] maxHelioLonAccel = new double[]
      {SURYA_MAX_HELIO_LON_ACCEL,   CHANDRA_MAX_HELIO_LON_ACCEL,
       BUDHA_MAX_HELIO_LON_ACCEL,   SHUKRA_MAX_HELIO_LON_ACCEL,
       MANGALA_MAX_HELIO_LON_ACCEL, GURU_MAX_HELIO_LON_ACCEL,
       SHANI_MAX_HELIO_LON_ACCEL,   URANUS_MAX_HELIO_LON_ACCEL,
       NEPTUNE_MAX_HELIO_LON_ACCEL, PLUTO_MAX_HELIO_LON_ACCEL,
       MNODE_MAX_HELIO_LON_ACCEL,   TNODE_MAX_HELIO_LON_ACCEL,
       MAPOGEE_MAX_HELIO_LON_ACCEL, OAPOGEE_MAX_HELIO_LON_ACCEL,
       1./0,                        CHIRON_MAX_HELIO_LON_ACCEL,
       PHOLUS_MAX_HELIO_LON_ACCEL,  CERES_MAX_HELIO_LON_ACCEL,
       PALLAS_MAX_HELIO_LON_ACCEL,  JUNO_MAX_HELIO_LON_ACCEL,
       VESTA_MAX_HELIO_LON_ACCEL,   INTPAPOG_MAX_HELIO_LON_ACCEL,
       INTPPERG_MAX_HELIO_LON_ACCEL};
  // Minimum heliocentric accelerations in longitudinal direction:
  static final double[] minHelioLonAccel = new double[]
      {SURYA_MIN_HELIO_LON_ACCEL,   CHANDRA_MIN_HELIO_LON_ACCEL,
       BUDHA_MIN_HELIO_LON_ACCEL,   SHUKRA_MIN_HELIO_LON_ACCEL,
       MANGALA_MIN_HELIO_LON_ACCEL, GURU_MIN_HELIO_LON_ACCEL,
       SHANI_MIN_HELIO_LON_ACCEL,   URANUS_MIN_HELIO_LON_ACCEL,
       NEPTUNE_MIN_HELIO_LON_ACCEL, PLUTO_MIN_HELIO_LON_ACCEL,
       MNODE_MIN_HELIO_LON_ACCEL,   TNODE_MIN_HELIO_LON_ACCEL,
       MAPOGEE_MIN_HELIO_LON_ACCEL, OAPOGEE_MIN_HELIO_LON_ACCEL,
       1./0,                        CHIRON_MIN_HELIO_LON_ACCEL,
       PHOLUS_MIN_HELIO_LON_ACCEL,  CERES_MIN_HELIO_LON_ACCEL,
       PALLAS_MIN_HELIO_LON_ACCEL,  JUNO_MIN_HELIO_LON_ACCEL,
       VESTA_MIN_HELIO_LON_ACCEL,   INTPAPOG_MIN_HELIO_LON_ACCEL,
       INTPPERG_MIN_HELIO_LON_ACCEL};




  // Speeds and accelerations in latitudinal direction:
  // Maximum geocentric speeds in latitudinal direction:
  static final double[] maxLatSpeed = new double[]
      {SURYA_MAX_LAT_SPEED,   CHANDRA_MAX_LAT_SPEED, BUDHA_MAX_LAT_SPEED,
       SHUKRA_MAX_LAT_SPEED,  MANGALA_MAX_LAT_SPEED, GURU_MAX_LAT_SPEED,
       SHANI_MAX_LAT_SPEED,   URANUS_MAX_LAT_SPEED,  NEPTUNE_MAX_LAT_SPEED,
       PLUTO_MAX_LAT_SPEED,   MNODE_MAX_LAT_SPEED,   TNODE_MAX_LAT_SPEED,
       MAPOGEE_MAX_LAT_SPEED, OAPOGEE_MAX_LAT_SPEED, 1./0,
       CHIRON_MAX_LAT_SPEED,  PHOLUS_MAX_LAT_SPEED,  CERES_MAX_LAT_SPEED,
       PALLAS_MAX_LAT_SPEED,  JUNO_MAX_LAT_SPEED,    VESTA_MAX_LAT_SPEED,
       INTPAPOG_MAX_LAT_SPEED,INTPPERG_MAX_LAT_SPEED};
  // Minimum geocentric speeds in latitudinal direction:
  static final double[] minLatSpeed = new double[]
      {SURYA_MIN_LAT_SPEED,   CHANDRA_MIN_LAT_SPEED, BUDHA_MIN_LAT_SPEED,
       SHUKRA_MIN_LAT_SPEED,  MANGALA_MIN_LAT_SPEED, GURU_MIN_LAT_SPEED,
       SHANI_MIN_LAT_SPEED,   URANUS_MIN_LAT_SPEED,  NEPTUNE_MIN_LAT_SPEED,
       PLUTO_MIN_LAT_SPEED,   MNODE_MIN_LAT_SPEED,   TNODE_MIN_LAT_SPEED,
       MAPOGEE_MIN_LAT_SPEED, OAPOGEE_MIN_LAT_SPEED, 1./0,
       CHIRON_MIN_LAT_SPEED,  PHOLUS_MIN_LAT_SPEED,  CERES_MIN_LAT_SPEED,
       PALLAS_MIN_LAT_SPEED,  JUNO_MIN_LAT_SPEED,    VESTA_MIN_LAT_SPEED,
       INTPAPOG_MIN_LAT_SPEED,INTPPERG_MIN_LAT_SPEED};

  // Maximum topocentric speeds in latitudinal direction, up to 50000m
  // altitude:
  static final double[] maxTopoLatSpeed = new double[]
      {SURYA_MAX_TOPO_LAT_SPEED,   CHANDRA_MAX_TOPO_LAT_SPEED,
       BUDHA_MAX_TOPO_LAT_SPEED,   SHUKRA_MAX_TOPO_LAT_SPEED,
       MANGALA_MAX_TOPO_LAT_SPEED, GURU_MAX_TOPO_LAT_SPEED,
       SHANI_MAX_TOPO_LAT_SPEED,   URANUS_MAX_TOPO_LAT_SPEED,
       NEPTUNE_MAX_TOPO_LAT_SPEED, PLUTO_MAX_TOPO_LAT_SPEED,
       MNODE_MAX_TOPO_LAT_SPEED,   TNODE_MAX_TOPO_LAT_SPEED,
       MAPOGEE_MAX_TOPO_LAT_SPEED, OAPOGEE_MAX_TOPO_LAT_SPEED,
       1./0,                       CHIRON_MAX_TOPO_LAT_SPEED,
       PHOLUS_MAX_TOPO_LAT_SPEED,  CERES_MAX_TOPO_LAT_SPEED,
       PALLAS_MAX_TOPO_LAT_SPEED,  JUNO_MAX_TOPO_LAT_SPEED,
       VESTA_MAX_TOPO_LAT_SPEED,   INTPAPOG_MAX_TOPO_LAT_SPEED,
       INTPPERG_MAX_TOPO_LAT_SPEED};
  // Minimum topocentric speeds in latitudinal direction, up to 50000m
  // altitude:
  static final double[] minTopoLatSpeed = new double[]
      {SURYA_MIN_TOPO_LAT_SPEED,   CHANDRA_MIN_TOPO_LAT_SPEED,
       BUDHA_MIN_TOPO_LAT_SPEED,   SHUKRA_MIN_TOPO_LAT_SPEED,
       MANGALA_MIN_TOPO_LAT_SPEED, GURU_MIN_TOPO_LAT_SPEED,
       SHANI_MIN_TOPO_LAT_SPEED,   URANUS_MIN_TOPO_LAT_SPEED,
       NEPTUNE_MIN_TOPO_LAT_SPEED, PLUTO_MIN_TOPO_LAT_SPEED,
       MNODE_MIN_TOPO_LAT_SPEED,   TNODE_MIN_TOPO_LAT_SPEED,
       MAPOGEE_MIN_TOPO_LAT_SPEED, OAPOGEE_MIN_TOPO_LAT_SPEED,
       1./0,                       CHIRON_MIN_TOPO_LAT_SPEED,
       PHOLUS_MIN_TOPO_LAT_SPEED,  CERES_MIN_TOPO_LAT_SPEED,
       PALLAS_MIN_TOPO_LAT_SPEED,  JUNO_MIN_TOPO_LAT_SPEED,
       VESTA_MIN_TOPO_LAT_SPEED,   INTPAPOG_MIN_TOPO_LAT_SPEED,
       INTPPERG_MIN_TOPO_LAT_SPEED};

  // Maximum heliocentric speeds in latitudinal direction:
  static final double[] maxHelioLatSpeed = new double[]
      {SURYA_MAX_HELIO_LAT_SPEED,   CHANDRA_MAX_HELIO_LAT_SPEED,
       BUDHA_MAX_HELIO_LAT_SPEED,   SHUKRA_MAX_HELIO_LAT_SPEED,
       MANGALA_MAX_HELIO_LAT_SPEED, GURU_MAX_HELIO_LAT_SPEED,
       SHANI_MAX_HELIO_LAT_SPEED,   URANUS_MAX_HELIO_LAT_SPEED,
       NEPTUNE_MAX_HELIO_LAT_SPEED, PLUTO_MAX_HELIO_LAT_SPEED,
       MNODE_MAX_HELIO_LAT_SPEED,   TNODE_MAX_HELIO_LAT_SPEED,
       MAPOGEE_MAX_HELIO_LAT_SPEED, OAPOGEE_MAX_HELIO_LAT_SPEED,
       1./0,                        CHIRON_MAX_HELIO_LAT_SPEED,
       PHOLUS_MAX_HELIO_LAT_SPEED,  CERES_MAX_HELIO_LAT_SPEED,
       PALLAS_MAX_HELIO_LAT_SPEED,  JUNO_MAX_HELIO_LAT_SPEED,
       VESTA_MAX_HELIO_LAT_SPEED,   INTPAPOG_MAX_HELIO_LAT_SPEED,
       INTPPERG_MAX_HELIO_LAT_SPEED};
  // Minimum heliocentric speeds in latitudinal direction:
  static final double[] minHelioLatSpeed = new double[]
      {SURYA_MIN_HELIO_LAT_SPEED,   CHANDRA_MIN_HELIO_LAT_SPEED,
       BUDHA_MIN_HELIO_LAT_SPEED,   SHUKRA_MIN_HELIO_LAT_SPEED,
       MANGALA_MIN_HELIO_LAT_SPEED, GURU_MIN_HELIO_LAT_SPEED,
       SHANI_MIN_HELIO_LAT_SPEED,   URANUS_MIN_HELIO_LAT_SPEED,
       NEPTUNE_MIN_HELIO_LAT_SPEED, PLUTO_MIN_HELIO_LAT_SPEED,
       MNODE_MIN_HELIO_LAT_SPEED,   TNODE_MIN_HELIO_LAT_SPEED,
       MAPOGEE_MIN_HELIO_LAT_SPEED, OAPOGEE_MIN_HELIO_LAT_SPEED,
       1./0,                        CHIRON_MIN_HELIO_LAT_SPEED,
       PHOLUS_MIN_HELIO_LAT_SPEED,  CERES_MIN_HELIO_LAT_SPEED,
       PALLAS_MIN_HELIO_LAT_SPEED,  JUNO_MIN_HELIO_LAT_SPEED,
       VESTA_MIN_HELIO_LAT_SPEED,   INTPAPOG_MAX_HELIO_LAT_SPEED,
       INTPPERG_MIN_HELIO_LAT_SPEED};

  // Maximum geocentric accelerations in latitudinal direction:
  static final double[] maxLatAccel = new double[]
      {SURYA_MAX_LAT_ACCEL,   CHANDRA_MAX_LAT_ACCEL, BUDHA_MAX_LAT_ACCEL,
       SHUKRA_MAX_LAT_ACCEL,  MANGALA_MAX_LAT_ACCEL, GURU_MAX_LAT_ACCEL,
       SHANI_MAX_LAT_ACCEL,   URANUS_MAX_LAT_ACCEL,  NEPTUNE_MAX_LAT_ACCEL,
       PLUTO_MAX_LAT_ACCEL,   MNODE_MAX_LAT_ACCEL,   TNODE_MAX_LAT_ACCEL,
       MAPOGEE_MAX_LAT_ACCEL, OAPOGEE_MAX_LAT_ACCEL, 1./0,
       CHIRON_MAX_LAT_ACCEL,  PHOLUS_MAX_LAT_ACCEL,  CERES_MAX_LAT_ACCEL,
       PALLAS_MAX_LAT_ACCEL,  JUNO_MAX_LAT_ACCEL,    VESTA_MAX_LAT_ACCEL,
       INTPAPOG_MAX_LAT_ACCEL,INTPPERG_MAX_LAT_ACCEL};
  // Minimum geocentric accelerations in latitudinal direction:
  static final double[] minLatAccel = new double[]
      {SURYA_MIN_LAT_ACCEL,   CHANDRA_MIN_LAT_ACCEL, BUDHA_MIN_LAT_ACCEL,
       SHUKRA_MIN_LAT_ACCEL,  MANGALA_MIN_LAT_ACCEL, GURU_MIN_LAT_ACCEL,
       SHANI_MIN_LAT_ACCEL,   URANUS_MIN_LAT_ACCEL,  NEPTUNE_MIN_LAT_ACCEL,
       PLUTO_MIN_LAT_ACCEL,   MNODE_MIN_LAT_ACCEL,   TNODE_MIN_LAT_ACCEL,
       MAPOGEE_MIN_LAT_ACCEL, OAPOGEE_MIN_LAT_ACCEL, 1./0,
       CHIRON_MIN_LAT_ACCEL,  PHOLUS_MIN_LAT_ACCEL,  CERES_MIN_LAT_ACCEL,
       PALLAS_MIN_LAT_ACCEL,  JUNO_MIN_LAT_ACCEL,    VESTA_MIN_LAT_ACCEL,
       INTPAPOG_MIN_LAT_ACCEL,INTPPERG_MIN_LAT_ACCEL};

  // Maximum topocentric accelerations in latitudinal direction, up to
  // 50000m altitude:
  static final double[] maxTopoLatAccel = new double[]
      {SURYA_MAX_TOPO_LAT_ACCEL,   CHANDRA_MAX_TOPO_LAT_ACCEL,
       BUDHA_MAX_TOPO_LAT_ACCEL,   SHUKRA_MAX_TOPO_LAT_ACCEL,
       MANGALA_MAX_TOPO_LAT_ACCEL, GURU_MAX_TOPO_LAT_ACCEL,
       SHANI_MAX_TOPO_LAT_ACCEL,   URANUS_MAX_TOPO_LAT_ACCEL,
       NEPTUNE_MAX_TOPO_LAT_ACCEL, PLUTO_MAX_TOPO_LAT_ACCEL,
       MNODE_MAX_TOPO_LAT_ACCEL,   TNODE_MAX_TOPO_LAT_ACCEL,
       MAPOGEE_MAX_TOPO_LAT_ACCEL, OAPOGEE_MAX_TOPO_LAT_ACCEL,
       1./0,                       CHIRON_MAX_TOPO_LAT_ACCEL,
       PHOLUS_MAX_TOPO_LAT_ACCEL,  CERES_MAX_TOPO_LAT_ACCEL,
       PALLAS_MAX_TOPO_LAT_ACCEL,  JUNO_MAX_TOPO_LAT_ACCEL,
       VESTA_MAX_TOPO_LAT_ACCEL,   INTPAPOG_MAX_TOPO_LAT_ACCEL,
       INTPPERG_MAX_TOPO_LAT_ACCEL};
  // Minimum topocentric accelerations in latitudinal direction, up to
  // 50000m altitude:
  static final double[] minTopoLatAccel = new double[]
      {SURYA_MIN_TOPO_LAT_ACCEL,   CHANDRA_MIN_TOPO_LAT_ACCEL,
       BUDHA_MIN_TOPO_LAT_ACCEL,   SHUKRA_MIN_TOPO_LAT_ACCEL,
       MANGALA_MIN_TOPO_LAT_ACCEL, GURU_MIN_TOPO_LAT_ACCEL,
       SHANI_MIN_TOPO_LAT_ACCEL,   URANUS_MIN_TOPO_LAT_ACCEL,
       NEPTUNE_MIN_TOPO_LAT_ACCEL, PLUTO_MIN_TOPO_LAT_ACCEL,
       MNODE_MIN_TOPO_LAT_ACCEL,   TNODE_MIN_TOPO_LAT_ACCEL,
       MAPOGEE_MIN_TOPO_LAT_ACCEL, OAPOGEE_MIN_TOPO_LAT_ACCEL,
       1./0,                       CHIRON_MIN_TOPO_LAT_ACCEL,
       PHOLUS_MIN_TOPO_LAT_ACCEL,  CERES_MIN_TOPO_LAT_ACCEL,
       PALLAS_MIN_TOPO_LAT_ACCEL,  JUNO_MIN_TOPO_LAT_ACCEL,
       VESTA_MIN_TOPO_LAT_ACCEL,   INTPAPOG_MIN_TOPO_LAT_ACCEL,
       INTPPERG_MIN_TOPO_LAT_ACCEL};

  // Maximum heliocentric accelerations in latitudinal direction:
  static final double[] maxHelioLatAccel = new double[]
      {SURYA_MAX_HELIO_LAT_ACCEL,   CHANDRA_MAX_HELIO_LAT_ACCEL,
       BUDHA_MAX_HELIO_LAT_ACCEL,   SHUKRA_MAX_HELIO_LAT_ACCEL,
       MANGALA_MAX_HELIO_LAT_ACCEL, GURU_MAX_HELIO_LAT_ACCEL,
       SHANI_MAX_HELIO_LAT_ACCEL,   URANUS_MAX_HELIO_LAT_ACCEL,
       NEPTUNE_MAX_HELIO_LAT_ACCEL, PLUTO_MAX_HELIO_LAT_ACCEL,
       MNODE_MAX_HELIO_LAT_ACCEL,   TNODE_MAX_HELIO_LAT_ACCEL,
       MAPOGEE_MAX_HELIO_LAT_ACCEL, OAPOGEE_MAX_HELIO_LAT_ACCEL,
       1./0,                        CHIRON_MAX_HELIO_LAT_ACCEL,
       PHOLUS_MAX_HELIO_LAT_ACCEL,  CERES_MAX_HELIO_LAT_ACCEL,
       PALLAS_MAX_HELIO_LAT_ACCEL,  JUNO_MAX_HELIO_LAT_ACCEL,
       VESTA_MAX_HELIO_LAT_ACCEL,   INTPAPOG_MAX_HELIO_LAT_ACCEL,
       INTPPERG_MAX_HELIO_LAT_ACCEL};
  // Minimum heliocentric accelerations in latitudinal direction:
  static final double[] minHelioLatAccel = new double[]
      {SURYA_MIN_HELIO_LAT_ACCEL,   CHANDRA_MIN_HELIO_LAT_ACCEL,
       BUDHA_MIN_HELIO_LAT_ACCEL,   SHUKRA_MIN_HELIO_LAT_ACCEL,
       MANGALA_MIN_HELIO_LAT_ACCEL, GURU_MIN_HELIO_LAT_ACCEL,
       SHANI_MIN_HELIO_LAT_ACCEL,   URANUS_MIN_HELIO_LAT_ACCEL,
       NEPTUNE_MIN_HELIO_LAT_ACCEL, PLUTO_MIN_HELIO_LAT_ACCEL,
       MNODE_MIN_HELIO_LAT_ACCEL,   TNODE_MIN_HELIO_LAT_ACCEL,
       MAPOGEE_MIN_HELIO_LAT_ACCEL, OAPOGEE_MIN_HELIO_LAT_ACCEL,
       1./0,                        CHIRON_MIN_HELIO_LAT_ACCEL,
       PHOLUS_MIN_HELIO_LAT_ACCEL,  CERES_MIN_HELIO_LAT_ACCEL,
       PALLAS_MIN_HELIO_LAT_ACCEL,  JUNO_MIN_HELIO_LAT_ACCEL,
       VESTA_MIN_HELIO_LAT_ACCEL,   INTPAPOG_MIN_HELIO_LAT_ACCEL,
       INTPPERG_MIN_HELIO_LAT_ACCEL};




  // Speeds and accelerations in the distance to the earth:
  // Maximum geocentric speeds in the distance to the earth:
  static final double[] maxDistSpeed = new double[]
      {SURYA_MAX_DIST_SPEED,   CHANDRA_MAX_DIST_SPEED, BUDHA_MAX_DIST_SPEED,
       SHUKRA_MAX_DIST_SPEED,  MANGALA_MAX_DIST_SPEED, GURU_MAX_DIST_SPEED,
       SHANI_MAX_DIST_SPEED,   URANUS_MAX_DIST_SPEED,  NEPTUNE_MAX_DIST_SPEED,
       PLUTO_MAX_DIST_SPEED,   MNODE_MAX_DIST_SPEED,   TNODE_MAX_DIST_SPEED,
       MAPOGEE_MAX_DIST_SPEED, OAPOGEE_MAX_DIST_SPEED, 1./0.,
       CHIRON_MAX_DIST_SPEED,  PHOLUS_MAX_DIST_SPEED,  CERES_MAX_DIST_SPEED,
       PALLAS_MAX_DIST_SPEED,  JUNO_MAX_DIST_SPEED,    VESTA_MAX_DIST_SPEED,
       INTPAPOG_MAX_DIST_SPEED,INTPPERG_MAX_DIST_SPEED};
  // Minimum geocentric speeds in the direction of the distance to the earth:
  static final double[] minDistSpeed = new double[]
      {SURYA_MIN_DIST_SPEED,   CHANDRA_MIN_DIST_SPEED, BUDHA_MIN_DIST_SPEED,
       SHUKRA_MIN_DIST_SPEED,  MANGALA_MIN_DIST_SPEED, GURU_MIN_DIST_SPEED,
       SHANI_MIN_DIST_SPEED,   URANUS_MIN_DIST_SPEED,  NEPTUNE_MIN_DIST_SPEED,
       PLUTO_MIN_DIST_SPEED,   MNODE_MIN_DIST_SPEED,   TNODE_MIN_DIST_SPEED,
       MAPOGEE_MIN_DIST_SPEED, OAPOGEE_MIN_DIST_SPEED, 1./0.,
       CHIRON_MIN_DIST_SPEED,  PHOLUS_MIN_DIST_SPEED,  CERES_MIN_DIST_SPEED,
       PALLAS_MIN_DIST_SPEED,  JUNO_MIN_DIST_SPEED,    VESTA_MIN_DIST_SPEED,
       INTPAPOG_MIN_DIST_SPEED,INTPPERG_MIN_DIST_SPEED};

  // Maximum topocentric speeds in the distance to the earth:
  static final double[] maxTopoDistSpeed = new double[]
      {SURYA_MAX_TOPO_DIST_SPEED,   CHANDRA_MAX_TOPO_DIST_SPEED,
       BUDHA_MAX_TOPO_DIST_SPEED,   SHUKRA_MAX_TOPO_DIST_SPEED,
       MANGALA_MAX_TOPO_DIST_SPEED, GURU_MAX_TOPO_DIST_SPEED,
       SHANI_MAX_TOPO_DIST_SPEED,   URANUS_MAX_TOPO_DIST_SPEED,
       NEPTUNE_MAX_TOPO_DIST_SPEED, PLUTO_MAX_TOPO_DIST_SPEED,
       MNODE_MAX_TOPO_DIST_SPEED,   TNODE_MAX_TOPO_DIST_SPEED,
       MAPOGEE_MAX_TOPO_DIST_SPEED, OAPOGEE_MAX_TOPO_DIST_SPEED,
       1./0.,                       CHIRON_MAX_TOPO_DIST_SPEED,
       PHOLUS_MAX_TOPO_DIST_SPEED,  CERES_MAX_TOPO_DIST_SPEED,
       PALLAS_MAX_TOPO_DIST_SPEED,  JUNO_MAX_TOPO_DIST_SPEED,
       VESTA_MAX_TOPO_DIST_SPEED,   INTPAPOG_MAX_TOPO_DIST_SPEED,
       INTPPERG_MAX_TOPO_DIST_SPEED};
  // Minimum topocentric speeds in the distance to the earth:
  static final double[] minTopoDistSpeed = new double[]
      {SURYA_MIN_TOPO_DIST_SPEED,   CHANDRA_MIN_TOPO_DIST_SPEED,
       BUDHA_MIN_TOPO_DIST_SPEED,   SHUKRA_MIN_TOPO_DIST_SPEED,
       MANGALA_MIN_TOPO_DIST_SPEED, GURU_MIN_TOPO_DIST_SPEED,
       SHANI_MIN_TOPO_DIST_SPEED,   URANUS_MIN_TOPO_DIST_SPEED,
       NEPTUNE_MIN_TOPO_DIST_SPEED, PLUTO_MIN_TOPO_DIST_SPEED,
       MNODE_MIN_TOPO_DIST_SPEED,   TNODE_MIN_TOPO_DIST_SPEED,
       MAPOGEE_MIN_TOPO_DIST_SPEED, OAPOGEE_MIN_TOPO_DIST_SPEED,
       1./0.,                       CHIRON_MIN_TOPO_DIST_SPEED,
       PHOLUS_MIN_TOPO_DIST_SPEED,  CERES_MIN_TOPO_DIST_SPEED,
       PALLAS_MIN_TOPO_DIST_SPEED,  JUNO_MIN_TOPO_DIST_SPEED,
       VESTA_MIN_TOPO_DIST_SPEED,   INTPAPOG_MIN_TOPO_DIST_SPEED,
       INTPPERG_MIN_TOPO_DIST_SPEED};

  // Maximum speeds in the distance to the sun:
  static final double[] maxHelioDistSpeed = new double[]
      {SURYA_MAX_HELIO_DIST_SPEED,   CHANDRA_MAX_HELIO_DIST_SPEED,
       BUDHA_MAX_HELIO_DIST_SPEED,   SHUKRA_MAX_HELIO_DIST_SPEED,
       MANGALA_MAX_HELIO_DIST_SPEED, GURU_MAX_HELIO_DIST_SPEED,
       SHANI_MAX_HELIO_DIST_SPEED,   URANUS_MAX_HELIO_DIST_SPEED,
       NEPTUNE_MAX_HELIO_DIST_SPEED, PLUTO_MAX_HELIO_DIST_SPEED,
       MNODE_MAX_HELIO_DIST_SPEED,   TNODE_MAX_HELIO_DIST_SPEED,
       MAPOGEE_MAX_HELIO_DIST_SPEED, OAPOGEE_MAX_HELIO_DIST_SPEED,
       1./0.,                        CHIRON_MAX_HELIO_DIST_SPEED,
       PHOLUS_MAX_HELIO_DIST_SPEED,  CERES_MAX_HELIO_DIST_SPEED,
       PALLAS_MAX_HELIO_DIST_SPEED,  JUNO_MAX_HELIO_DIST_SPEED,
       VESTA_MAX_HELIO_DIST_SPEED,   INTPAPOG_MAX_HELIO_DIST_SPEED,
       INTPPERG_MAX_HELIO_DIST_SPEED};
  // Minimum speeds in the distance to the sun:
  static final double[] minHelioDistSpeed = new double[]
      {SURYA_MIN_HELIO_DIST_SPEED,   CHANDRA_MIN_HELIO_DIST_SPEED,
       BUDHA_MIN_HELIO_DIST_SPEED,   SHUKRA_MIN_HELIO_DIST_SPEED,
       MANGALA_MIN_HELIO_DIST_SPEED, GURU_MIN_HELIO_DIST_SPEED,
       SHANI_MIN_HELIO_DIST_SPEED,   URANUS_MIN_HELIO_DIST_SPEED,
       NEPTUNE_MIN_HELIO_DIST_SPEED, PLUTO_MIN_HELIO_DIST_SPEED,
       MNODE_MIN_HELIO_DIST_SPEED,   TNODE_MIN_HELIO_DIST_SPEED,
       MAPOGEE_MIN_HELIO_DIST_SPEED, OAPOGEE_MIN_HELIO_DIST_SPEED,
       1./0.,                        CHIRON_MIN_HELIO_DIST_SPEED,
       PHOLUS_MIN_HELIO_DIST_SPEED,  CERES_MIN_HELIO_DIST_SPEED,
       PALLAS_MIN_HELIO_DIST_SPEED,  JUNO_MIN_HELIO_DIST_SPEED,
       VESTA_MIN_HELIO_DIST_SPEED,   INTPAPOG_MIN_HELIO_DIST_SPEED,
       INTPPERG_MIN_HELIO_DIST_SPEED};

  // Maximum geocentric accelerations in the distance to the earth:
  static final double[] maxDistAccel = new double[]
      {SURYA_MAX_DIST_ACCEL,   CHANDRA_MAX_DIST_ACCEL, BUDHA_MAX_DIST_ACCEL,
       SHUKRA_MAX_DIST_ACCEL,  MANGALA_MAX_DIST_ACCEL, GURU_MAX_DIST_ACCEL,
       SHANI_MAX_DIST_ACCEL,   URANUS_MAX_DIST_ACCEL,  NEPTUNE_MAX_DIST_ACCEL,
       PLUTO_MAX_DIST_ACCEL,   MNODE_MAX_DIST_ACCEL,   TNODE_MAX_DIST_ACCEL,
       MAPOGEE_MAX_DIST_ACCEL, OAPOGEE_MAX_DIST_ACCEL, 1./0.,
       CHIRON_MAX_DIST_ACCEL,  PHOLUS_MAX_DIST_ACCEL,  CERES_MAX_DIST_ACCEL,
       PALLAS_MAX_DIST_ACCEL,  JUNO_MAX_DIST_ACCEL,    VESTA_MAX_DIST_ACCEL,
       INTPAPOG_MAX_DIST_ACCEL,INTPPERG_MAX_DIST_ACCEL};
  // Minimum geocentric accelerations in the distance to the earth:
  static final double[] minDistAccel = new double[]
      {SURYA_MIN_DIST_ACCEL,   CHANDRA_MIN_DIST_ACCEL, BUDHA_MIN_DIST_ACCEL,
       SHUKRA_MIN_DIST_ACCEL,  MANGALA_MIN_DIST_ACCEL, GURU_MIN_DIST_ACCEL,
       SHANI_MIN_DIST_ACCEL,   URANUS_MIN_DIST_ACCEL,  NEPTUNE_MIN_DIST_ACCEL,
       PLUTO_MIN_DIST_ACCEL,   MNODE_MIN_DIST_ACCEL,   TNODE_MIN_DIST_ACCEL,
       MAPOGEE_MIN_DIST_ACCEL, OAPOGEE_MIN_DIST_ACCEL, 1./0.,
       CHIRON_MIN_DIST_ACCEL,  PHOLUS_MIN_DIST_ACCEL,  CERES_MIN_DIST_ACCEL,
       PALLAS_MIN_DIST_ACCEL,  JUNO_MIN_DIST_ACCEL,    VESTA_MIN_DIST_ACCEL,
       INTPAPOG_MIN_DIST_ACCEL,INTPPERG_MIN_DIST_ACCEL};

  // Maximum topocentric accelerations in the distance to the earth:
  static final double[] maxTopoDistAccel = new double[]
      {SURYA_MAX_TOPO_DIST_ACCEL,   CHANDRA_MAX_TOPO_DIST_ACCEL,
       BUDHA_MAX_TOPO_DIST_ACCEL,   SHUKRA_MAX_TOPO_DIST_ACCEL,
       MANGALA_MAX_TOPO_DIST_ACCEL, GURU_MAX_TOPO_DIST_ACCEL,
       SHANI_MAX_TOPO_DIST_ACCEL,   URANUS_MAX_TOPO_DIST_ACCEL,
       NEPTUNE_MAX_TOPO_DIST_ACCEL, PLUTO_MAX_TOPO_DIST_ACCEL,
       MNODE_MAX_TOPO_DIST_ACCEL,   TNODE_MAX_TOPO_DIST_ACCEL,
       MAPOGEE_MAX_TOPO_DIST_ACCEL, OAPOGEE_MAX_TOPO_DIST_ACCEL,
       1./0.,                       CHIRON_MAX_TOPO_DIST_ACCEL,
       PHOLUS_MAX_TOPO_DIST_ACCEL,  CERES_MAX_TOPO_DIST_ACCEL,
       PALLAS_MAX_TOPO_DIST_ACCEL,  JUNO_MAX_TOPO_DIST_ACCEL,
       VESTA_MAX_TOPO_DIST_ACCEL,   INTPAPOG_MAX_TOPO_DIST_ACCEL,
       INTPPERG_MAX_TOPO_DIST_ACCEL};
  // Minimum topocentric accelerations in the distance to the earth:
  static final double[] minTopoDistAccel = new double[]
      {SURYA_MIN_TOPO_DIST_ACCEL,   CHANDRA_MIN_TOPO_DIST_ACCEL,
       BUDHA_MIN_TOPO_DIST_ACCEL,   SHUKRA_MIN_TOPO_DIST_ACCEL,
       MANGALA_MIN_TOPO_DIST_ACCEL, GURU_MIN_TOPO_DIST_ACCEL,
       SHANI_MIN_TOPO_DIST_ACCEL,   URANUS_MIN_TOPO_DIST_ACCEL,
       NEPTUNE_MIN_TOPO_DIST_ACCEL, PLUTO_MIN_TOPO_DIST_ACCEL,
       MNODE_MIN_TOPO_DIST_ACCEL,   TNODE_MIN_TOPO_DIST_ACCEL,
       MAPOGEE_MIN_TOPO_DIST_ACCEL, OAPOGEE_MIN_TOPO_DIST_ACCEL,
       1./0.,                       CHIRON_MIN_TOPO_DIST_ACCEL,
       PHOLUS_MIN_TOPO_DIST_ACCEL,  CERES_MIN_TOPO_DIST_ACCEL,
       PALLAS_MIN_TOPO_DIST_ACCEL,  JUNO_MIN_TOPO_DIST_ACCEL,
       VESTA_MIN_TOPO_DIST_ACCEL,   INTPAPOG_MIN_TOPO_DIST_ACCEL,
       INTPPERG_MIN_TOPO_DIST_ACCEL};

  // Maximum accelerations in the distance to the sun:
  static final double[] maxHelioDistAccel = new double[]
      {SURYA_MAX_HELIO_DIST_ACCEL,   CHANDRA_MAX_HELIO_DIST_ACCEL,
       BUDHA_MAX_HELIO_DIST_ACCEL,   SHUKRA_MAX_HELIO_DIST_ACCEL,
       MANGALA_MAX_HELIO_DIST_ACCEL, GURU_MAX_HELIO_DIST_ACCEL,
       SHANI_MAX_HELIO_DIST_ACCEL,   URANUS_MAX_HELIO_DIST_ACCEL,
       NEPTUNE_MAX_HELIO_DIST_ACCEL, PLUTO_MAX_HELIO_DIST_ACCEL,
       MNODE_MAX_HELIO_DIST_ACCEL,   TNODE_MAX_HELIO_DIST_ACCEL,
       MAPOGEE_MAX_HELIO_DIST_ACCEL, OAPOGEE_MAX_HELIO_DIST_ACCEL,
       1./0.,                        CHIRON_MAX_HELIO_DIST_ACCEL,
       PHOLUS_MAX_HELIO_DIST_ACCEL,  CERES_MAX_HELIO_DIST_ACCEL,
       PALLAS_MAX_HELIO_DIST_ACCEL,  JUNO_MAX_HELIO_DIST_ACCEL,
       VESTA_MAX_HELIO_DIST_ACCEL,   INTPAPOG_MAX_HELIO_DIST_ACCEL,
       INTPPERG_MAX_HELIO_DIST_ACCEL};
  // Minimum accelerations in the distance to the sun:
  static final double[] minHelioDistAccel = new double[]
      {SURYA_MIN_HELIO_DIST_ACCEL,   CHANDRA_MIN_HELIO_DIST_ACCEL,
       BUDHA_MIN_HELIO_DIST_ACCEL,   SHUKRA_MIN_HELIO_DIST_ACCEL,
       MANGALA_MIN_HELIO_DIST_ACCEL, GURU_MIN_HELIO_DIST_ACCEL,
       SHANI_MIN_HELIO_DIST_ACCEL,   URANUS_MIN_HELIO_DIST_ACCEL,
       NEPTUNE_MIN_HELIO_DIST_ACCEL, PLUTO_MIN_HELIO_DIST_ACCEL,
       MNODE_MIN_HELIO_DIST_ACCEL,   TNODE_MIN_HELIO_DIST_ACCEL,
       MAPOGEE_MIN_HELIO_DIST_ACCEL, OAPOGEE_MIN_HELIO_DIST_ACCEL,
       1./0.,                        CHIRON_MIN_HELIO_DIST_ACCEL,
       PHOLUS_MIN_HELIO_DIST_ACCEL,  CERES_MIN_HELIO_DIST_ACCEL,
       PALLAS_MIN_HELIO_DIST_ACCEL,  JUNO_MIN_HELIO_DIST_ACCEL,
       VESTA_MIN_HELIO_DIST_ACCEL,   INTPAPOG_MIN_HELIO_DIST_ACCEL,
       INTPPERG_MIN_HELIO_DIST_ACCEL};

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

  
  private SwephData() { }
}

class SwephJPL {
  static final int J_MERCURY =  0;
  static final int J_VENUS   =  1;
  static final int J_EARTH   =  2;
  static final int J_MARS    =  3;
  static final int J_JUPITER =  4;
  static final int J_SATURN  =  5;
  static final int J_URANUS  =  6;
  static final int J_NEPTUNE =  7;
  static final int J_PLUTO   =  8;
  static final int J_MOON    =  9;
  static final int J_SUN     = 10;
  static final int J_SBARY   = 11;
  static final int J_EMB     = 12;
  static final int J_NUT     = 13;
  static final int J_LIB     = 14;

  JplSave js=new JplSave();


  SwissEph  sw=null;
  SwissData swed=null;
  SwissLib  sl=null;



  SwephJPL(SwissEph sw, SwissData swed, SwissLib sl) {
    this.sw=sw;
    this.swed=swed;
    this.sl=sl;
    if (this.sw==null) { this.sw=new SwissEph(); }
    if (this.swed==null) { this.swed=new SwissData(); }
    if (this.sl==null) { this.sl=new SwissLib(); }
  }


  /*
   * This subroutine opens the file jplfname, with a phony record length,
   * reads the first record, and uses the info to compute ksize,
   * the number of single precision words in a record.
   * RETURN: ksize (record size of ephemeris data)
   * jplfptr is opened on return.
   */
  private int fsizer(StringBuffer serr) throws SwissephException {
    /* Local variables */
    int ncon;
    double emrat;
    int numde;
    double au, ss[]=new double[3];
    int i;
    int ksize;
    String ttl="";  // JAVA: Not used???
    try {
      // throws SwissephException, if null or maybe for other reasons:
      js.jplfptr = sw.swi_fopen(SwephData.SEI_FILE_PLANET, js.jplfname, js.jplfpath, serr);
      /* ttl = ephemeris title, e.g.
       * "JPL Planetary Ephemeris DE404/LE404
       *  Start Epoch: JED=   625296.5-3001 DEC 21 00:00:00
       *  Final Epoch: JED=  2817168.5 3001 JAN 17 00:00:00c */
//    fread((void *) &ttl[0], 1, 252, js->jplfptr);
      for(int m=0; m<252; m++) {
        ttl+=(char)js.jplfptr.readByte();
      }
    /* cnam = names of constants */
//    fread((void *) js->ch_cnam, 1, 6*400, js->jplfptr);
      for(int m=0; m<6*400; m++) {
        ttl+=(char)js.jplfptr.readByte();
      }
      /* ss[0] = start epoch of ephemeris
       * ss[1] = end epoch
       * ss[2] = segment size in days */
//    fread((void *) &ss[0], sizeof(double), 3, js->jplfptr);
      for(int m=0; m<3; m++) {
        ss[m]=js.jplfptr.readDouble();
      }
// Don't mind "reorder"...
//    /* reorder ? */
//    if (ss[2] < 1 || ss[2] > 200)
//      js.do_reorder = true;
//    else
//      js.do_reorder = false;
      for (i = 0; i < 3; i++)
        js.eh_ss[i] = ss[i];
//    if (js.do_reorder)
//      reorder((char *) &js->eh_ss[0], sizeof(double), 3);
      /* ncon = number of constants */
//    fread((void *) &ncon, sizeof(long), 1, js->jplfptr);
        ncon=js.jplfptr.readInt();
//    if (js->do_reorder)
//      reorder((char *) &ncon, sizeof(long), 1);
      /* au = astronomical unit */
//    fread((void *) &au, sizeof(double), 1, js->jplfptr);
      au=js.jplfptr.readDouble();
//    if (js->do_reorder)
//      reorder((char *) &au, sizeof(double), 1);
      /* emrat = earth moon mass ratio */
//    fread((void *) &emrat, sizeof(double), 1, js->jplfptr);
      emrat=js.jplfptr.readDouble();
//    if (js->do_reorder)
//      reorder((char *) &emrat, sizeof(double), 1);
      /* ipt[i+0]: coefficients of planet i start at buf[ipt[i+0]-1]
       * ipt[i+1]: number of coefficients (interpolation order - 1)
       * ipt[i+2]: number of intervals in segment */
//    fread((void *) &js->eh_ipt[0], sizeof(long), 36, js->jplfptr);
      for(int m=0; m<36; m++) {
        js.eh_ipt[m]=js.jplfptr.readInt();
      }
//    if (js->do_reorder)
//      reorder((char *) &js->eh_ipt[0], sizeof(long), 36);
      /* numde = number of jpl ephemeris "404" with de404 */
//    fread((void *) &numde, sizeof(long), 1, js->jplfptr);
        numde=js.jplfptr.readInt();
//    if (js->do_reorder)
//      reorder((char *) &numde, sizeof(long), 1);
      js.jplfptr.seek(0);
      /*  find the number of ephemeris coefficients from the pointers */
    } catch (java.io.IOException ioe) {
      throw new SwissephException(1./0., SwissephException.FILE_READ_ERROR,
          SweConst.ERR, ioe.getMessage());
    }
    switch (numde) {
      case 403:
      case 405:
        ksize = 2036;
        break;
      case 404:
      case 406:
        ksize = 1456;
        break;
      case 200:
        ksize = 1652;
        break;
      case 102:
        ksize = 1652;     /* de102 is filled with blanks to length of de200 */
        break;
      default:
        if (serr != null) {
          serr.setLength(0);
          serr.append("unknown numde value "+numde+";");
        }
        throw new SwissephException(1./0., SwissephException.DATA_FILE_ERROR,
            SweConst.ERR, serr);
    }
    return ksize;
  }

  /*
   *     This subroutine reads the jpl planetary ephemeris
   *     and gives the position and velocity of the point 'ntarg'
   *     with respect to 'ncent'.
   *     calling sequence parameters:
   *       et = d.p. julian ephemeris date at which interpolation
   *            is wanted.
   *       ** note the entry dpleph for a doubly-dimensioned time **
   *          the reason for this option is discussed in the
   *          subroutine state
   *     ntarg = integer number of 'target' point.
   *     ncent = integer number of center point.
   *            the numbering convention for 'ntarg' and 'ncent' is:
   *                0 = mercury           7 = neptune
   *                1 = venus             8 = pluto
   *                2 = earth             9 = moon
   *                3 = mars             10 = sun
   *                4 = jupiter          11 = solar-system barycenter
   *                5 = saturn           12 = earth-moon barycenter
   *                6 = uranus           13 = nutations (longitude and obliq)
   *                                     14 = librations, if on eph file
   *             (if nutations are wanted, set ntarg = 13. for librations,
   *              set ntarg = 14. set ncent=0.)
   *      rrd = output 6-word d.p. array containing position and velocity
   *            of point 'ntarg' relative to 'ncent'. the units are au and
   *            au/day. for librations the units are radians and radians
   *            per day. in the case of nutations the first four words of
   *            rrd will be set to nutations and rates, having units of
   *            radians and radians/day.
   *            The option is available to have the units in km and km/sec.
   *            For this, set do_km=TRUE (default FALSE).
   */
  int swi_pleph(double et, int ntarg, int ncent, double[] rrd,
                StringBuffer serr) throws SwissephException {
    int i, retc;
    int list[]=new int[12];
    double[] pv = js.pv;
    double[] pvsun = js.pvsun;
    for (i = 0; i < 6; ++i)
      rrd[i] = 0.0;
    if (ntarg == ncent) {
      return 0;
    }
    for (i = 0; i < 12; ++i)
      list[i] = 0;
    /*     check for nutation call */
    if (ntarg == J_NUT) {
      if (js.eh_ipt[34] > 0) {
        list[10] = 2;
        return(state(et, list, false, pv, pvsun, rrd, serr));
      } else {
        if (serr != null) {
          serr.setLength(0);
          serr.append("No nutations on the JPL ephemeris file;");
        }
        throw new SwissephException(et, SwissephException.UNDEFINED,
            SwephData.NOT_AVAILABLE, serr);
      }
    }
    if (ntarg == J_LIB) {
      if (js.eh_ipt[37] > 0) {
        list[11] = 2;
        // throws SwissephException by itself:
        retc = state(et, list, false, pv, pvsun, rrd, serr);
        for (i = 0; i < 6; ++i) {
          rrd[i] = pv[i + 60];
        }
        return 0;
      } else {
        if (serr != null) {
          serr.setLength(0);
          serr.append("No librations on the ephemeris file;");
        }
        throw new SwissephException(et, SwissephException.DATA_FILE_ERROR,
            SwephData.NOT_AVAILABLE, serr);
      }
    }
    /* set up proper entries in 'list' array for state call */
    if (ntarg < J_SUN) {
      list[ntarg] = 2;
    }
    if (ntarg == J_MOON)  /* Mooon needs Earth */ {
      list[J_EARTH] = 2;
    }
    if (ntarg == J_EARTH)         /* Earth needs Moon */ {
      list[J_MOON] = 2;
    }
    if (ntarg == J_EMB)   /* EMB needs Earth */ {
      list[J_EARTH] = 2;
    }
    if (ncent < J_SUN) {
      list[ncent] = 2;
    }
    if (ncent == J_MOON)  /* Mooon needs Earth */ {
      list[J_EARTH] = 2;
    }
    if (ncent == J_EARTH)         /* Earth needs Moon */ {
      list[J_MOON] = 2;
    }
    if (ncent == J_EMB)   /* EMB needs Earth */ {
      list[J_EARTH] = 2;
    }
    // throws SwissephException by itself:
    retc = state(et, list, true, pv, pvsun, rrd, serr);
    if (ntarg == J_SUN || ncent == J_SUN) {
      for (i = 0; i < 6; ++i)
        pv[i + 6*J_SUN] = pvsun[i];
    }
    if (ntarg == J_SBARY || ncent == J_SBARY) {
      for (i = 0; i < 6; ++i) {
        pv[i + 6*J_SBARY] = 0.;
      }
    }
    if (ntarg == J_EMB || ncent == J_EMB) {
      for (i = 0; i < 6; ++i)
        pv[i + 6*J_EMB] = pv[i + 6*J_EARTH];
    }
    if ((ntarg==J_EARTH && ncent==J_MOON) || (ntarg == J_MOON && ncent==J_EARTH)){
      for (i = 0; i < 6; ++i)
        pv[i + 6*J_EARTH] = 0.;

    } else {
      if (list[J_EARTH] == 2) {
        for (i = 0; i < 6; ++i)
          pv[i + 6*J_EARTH] -= pv[i + 6*J_MOON] / (js.eh_emrat + 1.);
      }
      if (list[J_MOON] == 2) {
        for (i = 0; i < 6; ++i) {
          pv[i + 6*J_MOON] += pv[i + 6*J_EARTH];
        }
      }
    }
    for (i = 0; i < 6; ++i)
      rrd[i] = pv[i + ntarg * 6] - pv[i + ncent * 6];
    return SweConst.OK;
  }

  /*
   *  This subroutine differentiates and interpolates a
   *  set of chebyshev coefficients to give pos, vel, acc, and jerk
   *  calling sequence parameters:
   *    input:
   *     buf   1st location of array of d.p. chebyshev coefficients of position
   *        t   is dp fractional time in interval covered by
   *            coefficients at which interpolation is wanted, 0 <= t <= 1
   *     intv   is dp length of whole interval in input time units.
   *      ncf   number of coefficients per component
   *      ncm   number of components per set of coefficients
   *       na   number of sets of coefficients in full array
   *            (i.e., number of sub-intervals in full interval)
   *       ifl   int flag: =1 for positions only
   *                      =2 for pos and vel
   *                      =3 for pos, vel, and acc
   *                      =4 for pos, vel, acc, and jerk
   *    output:
   *      pv   d.p. interpolated quantities requested.
   *           assumed dimension is pv(ncm,fl).
   */
  /* Initialized data */
  int np_interp, nv_interp;
  int nac_interp;
  int njk_interp;
  double twot = 0.;
  private int interp(double[] buf, int bufOffs, double t, double intv,
                     int ncfin, int ncmin, int nain, int ifl, double[] pv,
                     int pvOffs) {
    /* Initialized data */
    double[] pc = js.pc;
    double[] vc = js.vc;
    double[] ac = js.ac;
    double[] jc = js.jc;
    int ncf = (int) ncfin;
    int ncm = (int) ncmin;
    int na = (int) nain;
    /* Local variables */
    double temp;
    int i, j, ni;
    double tc;
    double dt1, bma;
    double bma2, bma3;
    /*
     | get correct sub-interval number for this set of coefficients and then
     | get normalized chebyshev time within that subinterval.
     */
    if (t >= 0) {
      dt1 = Math.floor(t);
    } else {
      dt1 = -Math.floor(-t);
    }
    temp = na * t;
    ni = (int) (temp - dt1);
    /* tc is the normalized chebyshev time (-1 <= tc <= 1) */
    tc = ((temp % 1.0) + dt1) * 2. - 1.;
    /*
     *  check to see whether chebyshev time has changed,
     *  and compute new polynomial values if it has.
     *  (the element pc(2) is the value of t1(tc) and hence
     *  contains the value of tc on the previous call.)
     */
    if (tc != pc[1]) {
      np_interp = 2;
      nv_interp = 3;
      nac_interp = 4;
      njk_interp = 5;
      pc[1] = tc;
      twot = tc + tc;
    }
    /*
     *  be sure that at least 'ncf' polynomials have been evaluated
     *  and are stored in the array 'pc'.
     */
    if (np_interp < ncf) {
      for (i = np_interp; i < ncf; ++i)
        pc[i] = twot * pc[i - 1] - pc[i - 2];
      np_interp = ncf;
    }
    /*  interpolate to get position for each component */
    for (i = 0; i < ncm; ++i) {
      pv[pvOffs + i] = 0.;
      for (j = ncf-1; j >= 0; --j)
        pv[pvOffs + i] += pc[j] * buf[bufOffs + j + (i + ni * ncm) * ncf];
    }
    if (ifl <= 1) {
      return 0;
    }
    /*
     *       if velocity interpolation is wanted, be sure enough
     *       derivative polynomials have been generated and stored.
     */
    bma = (na + na) / intv;
    vc[2] = twot + twot;
    if (nv_interp < ncf) {
      for (i = nv_interp; i < ncf; ++i)
        vc[i] = twot * vc[i - 1] + pc[i - 1] + pc[i - 1] - vc[i - 2];
      nv_interp = ncf;
    }
    /*       interpolate to get velocity for each component */
    for (i = 0; i < ncm; ++i) {
      pv[pvOffs + i + ncm] = 0.;
      for (j = ncf-1; j >= 1; --j)
        pv[pvOffs + i + ncm] += vc[j] * buf[bufOffs + j + (i + ni * ncm) * ncf];
      pv[pvOffs + i + ncm] *= bma;
    }
    if (ifl == 2) {
      return 0;
    }
    /*       check acceleration polynomial values, and */
    /*       re-do if necessary */
    bma2 = bma * bma;
    ac[3] = pc[1] * 24.;
    if (nac_interp < ncf) {
      nac_interp = ncf;
      for (i = nac_interp; i < ncf; ++i)
        ac[i] = twot * ac[i - 1] + vc[i - 1] * 4. - ac[i - 2];
    }
    /*       get acceleration for each component */
    for (i = 0; i < ncm; ++i) {
      pv[pvOffs + i + ncm * 2] = 0.;
      for (j = ncf-1; j >= 2; --j)
        pv[pvOffs + i + ncm * 2] += ac[j] * buf[bufOffs + j + (i + ni * ncm) * ncf];
      pv[pvOffs + i + ncm * 2] *= bma2;
    }
    if (ifl == 3) {
      return 0;
    }
    /*       check jerk polynomial values, and */
    /*       re-do if necessary */
    bma3 = bma * bma2;
    jc[4] = pc[1] * 192.;
    if (njk_interp < ncf) {
      njk_interp = ncf;
      for (i = njk_interp; i < ncf; ++i)
        jc[i] = twot * jc[i - 1] + ac[i - 1] * 6. - jc[i - 2];
    }
    /*       get jerk for each component */
    for (i = 0; i < ncm; ++i) {
      pv[pvOffs + i + ncm * 3] = 0.;
      for (j = ncf-1; j >= 3; --j)
        pv[pvOffs + i + ncm * 3] += jc[j] * buf[bufOffs + j + (i + ni * ncm) * ncf];
      pv[pvOffs + i + ncm * 3] *= bma3;
    }
    return 0;
  }

  /*
   | ********** state ********************
   | this subroutine reads and interpolates the jpl planetary ephemeris file
   |  calling sequence parameters:
   |  input:
   |     et    dp julian ephemeris epoch at which interpolation is wanted.
   |     list  12-word integer array specifying what interpolation
   |           is wanted for each of the bodies on the file.
   |                      list(i)=0, no interpolation for body i
   |                             =1, position only
   |                             =2, position and velocity
   |            the designation of the astronomical bodies by i is:
   |                      i = 0: mercury
   |                        = 1: venus
   |                        = 2: earth-moon barycenter, NOT earth!
   |                        = 3: mars
   |                        = 4: jupiter
   |                        = 5: saturn
   |                        = 6: uranus
   |                        = 7: neptune
   |                        = 8: pluto
   |                        = 9: geocentric moon
   |                        =10: nutations in longitude and obliquity
   |                        =11: lunar librations (if on file)
   |            If called with list = NULL, only the header records are read and
   |            stored in the global areas.
   |  do_bary   short, if true, barycentric, if false, heliocentric.
   |              only the 9 planets 0..8 are affected by it.
   |  output:
   |       pv   dp 6 x 11 array that will contain requested interpolated
   |            quantities.  the body specified by list(i) will have its
   |            state in the array starting at pv(1,i).  (on any given
   |            call, only those words in 'pv' which are affected by the
   |            first 10 'list' entries (and by list(11) if librations are
   |            on the file) are set.  the rest of the 'pv' array
   |            is untouched.)  the order of components starting in
   |            pv is: x,y,z,dx,dy,dz.
   |            all output vectors are referenced to the earth mean
   |            equator and equinox of epoch. the moon state is always
   |            geocentric; the other nine states are either heliocentric
   |            or solar-system barycentric, depending on the setting of
   |            common flags (see below).
   |            lunar librations, if on file, are put into pv(k,10) if
   |            list(11) is 1 or 2.
   |    pvsun   dp 6-word array containing the barycentric position and
   |            velocity of the sun.
   |      nut   dp 4-word array that will contain nutations and rates,
   |            depending on the setting of list(10).  the order of
   |            quantities in nut is:
   |                     d psi  (nutation in longitude)
   |                     d epsilon (nutation in obliquity)
   |                     d psi dot
   |                     d epsilon dot
   |  globals used:
   |    do_km   logical flag defining physical units of the output states.
   |            TRUE = return km and km/sec, FALSE = return au and au/day
   |            default value = FALSE  (km determines time unit
   |            for nutations and librations.  angle unit is always radians.)
   */
  int irecsz_state;
  int nrl_state, lpt_state[]=new int[3], ncoeffs_state;
  private int state(double et, int[] list, boolean do_bary, double[] pv,
                    double[] pvsun, double[] nut, StringBuffer serr)
      throws SwissephException {
    int i, j, k;
    long flen;
    int nseg, nb;
    double[] buf = js.buf;
    double aufac=0., s, t=0., intv=0.;
    int nrecl, ksize;
    int nr;
    double et_mn, et_fr;
    int[] ipt = js.eh_ipt;
    String ch_ttl="";  // JAVA: Not used???
    boolean ferr=false;
    try {
      if (js.jplfptr == null ||
          (js.jplfptr.fp == null && js.jplfptr.sk == null)) {
        // fsizer() throws SwissephException
        ksize = fsizer(serr); /* the number of single precision words in a record */
        nrecl = 4;
        if (ksize < 0) {
          if (serr != null && ksize != SwephData.NOT_AVAILABLE) {
            serr.setLength(0);
            serr.append("fsizer does not work");
          }
          throw new SwissephException(et, SwissephException.DATA_FILE_ERROR,  // Or is it some other error???
              (int)ksize, serr);
        }
        irecsz_state = nrecl * ksize;     /* record size in bytes */
        ncoeffs_state = ksize / 2;        /* # of coefficients, doubles */
        /* ttl = ephemeris title, e.g.
         * "JPL Planetary Ephemeris DE404/LE404
         *  Start Epoch: JED=   625296.5-3001 DEC 21 00:00:00
         *  Final Epoch: JED=  2817168.5 3001 JAN 17 00:00:00c */
//      fread((void *) &ch_ttl[0], 1, 252, js.jplfptr);
        for(int m=0;m<252;m++) {
          ch_ttl+=(char)js.jplfptr.readByte();
        }
        /* cnam = names of constants */
//      fread((void *) js.ch_cnam, 1, 2400, js.jplfptr);
        for(int m=0;m<2400;m++) {
          js.ch_cnam+=(char)js.jplfptr.readByte();
        }
        /* ss[0] = start epoch of ephemeris
         * ss[1] = end epoch
         * ss[2] = segment size in days */
//      fread((void *) &js.eh_ss[0], sizeof(double), 3, js.jplfptr);
        for(int m=0;m<3;m++) {
          js.eh_ss[m]=js.jplfptr.readDouble();
        }
//      if (js.do_reorder)
//        reorder((char *) &js.eh_ss[0], sizeof(double), 3);
        /* ncon = number of constants */
//      fread((void *) &js.eh_ncon, sizeof(long), 1, js.jplfptr);
        js.eh_ncon=js.jplfptr.readInt();
//      if (js.do_reorder)
//        reorder((char *) &js.eh_ncon, sizeof(long), 1);
        /* au = astronomical unit */
//      fread((void *) &js.eh_au, sizeof(double), 1, js.jplfptr);
        js.eh_au=js.jplfptr.readDouble();
//      if (js.do_reorder)
//        reorder((char *) &js.eh_au, sizeof(double), 1);
        /* emrat = earth moon mass ratio */
//      fread((void *) &js.eh_emrat, sizeof(double), 1, js.jplfptr);
        js.eh_emrat=js.jplfptr.readDouble();
//      if (js.do_reorder)
//        reorder((char *) &js.eh_emrat, sizeof(double), 1);
        /* ipt[i+0]: coefficients of planet i start at buf[ipt[i+0]-1]
         * ipt[i+1]: number of coefficients (interpolation order - 1)
         * ipt[i+2]: number of intervals in segment */
//      fread((void *) &ipt[0], sizeof(long), 36, js.jplfptr);
        for(int m=0;m<36;m++) {
          ipt[m]=js.jplfptr.readInt();
        }
//      if (js.do_reorder)
//        reorder((char *) &ipt[0], sizeof(long), 36);
        /* numde = number of jpl ephemeris "404" with de404 */
//      fread((void *) &js.eh_denum, sizeof(long), 1, js.jplfptr);
        js.eh_denum=js.jplfptr.readInt();
//      if (js.do_reorder)
//        reorder((char *) &js.eh_denum, sizeof(long), 1);
//      fread((void *) &lpt[0], sizeof(long), 3, js.jplfptr);
        for(int m=0;m<3;m++) {
          lpt_state[m]=js.jplfptr.readInt();
        }
//      if (js.do_reorder)
//        reorder((char *) &lpt[0], sizeof(long), 3);
        /* cval[]:  other constants in next record */
//      fseek(js.jplfptr, 1L * irecsz, 0);
        js.jplfptr.seek(1L * irecsz_state);
//      fread((void *) &js.eh_cval[0], sizeof(double), 400, js.jplfptr);
        for(int m=0;m<400;m++) {
          js.eh_cval[m]=js.jplfptr.readDouble();
        }
//      if (js.do_reorder)
//        reorder((char *) &js.eh_cval[0], sizeof(double), 400);
        js.jplfptr.seek(2L * irecsz_state);
        for (i = 0; i < 3; ++i)
          ipt[i + 36] = lpt_state[i];
        nrl_state = 0;
        /* is file length correct? */
        /* file length */
//      fseek(js.jplfptr, 0L, SEEK_END);
//      flen = ftell(js.jplfptr);
        flen=js.jplfptr.length();
        /* # of segments in file */
        nseg = (int) ((js.eh_ss[1] - js.eh_ss[0]) / js.eh_ss[2]);
        /* sum of all cheby coeffs of all planets and segments */
        for(i = 0, nb = 0; i < 13; i++) {
          k = 3;
          if (i == 11) {
            k = 2;
          }
          nb += (ipt[i*3+1] * ipt[i*3+2]) * k * nseg;
        }
        /* add start and end epochs of segments */
        nb += 2 * nseg;
        /* doubles to bytes */
        nb *= 8;
        /* add size of header and constants section */
        nb += 2 * ksize * nrecl;
        if (flen != nb
          /* some of our files are one record too long */
          && flen - nb != ksize * nrecl) {
          if (serr != null) {
            serr.setLength(0);
            serr.append("JPL ephemeris file is mutilated; length = "+flen+" instead of "+nb+".");
            if (serr.length() + js.jplfname.length() < SwissData.AS_MAXCH - 1) {
              serr.setLength(0); // Nanu???
              serr.append("JPL ephemeris file "+js.jplfname+" is mutilated; length = "+flen+" instead of "+nb+".");
            }
          }
          throw new SwissephException(et, SwissephException.FILE_READ_ERROR,
              SweConst.ERR, serr);
        }
      }
      if (list == null) {
        return 0;
      }
      s = et - .5;
      et_mn = Math.floor(s);
      et_fr = s - et_mn;    /* fraction of days since previous midnight */
      et_mn += .5;  /* midnight before epoch */
      /*       error return for epoch out of range */
      if (et < js.eh_ss[0] || et > js.eh_ss[1]) {
        if (serr != null) {
          serr.setLength(0);
          serr.append("jd "+et+" outside JPL eph. range "+js.eh_ss[0]+" .. "+js.eh_ss[1]+";");
        }
        throw new SwissephException(et, SwissephException.OUT_OF_TIME_RANGE,
            SwephData.BEYOND_EPH_LIMITS, serr);
      }
      /*       calculate record # and relative time in interval */
      nr = (int) ((et_mn - js.eh_ss[0]) / js.eh_ss[2]) + 2;
      if (et_mn == js.eh_ss[1]) {
        --nr;       /* end point of ephemeris, use last record */
      }
      t = (et_mn - ((nr - 2) * js.eh_ss[2] + js.eh_ss[0]) + et_fr) / js.eh_ss[2];
      /* read correct record if not in core */
      if (nr != nrl_state) {
        nrl_state = nr;
        js.jplfptr.seek(nr * irecsz_state);
        for (k = 1; k <= ncoeffs_state; ++k) {
//        if ( fread((void *) &buf[k - 1], sizeof(double), 1, js.jplfptr) != 1) {

          buf[k - 1]=js.jplfptr.readDouble();
//        }
//        if (js.do_reorder)
//          reorder((char *) &buf[k-1], sizeof(double), 1);
        }
      }
      if (js.do_km) {
        intv = js.eh_ss[2] * 86400.;
        aufac = 1.;
      } else {
        intv = js.eh_ss[2];
        aufac = 1. / js.eh_au;
      }
      /*   interpolate ssbary sun */
    } catch (java.io.EOFException ef) {
      ferr=true;
    } catch (java.io.IOException ie) {
      ferr=true;
    }
    if (ferr) {
      if (serr != null) {
        serr.setLength(0);
        serr.append("Read error in JPL eph. at "+et+"\n");
      }
      throw new SwissephException(et, SwissephException.FILE_READ_ERROR,
          SweConst.ERR, serr);
    }
    interp(buf, (int) ipt[30] - 1, t, intv, ipt[31], 3, ipt[32], 2, pvsun, 0);
    for (i = 0; i < 6; ++i) {
      pvsun[i] *= aufac;
    }
    /*   check and interpolate whichever bodies are requested */
    for (i = 0; i < 10; ++i) {
      if (list[i] > 0) {
        interp(buf, (int) ipt[i * 3] - 1, t, intv, ipt[i * 3 + 1], 3,
               ipt[i * 3 + 2], list[i], pv, i * 6);
        for (j = 0; j < 6; ++j) {
          if (i < 9 && ! do_bary) {
            pv[j + i * 6] = pv[j + i * 6] * aufac - pvsun[j];
          } else {
            pv[j + i * 6] *= aufac;
          }
        }
      }
    }
    /*       do nutations if requested (and if on file) */
    if (list[10] > 0 && ipt[34] > 0) {
      interp(buf, (int) ipt[33] - 1, t, intv, ipt[34], 2, ipt[35],
               list[10], nut, 0);
    }
    /*       get librations if requested (and if on file) */
    if (list[11] > 0 && ipt[37] > 0) {
      interp(buf, (int) ipt[36] - 1, t, intv, ipt[37], 3, ipt[38], list[1],
              pv, 60);
    }
    return SweConst.OK;
  }

  /*
   *  this entry obtains the constants from the ephemeris file
   *  call state to initialize the ephemeris and read in the constants
   */
  private int read_const_jpl(double[] ss,  StringBuffer serr) throws SwissephException {
    int i;
    // throws SwissephException if !SweConst.OK:
    state(0.0, null, false, null, null, null, serr);

    for (i = 0; i < 3; i++)
      ss[i] = js.eh_ss[i];
    return SweConst.OK;
  }

//  void reorder(char *x, int size, int number) {
//    int i, j;
//    char s[8];
//    char *sp1 = x;
//    char *sp2 = &s[0];
//    for (i = 0; i < number; i++) {
//      for (j = 0; j < size; j++)
//        *(sp2 + j) = *(sp1 + size - j - 1);
//      for (j = 0; j < size; j++)
//        *(sp1 + j) = *(sp2 + j);
//      sp1 += size;
//    }
//  }

  void swi_close_jpl_file() {
    if (js != null) {
      try {
        if (js.jplfptr != null) {
          js.jplfptr.close();
        }
      } catch (java.io.IOException e) {
      }
      if (js.jplfname != null) {
        js.jplfname = null;
      }
      if (js.jplfpath != null) {
        js.jplfpath = null;
      }
      js = null;
    }
  }

  int swi_open_jpl_file(double[] ss, String fname, String fpath,
                                StringBuffer serr) throws SwissephException {
    int retc = SweConst.OK;
    /* if open, return */
    if (js != null && js.jplfptr != null) {
      return SweConst.OK;
    }
    js=new JplSave();
/*
    if ((js = (struct jpl_save *) CALLOC(1, sizeof(struct jpl_save))) == null
      || (js.jplfname = MALLOC(strlen(fname)+1)) == null
      || (js.jplfpath = MALLOC(strlen(fpath)+1)) == null
      ) {
      if (serr != null)
        strcpy(serr, "error in malloc() with JPL ephemeris.");
      return SweConst.ERR;
    }
*/
    js.jplfname=fname;
    js.jplfpath=fpath;
    try {
      retc = read_const_jpl(ss, serr);
    } catch (SwissephException se) {
      swi_close_jpl_file();
      throw se;
    }

    /* intializations for function interpol() */
    js.pc[0] = 1;
    js.pc[1] = 2;
    js.vc[1] = 1;
    js.ac[2] = 4;
    js.jc[3] = 24;

    return retc;
  }

  int swi_get_jpl_denum() {
    return js.eh_denum;
  }

  double[] getJPLRange(String fname) throws SwissephException {
    double start=0./0., end=0./0.;
    FilePtr fp = null;
    try {
      fp = sw.swi_fopen(SwephData.SEI_FILE_PLANET, fname, swed.ephepath, null);
      fp.seek(252+6*400);
      start = fp.readDouble();
      end = fp.readDouble();
    } catch (SwissephException e) {
      throw e;
    } catch (Exception e) {
    }
    try { fp.close(); } catch (Exception e) { }
    return new double[]{start, end};
  }
}


class JplSave {
  String jplfname=null;
  String jplfpath=null;
  FilePtr jplfptr=null;
//  boolean do_reorder;
  double eh_cval[]=new double[400];
  double eh_ss[]=new double[3], eh_au, eh_emrat;
  int eh_denum, eh_ncon, eh_ipt[]=new int[39];
  String ch_cnam="";
  double pv[]=new double[78];
  double pvsun[]=new double[6];
  double buf[]=new double[1500];
  double pc[]=new double[18], vc[]=new double[18],
         ac[]=new double[18], jc[]=new double[18];
  boolean do_km;
}
class SwephMosh {

  SwissLib sl=null;
  SwissEph sw=null;
  SwissData swed=null;
  Swemmoon sm=null;
  SweDate sd=null;


  private static final double TIMESCALE=3652500.0;
  private static final int FICT_GEO=1;
  private static final int pnoint2msh[] = {2, 2, 0, 1, 3, 4, 5, 6, 7, 8};

  /* From Simon et al (1994)  */
  private static final double freqs[] = {
  /* Arc sec per 10000 Julian years.  */
    53810162868.8982,
    21066413643.3548,
    12959774228.3429,
    6890507749.3988,
    1092566037.7991,
    439960985.5372,
    154248119.3933,
    78655032.0744,
    52272245.1795
  };

  private static final double phases[] = {
  /* Arc sec.  */
    252.25090552 * 3600.,
    181.97980085 * 3600.,
    100.46645683 * 3600.,
    355.43299958 * 3600.,
    34.35151874 * 3600.,
    50.07744430 * 3600.,
    314.05500511 * 3600.,
    304.34866548 * 3600.,
    860492.1546,
  };

  double ss[][]=new double[9][24];
  double cc[][]=new double[9][24];



  SwephMosh(SwissLib sl, SwissEph sw, SwissData swed) {
    this.sl    = sl;
    this.sw    = sw;
    this.swed  = swed;
    this.sm    = new Swemmoon();
    if (this.sl   ==null) { this.sl   =new SwissLib(); }
    if (this.sw   ==null) { this.sw   =new SwissEph(); }
    if (this.swed ==null) { this.swed =new SwissData(); }
  }



  private int swi_moshplan2 (double J, int iplm, double[] pobj) {
    int i, j, k, m, k1, ip, np, nt;
    byte p[]; int pOff=0;
    double pl[], pb[], pr[]; int plOff=0, pbOff=0, prOff=0;
    double su, cu, sv, cv, T;
    double t, sl, sb, sr;
    Plantbl plan = planets[iplm];

    T = (J - SwephData.J2000) / TIMESCALE;
    /* Calculate sin( i*MM ), etc. for needed multiple angles.  */
    for (i = 0; i < 9; i++) {
      if ((j = plan.max_harmonic[i]) > 0) {
        sr = (sm.mods3600 (freqs[i] * T) + phases[i]) * SwephData.STR;
        sscc (i, sr, j);
      }
    }

    /* Point to start of table of arguments. */
    p = plan.arg_tbl;
    /* Point to tabulated cosine and sine amplitudes.  */
    pl = plan.lon_tbl;
    pb = plan.lat_tbl;
    pr = plan.rad_tbl;
    sl = 0.0;
    sb = 0.0;
    sr = 0.0;

    for (;;)
      {
        /* argument of sine and cosine */
        /* Number of periodic arguments. */
        np = p[pOff++];
        if (np < 0) {
          break;
        }
        if (np == 0) {                       /* It is a polynomial term.  */
            nt = p[pOff++];
            /* Longitude polynomial. */
            cu = pl[plOff++];
            for (ip = 0; ip < nt; ip++)
              {
                cu = cu * T + pl[plOff++];
              }
            sl +=  sm.mods3600 (cu);
            /* Latitude polynomial. */
            cu = pb[pbOff++];
            for (ip = 0; ip < nt; ip++)
              {
                cu = cu * T + pb[pbOff++];
              }
            sb += cu;
            /* Radius polynomial. */
            cu = pr[prOff++];
            for (ip = 0; ip < nt; ip++)
              {
                cu = cu * T + pr[prOff++];
              }
            sr += cu;
            continue;
          }
        k1 = 0;
        cv = 0.0;
        sv = 0.0;
        for (ip = 0; ip < np; ip++)
          {
            /* What harmonic.  */
            j = p[pOff++];
            /* Which planet.  */
            m = p[pOff++] - 1;
            if (j!=0) {
                k = j;
                if (j < 0) {
                  k = -k;
                }
                k -= 1;
                su = ss[m][k];    /* sin(k*angle) */
                if (j < 0) {
                  su = -su;
                }
                cu = cc[m][k];
                if (k1 == 0) {               /* set first angle */
                    sv = su;
                    cv = cu;
                    k1 = 1;
                  }
                else
                  {               /* combine angles */
                    t = su * cv + cu * sv;
                    cv = cu * cv - su * sv;
                    sv = t;
                  }
              }
          }
        /* Highest power of T.  */
        nt = p[pOff++];
        /* Longitude. */
        cu = pl[plOff++];
        su = pl[plOff++];
        for (ip = 0; ip < nt; ip++)
          {
            cu = cu * T + pl[plOff++];
            su = su * T + pl[plOff++];
          }
        sl += cu * cv + su * sv;
        /* Latitiude. */
        cu = pb[pbOff++];
        su = pb[pbOff++];
        for (ip = 0; ip < nt; ip++)
          {
            cu = cu * T + pb[pbOff++];
            su = su * T + pb[pbOff++];
          }
        sb += cu * cv + su * sv;
        /* Radius. */
        cu = pr[prOff++];
        su = pr[prOff++];
        for (ip = 0; ip < nt; ip++)
          {
            cu = cu * T + pr[prOff++];
            su = su * T + pr[prOff++];
          }
        sr += cu * cv + su * sv;
      }
    pobj[0] = SwephData.STR * sl;
    pobj[1] = SwephData.STR * sb;
    pobj[2] = SwephData.STR * plan.distance * sr + plan.distance;
    return SweConst.OK;
  }

  /* Moshier ephemeris.
   * computes heliocentric cartesian equatorial coordinates of
   * equinox 2000
   * for earth and a planet
   * tjd          julian day
   * ipli         internal SWEPH planet number
   * xp           array of 6 doubles for planet's position and speed
   * xe                                  earth's
   * serr         error string
   */
  int swi_moshplan(double tjd, int ipli, boolean do_save, double[] xpret,
                   double[] xeret, StringBuffer serr) {
    int i;
    boolean do_earth = false;
    double dx[]=new double[3], x2[]=new double[3],
           xxe[]=new double[6], xxp[]=new double[6];
    double xp[], xe[];
    double dt;
    String s;
    int iplm = pnoint2msh[ipli];
    PlanData pdp = swed.pldat[ipli];
    PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
    double seps2000 = swed.oec2000.seps;
    double ceps2000 = swed.oec2000.ceps;
    if (do_save) {
      xp = pdp.x;
      xe = pedp.x;
    } else {
      xp = xxp;
      xe = xxe;
    }
    if (do_save || ipli == SwephData.SEI_EARTH || xeret != null) {
      do_earth = true;
    }
    /* tjd beyond ephemeris limits, give some margin for spped at edge */
    if (tjd < SwephData.MOSHPLEPH_START - 0.3 ||
        tjd > SwephData.MOSHPLEPH_END + 0.3) {
      if (serr != null) {
        serr.setLength(0);
        s="jd "+tjd+" outside Moshier planet range "+
          SwephData.MOSHPLEPH_START+" .. "+
          SwephData.MOSHPLEPH_END+" ";
        if (serr.length() + s.length() < SwissData.AS_MAXCH) {
          serr.append(s);
        }
      }
      return(SweConst.ERR);
    }
    /* earth, for geocentric position */
    if (do_earth) {
      if (tjd == pedp.teval && pedp.iephe == SweConst.SEFLG_MOSEPH) {
        xe = pedp.x;
      } else {
        /* emb */
        swi_moshplan2(tjd, pnoint2msh[SwephData.SEI_EMB], xe); /* emb hel. ecl. 2000 polar */
        sl.swi_polcart(xe, xe);                        /* to cartesian */
        sl.swi_coortrf2(xe, xe, -seps2000, ceps2000);/* and equator 2000 */
        embofs_mosh(tjd, xe);               /* emb -> earth */
        if (do_save) {
          pedp.teval = tjd;
          pedp.xflgs = -1;
          pedp.iephe = SweConst.SEFLG_MOSEPH;
        }
        /* one more position for speed. */
        swi_moshplan2(tjd - SwephData.PLAN_SPEED_INTV, pnoint2msh[SwephData.SEI_EMB], x2);
        sl.swi_polcart(x2, x2);
        sl.swi_coortrf2(x2, x2, -seps2000, ceps2000);
        embofs_mosh(tjd - SwephData.PLAN_SPEED_INTV, x2);
        for (i = 0; i <= 2; i++)
          dx[i] = (xe[i] - x2[i]) / SwephData.PLAN_SPEED_INTV;
        /* store speed */
        for (i = 0; i <= 2; i++) {
          xe[i+3] = dx[i];
        }
      }
      if (xeret != null) {
        for (i = 0; i <= 5; i++) {
          xeret[i] = xe[i];
        }
      }
    }
    /* earth is the planet wanted */
    if (ipli == SwephData.SEI_EARTH) {
      xp = xe;
    } else {
      /* other planet */
      /* if planet has already been computed, return */
      if (tjd == pdp.teval && pdp.iephe == SweConst.SEFLG_MOSEPH) {
        xp = pdp.x;
      } else {
        swi_moshplan2(tjd, iplm, xp);
        sl.swi_polcart(xp, xp);
        sl.swi_coortrf2(xp, xp, -seps2000, ceps2000);
        if (do_save) {
          pdp.teval = tjd;
          pdp.xflgs = -1;
          pdp.iephe = SweConst.SEFLG_MOSEPH;
        }
        /* one more position for speed.
         * the following dt gives good speed for light-time correction
         */
        dt = SwephData.PLAN_SPEED_INTV;
        swi_moshplan2(tjd - dt, iplm, x2);
        sl.swi_polcart(x2, x2);
        sl.swi_coortrf2(x2, x2, -seps2000, ceps2000);
        for (i = 0; i <= 2; i++)
          dx[i] = (xp[i] - x2[i]) / dt;
        /* store speed */
        for (i = 0; i <= 2; i++) {
          xp[i+3] = dx[i];
        }
      }
      if (xpret != null) {
        for (i = 0; i <= 5; i++) {
          xpret[i] = xp[i];
        }
      }
    }
    return(SweConst.OK);
  }


  /* Prepare lookup table of sin and cos ( i*Lj )
   * for required multiple angles
   */
  private void sscc (int k, double arg, int n) {
    double cu, su, cv, sv, s;
    int i;

    su = Math.sin (arg);
    cu = Math.cos (arg);
    ss[k][0] = su;                /* sin(L) */
    cc[k][0] = cu;                /* cos(L) */
    sv = 2.0 * su * cu;
    cv = cu * cu - su * su;
    ss[k][1] = sv;                /* sin(2L) */
    cc[k][1] = cv;
    for (i = 2; i < n; i++)
      {
        s = su * cv + cu * sv;
        cv = cu * cv - su * sv;
        sv = s;
        ss[k][i] = sv;            /* sin( i+1 L ) */
        cc[k][i] = cv;
      }
  }


  /* Adjust position from Earth-Moon barycenter to Earth
   *
   * J = Julian day number
   * xemb = rectangular equatorial coordinates of Earth
   */
  private void embofs_mosh(double tjd, double xemb[]) {
    double T, M, a, L, B, p;
    double smp, cmp, s2mp, c2mp, s2d, c2d, sf, cf;
    double s2f, sx, cx, xyz[]=new double[6];
    double seps = swed.oec.seps;
    double ceps = swed.oec.ceps;
    int i;
    /* Short series for position of the Moon
     */
    T = (tjd-SwephData.J1900)/36525.0;
    /* Mean anomaly of moon (MP) */
    a = sl.swe_degnorm(((1.44e-5*T + 0.009192)*T + 477198.8491)*T + 296.104608);
    a *= SwissData.DEGTORAD;
    smp = Math.sin(a);
    cmp = Math.cos(a);
    s2mp = 2.0*smp*cmp;           /* sin(2MP) */
    c2mp = cmp*cmp - smp*smp;     /* cos(2MP) */
    /* Mean elongation of moon (D) */
    a = sl.swe_degnorm(((1.9e-6*T - 0.001436)*T + 445267.1142)*T + 350.737486);
    a  = 2.0 * SwissData.DEGTORAD * a;
    s2d = Math.sin(a);
    c2d = Math.cos(a);
    /* Mean distance of moon from its ascending node (F) */
    a = sl.swe_degnorm((( -3.e-7*T - 0.003211)*T + 483202.0251)*T + 11.250889);
    a  *= SwissData.DEGTORAD;
    sf = Math.sin(a);
    cf = Math.cos(a);
    s2f = 2.0*sf*cf;      /* sin(2F) */
    sx = s2d*cmp - c2d*smp;       /* sin(2D - MP) */
    cx = c2d*cmp + s2d*smp;       /* cos(2D - MP) */
    /* Mean longitude of moon (LP) */
    L = ((1.9e-6*T - 0.001133)*T + 481267.8831)*T + 270.434164;
    /* Mean anomaly of sun (M) */
    M = sl.swe_degnorm((( -3.3e-6*T - 1.50e-4)*T + 35999.0498)*T + 358.475833);
    /* Ecliptic longitude of the moon */
    L =   L
          + 6.288750*smp
          + 1.274018*sx
          + 0.658309*s2d
          + 0.213616*s2mp
          - 0.185596*Math.sin( SwissData.DEGTORAD * M )
          - 0.114336*s2f;
    /* Ecliptic latitude of the moon */
    a = smp*cf;
    sx = cmp*sf;
    B =     5.128189*sf
          + 0.280606*(a+sx)               /* sin(MP+F) */
          + 0.277693*(a-sx)               /* sin(MP-F) */
          + 0.173238*(s2d*cf - c2d*sf);   /* sin(2D-F) */
    B *= SwissData.DEGTORAD;
    /* Parallax of the moon */
    p =    0.950724
          +0.051818*cmp
          +0.009531*cx
          +0.007843*c2d
          +0.002824*c2mp;
    p *= SwissData.DEGTORAD;
    /* Elongation of Moon from Sun
     */
    L = sl.swe_degnorm(L);
    L *= SwissData.DEGTORAD;
    /* Distance in au */
    a = 4.263523e-5/Math.sin(p);
    /* Convert to rectangular ecliptic coordinates */
    xyz[0] = L;
    xyz[1] = B;
    xyz[2] = a;
    sl.swi_polcart(xyz, xyz);
    /* Convert to equatorial */
    sl.swi_coortrf2(xyz, xyz, -seps, ceps);
    /* Precess to equinox of J2000.0 */
    sl.swi_precess(xyz, tjd, SwephData.J_TO_J2000);
    /* now emb -> earth */
    for (i = 0; i <= 2; i++)
      xemb[i] -= xyz[i] / (SwephData.EARTH_MOON_MRAT + 1.0);
  }

  /* orbital elements of planets that are computed from osculating elements
   *   epoch
   *   equinox
   *   mean anomaly,
   *   semi axis,
   *   eccentricity,
   *   argument of perihelion,
   *   ascending node
   *   inclination
   */
                                  /* use James Neely's revised elements
                                   *      of Uranian planets*/
  static final String plan_fict_nam[] =
    {"Cupido", "Hades", "Zeus", "Kronos",
     "Apollon", "Admetos", "Vulkanus", "Poseidon",
     "Isis-Transpluto", "Nibiru", "Harrington",
     "Leverrier", "Adams",
     "Lowell", "Pickering",};

  String swi_get_fict_name(int ipl, String snam) {
    if (snam==null) { snam=""; }
    StringBuffer sbnam=new StringBuffer(snam);
    if (read_elements_file(ipl, 0, null, null,
         null, null, null, null, null, null,
         sbnam, null, null) == SweConst.ERR) {
      return "name not found";
    }
    return sbnam.toString();
  }

  private static final double plan_oscu_elem[][]=new double[][] {
    {SwephData.J1900, SwephData.J1900, 163.7409, 40.99837, 0.00460, 171.4333, 129.8325, 1.0833},/* Cupido Neely */
    {SwephData.J1900, SwephData.J1900,  27.6496, 50.66744, 0.00245, 148.1796, 161.3339, 1.0500},/* Hades Neely */
    {SwephData.J1900, SwephData.J1900, 165.1232, 59.21436, 0.00120, 299.0440,   0.0000, 0.0000},/* Zeus Neely */
    {SwephData.J1900, SwephData.J1900, 169.0193, 64.81960, 0.00305, 208.8801,   0.0000, 0.0000},/* Kronos Neely */
    {SwephData.J1900, SwephData.J1900, 138.0533, 70.29949, 0.00000,   0.0000,   0.0000, 0.0000},/* Apollon Neely */
    {SwephData.J1900, SwephData.J1900, 351.3350, 73.62765, 0.00000,   0.0000,   0.0000, 0.0000},/* Admetos Neely */
    {SwephData.J1900, SwephData.J1900,  55.8983, 77.25568, 0.00000,   0.0000,   0.0000, 0.0000},/* Vulcanus Neely */
    {SwephData.J1900, SwephData.J1900, 165.5163, 83.66907, 0.00000,   0.0000,   0.0000, 0.0000},/* Poseidon Neely */
    /* Isis-Transpluto; elements from "Die Sterne" 3/1952, p. 70ff.
     * Strubell does not give an equinox. 1945 is taken to best reproduce
     * ASTRON ephemeris. (This is a strange choice, though.)
     * The epoch is 1772.76. The year is understood to have 366 days.
     * The fraction is counted from 1 Jan. 1772 */
    {2368547.66, 2431456.5, 0.0, 77.775, 0.3, 0.7, 0, 0},
    /* Nibiru, elements from Christian Woeltge, Hannover */
    {1856113.380954, 1856113.380954, 0.0, 234.8921, 0.981092, 103.966, -44.567, 158.708},
    /* Harrington, elements from Astronomical Journal 96(4), Oct. 1988 */
    {2374696.5, SwephData.J2000, 0.0, 101.2, 0.411, 208.5, 275.4, 32.4},
    /* Leverrier's Neptune,
          according to W.G. Hoyt, "Planets X and Pluto", Tucson 1980, p. 63 */
    {2395662.5, 2395662.5, 34.05, 36.15, 0.10761, 284.75, 0, 0},
    /* Adam's Neptune */
    {2395662.5, 2395662.5, 24.28, 37.25, 0.12062, 299.11, 0, 0},
    /* Lowell's Pluto */
    {2425977.5, 2425977.5, 281, 43.0, 0.202, 204.9, 0, 0},
    /* Pickering's Pluto */
    {2425977.5, 2425977.5, 48.95, 55.1, 0.31, 280.1, 100, 15}, 
  };

  /* computes a planet from osculating elements *
   * tjd          julian day
   * ipl          body number
   * ipli         body number in planetary data structure
   * iflag        flags
   */
  int swi_osc_el_plan(double tjd, double xp[], int ipl, int ipli,
                      double[] xearth, double[] xsun, StringBuffer serr) {
    double pqr[]=new double[9], x[]=new double[6];
    double eps, K, fac, rho, cose, sine;
    double alpha, beta, zeta, sigma, M2, Msgn, M_180_or_0;
    DblObj tjd0=new DblObj();
    DblObj tequ=new DblObj();
    DblObj mano=new DblObj();
    DblObj sema=new DblObj();
    DblObj ecce=new DblObj();
    DblObj parg=new DblObj();
    DblObj node=new DblObj();
    DblObj incl=new DblObj();
    double dmot;
    double cosnode, sinnode, cosincl, sinincl, cosparg, sinparg;
    double M, E;
    PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
    PlanData pdp = swed.pldat[ipli];
    IntObj fict_ifl = new IntObj(); fict_ifl.val = 0;
    int i;
    /* orbital elements, either from file or, if file not found,
     * from above built-in set
     */
    if (read_elements_file(ipl, tjd, tjd0, tequ,
         mano, sema, ecce, parg, node, incl,
         null, fict_ifl, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    dmot = 0.9856076686 * SwissData.DEGTORAD / sema.val / Math.sqrt(sema.val);
                                                            /* daily motion */
    if ((fict_ifl.val & FICT_GEO) != 0) {
      dmot /= Math.sqrt(SwephData.SUN_EARTH_MRAT);
    }
    cosnode = Math.cos(node.val);
    sinnode = Math.sin(node.val);
    cosincl = Math.cos(incl.val);
    sinincl = Math.sin(incl.val);
    cosparg = Math.cos(parg.val);
    sinparg = Math.sin(parg.val);
    /* Gaussian vector */
    pqr[0] = cosparg * cosnode - sinparg * cosincl * sinnode;
    pqr[1] = -sinparg * cosnode - cosparg * cosincl * sinnode;
    pqr[2] = sinincl * sinnode;
    pqr[3] = cosparg * sinnode + sinparg * cosincl * cosnode;
    pqr[4] = -sinparg * sinnode + cosparg * cosincl * cosnode;
    pqr[5] = -sinincl * cosnode;
    pqr[6] = sinparg * sinincl;
    pqr[7] = cosparg * sinincl;
    pqr[8] = cosincl;
    /* Kepler problem */
    E = M = sl.swi_mod2PI(mano.val + (tjd - tjd0.val) * dmot); /* mean anomaly of date*/
    /* better E for very high eccentricity and small M */
    if (ecce.val > 0.975) {
      M2 = M * SwissData.RADTODEG;
      if (M2 > 150 && M2 < 210) {
        M2 -= 180;
        M_180_or_0 = 180;
      } else
        M_180_or_0 = 0;
      if (M2 > 330) {
        M2 -= 360;
      }
      if (M2 < 0) {
        M2 = -M2;
        Msgn = -1;
      } else {
        Msgn = 1;
      }
      if (M2 < 30) {
        M2 *= SwissData.DEGTORAD;
        alpha = (1 - ecce.val) / (4 * ecce.val + 0.5);
        beta = M2 / (8 * ecce.val + 1);
        zeta = Math.pow(beta + Math.sqrt(beta * beta + alpha * alpha), 1/3);
        sigma = zeta - alpha / 2;
        sigma = sigma - 0.078 * sigma * sigma * sigma * sigma * sigma / (1 + ecce.val)
  ;
        E = Msgn * (M2 + ecce.val * (3 * sigma - 4 * sigma * sigma * sigma))
                          + M_180_or_0;
      }
    }
    E = sl.swi_kepler(E, M, ecce.val);
    /* position and speed, referred to orbital plane */
    if ((fict_ifl.val & FICT_GEO) != 0) {
      K = SwephData.KGAUSS_GEO / Math.sqrt(sema.val); 
    } else {
      K = SwephData.KGAUSS / Math.sqrt(sema.val);
    }
    cose = Math.cos(E);
    sine = Math.sin(E);
    fac = Math.sqrt((1 - ecce.val) * (1 + ecce.val));
    rho = 1 - ecce.val * cose;
    x[0] = sema.val * (cose - ecce.val);
    x[1] = sema.val * fac * sine;
    x[3] = -K * sine / rho;
    x[4] = K * fac * cose / rho;
    /* transformation to ecliptic */
    xp[0] = pqr[0] * x[0] + pqr[1] * x[1];
    xp[1] = pqr[3] * x[0] + pqr[4] * x[1];
    xp[2] = pqr[6] * x[0] + pqr[7] * x[1];
    xp[3] = pqr[0] * x[3] + pqr[1] * x[4];
    xp[4] = pqr[3] * x[3] + pqr[4] * x[4];
    xp[5] = pqr[6] * x[3] + pqr[7] * x[4];
    /* transformation to equator */
    eps = sl.swi_epsiln(tequ.val);
    sl.swi_coortrf(xp, xp, -eps);
    sl.swi_coortrf(xp, 3, xp, 3, -eps);
    /* precess to J2000 */
    if (tequ.val != SwephData.J2000) {
      sl.swi_precess(xp, tequ.val, SwephData.J_TO_J2000);
      sl.swi_precess(xp, 3, tequ.val, SwephData.J_TO_J2000);
    }
    /* to solar system barycentre */
    if ((fict_ifl.val & FICT_GEO) != 0) {
      for (i = 0; i <= 5; i++) {
        xp[i] += xearth[i];
      }
    } else {
      for (i = 0; i <= 5; i++) {    
        xp[i] += xsun[i];
      }
    }
    if (pdp.x == xp) {
      pdp.teval = tjd;   /* for precession! */
      pdp.iephe = pedp.iephe;
    }
    return SweConst.OK;
  }

  /* note: input parameter tjd is required for T terms in elements */
  private int read_elements_file(int ipl, double tjd,
                                 DblObj tjd0, DblObj tequ,
                                 DblObj mano, DblObj sema, DblObj ecce,
                                 DblObj parg, DblObj node, DblObj incl,
                                 StringBuffer pname, IntObj fict_ifl,
                                 StringBuffer serr) {
    int i, iline, iplan, retc, ncpos;
    FilePtr fp = null;
    String s, sp;
    int spIdx=0;
    String cpos[]=new String[20], serri="";
    boolean elem_found = false;
    double tt = 0;
    /* -1, because file information is not saved, file is always closed */
    if ((fp = sw.swi_fopen(-1, SweConst.SE_FICTFILE, swed.ephepath, serr)) == null) {
      /* file does not exist, use built-in bodies */
      if (ipl >= SweConst.SE_NFICT_ELEM) {
        if (serr != null) {
          serr.append("error no elements for fictitious body no ").append(ipl);
        }
        return SweConst.ERR;
      }
      if (tjd0 != null) {
        tjd0.val = plan_oscu_elem[ipl][0];                   /* epoch */
      }
      if (tequ != null) {
        tequ.val = plan_oscu_elem[ipl][1];                   /* equinox */
      }
      if (mano != null) {
        mano.val = plan_oscu_elem[ipl][2] * SwissData.DEGTORAD; /* mean anomaly */
      }
      if (sema != null) {
        sema.val = plan_oscu_elem[ipl][3];                   /* semi-axis */
      }
      if (ecce != null) {
        ecce.val = plan_oscu_elem[ipl][4];                   /* eccentricity */
      }
      if (parg != null) {
        parg.val = plan_oscu_elem[ipl][5] * SwissData.DEGTORAD; /* arg. of peri. */
      }
      if (node != null) {
        node.val = plan_oscu_elem[ipl][6] * SwissData.DEGTORAD;  /* asc. node */
      }
      if (incl != null) {
        incl.val = plan_oscu_elem[ipl][7] * SwissData.DEGTORAD; /* inclination*/
      }
      if (pname != null) {
        pname.setLength(0);
        pname.append(plan_fict_nam[ipl]);
      }
      return SweConst.OK;
    }
    /*
     * find elements in file
     */
    iline = 0;
    iplan = -1;
    try {
//    while (fgets(s, AS_MAXCH, fp) != null)
      while ((s=fp.readLine()) != null) {
        s=s.trim();
//        iline++;
//        spIdx = 0;
//        while(s.charAt(spIdx) == ' ' || s.charAt(spIdx) == '\t')
//          spIdx++;
//        s=s.substring(spIdx);
        sp = s;
        spIdx=0;
        char ch=s.charAt(spIdx);
        if (ch == '#' || ch=='\r' || ch=='\n' || ch=='\0') {
          continue;
        }
//    if ((sp = strchr(s, '#')) != NULL)
//      *sp = '\0';
        sp = null;
        if ((spIdx = s.indexOf('#')) >= 0) {
          s = s.substring(0,s.indexOf('#'));
          sp = "";
        }
        ncpos = sl.swi_cutstr(s, ",", cpos, 20);
        serri="error in file "+SweConst.SE_FICTFILE+", line "+
              iline+":";
        if (ncpos < 9) {
          if (serr != null) {
            serr.setLength(0);
            serr.append(serri).append(" nine elements required");
          }
          return SweConst.ERR;
        }
        iplan++;
        if (iplan != ipl) {
          continue;
        }
        elem_found = true;
        /* epoch of elements */
        if (tjd0 != null) {
          sp = cpos[0];
//          for (i = 0; i < 5; i++)
//       sp[i] = tolower(sp[i]);
          sp=sp.length()<=5?sp.toLowerCase():
                               sp.substring(0,5).toLowerCase()+sp.substring(5);
          if (sp.startsWith("j2000")) {
            tjd0.val = SwephData.J2000;
          } else if (sp.startsWith("b1950")) {
            tjd0.val = SwephData.B1950;
          } else if (sp.startsWith("j1900")) {
            tjd0.val = SwephData.J1900;
          } else if (sp.charAt(0) == 'j' || sp.charAt(0) == 'b') {
            if (serr != null) {
              serr.setLength(0);
              serr.append(serri).append(" invalid epoch");
            }
//          goto return_err;
            fp.close(); return SweConst.ERR;
          } else
            tjd0.val = SwissLib.atof(sp);
          tt = tjd - tjd0.val;
        }
        /* equinox */
        if (tequ != null) {
          sp = cpos[1];
          spIdx=0;
          while(sp.charAt(spIdx) == ' ' || sp.charAt(spIdx) == '\t')
            spIdx++;
//          for (i = 0; i < 5; i++)
//       sp[i] = tolower(sp[i]);
          sp=sp.substring(spIdx);
          sp=sp.length()<5?sp.toLowerCase():
                               sp.substring(0,5).toLowerCase()+sp.substring(5);
          if (sp.startsWith("j2000")) {
            tequ.val = SwephData.J2000;
          } else if (sp.startsWith("b1950")) {
            tequ.val = SwephData.B1950;
          } else if (sp.startsWith("j1900")) {
            tequ.val = SwephData.J1900;
          } else if (sp.startsWith("jdate")) {
            tequ.val = tjd;
          } else if (sp.charAt(0) == 'j' || sp.charAt(0) == 'b') {
            if (serr != null) {
              serr.setLength(0);
              serr.append(serri).append(" invalid equinox");
            }
//          goto return_err;
            fp.close(); return SweConst.ERR;
          } else {
//        *tequ = atof(sp);
            tequ.val = SwissLib.atof(sp);
          }
        }
        /* mean anomaly t0 */
        if (mano != null) {
          retc = check_t_terms(tt, cpos[2], mano);
          mano.val = sl.swe_degnorm(mano.val);
          if (retc == SweConst.ERR) {
            if (serr != null) {
              serr.append(serri).append(" mean anomaly value invalid");
            }
//          goto return_err;
            fp.close(); return SweConst.ERR;
          }
          /* if mean anomaly has t terms (which happens with fictitious
           * planet Vulcan), we set
           * epoch = tjd, so that no motion will be added anymore
           * equinox = tjd */
          if (retc == 1) {
            tjd0.val = tjd;
          }
          mano.val *= SwissData.DEGTORAD;
        }
        /* semi-axis */
        if (sema != null) {
          retc = check_t_terms(tt, cpos[3], sema);
          if (sema.val <= 0 || retc == SweConst.ERR) {
            if (serr != null) {
              serr.append(serri).append(" semi-axis value invalid");
            }
//          goto return_err;
            fp.close(); return SweConst.ERR;
          }
        }
        /* eccentricity */
        if (ecce != null) {
          retc = check_t_terms(tt, cpos[4], ecce);
          if (ecce.val >= 1 || ecce.val < 0 || retc == SweConst.ERR) {
            if (serr != null) {
              serr.setLength(0);
              serr.append(serri).append(" eccentricity invalid (no parabolic or hyperbolic or bits allowed)");
            }
//          goto return_err;
            fp.close(); return SweConst.ERR;
          }
        }
        /* perihelion argument */
        if (parg != null) {
          retc = check_t_terms(tt, cpos[5], parg);
          parg.val = sl.swe_degnorm(parg.val);
          if (retc == SweConst.ERR) {
            if (serr != null) {
              serr.setLength(0);
              serr.append(serri).append(" perihelion argument value invalid");
            }
//          goto return_err;
            fp.close(); return SweConst.ERR;
          }
          parg.val *= SwissData.DEGTORAD;
        }
        /* node */
        if (node != null) {
          retc = check_t_terms(tt, cpos[6], node);
          node.val = sl.swe_degnorm(node.val);
          if (retc == SweConst.ERR) {
            if (serr != null) {
              serr.setLength(0);
              serr.append(serri).append(" node value invalid");
            }
//          goto return_err;
            fp.close(); return SweConst.ERR;
          }
          node.val *= SwissData.DEGTORAD;
        }
        /* inclination */
        if (incl != null) {
          retc = check_t_terms(tt, cpos[7], incl);
          incl.val = sl.swe_degnorm(incl.val);
          if (retc == SweConst.ERR) {
            if (serr != null) {
              serr.setLength(0);
              serr.append(serri).append(" inclination value invalid");
            }
//          goto return_err;
            fp.close(); return SweConst.ERR;
          }
          incl.val *= SwissData.DEGTORAD;
        }
        /* planet name */
        if (pname != null) {
          sp = cpos[8];
          spIdx=0;
          while(sp.charAt(spIdx) == ' ' || sp.charAt(spIdx) == '\t')
            spIdx++;
          sp=sp.substring(spIdx);
//      swi_right_trim(sp);
          sp=sp.trim();
          pname.setLength(0); pname.append(sp);
        }
        /* geocentric */
        if (fict_ifl != null && ncpos > 9) {
//          for (sp = cpos[9]; *sp != '\0'; sp++)
//            *sp = tolower(*sp);
          sp = sp.substring(0,Math.min(sp.length(),spIdx+9)) +
               sp.substring(Math.min(sp.length(),spIdx+9)).toLowerCase();
//          if (strstr(cpos[9], "geo") != NULL)
//            fict_ifl.val |= FICT_GEO;
          if (cpos[9].indexOf("geo") >= 0) {
            fict_ifl.val |= FICT_GEO;
          }
        }
        break;
      }
      if (!elem_found) {
        if (serr != null) {
          serr.append(serri).append(" elements for planet ").append(ipl).append(" not found");
        }
//      goto return_err;
        fp.close(); return SweConst.ERR;
      }
      fp.close();
      return SweConst.OK;
    } catch (java.io.IOException e) {
      if (fp!=null) { try { fp.close(); } catch (java.io.IOException ie) { } }
    }
    return SweConst.ERR;
  }

  private int check_t_terms(double t, String sinp, DblObj doutp) {
    int i, isgn = 1, z;
    int retc = 0;
    int spidx;
    double tt[]=new double[5], fac;
    tt[0] = t / 36525;
    tt[1] = tt[0];
    tt[2] = tt[1] * tt[1];
    tt[3] = tt[2] * tt[1];
    tt[4] = tt[3] * tt[1];
//    if (strpbrk(sinp, "+-") != null)
    if (sinp.indexOf('+') + sinp.indexOf('-') > -2) {
      retc = 1; /* with additional terms */
    }
    spidx=0;
    doutp.val = 0;
    fac = 1;
    z = 0;
    while (true) {
      while(spidx<sinp.length() &&
            (sinp.charAt(spidx)==' ' || sinp.charAt(spidx)=='\t')) {
        spidx++;
      }
      if (spidx==sinp.length() ||
          sinp.charAt(spidx)=='+' || sinp.charAt(spidx)=='-') {
        if (z > 0) {
          doutp.val += fac;
        }
        isgn = 1;
        if (spidx!=sinp.length() && sinp.charAt(spidx) == '-') {
          isgn = -1;
        }
        fac = 1 * isgn;
        if (spidx==sinp.length()) {
          return retc;
        }
        spidx++;
      } else {
        while(spidx<sinp.length() &&
              (sinp.charAt(spidx)=='*' || sinp.charAt(spidx)==' '
              || sinp.charAt(spidx)=='\t')) {
          spidx++;
        }
        if (spidx<sinp.length() &&
            (sinp.charAt(spidx)=='t' || sinp.charAt(spidx)=='T')) {
                /* a T */
          spidx++;
          if (spidx<sinp.length() &&
              (sinp.charAt(spidx)=='+' || sinp.charAt(spidx)=='-')) {
            fac *= tt[0];
          } else if ((i = SwissLib.atoi(sinp.substring(Math.min(sinp.length(),spidx)))) <= 4 && i >= 0) {
            fac *= tt[i];
          }
        } else {
          /* a number */
          double db=SwissLib.atof(sinp.substring(spidx));
          if (db!=0 || sinp.charAt(spidx)=='0') {
            fac *= db;
          }
        }
        while (spidx<sinp.length() &&
               (Character.isDigit(sinp.charAt(spidx)) ||
                sinp.charAt(spidx)=='.'))
          spidx++;
      }
      z++;
    }
  }

  private Plantbl planets[] = {
    SwemptabMer.mer404,
    SwemptabVen.ven404,
    SwemptabEar.ear404,
    SwemptabMar.mar404,
    SwemptabJup.jup404,
    SwemptabSat.sat404,
    SwemptabUra.ura404,
    SwemptabNep.nep404,
    SwemptabPlu.plu404,
  };
}



class SwissData {

  
  public String ODEGREE_CHAR=""+'\u00b0'; // Unicode degree character 176
                                          // Identical in most ISO-8859 sets


  public static final String ayanamsa_name[] = {
     "Fagan/Bradley",
     "Lahiri",
     "De Luce",
     "Raman",
     "Ushashashi",
     "Krishnamurti",
     "Djwhal Khul",
     "Yukteshwar",
     "J.N. Bhasin",
     "Babylonian/Kugler 1",
     "Babylonian/Kugler 2",
     "Babylonian/Kugler 3",
     "Babylonian/Huber",
     "Babylonian/Eta Piscium",
     "Babylonian/Aldebaran = 15 Tau",
     "Hipparchos",
     "Sassanian",
     "Galact. Center = 0 Sag",
     "J2000",
     "J1900",
     "B1950",
  };

//////////////////////////////////////////////////////////////////////////////
// sweodef.h: ////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
  static final double M_PI=3.14159265358979323846;

  public static final int AS_MAXCH=256; // used for string declarations,
                                        // allowing 255 char+\0

  static final double DEGTORAD=0.0174532925199433;
  static final double RADTODEG=57.2957795130823;

  static final int DEG=360000;  // degree expressed in centiseconds
  static final int DEG7_30=2700000;	// 7.5 degrees
  static final int DEG15=15 * DEG;
  static final int DEG24=24 * DEG;
  static final int DEG30=30 * DEG;
  static final int DEG60=60 * DEG;
  static final int DEG90=90 * DEG;
  static final int DEG120=120 * DEG;
  static final int DEG150=150 * DEG;
  static final int DEG180=180 * DEG;
  static final int DEG270=270 * DEG;
  static final int DEG360=360 * DEG;

  static final double CSTORAD=4.84813681109536E-08; // centisec to rad:
                                                    // pi / 180 /3600/100
  static final double RADTOCS=2.06264806247096E+07; // rad to centisec
                                                    // 180*3600*100/pi

  static final double CS2DEG=1.0/360000.0;	     // centisec to degree

  static final String BFILE_R_ACCESS="r";  // open binary file for reading
  static final String BFILE_RW_ACCESS="r+";// open binary file for writing and reading
  static final String BFILE_W_CREATE="w";  // create/open binary file for write
  static final String BFILE_A_ACCESS="a+"; // create/open binary file for append
  static final String FILE_R_ACCESS="r";   // open text file for reading
  static final String FILE_RW_ACCESS="r+"; // open text file for writing and reading
  static final String FILE_W_CREATE="w";   // create/open text file for write
  static final String FILE_A_ACCESS="a+";  // create/open text file for append
  static final int O_BINARY=0;	           // for open(), not defined in Unix
  static final int OPEN_MODE=0666;         // default file creation mode
  public String DIR_GLUE;              // glue string for directory/file
  public static final String PATH_SEPARATOR=";:"; // semicolon or colon may be used


//////////////////////////////////////////////////////////////////////////////
// swephexp.h: ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
  public static final int SE_NSIDM_PREDEF         =21;

//  static final int SE_MAX_STNAME=20;    // maximum size of fixstar name;
//                                        // the parameter star in swe_fixstar
//					// must allow twice this space for
//				        // the returned star name.
//

  static final int pnoext2int[] = {SwephData.SEI_SUN, SwephData.SEI_MOON,
    SwephData.SEI_MERCURY, SwephData.SEI_VENUS, SwephData.SEI_MARS,
    SwephData.SEI_JUPITER, SwephData.SEI_SATURN, SwephData.SEI_URANUS,
    SwephData.SEI_NEPTUNE, SwephData.SEI_PLUTO, 0, 0, 0, 0, SwephData.SEI_EARTH,
    SwephData.SEI_CHIRON, SwephData.SEI_PHOLUS, SwephData.SEI_CERES,
    SwephData.SEI_PALLAS, SwephData.SEI_JUNO, SwephData.SEI_VESTA, };

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
  boolean ephe_path_is_set=false;
  boolean jpl_file_is_open=false;
  FilePtr fixfp=null;
  String ephepath;
  String jplfnam;
  int jpldenum;
  boolean geopos_is_set=false;
  boolean ayana_is_set=false;

  FileData fidat[] = new FileData[SwephData.SEI_NEPHFILES];
  GenConst gcdat;
  PlanData pldat[] = new PlanData[SwephData.SEI_NPLANETS];
  PlanData nddat[] = new PlanData[SwephData.SEI_NNODE_ETC];
  SavePositions savedat[] = new SavePositions[SweConst.SE_NPLANETS+1];
  Epsilon oec, oec2000;
  Nut nut, nut2000, nutv;
  TopoData topd;
  SidData sidd;
  String astelem;
  double ast_G, ast_H, ast_diam;
  int i_saved_planet_name;
  String saved_planet_name;

  
  public SwissData() {
    // File separator character:
    DIR_GLUE = System.getProperty("file.separator");

    try {
      // ODEGREE_CHAR:
      String cp=System.getProperties().getProperty("file.encoding");
      if (cp!=null) {
        if (cp.toUpperCase().startsWith("CP")) {
          try {
            int cpn=Integer.parseInt(cp.substring(2));
            if (cpn>=437 && cpn<870) {
              ODEGREE_CHAR=""+'\u00f8';
            }
          } catch (NumberFormatException nfe) {
          }
          ODEGREE_CHAR=""+'\u00f8'; // DOS degree character 248
        } else if (cp.toUpperCase().startsWith("ISO-8859-")) {
          ODEGREE_CHAR=""+'\u00b0'; // Latin1 degree character 176
        } else if (cp.toUpperCase().startsWith("UTF")) {
          ODEGREE_CHAR=""+'\u00b0'; // Default Unicode...
        }
      }
    } catch (SecurityException ase) {
      if (DIR_GLUE.equals("/")) {
        ODEGREE_CHAR=""+'\u00b0'; // Latin1 degree character 176
      } else if (DIR_GLUE.equals("\\")) {
        ODEGREE_CHAR=""+'\u00f8'; // DOS degree character 248
      } else {
        ODEGREE_CHAR=""+'\u00b0'; // Default Unicode...
      }
    }
    // Macintoshs (prior to MacOS X) should use '\u00a1', but how to
    // identify more reasonably? Has the Mac an appropriate text window anyway?
    if (DIR_GLUE.equals(":")) {
      ODEGREE_CHAR=""+'\u00a1';
    }


    int i;
    for(i=0;i<SwephData.SEI_NEPHFILES;i++){ fidat[i] = new FileData(); }
    gcdat = new GenConst();
    for(i=0;i<SwephData.SEI_NPLANETS;i++){ pldat[i] = new PlanData(); }
    for(i=0;i<SwephData.SEI_NNODE_ETC;i++){ nddat[i] = new PlanData(); }
    for(i=0;i<SweConst.SE_NPLANETS+1;i++){ savedat[i] = new SavePositions(); }
    oec = new Epsilon();
    oec2000 = new Epsilon();
    nut = new Nut();
    nut2000 = new Nut();
    nutv = new Nut();
    topd = new TopoData();
    sidd = new SidData();
  }

}


class SwissephException extends RuntimeException {
  private double jdet=0;
  private int type=0;
  private int rc=0;

  public static final int UNDEFINED                     = 0;

  // FILE errors:
  public static final int FILE_ERROR                    = 1;
  public static final int UNSPECIFIED_FILE_ERROR        = FILE_ERROR | 2;
  public static final int INVALID_FILE_NAME             = FILE_ERROR | 4;
  public static final int FILE_NOT_FOUND                = FILE_ERROR | 8;
  public static final int FILE_OPEN_FAILED              = FILE_ERROR | 16;
  public static final int FILE_READ_ERROR               = FILE_ERROR | 32;
  public static final int DATA_FILE_ERROR               = FILE_ERROR | 64;

  // Parameter errors:
  public static final int PARAM_ERROR                   = 128;
  public static final int OUT_OF_TIME_RANGE             = PARAM_ERROR | 256;
  public static final int UNSUPPORTED_OBJECT            = PARAM_ERROR | 512;
  public static final int INVALID_PARAMETER_COMBINATION = PARAM_ERROR | 1024;

  // User requested:
  public static final int USER_ERROR                    = 2048;
  public static final int BEYOND_USER_TIME_LIMIT        = USER_ERROR | 4096;



  public SwissephException(double jdet, int type, int rc, StringBuffer sb) {
    super(sb==null?null:sb.toString());
    this.jdet = jdet;
    this.type = type;
    this.rc = rc;
  }

  public SwissephException(double jdet, int type, int rc, String s) {
    super(s);
    this.jdet = jdet;
    this.type = type;
    this.rc = rc;
  }

  public SwissephException(double jdet, int type, String s) {
    super(s);
    this.jdet = jdet;
    this.type = type;
  }

  public SwissephException(double jdet, String s) {
    super(s);
    this.jdet = jdet;
    this.type = UNDEFINED;
  }

  
  public double getJD() {
    return jdet;
  }

  public int getType() {
    return type;
  }

  int getRC() {
    return rc;
  }
}


class SwissEph {

    SwissData swed;
    SwephMosh smosh;
    SwephJPL sj;
    SwissLib sl;
    Swecl sc=null;
    Swemmoon sm;
    SweHouse sh=null;
    Extensions ext=null;

    double lastLat=0.;
    double lastLong=0.;
    int lastHSys=-1;

    
    //////////////////////////////////////////////////////////////////////////////
    // Constructors: /////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////
    
    public SwissEph() {
        this(null);
    }

    public String getTmp() {
        String tmp = "";
        if(System.getProperty("os.name").toLowerCase().indexOf("windows") > -1){
            tmp = "c:/temp";
        } else {
            tmp = "/tmp";
        }
        return tmp;
    }    

    
    public SwissEph(String path) {
               
        swed     = new SwissData();
        sl       = new SwissLib(this.swed);
        sm       = new Swemmoon(this.swed, this.sl);
        smosh    = new SwephMosh(this.sl, this, this.swed);
        sj       = new SwephJPL(this, this.swed, this.sl);

        swed.ephe_path_is_set=false;
        swed.jpl_file_is_open=false;
        swed.fixfp=null;
        swed.ephepath=SweConst.SE_EPHE_PATH;
        swed.jplfnam=SweConst.SE_FNAME_DFT;
        swed.geopos_is_set=false;
        swed.ayana_is_set=false;
        swe_set_ephe_path(path);

    }
    //////////////////////////////////////////////////////////////////////////////
    // End of Constructors ///////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////


    //////////////////////////////////////////////////////////////////////////////
    // Public Methods: ///////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    private int httpBufSize=300;

    
    public void setHttpBufSize(int size) {
        httpBufSize=size;
        if (size<100) {
            httpBufSize=100;
        }
        swe_close();
    }

    /* The routine called by the user.
     * It checks whether a position for the same planet, the same t, and the
     * same flag bits has already been computed.
     * If yes, this position is returned. Otherwise it is computed.
     * -> If the SEFLG_SPEED flag has been specified, the speed will be returned
     * at offset 3 of position array x[]. Its precision is probably better
     * than 0.002"/day.
     * -> If the SEFLG_SPEED3 flag has been specified, the speed will be computed
     * from three positions. This speed is less accurate than SEFLG_SPEED,
     * i.e. better than 0.1"/day. And it is much slower. It is used for
     * program tests only.
     * -> If no speed flag has been specified, no speed will be returned.
     */
    private int swe_calc_epheflag_sv = 0;

    
    public int swe_calc_ut(double tjd_ut, int ipl, int iflag, double xx[],
                           StringBuffer serr) {
        return swe_calc(tjd_ut + SweDate.getDeltaT(tjd_ut), ipl, iflag, xx, serr);
    }
    
    public int swe_calc(double tjd, int ipl, int iflag, double xx[],
                        StringBuffer serr) {
        // It has been rewritten to be wrapper to the old interface without
        // exception handling like it was in C. The old routine can now be
        // found in the method _calc().
        int ret = 0;
        try {
            ret = _calc(tjd, ipl, iflag, xx, serr);
        } catch (SwissephException se) {
            ret = se.getRC();
            serr.setLength(0);
            serr.append(se.getMessage());
        }
        return ret;
    }

    // This is the new recommended interface for planetary calculations.
    // It should be rewritten to be used for fixstars as well.
    public int calc(double jdET, int ipl, int iflag, double xx[])
        throws SwissephException {
        return _calc(jdET, ipl, iflag, xx, new StringBuffer());
    }

    private int _calc(double tjd, int ipl, int iflag, double xx[],
                      StringBuffer serr) throws SwissephException {
        int i, j;
        int iflgcoor;
        int iflgsave = iflag;
        int epheflag;
        SavePositions sd;
        double x[]=new double[6], xs[];
        double x0[]=new double[24],
            x2[]=new double[24];
        double dt;

        /* if ephemeris flag != ephemeris flag of last call,
         * we clear the save area, to prevent swecalc() using
         * previously computed data for current calculation.
         * except with ipl = SE_ECL_NUT which is not dependent
         * on ephemeris, and except if change is from
         * ephemeris = 0 to ephemeris = SEFLG_DEFAULTEPH
         * or vice-versa.
         */
        epheflag = iflag & SweConst.SEFLG_EPHMASK;
        if ((epheflag & SweConst.SEFLG_DEFAULTEPH)!=0) {
            epheflag = 0;
        }
        if (swe_calc_epheflag_sv != epheflag && ipl != SweConst.SE_ECL_NUT) {
            swe_close();
            swe_calc_epheflag_sv = epheflag;
        }
        /* high precision speed prevails fast speed */
        if ((iflag & SweConst.SEFLG_SPEED3)!=0 && (iflag & SweConst.SEFLG_SPEED)!=0) {
            iflag = iflag & ~SweConst.SEFLG_SPEED3;
        }
        /* cartesian flag excludes radians flag */
        if (((iflag & SweConst.SEFLG_XYZ)!=0) &&
            ((iflag & SweConst.SEFLG_RADIANS)!=0)) {
            iflag = iflag & ~SweConst.SEFLG_RADIANS;
        }
        /*    if (iflag & SweConst.SEFLG_ICRS)
              iflag |= SweConst.SEFLG_J2000;*/
        /* pointer to save area */
        if (ipl < SweConst.SE_NPLANETS && ipl >= SweConst.SE_SUN) {
            sd = swed.savedat[ipl];
        } else {
            /* other bodies, e.g. asteroids called with ipl = SE_AST_OFFSET + MPC# */
            sd = swed.savedat[SweConst.SE_NPLANETS];
        }
        /*
         * if position is available in save area, it is returned.
         * this is the case, if tjd = tsave and iflag = iflgsave.
         * coordinate flags can be neglected, because save area
         * provides all coordinate types.
         * if ipl > SE_AST(EROID)_OFFSET, ipl must be checked,
         * because all asteroids called by MPC number share the same
         * save area.
         */
        iflgcoor = SweConst.SEFLG_EQUATORIAL | SweConst.SEFLG_XYZ |
            SweConst.SEFLG_RADIANS;

        try { // SwissephExceptions from swecalc
            if (sd.tsave != tjd || tjd == 0 || ipl != sd.ipl ||
                ((sd.iflgsave & ~iflgcoor) != (iflag & ~iflgcoor))) {
                /*
                 * otherwise, new position must be computed
                 */
                if ((iflag & SweConst.SEFLG_SPEED3) == 0) {
                    /*
                     * with high precision speed from one call of swecalc()
                     * (FAST speed)
                     */
                    sd.tsave = tjd;
                    sd.ipl = ipl;
                    if ((sd.iflgsave = swecalc(tjd, ipl, iflag, sd.xsaves, serr)) ==
                        SweConst.ERR) {
                        return swe_calc_error(xx);
                    }
                } else {
                    /*
                     * with speed from three calls of swecalc(), slower and less accurate.
                     * (SLOW speed, for test only)
                     */
                    sd.tsave = tjd;
                    sd.ipl = ipl;
                    switch(ipl) {
                        case SweConst.SE_MOON:
                            dt = SwephData.MOON_SPEED_INTV;
                            break;
                        case SweConst.SE_OSCU_APOG:
                        case SweConst.SE_TRUE_NODE:
                            /* this is the optimum dt with Moshier ephemeris, but not with
                             * JPL ephemeris or SWISSEPH. To avoid completely false speed
                             * in case that JPL is wanted but the program returns Moshier,
                             * we use Moshier optimum.
                             * For precise speed, use JPL and FAST speed computation,
                             */
                            dt = SwephData.NODE_CALC_INTV_MOSH;
                            break;
                        default:
                            dt = SwephData.PLAN_SPEED_INTV;
                            break;
                    }
                    sd.iflgsave = swecalc(tjd-dt, ipl, iflag, x0, serr);
                    if (sd.iflgsave == SweConst.ERR) {
                        return swe_calc_error(xx);
                    }
                    sd.iflgsave = swecalc(tjd+dt, ipl, iflag, x2, serr);
                    if (sd.iflgsave == SweConst.ERR) {
                        return swe_calc_error(xx);
                    }
                    sd.iflgsave = swecalc(tjd, ipl, iflag, sd.xsaves, serr);
                    if (sd.iflgsave == SweConst.ERR) {
                        return swe_calc_error(xx);
                    }
                    denormalize_positions(x0, sd.xsaves, x2);
                    calc_speed(x0, sd.xsaves, x2, dt);
                }
            }
        } catch (SwissephException se) {
            sd.iflgsave = SweConst.ERR;
            swe_calc_error(xx);
            throw se;
        }
        // end_swe_calc:
        int xsOffset=0;
        xs=sd.xsaves;
        if ((iflag & SweConst.SEFLG_EQUATORIAL) != 0) {
            xsOffset=12;        /* equatorial coordinates */
            //    } else {
            //      xsOffset=0;         /* ecliptic coordinates */
        }
        if ((iflag & SweConst.SEFLG_XYZ)!=0) {
            xsOffset+=6;         /* cartesian coordinates */
        }
        if (ipl == SweConst.SE_ECL_NUT) {
            i = 4;
        } else {
            i = 3;
        }
        for (j = 0; j < i; j++) { x[j] = xs[j+xsOffset]; }
        for (j = i; j < 6; j++) { x[j] = 0; }
        if ((iflag & (SweConst.SEFLG_SPEED3 | SweConst.SEFLG_SPEED))!=0) {
            for (j = 3; j < 6; j++) { x[j] = xs[j+xsOffset]; }
        }
        if ((iflag & SweConst.SEFLG_RADIANS)!=0) {
            if (ipl == SweConst.SE_ECL_NUT) {
                for (j = 0; j < 4; j++)
                    x[j] *= SwissData.DEGTORAD;
            } else {
                for (j = 0; j < 2; j++)
                    x[j] *= SwissData.DEGTORAD;
                if ((iflag & (SweConst.SEFLG_SPEED3 | SweConst.SEFLG_SPEED))!=0) {
                    for (j = 3; j < 5; j++)
                        x[j] *= SwissData.DEGTORAD;
                }
            }  
        } 
        for (i = 0; i <= 5; i++) {
            xx[i] = x[i];
        }
        iflag = sd.iflgsave;
        /* if no ephemeris has been specified, do not return chosen ephemeris */
        if ((iflgsave & SweConst.SEFLG_EPHMASK) == 0) {
            iflag = iflag & ~SweConst.SEFLG_DEFAULTEPH;
        }
        return iflag;
    }

    /* closes all open files, frees space of planetary data,
     * deletes memory of all computed positions
     */
    
    public void swe_close() {
        int i;
        try {
            /* close SWISSEPH files */
            for(i=0;i<SwephData.SEI_NEPHFILES;i++) {
                swed.fidat[i].clearData();
            }
            /* free planets data space */
            for(i=0;i<SwephData.SEI_NPLANETS;i++) {
                swed.pldat[i].clearData();
            }
            for (i=0; i <= SweConst.SE_NPLANETS; i++) {/* "<=" is correct! see decl.*/
                swed.savedat[i].clearData();
            }
            /* clear node data space */
            for(i=0;i<SwephData.SEI_NNODE_ETC;i++) {
                swed.nddat[i].clearData();
            }
            swed.oec.clearData();
            swed.oec2000.clearData();
            swed.nut.clearData();
            swed.nut2000.clearData();
            swed.nutv.clearData();
            /* close JPL file */
            sj.swi_close_jpl_file();
            swed.jpl_file_is_open=false;
            /* close fixed stars */
            if (swed.fixfp!=null) {
                swed.fixfp.close();
                swed.fixfp=null;
            }
        } catch (java.io.IOException e) {
            // NBT
        }
    }

    /* sets ephemeris file path.
     * also calls swe_close(). this makes sure that swe_calc()
     * won't return planet positions previously computed from other
     * ephemerides
     */
    
    public void swe_set_ephe_path(String path) {
        String s="";
        swed.ephe_path_is_set=true;
        /* close all open files and delete all planetary data */
        swe_close();
        //  /* environment variable SE_EPHE_PATH has priority */
        //  if ((sp = getenv("SE_EPHE_PATH")) != NULL
        //    && strlen(sp) != 0
        //    && strlen(sp) <= AS_MAXCH-1-13) {
        //    strcpy(s, sp);
        //  } else
        if (path == null || path.length() == 0) {
            s=SweConst.SE_EPHE_PATH;
        } else if (path.length() <= SwissData.AS_MAXCH-1-13) {
            s=path;
        } else {
            s=SweConst.SE_EPHE_PATH;
        }
        // JAVA: Skipping this code in the Java version - it does not do anything
        // meaningful anyway...
        //    if (! s.endsWith(swed.DIR_GLUE)) {
        //      s+=swed.DIR_GLUE;
        //    }
        swed.ephepath=s;
    }

    /* sets jpl file name.
     * also calls swe_close(). this makes sure that swe_calc()
     * won't return planet positions previously computed from other
     * ephemerides
     */
    
    public void swe_set_jpl_file(String fname) {
        /* close all open files and delete all planetary data */
        swe_close();
        /* if path is contained in fnam, it is filled into the path variable */
        if (fname.indexOf(swed.DIR_GLUE)>=0) {
            fname=fname.substring(fname.lastIndexOf(swed.DIR_GLUE));
        }
        if (fname.length() >= SwissData.AS_MAXCH) {
            fname=fname.substring(0,SwissData.AS_MAXCH);
        }
        swed.jplfnam=fname;
    }

    
    public void swe_set_sid_mode(int sid_mode, double t0, double ayan_t0) {
        SidData sip = swed.sidd;
        sip.sid_mode = sid_mode;
        if (sid_mode >= SweConst.SE_SIDBITS) {
            sid_mode %= SweConst.SE_SIDBITS;
        }
        /* standard equinoxes: positions always referred to ecliptic of t0 */
        if (sid_mode == SweConst.SE_SIDM_J2000
            || sid_mode == SweConst.SE_SIDM_J1900
            || sid_mode == SweConst.SE_SIDM_B1950) {
            sip.sid_mode |= SweConst.SE_SIDBIT_ECL_T0;
        }
        if (sid_mode >= SwissData.SE_NSIDM_PREDEF && sid_mode != SweConst.SE_SIDM_USER) {
            sip.sid_mode = sid_mode = SweConst.SE_SIDM_FAGAN_BRADLEY;
        }
        swed.ayana_is_set = true;
        if (sid_mode == SweConst.SE_SIDM_USER) {
            sip.t0 = t0;
            sip.ayan_t0 = ayan_t0;
        } else {
            sip.t0 = SwephData.ayanamsa[sid_mode].t0;
            sip.ayan_t0 = SwephData.ayanamsa[sid_mode].ayan_t0;
        }
        swi_force_app_pos_etc();
    }

    /* the ayanamsa (precession in longitude)
     * according to Newcomb's definition: 360 -
     * longitude of the vernal point of t referred to the
     * ecliptic of t0.
     */
    
    public double swe_get_ayanamsa(double tjd_et) {
        double x[]=new double[6], eps;
        SidData sip = swed.sidd;
        if (!swed.ayana_is_set) {
            swe_set_sid_mode(SweConst.SE_SIDM_FAGAN_BRADLEY, 0, 0);
        }
        /* vernal point (tjd), cartesian */
        x[0] = 1;
        x[1] = x[2] = 0;
        /* to J2000 */
        if (tjd_et != SwephData.J2000) {
            sl.swi_precess(x, tjd_et, SwephData.J_TO_J2000);
        }
        /* to t0 */
        sl.swi_precess(x, sip.t0, SwephData.J2000_TO_J);
        /* to ecliptic */
        eps = sl.swi_epsiln(sip.t0);
        sl.swi_coortrf(x, x, eps);
        /* to polar */
        sl.swi_cartpol(x, x);
        /* subtract initial value of ayanamsa */
        x[0] = x[0] * SwissData.RADTODEG - sip.ayan_t0;
        /* get ayanamsa */
        return sl.swe_degnorm(-x[0]);
    }

    
    public double swe_get_ayanamsa_ut(double tjd_ut) {
        return swe_get_ayanamsa(tjd_ut + SweDate.getDeltaT(tjd_ut));
    }

    
    
    public int swe_fixstar(StringBuffer star, double tjd, int iflag, double xx[],
                           StringBuffer serr) {
        int i;
        int star_nr = 0;
        boolean isnomclat = false;
        int cmplen;
        // Missing parameters are in "int swe_fixstar_found(...)"!
        String sstar=null;
        String fstar=null;
        String s, sp;
        int line = 0;
        int fline = 0;
        int epheflag, iflgsave;
        iflag |= SweConst.SEFLG_SPEED; /* we need this in order to work correctly */
        iflgsave = iflag;

        if (serr != null) {
            serr.setLength(0);
        }
        iflag = plaus_iflag(iflag);
        if (((iflag & SweConst.SEFLG_SIDEREAL)!=0) && !swed.ayana_is_set) {
            swe_set_sid_mode(SweConst.SE_SIDM_FAGAN_BRADLEY, 0, 0);
        }
        epheflag = iflag & SweConst.SEFLG_EPHMASK;
        
        swi_check_ecliptic(tjd);
        
        swi_check_nutation(tjd, iflag);
        if (swed.fixfp == null) {
            try {
                swed.fixfp = swi_fopen(SwephData.SEI_FILE_FIXSTAR, SweConst.SE_STARFILE,
                                       swed.ephepath, serr);
            } catch (SwissephException se) {
                return swe_fixstar_error(xx,SweConst.ERR);
            }
        }
        
        swed.fixfp.seek(0);
        sstar=star.toString().substring(0,
                                        Math.min(star.length(),SweConst.SE_MAX_STNAME));
        if (sstar.length()>0) {
            if (sstar.charAt(0) == ',') {
                isnomclat = true;
            } else if (Character.isDigit(sstar.charAt(0))) {
                // Use SwissLib.atoi(...)!!!
                star_nr = Integer.parseInt(sstar);
            } else {
                /* traditional name of star to lower case */
                sstar=sstar.toLowerCase();
                if (sstar.indexOf(',')>=0) {
                    sstar=sstar.substring(0,sstar.indexOf(','));
                }
            }
            sstar=sstar.trim();
        }
        cmplen = sstar.length();
        if (cmplen == 0) {
            if (serr != null) {
                serr.setLength(0);
                serr.append("star name empty");
            }
            return swe_fixstar_error(xx,SweConst.ERR);
        }
        try {
            while ((s=swed.fixfp.readLine())!=null) {
                fline++;
                if (s.startsWith("#")) { continue; }
                line++;
                if (star_nr == line) {
                    return swe_fixstar_found(serr,s,star,tjd,iflag,iflgsave,epheflag,xx);
                }
                else if (star_nr > 0) {
                    continue;
                }
                if(s.indexOf(',')<0) {
                    if (serr != null) {
                        serr.setLength(0);
                        serr.append("star file "+SweConst.SE_STARFILE+" damaged at line "+
                                    fline);
                    }
                    return swe_fixstar_error(xx,SweConst.ERR);
                }
                sp=s.substring(s.indexOf(','));
                if (isnomclat) {
                    if (sp.substring(0,Math.min(sp.length(),cmplen)).equals(
                                                                            sstar.substring(0,Math.min(sstar.length(),cmplen)))) {
                        return swe_fixstar_found(serr,s,star,tjd,iflag,iflgsave,epheflag,xx);
                    } else {
                        continue;
                    }
                }
                fstar=s.substring(0,
                                  Math.min(SweConst.SE_MAX_STNAME,s.indexOf(','))).trim();
                i = fstar.length();
                if (i < cmplen) {
                    continue;
                }
                fstar=fstar.toLowerCase();
                if (fstar.substring(0,Math.min(fstar.length(),cmplen)).equals(
                                                                              sstar.substring(0,Math.min(sstar.length(),cmplen)))) {
                    return swe_fixstar_found(serr,s,star,tjd,iflag,iflgsave,epheflag,xx);
                }
            }
        } catch (java.io.IOException ioe) {
        }
        if (serr != null && star.length() < SwissData.AS_MAXCH - 20) {
            serr.setLength(0);
            serr.append("star "+star+" not found");
        }
        return swe_fixstar_error(xx,SweConst.ERR);
    }

    
    public int swe_fixstar_ut(StringBuffer star, double tjd_ut, int iflag,
                              double[] xx, StringBuffer serr) {
        return swe_fixstar(star, tjd_ut + SweDate.getDeltaT(tjd_ut),
                           iflag, xx, serr);
    }


    
    public String swe_get_planet_name(int ipl) {
        String s="";
        int i;
        int retc;
        double xp[]=new double[6];
        if (ipl != 0 && ipl == swed.i_saved_planet_name) {
            s=swed.saved_planet_name;
            return s;
        }
        switch(ipl) {
            case SweConst.SE_SUN:
                s = SwephData.SE_NAME_SUN;
                break;
            case SweConst.SE_MOON:
                s = SwephData.SE_NAME_MOON;
                break;
            case SweConst.SE_MERCURY:
                s = SwephData.SE_NAME_MERCURY;
                break;
            case SweConst.SE_VENUS:
                s = SwephData.SE_NAME_VENUS;
                break;
            case SweConst.SE_MARS:
                s = SwephData.SE_NAME_MARS;
                break;
            case SweConst.SE_JUPITER:
                s = SwephData.SE_NAME_JUPITER;
                break;
            case SweConst.SE_SATURN:
                s = SwephData.SE_NAME_SATURN;
                break;
            case SweConst.SE_URANUS:
                s = SwephData.SE_NAME_URANUS;
                break;
            case SweConst.SE_NEPTUNE:
                s = SwephData.SE_NAME_NEPTUNE;
                break;
            case SweConst.SE_PLUTO:
                s = SwephData.SE_NAME_PLUTO;
                break;
            case SweConst.SE_MEAN_NODE:
                s = SwephData.SE_NAME_MEAN_NODE;
                break;
            case SweConst.SE_TRUE_NODE:
                s = SwephData.SE_NAME_TRUE_NODE;
                break;
            case SweConst.SE_MEAN_APOG:
                s = SwephData.SE_NAME_MEAN_APOG;
                break;
            case SweConst.SE_OSCU_APOG:
                s = SwephData.SE_NAME_OSCU_APOG;
                break;
            case SweConst.SE_INTP_APOG: 
                s = SwephData.SE_NAME_INTP_APOG;
                break;  
            case SweConst.SE_INTP_PERG: 
                s = SwephData.SE_NAME_INTP_PERG;
                break;  
            case SweConst.SE_EARTH:
                s = SwephData.SE_NAME_EARTH;
                break;
            case SweConst.SE_CHIRON:
            case SweConst.SE_AST_OFFSET + SwephData.MPC_CHIRON:
                s = SwephData.SE_NAME_CHIRON;
                break;
            case SweConst.SE_PHOLUS:
            case SweConst.SE_AST_OFFSET + SwephData.MPC_PHOLUS:
                s = SwephData.SE_NAME_PHOLUS;
                break;
            case SweConst.SE_CERES:
            case SweConst.SE_AST_OFFSET + SwephData.MPC_CERES:
                s = SwephData.SE_NAME_CERES;
                break;
            case SweConst.SE_PALLAS:
            case SweConst.SE_AST_OFFSET + SwephData.MPC_PALLAS:
                s = SwephData.SE_NAME_PALLAS;
                break;
            case SweConst.SE_JUNO:
            case SweConst.SE_AST_OFFSET + SwephData.MPC_JUNO:
                s = SwephData.SE_NAME_JUNO;
                break;
            case SweConst.SE_VESTA:
            case SweConst.SE_AST_OFFSET + SwephData.MPC_VESTA:
                s = SwephData.SE_NAME_VESTA;
                break;
            default:
                /* fictitious planets */
                if (ipl >= SweConst.SE_FICT_OFFSET && ipl <= SweConst.SE_FICT_MAX) {
                    return smosh.swi_get_fict_name(ipl - SweConst.SE_FICT_OFFSET, s);
                }
                /* asteroids */
                if (ipl > SweConst.SE_AST_OFFSET) {
                    /* if name is already available */
                    if (ipl == swed.fidat[SwephData.SEI_FILE_ANY_AST].ipl[0]) {
                        s=swed.fidat[SwephData.SEI_FILE_ANY_AST].astnam;
                        /* else try to get it from ephemeris file */
                    } else {
                        retc = sweph(SwephData.J2000, ipl, SwephData.SEI_FILE_ANY_AST, 0,
                                     null, SwephData.NO_SAVE, xp, null);
                        if (retc != SweConst.ERR && retc != SwephData.NOT_AVAILABLE) {
                            s=swed.fidat[SwephData.SEI_FILE_ANY_AST].astnam;
                        } else {
                            s=(ipl - SweConst.SE_AST_OFFSET)+": not found";
                        }
                    }
                    /* If there is a provisional designation only in ephemeris file,
                     * we look for a name in seasnam.txt, which can be updated by
                     * the user.
                     * Some old ephemeris files return a '?' in the first position.
                     * There are still a couple of unnamed bodies that got their
                     * provisional designation before 1925, when the current method
                     * of provisional designations was introduced. They have an 'A'
                     * as the first character, e.g. A924 RC.
                     * The file seasnam.txt may contain comments starting with '#'.
                     * There must be at least two columns:
                     * 1. asteroid catalog number
                     * 2. asteroid name
                     * The asteroid number may or may not be in brackets
                     */
                    // Hopefully, I did understand the whole thing correctly...
                    if (s.charAt(0) == '?' || Character.isDigit(s.charAt(1))) {
                        int ipli = (int) (ipl - SweConst.SE_AST_OFFSET), iplf = 0;
                        FilePtr fp = null;
                        String si;
                        try {
                            fp = swi_fopen(-1, SweConst.SE_ASTNAMFILE, swed.ephepath, null);
                        } catch (SwissephException se) {
                        }
                        if (fp != null) {
                            while(ipli != iplf) {
                                try {
                                    si=fp.readLine();
                                    if (si==null) { break; }
                                    StringTokenizer tk=new StringTokenizer(si," \t([{"); // }
                                    String sk=tk.nextToken();
                                    if (sk.startsWith("#") ||
                                        Character.isWhitespace(sk.charAt(0))) {
                                        continue;
                                    }
                                    /* catalog number of body of current line */
                                    iplf = Double.valueOf(sk).intValue();
                                    if (ipli != iplf) {
                                        continue;
                                    }
                                    s=tk.nextToken("#\r\n").trim();
                                    fp.close();
                                } catch (java.io.IOException ioe) {
                                    // NBT
                                } catch (NoSuchElementException nse) {
                                    continue; /* there is no name */
                                }
                            }
                        }
                    }
                } else  {
                    i = ipl;
                    s=""+i;
                }
                break;
                // End of default
        } // End of switch()
        if (s.length() < 80) {
            swed.i_saved_planet_name = ipl;
            swed.saved_planet_name = s;
        }
        return s;
    }

    public String swe_get_ayanamsa_name(int isidmode) {
        if (isidmode < SwissData.SE_NSIDM_PREDEF)
            return SwissData.ayanamsa_name[isidmode];
        return null;
    }

    /* set geographic position and altitude of observer */
    
    public void swe_set_topo(double geolon, double geolat, double geoalt) {
        swed.topd.geolon = geolon;
        swed.topd.geolat = geolat;
        swed.topd.geoalt = geoalt;
        swed.geopos_is_set = true;
        /* to force new calculation of observer position vector */
        swed.topd.teval = 0;
        /* to force new calculation of light-time etc.
         */
        swi_force_app_pos_etc();
    }


    ////////////////////////////////////////////////////////////////////////////
    // Methods from SwephJPL.java: /////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    public double[] getJPLRange(String fname) {
        if (sj==null) {
            sj=new SwephJPL(this, swed, sl);
        }
        return sj.getJPLRange(fname);
    }

    ////////////////////////////////////////////////////////////////////////////
    // Methods from Swecl.java: ////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    
    public void swe_azalt(double tjd_ut, int calc_flag, double[] geopos,
                          double atpress, double attemp, double[] xin,
                          double[] xaz) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        sc.swe_azalt(tjd_ut, calc_flag, geopos, atpress, attemp, xin, xaz);
    }

    
    public void swe_azalt_rev(double tjd_ut, int calc_flag, double[] geopos,
                              double[] xin, double[] xout) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        sc.swe_azalt_rev(tjd_ut, calc_flag, geopos, xin, xout);
    }

    
    public int swe_lun_eclipse_how(double tjd_ut, int ifl, double[] geopos,
                                   double[] attr, StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_lun_eclipse_how(tjd_ut, ifl, geopos, attr, serr);
    }

    
    public int swe_lun_eclipse_when(double tjd_start, int ifl, int ifltype,
                                    double[] tret, int backward,
                                    StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_lun_eclipse_when(tjd_start,ifl,ifltype,tret,backward,serr);
    }

    
    public int swe_nod_aps(double tjd_et, int ipl, int iflag, int  method,
                           double[] xnasc, double[] xndsc,
                           double[] xperi, double[] xaphe,
                           StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_nod_aps(tjd_et, ipl, iflag, method, xnasc, xndsc,
                              xperi, xaphe, serr);
    }

    
    public int swe_nod_aps_ut(double tjd_ut, int ipl, int iflag, int  method,
                              double[] xnasc, double[] xndsc,
                              double[] xperi, double[] xaphe,
                              StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_nod_aps_ut(tjd_ut, ipl, iflag, method, xnasc, xndsc,
                                 xperi, xaphe, serr);
    }

    
    public int swe_pheno(double tjd, int ipl, int iflag, double[] attr,
                         StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_pheno(tjd, ipl, iflag, attr, serr);
    }

    
    public int swe_pheno_ut(double tjd_ut, int ipl, int iflag, double[] attr,
                            StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_pheno_ut(tjd_ut, ipl, iflag, attr, serr);
    }

    
    public double swe_refrac(double inalt, double atpress, double attemp,
                             int calc_flag) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_refrac(inalt, atpress, attemp, calc_flag);
    }

    
    public int swe_rise_trans(double tjd_ut, int ipl, StringBuffer starname,
                              int epheflag, int rsmi, double[] geopos,
                              double atpress, double attemp, DblObj tret,
                              StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_rise_trans(tjd_ut, ipl, starname, epheflag, rsmi, geopos,
                                 atpress, attemp, tret, serr);
    }

    
    public int swe_sol_eclipse_how(double tjd_ut, int ifl, double[] geopos,
                                   double[] attr, StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_sol_eclipse_how(tjd_ut, ifl, geopos, attr, serr);
    }

    
    public int swe_sol_eclipse_when_glob(double tjd_start, int ifl, int ifltype,
                                         double tret[], int backward,
                                         StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_sol_eclipse_when_glob(tjd_start, ifl, ifltype, tret,
                                            backward, serr);
    }

    
    public int swe_sol_eclipse_when_loc(double tjd_start, int ifl,
                                        double[] geopos, double[] tret,
                                        double[] attr, int backward,
                                        StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_sol_eclipse_when_loc(tjd_start, ifl, geopos, tret, attr,
                                           backward, serr);
    }

    
    public int swe_sol_eclipse_where(double tjd_ut, int ifl, double[] geopos,
                                     double[] attr, StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_sol_eclipse_where(tjd_ut, ifl, geopos, attr, serr);
    }


    /* Same declaration as swe_sol_eclipse_when_loc().
     * In addition:
     * int32 ipl          planet number of occulted body
     * char* starname     name of occulted star. Must be NULL or "", if a planetary
     *                    occultation is to be calculated. For the use of this
     *                    field, also see swe_fixstar().
     * int32 ifl        ephemeris flag. If you want to have only one conjunction
     *                    of the moon with the body tested, add the following flag:
     *                    ifl |= SE_ECL_ONE_TRY. If this flag is not set,
     *                    the function will search for an occultation until it
     *                    finds one. For bodies with ecliptical latitudes > 5,
     *                    the function may search successlessly until it reaches
     *                    the end of the ephemeris.
     */
    
    public int swe_lun_occult_when_loc(double tjd_start, int ipl, StringBuffer starname, int ifl,
                                       double[] geopos, double[] tret, double[] attr, int backward, StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_lun_occult_when_loc(tjd_start, ipl, starname, ifl, geopos, tret, attr, backward, serr);
    }

    
    public int swe_lun_occult_where(double tjd_ut,
                                    int ipl,
                                    StringBuffer starname,
                                    int ifl,
                                    double[] geopos,
                                    double[] attr,
                                    StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_lun_occult_where(tjd_ut, ipl, starname, ifl, geopos, attr, serr);
    }


    /* When is the next lunar occultation anywhere on earth?
     * This function also finds solar eclipses, but is less efficient
     * than swe_sol_eclipse_when_glob().
     *
     * input parameters:
     *
     * tjd_start          start time for search (UT)
     * ipl                planet number of occulted body
     * starname           name of occulted star. Must be NULL or "", if a planetary
     *                    occultation is to be calculated. For the use of this
     *                    field, also see swe_fixstar().
     * ifl                      ephemeris to be used (SEFLG_SWIEPH, etc.)
     *                  ephemeris flag. If you want to have only one conjunction
     *                    of the moon with the body tested, add the following flag:
     *                    ifl |= SE_ECL_ONE_TRY. If this flag is not set,
     *                    the function will search for an occultation until it
     *                    finds one. For bodies with ecliptical latitudes > 5,
     *                    the function may search successlessly until it reaches
     *                    the end of the ephemeris.
     *
     * ifltype          eclipse type to be searched (SE_ECL_TOTAL, etc.)
     *                    0, if any type of eclipse is wanted
     *                    this functionality also works with occultations
     *
     * return values:
     *
     * retflag    SE_ECL_TOTAL or SE_ECL_ANNULAR or SE_ECL_PARTIAL
     *              or SE_ECL_ANNULAR_TOTAL
     *              SE_ECL_CENTRAL
     *              SE_ECL_NONCENTRAL
     *
     * tret[0]    time of maximum eclipse
     * tret[1]    time, when eclipse takes place at local apparent noon
     * tret[2]    time of eclipse begin
     * tret[3]    time of eclipse end
     * tret[4]    time of totality begin
     * tret[5]    time of totality end
     * tret[6]    time of center line begin
     * tret[7]    time of center line end
     * tret[8]    time when annular-total eclipse becomes total
     *               not implemented so far
     * tret[9]    time when annular-total eclipse becomes annular again
     *               not implemented so far
     *         declare as tret[10] at least!
     *
     */
    
    public int swe_lun_occult_when_glob(
                                        double tjd_start, int ipl, StringBuffer starname, int ifl, int ifltype,
                                        double[] tret, int backward, StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_lun_occult_when_glob(tjd_start, ipl, starname, ifl, ifltype, tret, backward, serr);
    }

    /* function finds the gauquelin sector position of a planet or fixed star
     * 
     * if starname != NULL then a star is computed.
     * iflag: use the flags SE_SWIEPH, SE_JPLEPH, SE_MOSEPH, SEFLG_TOPOCTR.
     *
     * imeth defines method:
     *           imeth = 0                  sector from longitude and latitude
     *           imeth = 1                  sector from longitude, with lat = 0
     *           imeth = 2                  sector from rise and set
     *           imeth = 3                  sector from rise and set with refraction
     * rise and set are defined as appearance and disappearance of disc center.
     *
     * geopos is an array of 3 doubles for geo. longitude, geo. latitude, elevation.
     * atpress and attemp are only needed for imeth = 3. If imeth = 3,
     * If imeth=3 and atpress not given (= 0), the programm assumes 1013.25 mbar;
     * if a non-zero height above sea is given in geopos, atpress is estimated.
     * dgsect is return area (pointer to a double)
     * serr is pointer to error string, may be NULL
     */
    
    public int swe_gauquelin_sector(double t_ut, int ipl, StringBuffer starname, int iflag, int imeth, double[] geopos, double atpress, double attemp, DblObj dgsect, StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_gauquelin_sector(t_ut, ipl, starname, iflag, imeth, geopos, atpress, attemp, dgsect, serr);
    }
    ////////////////////////////////////////////////////////////////////////////
    // Methods from SweHouse.java: /////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    
    public double swe_house_pos(double armc, double geolat, double eps,
                                int hsys, double xpin[], StringBuffer serr) {
        if (sh==null) {
            sh=new SweHouse(sl, this, swed);
        }
        return sh.swe_house_pos(armc, geolat, eps, hsys, xpin, serr);
    }


    
    public int swe_houses_armc(double armc, double geolat, double eps,
                               int hsys, double[] cusp, double[] ascmc) {
        if (sh==null) {
            sh=new SweHouse(sl, this, swed);
        }
        return sh.swe_houses_armc(armc, geolat, eps, hsys, cusp, ascmc, 0);
    }


      
    public int swe_houses(double tjd_ut, int iflag, double geolat,
                          double geolon, int hsys, double[] cusp,
                          double[] ascmc) {
        return swe_houses(tjd_ut, iflag, geolat, geolon, hsys, cusp, ascmc, 0);
    }
    public int swe_houses(double tjd_ut, int iflag, double geolat,
                          double geolon, int hsys, double[] cusp,
                          double[] ascmc, int aOffs) {
        if (sh==null) {
            sh=new SweHouse(sl, this, swed);
        }
        return sh.swe_houses(tjd_ut, iflag, geolat, geolon, hsys, cusp, ascmc, aOffs);
    }


    
    public double getTransitET(TransitCalculator tc, double jdET, boolean backwards)
        throws IllegalArgumentException, SwissephException {
        return getTransitET(tc,
                            jdET,
                            backwards,
                            (backwards?-Double.MAX_VALUE:Double.MAX_VALUE));
    }
    
    public double getTransitET(TransitCalculator tc, double jdET, boolean backwards, double jdLimit)
        throws IllegalArgumentException, SwissephException {
        if (ext==null) { ext=new Extensions(this); }
        return ext.getTransit(tc, jdET, backwards, jdLimit);
    }
    
    public double getTransitUT(
                               TransitCalculator tc,
                               double jdUT,
                               boolean backwards)
        throws IllegalArgumentException, SwissephException {
        if (ext==null) { ext=new Extensions(this); }
        double jdET = ext.getTransit(
                                     tc,
                                     jdUT + SweDate.getDeltaT(jdUT),
                                     backwards,
                                     (backwards?-Double.MAX_VALUE:Double.MAX_VALUE));
        return jdET - SweDate.getDeltaT(jdET);
    }
    
    public double getTransitUT(
                               TransitCalculator tc,
                               double jdUT,
                               boolean backwards,
                               double jdLimit)
        throws IllegalArgumentException, SwissephException {
        if (ext==null) { ext=new Extensions(this); }
        double jdET = ext.getTransit(
                                     tc,
                                     jdUT + SweDate.getDeltaT(jdUT),
                                     backwards,
                                     jdLimit + SweDate.getDeltaT(jdLimit));
        return jdET - SweDate.getDeltaT(jdET);
    }
    //////////////////////////////////////////////////////////////////////////////
    // End of public methods /////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////
    private int swe_calc_error(double[] xx) {
        for (int i = 0; i < xx.length; i++) {
            xx[i] = 0;
        }
        return SweConst.ERR;
    }


    int swecalc(double tjd, int ipl, int iflag, double[] x, StringBuffer serr) 
        throws SwissephException {
        int i;
        int ipli, ipli_ast, ifno;
        int retc;
        int epheflag = SweConst.SEFLG_DEFAULTEPH;
        PlanData pdp;
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        PlanData ndp;
        double xp[], xp2[];
        double ss[]=new double[3];
        String serr2="";

        if (serr!=null) { serr.setLength(0); }
        
        iflag = plaus_iflag(iflag);
        
        if ((iflag & SweConst.SEFLG_MOSEPH)!=0) {
            epheflag = SweConst.SEFLG_MOSEPH;
        }
        if ((iflag & SweConst.SEFLG_SWIEPH)!=0) {
            epheflag = SweConst.SEFLG_SWIEPH;
        }
        if ((iflag & SweConst.SEFLG_JPLEPH)!=0) {
            epheflag = SweConst.SEFLG_JPLEPH;
        }
        /* no barycentric calculations with Moshier ephemeris */
        if (((iflag & SweConst.SEFLG_BARYCTR)!=0) &&
            ((iflag & SweConst.SEFLG_MOSEPH)!=0)) {
            if (serr != null) {
                serr.append("barycentric Moshier positions are not supported.");
            }
            throw new SwissephException(tjd, SwissephException.INVALID_PARAMETER_COMBINATION,
                                        SweConst.ERR, serr);
        }
        if (epheflag != SweConst.SEFLG_MOSEPH && !swed.ephe_path_is_set) {
            swe_set_ephe_path(null);
        }
        if ((iflag & SweConst.SEFLG_SIDEREAL)!=0 && !swed.ayana_is_set) {
            swe_set_sid_mode(SweConst.SE_SIDM_FAGAN_BRADLEY, 0, 0);
        }
        
        swi_check_ecliptic(tjd);
        
        swi_check_nutation(tjd, iflag);
        
        if (ipl == SweConst.SE_ECL_NUT) {
            x[0] = swed.oec.eps + swed.nut.nutlo[1];	/* true ecliptic */
            x[1] = swed.oec.eps;			/* mean ecliptic */
            x[2] = swed.nut.nutlo[0];		/* nutation in longitude */
            x[3] = swed.nut.nutlo[1];		/* nutation in obliquity */
            /*if ((iflag & SweConst.SEFLG_RADIANS) == 0)*/
            for (i = 0; i <= 3; i++)
                x[i] *= SwissData.RADTODEG;
            return(iflag);
            
        } else if (ipl == SweConst.SE_MOON) {
            /* internal planet number */
            ipli = SwephData.SEI_MOON;
            pdp = swed.pldat[ipli];
            xp = pdp.xreturn;
            switch(epheflag) {
                case SweConst.SEFLG_JPLEPH:
                    retc = jplplan(tjd, ipli, iflag, SwephData.DO_SAVE, null,null,null, serr);
                    /* read error or corrupt file */
                    if (retc == SweConst.ERR) {
                        swecalc_error(x);
                        throw new SwissephException(tjd, SwissephException.DATA_FILE_ERROR,
                                                    SweConst.ERR, serr);
                    }
                    /* jpl ephemeris not on disk or date beyond ephemeris range
                     *     or file corrupt */
                    if (retc == SwephData.NOT_AVAILABLE) {
                        iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_SWIEPH;
                        if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                            serr.append(" \ntrying Swiss Eph; ");
                        }
                        retc =  sweph_moon(tjd, ipli, iflag, serr);
                        if (retc == SweConst.ERR) {
                            return swecalc_error(x);
                        }
                    } else if (retc == SwephData.BEYOND_EPH_LIMITS) {
                        if (tjd > SwephData.MOSHLUEPH_START &&
                            tjd < SwephData.MOSHLUEPH_END) {
                            iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_MOSEPH;
                            if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                                serr.append(" \nusing Moshier Eph; ");
                            }
                            //              goto moshier_moon;
                            retc = moshier_moon(tjd, SwephData.DO_SAVE, null, serr);
                            if (retc == SweConst.ERR) {
                                return swecalc_error(x);
                            }
                        } else
                            return swecalc_error(x);
                    }
                    break;
                case SweConst.SEFLG_SWIEPH:
                    retc =  sweph_moon(tjd, ipli,iflag, serr);
                    if (retc == SweConst.ERR) {
                        return swecalc_error(x);
                    }
                    break;
                case SweConst.SEFLG_MOSEPH:
                    //          moshier_moon:
                    retc = moshier_moon(tjd, SwephData.DO_SAVE, null, serr);
                    if (retc == SweConst.ERR) {
                        return swecalc_error(x);
                    }
                    break;
                default:
                    break;
            }
            /* heliocentric, lighttime etc. */
            if ((retc = app_pos_etc_moon(iflag, serr))!=SweConst.OK) {
                return swecalc_error(x); // retc may be wrong with sidereal calculation
            }
            
        } else if (ipl == SweConst.SE_SUN &&
                   ((iflag & SweConst.SEFLG_BARYCTR)!=0)) {
            /* barycentric sun must be handled separately because of
             * the following reasons:
             * ordinary planetary computations use the function
             * main_planet() and its subfunction jplplan(),
             * see further below.
             * now, these functions need the swisseph internal
             * planetary indices, where SEI_EARTH = SEI_SUN = 0.
             * therefore they don't know the difference between
             * a barycentric sun and a barycentric earth and
             * always return barycentric earth.
             * to avoid this problem, many functions would have to
             * be changed. as an alternative, we choose a more
             * separate handling. */
            ipli = SwephData.SEI_SUN;	/* = SEI_EARTH ! */
            xp = pedp.xreturn;

            switch (epheflag) {
                case SweConst.SEFLG_JPLEPH:
                    /* open ephemeris, if still closed */
                    if (!swed.jpl_file_is_open) {
                        retc = sj.swi_open_jpl_file(ss, swed.jplfnam, swed.ephepath, serr);
                        swed.jpldenum = sj.swi_get_jpl_denum();
                        if (retc != SweConst.OK) {
                            retc = sweph_sbar(tjd, iflag, psdp, pedp, serr);
                        }
                        if (retc == SweConst.ERR) {
                            return swecalc_error(x);
                        }
                        swed.jpl_file_is_open = true;
                    }
                    retc = sj.swi_pleph(tjd, SwephJPL.J_SUN, SwephJPL.J_SBARY, psdp.x, serr);
                    if (retc == SweConst.ERR || retc == SwephData.BEYOND_EPH_LIMITS) {
                        sj.swi_close_jpl_file();
                        swed.jpl_file_is_open = false;
                        return swecalc_error(x);
                    }
                    /* jpl ephemeris not on disk or date beyond ephemeris range
                     *     or file corrupt */
                    if (retc == SwephData.NOT_AVAILABLE) {
                        iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_SWIEPH;
                        if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                            serr.append(" \ntrying Swiss Eph; ");
                        }
                        retc = sweph_sbar(tjd, iflag, psdp, pedp, serr);
                        if (retc == SweConst.ERR) {
                            return swecalc_error(x);
                        }
                    }
                    psdp.teval = tjd;
                    break;
                case SweConst.SEFLG_SWIEPH:
                    retc = sweph_sbar(tjd, iflag, psdp, pedp, serr);
                    if (retc == SweConst.ERR) {
                        return swecalc_error(x);
                    }
                    break;
                default:
                    return SweConst.ERR;
            }
            /* flags */
            if ((retc = app_pos_etc_sbar(iflag, serr)) != SweConst.OK) {
                return swecalc_error(x);
            }
            /* iflag has possibly changed */
            iflag = pedp.xflgs;
            /* barycentric sun is now in save area of barycentric earth.
             * (pedp->xreturn = swed.pldat[SEI_EARTH].xreturn).
             * in case a barycentric earth computation follows for the same
             * date, the planetary functions will return the barycentric
             * SUN unless we force a new computation of pedp->xreturn.
             * this can be done by initializing the save of iflag.
             */
            pedp.xflgs = -1;
            
        } else if (ipl == SweConst.SE_SUN 	/* main planet */
                   || ipl == SweConst.SE_MERCURY
                   || ipl == SweConst.SE_VENUS
                   || ipl == SweConst.SE_MARS
                   || ipl == SweConst.SE_JUPITER
                   || ipl == SweConst.SE_SATURN
                   || ipl == SweConst.SE_URANUS
                   || ipl == SweConst.SE_NEPTUNE
                   || ipl == SweConst.SE_PLUTO
                   || ipl == SweConst.SE_EARTH) {
            if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
                if (ipl == SweConst.SE_SUN) {
                    /* heliocentric position of Sun does not exist */
                    for (i = 0; i < 24; i++) {
                        x[i] = 0;
                    }
                    return iflag;
                }
            } else if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
                // NOOP
            } else {		/* geocentric */
                if (ipl == SweConst.SE_EARTH) {
                    /* geocentric position of Earth does not exist */
                    for (i = 0; i < 24; i++) {
                        x[i] = 0;
                    }
                    return iflag;
                }
            }
            /* internal planet number */
            ipli = SwissData.pnoext2int[ipl];
            pdp = swed.pldat[ipli];
            xp = pdp.xreturn;
            retc = main_planet(tjd, ipli, epheflag, iflag, serr);
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            /* iflag has possibly changed in main_planet() */
            iflag = pdp.xflgs;
            
        } else if (ipl == SweConst.SE_MEAN_NODE) {
            if (((iflag & SweConst.SEFLG_HELCTR)!=0) ||
                ((iflag & SweConst.SEFLG_BARYCTR)!=0)) {
                /* heliocentric/barycentric lunar node not allowed */
                for (i = 0; i < 24; i++) {
                    x[i] = 0;
                }
                return iflag;
            }
            ndp = swed.nddat[SwephData.SEI_MEAN_NODE];
            xp = ndp.xreturn;
            xp2 = ndp.x;
            retc = sm.swi_mean_node(tjd, xp2, serr);
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            /* speed (is almost constant; variation < 0.001 arcsec) */
            retc = sm.swi_mean_node(tjd - SwephData.MEAN_NODE_SPEED_INTV, xp2, 3, serr);
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            xp2[3] = sl.swe_difrad2n(xp2[0], xp2[3]) / SwephData.MEAN_NODE_SPEED_INTV;
            xp2[4] = xp2[5] = 0;
            ndp.teval = tjd;
            ndp.xflgs = -1;
            /* lighttime etc. */
            retc = app_pos_etc_mean(SwephData.SEI_MEAN_NODE, iflag, serr);
            if (retc != SweConst.OK) {
                return swecalc_error(x);
            }
            /* to avoid infinitesimal deviations from latitude = 0
             * that result from conversions */
            if ((iflag & SweConst.SEFLG_SIDEREAL)==0 &&
                (iflag & SweConst.SEFLG_J2000)==0) {
                ndp.xreturn[1] = 0.0;	/* ecl. latitude       */
                ndp.xreturn[4] = 0.0;	/*               speed */
                ndp.xreturn[5] = 0.0;	/*      radial   speed */
                ndp.xreturn[8] = 0.0;	/* z coordinate        */
                ndp.xreturn[11] = 0.0;	/*               speed */
            }
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            
        } else if (ipl == SweConst.SE_MEAN_APOG) {
            if (((iflag & SweConst.SEFLG_HELCTR)!=0) ||
                ((iflag & SweConst.SEFLG_BARYCTR)!=0)) {
                /* heliocentric/barycentric lunar apogee not allowed */
                for (i = 0; i < 24; i++) {
                    x[i] = 0;
                }
                return iflag;
            }
            ndp = swed.nddat[SwephData.SEI_MEAN_APOG];
            xp = ndp.xreturn;
            xp2 = ndp.x;
            retc = sm.swi_mean_apog(tjd, xp2, serr);
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            /* speed (is not constant! variation ~= several arcsec) */
            retc = sm.swi_mean_apog(tjd - SwephData.MEAN_NODE_SPEED_INTV, xp2, 3, serr);
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            for(i = 0; i <= 1; i++) {
                xp2[3+i] = sl.swe_difrad2n(xp2[i], xp2[3+i]) / SwephData.MEAN_NODE_SPEED_INTV;
            }
            xp2[5] = 0;
            ndp.teval = tjd;
            ndp.xflgs = -1;
            /* lighttime etc. */
            if ((retc = app_pos_etc_mean(SwephData.SEI_MEAN_APOG, iflag, serr)) !=
                SweConst.OK) {
                return swecalc_error(x);
            }
            /* to avoid infinitesimal deviations from r-speed = 0
             * that result from conversions */
            ndp.xreturn[5] = 0.0;	/*               speed */
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            
        } else if (ipl == SweConst.SE_TRUE_NODE) {
            if (((iflag & SweConst.SEFLG_HELCTR)!=0) ||
                ((iflag & SweConst.SEFLG_BARYCTR)!=0)) {
                /* heliocentric/barycentric lunar node not allowed */
                for (i = 0; i < 24; i++) {
                    x[i] = 0;
                }
                return iflag;
            }
            ndp = swed.nddat[SwephData.SEI_TRUE_NODE];
            xp = ndp.xreturn;
            retc = lunar_osc_elem(tjd, SwephData.SEI_TRUE_NODE, iflag, serr);
            iflag = ndp.xflgs;
            /* to avoid infinitesimal deviations from latitude = 0
             * that result from conversions */
            if ((iflag & SweConst.SEFLG_SIDEREAL)==0 &&
                (iflag & SweConst.SEFLG_J2000)==0) {
                ndp.xreturn[1] = 0.0;	/* ecl. latitude       */
                ndp.xreturn[4] = 0.0;	/*               speed */
                ndp.xreturn[8] = 0.0;	/* z coordinate        */
                ndp.xreturn[11] = 0.0;	/*               speed */
            }
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            
        } else if (ipl == SweConst.SE_OSCU_APOG) {
            if (((iflag & SweConst.SEFLG_HELCTR)!=0) ||
                ((iflag & SweConst.SEFLG_BARYCTR)!=0)) {
                /* heliocentric/barycentric lunar apogee not allowed */
                for (i = 0; i < 24; i++) {
                    x[i] = 0;
                }
                return iflag;
            }
            ndp = swed.nddat[SwephData.SEI_OSCU_APOG];
            xp = ndp.xreturn;
            retc = lunar_osc_elem(tjd, SwephData.SEI_OSCU_APOG, iflag, serr);
            iflag = ndp.xflgs;
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            
        } else if (ipl == SweConst.SE_INTP_APOG) {
            if ((iflag & SweConst.SEFLG_HELCTR)!=0 ||
                (iflag & SweConst.SEFLG_BARYCTR)!=0) {
                /* heliocentric/barycentric lunar apogee not allowed */
                for (i = 0; i < 24; i++) {
                    x[i] = 0;
                }
                return iflag;
            }
            ndp = swed.nddat[SwephData.SEI_INTP_APOG];
            xp = ndp.xreturn;
            retc = intp_apsides(tjd, SwephData.SEI_INTP_APOG, iflag, serr); 
            iflag = ndp.xflgs;
            if (retc == SweConst.ERR)
                return swecalc_error(x);
            
        } else if (ipl == SweConst.SE_INTP_PERG) {
            if ((iflag & SweConst.SEFLG_HELCTR)!=0 ||
                (iflag & SweConst.SEFLG_BARYCTR)!=0) {
                /* heliocentric/barycentric lunar apogee not allowed */
                for (i = 0; i < 24; i++) {
                    x[i] = 0;
                }
                return iflag;
            }
            ndp = swed.nddat[SwephData.SEI_INTP_PERG];
            xp = ndp.xreturn;
            retc = intp_apsides(tjd, SwephData.SEI_INTP_PERG, iflag, serr); 
            iflag = ndp.xflgs;
            if (retc == SweConst.ERR)
                return swecalc_error(x);
            
        } else if (ipl == SweConst.SE_CHIRON
                   || ipl == SweConst.SE_PHOLUS
                   || ipl == SweConst.SE_CERES		/* Ceres - Vesta */
                   || ipl == SweConst.SE_PALLAS
                   || ipl == SweConst.SE_JUNO
                   || ipl == SweConst.SE_VESTA
                   || ipl > SweConst.SE_AST_OFFSET) {
            /* internal planet number */
            if (ipl < SweConst.SE_NPLANETS) {
                ipli = SwissData.pnoext2int[ipl];
            } else if (ipl <= SweConst.SE_AST_OFFSET + SwephData.MPC_VESTA) {
                ipli = SwephData.SEI_CERES + ipl - SweConst.SE_AST_OFFSET - 1;
                ipl = SweConst.SE_CERES + ipl - SweConst.SE_AST_OFFSET - 1;
            } else {		/* any asteroid except*/
                ipli = SwephData.SEI_ANYBODY;
            }
            if (ipli == SwephData.SEI_ANYBODY) {
                ipli_ast = ipl;
            } else {
                ipli_ast = ipli;
            }
            pdp = swed.pldat[ipli];
            xp = pdp.xreturn;
            if (ipli_ast > SweConst.SE_AST_OFFSET) {
                ifno = SwephData.SEI_FILE_ANY_AST;
            } else {
                ifno = SwephData.SEI_FILE_MAIN_AST;
            }
            if (ipli == SwephData.SEI_CHIRON &&
                (tjd < SwephData.CHIRON_START || tjd > SwephData.CHIRON_END)) {
                if (serr != null) {
                    serr.setLength(0);
                    serr.append("Chiron's ephemeris is restricted to JD "+
                                SwephData.CHIRON_START+" - JD "+
                                SwephData.CHIRON_END);
                }
                return SweConst.ERR;
            }
            if (ipli == SwephData.SEI_PHOLUS && tjd < SwephData.PHOLUS_START) {
                if (serr != null) {
                    serr.setLength(0);
                    serr.append("Pholus's ephemeris is restricted to the time after JD "+
                                SwephData.PHOLUS_START);
                }
                return SweConst.ERR;
            }
            //  do_asteroid:
            while (true) {
                /* earth and sun are also needed */
                retc = main_planet(tjd, SwephData.SEI_EARTH, epheflag, iflag, serr);
                if (retc == SweConst.ERR) {
                    return swecalc_error(x);
                }
                /* iflag (ephemeris bit) has possibly changed in main_planet() */
                iflag = swed.pldat[SwephData.SEI_EARTH].xflgs;
                /* asteroid */
                if (serr != null) {
                    serr2=serr.toString();
                    serr.setLength(0);
                }
                /* asteroid */
                retc = sweph(tjd, ipli_ast, ifno, iflag, psdp.x, SwephData.DO_SAVE,
                             null, serr);
                if (retc == SweConst.ERR || retc == SwephData.NOT_AVAILABLE) {
                    return swecalc_error(x);
                }
                retc = app_pos_etc_plan(ipli_ast, iflag, serr);
                if (retc == SweConst.ERR) {
                    return swecalc_error(x);
                }
                /* app_pos_etc_plan() might have failed, if t(light-time)
                 * is beyond ephemeris range. in this case redo with Moshier
                 */
                if (retc == SwephData.NOT_AVAILABLE ||
                    retc == SwephData.BEYOND_EPH_LIMITS) {
                    if (epheflag != SweConst.SEFLG_MOSEPH) {
                        iflag = (iflag & ~SweConst.SEFLG_EPHMASK) | SweConst.SEFLG_MOSEPH;
                        epheflag = SweConst.SEFLG_MOSEPH;
                        if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                            serr.append("\nusing Moshier eph.; ");
                        }
                        //          goto do_asteroid;
                        continue;
                    } else
                        return swecalc_error(x);
                }
                break;
            }
            /* add warnings from earth/sun computation */
            if (serr != null && serr.length()==0 && serr2.length()!=0) {
                serr.setLength(0);
                serr2=serr2.substring(0,Math.min(serr2.length(),SwissData.AS_MAXCH-5));
                serr.append("sun: "+serr2);
            }
            
            // JAVA: Geht nur mit Moshier Routinen???
        } else if (ipl >= SweConst.SE_FICT_OFFSET && ipl <= SweConst.SE_FICT_MAX) {
            /* internal planet number */
            ipli = SwephData.SEI_ANYBODY;
            pdp = swed.pldat[ipli];
            xp = pdp.xreturn;
            //  do_fict_plan:
            while (true) {
                /* the earth for geocentric position */
                retc = main_planet(tjd, SwephData.SEI_EARTH, epheflag, iflag, serr);
                /* iflag (ephemeris bit) has possibly changed in main_planet() */
                iflag = swed.pldat[SwephData.SEI_EARTH].xflgs;
                /* planet from osculating elements */
                if (smosh.swi_osc_el_plan(tjd, pdp.x, ipl-SweConst.SE_FICT_OFFSET,
                                          ipli, pedp.x, psdp.x, serr) != SweConst.OK) {
                    return swecalc_error(x);
                }
                if (retc == SweConst.ERR) {
                    return swecalc_error(x);
                }
                retc = app_pos_etc_plan_osc(ipl, ipli, iflag, serr);
                if (retc == SweConst.ERR) {
                    return swecalc_error(x);
                }
                /* app_pos_etc_plan_osc() might have failed, if t(light-time)
                 * is beyond ephemeris range. in this case redo with Moshier
                 */
                if (retc == SwephData.NOT_AVAILABLE ||
                    retc == SwephData.BEYOND_EPH_LIMITS) {
                    if (epheflag != SweConst.SEFLG_MOSEPH) {
                        iflag = (iflag & ~SweConst.SEFLG_EPHMASK) | SweConst.SEFLG_MOSEPH;
                        epheflag = SweConst.SEFLG_MOSEPH;
                        if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                            serr.append("\nusing Moshier eph.; ");
                        }
                        //        goto do_fict_plan;
                        continue;
                    } else
                        return swecalc_error(x);
                }
                break;
            }
            
        } else {
            if (serr != null) {
                serr.setLength(0);
                serr.append("illegal planet number "+ipl+".");
            }
            return swecalc_error(x);
        }
        for (i = 0; i < 24; i++) {
            x[i] = xp[i];
        }
        return(iflag);
    }

    int moshier_moon(double tjd, boolean do_save, double[] xpmret,
                     StringBuffer serr) {
        int retc = sm.swi_moshmoon(tjd, do_save, null, serr);
        if (retc == SweConst.ERR) {
            return SweConst.ERR;
        }
        /* for hel. position, we need earth as well */
        retc = smosh.swi_moshplan(tjd, SwephData.SEI_EARTH, do_save, null, null, serr);
        if (retc == SweConst.ERR) {
            return SweConst.ERR;
        }
        return SweConst.OK;
    }

    int swecalc_error(double x[]) {
        
        //  return_error:;
        for (int i = 0; i < 24; i++) {
            x[i] = 0.;
        }
        return SweConst.ERR;
    }

    int sweph_sbar(double tjd, int iflag, PlanData psdp, PlanData pedp,
                   StringBuffer serr) {
        int retc;
        /* sweplan() provides barycentric sun as a by-product in save area;
         * it is saved in swed.pldat[SEI_SUNBARY].x */
        retc = sweplan(tjd, SwephData.SEI_EARTH, SwephData.SEI_FILE_PLANET, iflag,
                       SwephData.DO_SAVE, null, null, null, null, serr);
        if (retc == SweConst.ERR || retc == SwephData.NOT_AVAILABLE) {
            return SweConst.ERR;
        }
        psdp.teval = tjd;
        /* pedp.teval = tjd; */
        return SweConst.OK;
    }

    int sweph_moon(double tjd, int ipli, int iflag, StringBuffer serr) {
        int retc;
        retc = sweplan(tjd, ipli, SwephData.SEI_FILE_MOON, iflag, SwephData.DO_SAVE,
                       null, null, null, null, serr);
        if (retc == SweConst.ERR) {
            return SweConst.ERR;
        }
        /* if sweph file not found, switch to moshier */
        if (retc == SwephData.NOT_AVAILABLE) {
            if (tjd > SwephData.MOSHLUEPH_START && tjd < SwephData.MOSHLUEPH_END) {
                iflag = (iflag & ~SweConst.SEFLG_SWIEPH) | SweConst.SEFLG_MOSEPH;
                if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                    serr.append(" \nusing Moshier eph.; ");
                }
                //        goto moshier_moon;
                retc = moshier_moon(tjd, SwephData.DO_SAVE, null, serr);
                if (retc == SweConst.ERR) {
                    return SweConst.ERR;
                }
            } else
                return SweConst.ERR;
        }
        return SweConst.OK;
    }

    /* calculates obliquity of ecliptic and stores it together
     * with its date, sine, and cosine
     */
    void calc_epsilon(double tjd, Epsilon e) {
        e.teps = tjd;
        e.eps = sl.swi_epsiln(tjd);
        e.seps = Math.sin(e.eps);
        e.ceps = Math.cos(e.eps);
    }

    /* computes a main planet from any ephemeris, if it
     * has not yet been computed for this date.
     * since a geocentric position requires the earth, the
     * earth's position will be computed as well. With SWISSEPH
     * files the barycentric sun will be done as well.
     * With Moshier, the moon will be done as well.
     *
     * tjd          = julian day
     * ipli         = body number
     * epheflag     = which ephemeris? JPL, SWISSEPH, Moshier?
     * iflag        = other flags
     *
     * the geocentric apparent position of ipli (or whatever has
     * been specified in iflag) will be saved in
     * &swed.pldat[ipli].xreturn[];
     *
     * the barycentric (heliocentric with Moshier) position J2000
     * will be kept in
     * &swed.pldat[ipli].x[];
     */
    int main_planet(double tjd, int ipli, int epheflag, int iflag,
                    StringBuffer serr) {
        int retc;
        boolean calc_swieph=false;
        boolean calc_moshier=false;
        if (epheflag == SweConst.SEFLG_JPLEPH) {
            retc = jplplan(tjd, ipli, iflag, SwephData.DO_SAVE,
                           null, null, null,serr);
            /* read error or corrupt file */
            if (retc == SweConst.ERR) {
                return SweConst.ERR;
            }
            /* jpl ephemeris not on disk or date beyond ephemeris range */
            if (retc == SwephData.NOT_AVAILABLE) {
                iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_SWIEPH;
                if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                    serr.append(" \ntrying Swiss Eph; ");
                }
                calc_swieph=true;
                //        goto sweph_planet;
            } else if (retc == SwephData.BEYOND_EPH_LIMITS) {
                if (tjd > SwephData.MOSHPLEPH_START && tjd < SwephData.MOSHPLEPH_END) {
                    iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_MOSEPH;
                    if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                        serr.append(" \nusing Moshier Eph; ");
                    }
                    calc_moshier=true;
                    //          goto moshier_planet;
                } else {
                    return SweConst.ERR;
                }
            }
            if (!calc_swieph && !calc_moshier) {
                /* geocentric, lighttime etc. */
                if (ipli == SwephData.SEI_SUN) {
                    retc = app_pos_etc_sun(iflag, serr);
                } else {
                    retc = app_pos_etc_plan(ipli, iflag, serr);
                }
                if (retc == SweConst.ERR) {
                    return SweConst.ERR;
                }
                /* t for light-time beyond ephemeris range */
                if (retc == SwephData.NOT_AVAILABLE) {
                    iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_SWIEPH;
                    if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                        serr.append(" \ntrying Swiss Eph; ");
                    }
                    calc_swieph=true;
                    //          goto sweph_planet;
                } else if (retc == SwephData.BEYOND_EPH_LIMITS) {
                    if (tjd > SwephData.MOSHPLEPH_START &&
                        tjd < SwephData.MOSHPLEPH_END) {
                        iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_MOSEPH;
                        if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                            serr.append(" \nusing Moshier Eph; ");
                        }
                        calc_moshier=true;
                        //            goto moshier_planet;
                    } else {
                        return SweConst.ERR;
                    }
                }
            }
        } // SweConst.SEFLG_JPLEPH
        if (epheflag == SweConst.SEFLG_SWIEPH || calc_swieph) {
            //      sweph_planet:
            /* compute barycentric planet (+ earth, sun, moon) */
            retc = sweplan(tjd, ipli, SwephData.SEI_FILE_PLANET, iflag, SwephData.DO_SAVE,
                           null, null, null, null, serr);
            if (retc == SweConst.ERR) {
                return SweConst.ERR;
            }
            /* if sweph file not found, switch to moshier */
            if (retc == SwephData.NOT_AVAILABLE) {
                if (tjd > SwephData.MOSHPLEPH_START && tjd < SwephData.MOSHPLEPH_END) {
                    iflag = (iflag & ~SweConst.SEFLG_SWIEPH) | SweConst.SEFLG_MOSEPH;
                    if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                        serr.append(" \nusing Moshier eph.; ");
                    }
                    calc_moshier=true;
                    //          goto moshier_planet;
                } else {
                    return SweConst.ERR;
                }
            }
            if (!calc_moshier) {
                /* geocentric, lighttime etc. */
                if (ipli == SwephData.SEI_SUN) {
                    retc = app_pos_etc_sun(iflag, serr);
                } else {
                    retc = app_pos_etc_plan(ipli, iflag, serr);
                }
                if (retc == SweConst.ERR) {
                    return SweConst.ERR;
                }
                /* if sweph file for t(lighttime) not found, switch to moshier */
                if (retc == SwephData.NOT_AVAILABLE) {
                    if (tjd > SwephData.MOSHPLEPH_START &&
                        tjd < SwephData.MOSHPLEPH_END) {
                        iflag = (iflag & ~SweConst.SEFLG_SWIEPH) | SweConst.SEFLG_MOSEPH;
                        if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                            serr.append(" \nusing Moshier eph.; ");
                        }
                        calc_moshier=true;
                        //          goto moshier_planet;
                    } else {
                        return SweConst.ERR;
                    }
                }
            } // SweConst.SEFLG_SWIEPH
        } // !calc_moshier
        if (epheflag == SweConst.SEFLG_MOSEPH || calc_moshier) {
            //      moshier_planet:
            retc = smosh.swi_moshplan(tjd, ipli, SwephData.DO_SAVE, null, null, serr);
            if (retc == SweConst.ERR) {
                return SweConst.ERR;
            }
            /* geocentric, lighttime etc. */
            if (ipli == SwephData.SEI_SUN) {
                retc = app_pos_etc_sun(iflag, serr);
            } else {
                retc = app_pos_etc_plan(ipli, iflag, serr);
            }
            if (retc == SweConst.ERR) {
                return SweConst.ERR;
            }
        }
        return SweConst.OK;
    }

    /* Computes a main planet from any ephemeris or returns
     * it again, if it has been computed before.
     * In barycentric equatorial position of the J2000 equinox.
     * The earth's position is computed as well. With SWISSEPH
     * and JPL ephemeris the barycentric sun is computed, too.
     * With Moshier, the moon is returned, as well.
     *
     * tjd          = julian day
     * ipli         = body number
     * epheflag     = which ephemeris? JPL, SWISSEPH, Moshier?
     * iflag        = other flags
     * xp, xe, xs, and xm are the pointers, where the program
     * either finds or stores (if not found) the barycentric
     * (heliocentric with Moshier) positions of the following
     * bodies:
     * xp           planet
     * xe           earth
     * xs           sun
     * xm           moon
     *
     * xm is used with Moshier only
     */
    int main_planet_bary(double tjd, int ipli, int epheflag, int iflag,
                         boolean do_save,
                         double xp[], double xe[], double xs[], double xm[],
                         StringBuffer serr) {
        int i;
        int retc;
        boolean calc_moshier=false;
        boolean calc_swieph=false;
        if (epheflag == SweConst.SEFLG_JPLEPH) {
            retc = jplplan(tjd, ipli, iflag, do_save, xp, xe, xs, serr);
            /* read error or corrupt file */
            if (retc == SweConst.ERR || retc == SwephData.BEYOND_EPH_LIMITS) {
                return retc;
            }
            /* jpl ephemeris not on disk or date beyond ephemeris range */
            if (retc == SwephData.NOT_AVAILABLE) {
                iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_SWIEPH;
                if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                    serr.append(" \ntrying Swiss Eph; ");
                }
                calc_swieph=true;
                //        goto sweph_planet;
            }
        }
        if (epheflag == SweConst.SEFLG_SWIEPH || calc_swieph) {
            //      sweph_planet:
            /* compute barycentric planet (+ earth, sun, moon) */
            retc = sweplan(tjd, ipli, SwephData.SEI_FILE_PLANET, iflag, do_save,
                           xp, xe, xs, xm, serr);
            if (retc == SweConst.ERR || retc == SwephData.NOT_AVAILABLE) {
                return retc;
            }
        }
        if (epheflag == SweConst.SEFLG_MOSEPH || calc_moshier) {
            retc = smosh.swi_moshplan(tjd, ipli, do_save, xp, xe, serr);
            if (retc == SweConst.ERR) {
                return SweConst.ERR;
            }
            for (i = 0; i <= 5; i++) {
                xs[i] = 0;
            }
        }
        return SweConst.OK;
    }

    /* SWISSEPH
     * this routine computes heliocentric cartesian equatorial coordinates
     * of equinox 2000 of
     * geocentric moon
     *
     * tjd          julian date
     * iflag        flag
     * do_save      save J2000 position in save area pdp->x ?
     * xp           array of 6 doubles for lunar position and speed
     * serr         error string
     */
    int swemoon(double tjd, int iflag, boolean do_save, double xpret[],
                StringBuffer serr) {
        int i, retc;
        PlanData pdp = swed.pldat[SwephData.SEI_MOON];
        int speedf1, speedf2;
        double xx[]=new double[6], xp[];
        if (do_save) {
            xp = pdp.x;
        }
        else
            xp = xx;
        /* if planet has already been computed for this date, return
         * if speed flag has been turned on, recompute planet */
        speedf1 = pdp.xflgs & SweConst.SEFLG_SPEED;
        speedf2 = iflag & SweConst.SEFLG_SPEED;
        if (tjd == pdp.teval
            && pdp.iephe == SweConst.SEFLG_SWIEPH
            && ((speedf2==0) || (speedf1!=0))) {
            xp = pdp.x;
        } else {
            /* call sweph for moon */
            retc = sweph(tjd, SwephData.SEI_MOON, SwephData.SEI_FILE_MOON, iflag,
                         null, do_save, xp, serr);
            if (retc != SweConst.OK) {
                return(retc);
            }
            if (do_save) {
                pdp.teval = tjd;
                pdp.xflgs = -1;
                pdp.iephe = SweConst.SEFLG_SWIEPH;
            }
        }
        if (xpret != null) {
            for (i = 0; i <= 5; i++) {
                xpret[i] = xp[i];
            }
        }
        return SweConst.OK;
    }

    /* SWISSEPH
     * this function computes
     * 1. a barycentric planet
     * plus, under certain conditions,
     * 2. the barycentric sun,
     * 3. the barycentric earth, and
     * 4. the geocentric moon,
     * in barycentric cartesian equatorial coordinates J2000.
     *
     * these are the data needed for calculation of light-time etc.
     *
     * tjd          julian date
     * ipli         SEI_ planet number
     * ifno         ephemeris file number
     * do_save      write new positions in save area
     * xp           array of 6 doubles for planet's position and velocity
     * xpe                                 earth's
     * xps                                 sun's
     * xpm                                 moon's
     * serr         error string
     *
     * xp - xpm can be NULL. if do_save is TRUE, all of them can be NULL.
     * the positions will be written into the save area (swed.pldat[ipli].x)
     */
    int sweplan(double tjd, int ipli, int ifno, int iflag, boolean do_save,
                double xpret[], double xperet[], double xpsret[],
                double xpmret[], StringBuffer serr) {
        int i, retc;
        boolean do_earth = false, do_moon = false, do_sunbary = false;
        PlanData pdp = swed.pldat[ipli];
        PlanData pebdp = swed.pldat[SwephData.SEI_EMB];
        PlanData psbdp = swed.pldat[SwephData.SEI_SUNBARY];
        PlanData pmdp = swed.pldat[SwephData.SEI_MOON];
        double xxp[]=new double[6], xxm[]=new double[6],
            xxs[]=new double[6], xxe[]=new double[6];
        double xp[], xpe[], xpm[], xps[];
        int speedf1, speedf2;
        /* xps (barycentric sun) may be necessary because some planets on sweph
         * file are heliocentric, other ones are barycentric. without xps,
         * the heliocentric ones cannot be returned barycentrically.
         */
        if (do_save || ipli == SwephData.SEI_SUNBARY
            || (pdp.iflg & SwephData.SEI_FLG_HELIO)!=0
            || xpsret != null || (iflag & SweConst.SEFLG_HELCTR)!=0) {
            do_sunbary = true;
        }
        if (do_save || ipli == SwephData.SEI_EARTH || xperet != null) {
            do_earth = true;
        }
        if (ipli == SwephData.SEI_MOON) {
            do_earth = true;
            do_sunbary = true;
        }
        if (do_save || ipli == SwephData.SEI_MOON || ipli == SwephData.SEI_EARTH ||
            xperet != null || xpmret != null) {
            do_moon = true;
        }
        if (do_save) {
            xp = pdp.x;
            xpe = pebdp.x;
            xps = psbdp.x;
            xpm = pmdp.x;
        } else {
            xp = xxp;
            xpe = xxe;
            xps = xxs;
            xpm = xxm;
        }
        speedf2 = iflag & SweConst.SEFLG_SPEED;
        /* barycentric sun */
        if (do_sunbary) {
            speedf1 = psbdp.xflgs & SweConst.SEFLG_SPEED;
            /* if planet has already been computed for this date, return
             * if speed flag has been turned on, recompute planet */
            if (tjd == psbdp.teval
                && psbdp.iephe == SweConst.SEFLG_SWIEPH
                && ((speedf2==0) || (speedf1!=0))) {
                for (i = 0; i <= 5; i++) {
                    xps[i] = psbdp.x[i];
                }
            } else {
                retc = sweph(tjd, SwephData.SEI_SUNBARY, SwephData.SEI_FILE_PLANET, iflag,
                             null, do_save, xps, serr);
                if (retc != SweConst.OK) {
                    return(retc);
                }
            }
            if (xpsret != null) {
                for (i = 0; i <= 5; i++) {
                    xpsret[i] = xps[i];
                }
            }
        }
        /* moon */
        if (do_moon) {
            speedf1 = pmdp.xflgs & SweConst.SEFLG_SPEED;
            if (tjd == pmdp.teval
                && pmdp.iephe == SweConst.SEFLG_SWIEPH
                && ((speedf2==0) || (speedf1!=0))) {
                for (i = 0; i <= 5; i++) {
                    xpm[i] = pmdp.x[i];
                }
            } else {
                retc = sweph(tjd, SwephData.SEI_MOON, SwephData.SEI_FILE_MOON, iflag, null,
                             do_save, xpm, serr);
                if (retc == SweConst.ERR) {
                    return(retc);
                }
                /* if moon file doesn't exist, take moshier moon */
                if (swed.fidat[SwephData.SEI_FILE_MOON].fptr == null) {
                    if (serr != null && serr.length() + 35 < SwissData.AS_MAXCH) {
                        serr.append(" \nusing Moshier eph. for moon; ");
                    }
                    retc = sm.swi_moshmoon(tjd, do_save, xpm, serr);
                    if (retc != SweConst.OK) {
                        return(retc);
                    }
                }
            }
            if (xpmret != null) {
                for (i = 0; i <= 5; i++) {
                    xpmret[i] = xpm[i];
                }
            }
        }
        /* barycentric earth */
        if (do_earth) {
            speedf1 = pebdp.xflgs & SweConst.SEFLG_SPEED;
            if (tjd == pebdp.teval
                && pebdp.iephe == SweConst.SEFLG_SWIEPH
                && ((speedf2==0) || (speedf1!=0))) {
                for (i = 0; i <= 5; i++) {
                    xpe[i] = pebdp.x[i];
                }
            } else {
                retc = sweph(tjd, SwephData.SEI_EMB, SwephData.SEI_FILE_PLANET, iflag, null,
                             do_save, xpe, serr);
                if (retc != SweConst.OK) {
                    return(retc);
                }
                /* earth from emb and moon */
                embofs(xpe, 0, xpm, 0);
                /* speed is needed, if
                 * 1. true position is being computed before applying light-time etc.
                 *    this is the position saved in pdp->x.
                 *    in this case, speed is needed for light-time correction.
                 * 2. the speed flag has been specified.
                 */
                if (xpe == pebdp.x || ((iflag & SweConst.SEFLG_SPEED)!=0)) {
                    embofs(xpe, 3, xpm, 3);
                }
            }
            if (xperet != null) {
                for (i = 0; i <= 5; i++) {
                    xperet[i] = xpe[i];
                }
            }
        }
        if (ipli == SwephData.SEI_MOON) {
            for (i = 0; i <= 5; i++) {
                xp[i] = xpm[i];
            }
        } else if (ipli == SwephData.SEI_EARTH) {
            for (i = 0; i <= 5; i++) {
                xp[i] = xpe[i];
            }
        } else if (ipli == SwephData.SEI_SUN) {
            for (i = 0; i <= 5; i++) {
                xp[i] = xps[i];
            }
        } else {
            /* planet */
            speedf1 = pdp.xflgs & SweConst.SEFLG_SPEED;
            if (tjd == pdp.teval
                && pdp.iephe == SweConst.SEFLG_SWIEPH
                && ((speedf2==0) || (speedf1!=0))) {
                for (i = 0; i <= 5; i++) {
                    xp[i] = pdp.x[i];
                }
                return(SweConst.OK);
            } else {
                retc = sweph(tjd, ipli, ifno, iflag, null, do_save, xp, serr);
                if (retc != SweConst.OK) {
                    return(retc);
                }
                /* if planet is heliocentric, it must be transformed to barycentric */
                if ((pdp.iflg & SwephData.SEI_FLG_HELIO)!=0) {
                    /* now barycentric planet */
                    for (i = 0; i <= 2; i++) {
                        xp[i] += xps[i];
                    }
                    if (do_save || ((iflag & SweConst.SEFLG_SPEED)!=0)) {
                        for (i = 3; i <= 5; i++) {
                            xp[i] += xps[i];
                        }
                    }
                }
            }
        }
        if (xpret != null) {
            for (i = 0; i <= 5; i++) {
                xpret[i] = xp[i];
            }
        }
        return SweConst.OK;
    }

    /* jpl ephemeris.
     * this function computes
     * 1. a barycentric planet position
     * plus, under certain conditions,
     * 2. the barycentric sun,
     * 3. the barycentric earth,
     * in barycentric cartesian equatorial coordinates J2000.
  
     * tjd          julian day
     * ipli         sweph internal planet number
     * do_save      write new positions in save area
     * xp           array of 6 doubles for planet's position and speed vectors
     * xpe                                 earth's
     * xps                                 sun's
     * serr         pointer to error string
     *
     * xp - xps can be NULL. if do_save is TRUE, all of them can be NULL.
     * the positions will be written into the save area (swed.pldat[ipli].x)
     */
    int jplplan(double tjd, int ipli, int iflag, boolean do_save,
                double xpret[], double xperet[], double xpsret[],
                StringBuffer serr) throws SwissephException {
        int i, retc;
        boolean do_earth = false, do_sunbary = false;
        double ss[]=new double[3];
        double xxp[]=new double[6], xxe[]=new double[6], xxs[]=new double[6];
        double xp[], xpe[], xps[];
        int ictr = SwephJPL.J_SBARY;
        PlanData pdp = swed.pldat[ipli];
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        /* we assume Teph ~= TDB ~= TT. The maximum error is < 0.002 sec, 
         * corresponding to an ephemeris error < 0.001 arcsec for the moon */
        /* double tjd_tdb, T;
           T = (tjd - 2451545.0)/36525.0;
           tjd_tdb = tjd + (0.001657 * sin(628.3076 * T + 6.2401)
           + 0.000022 * sin(575.3385 * T + 4.2970)
           + 0.000014 * sin(1256.6152 * T + 6.1969)) / 8640.0;*/
        if (do_save) {
            xp = pdp.x;
            xpe = pedp.x;
            xps = psdp.x;
        } else {
            xp = xxp;
            xpe = xxe;
            xps = xxs;
        }
        if (do_save || ipli == SwephData.SEI_EARTH || xperet != null
            || (ipli == SwephData.SEI_MOON)) {
            /* && (iflag & (SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR |
               SweConst.SEFLG_NOABERR))!=0)) */
            do_earth = true;
        }
        if (do_save || ipli == SwephData.SEI_SUNBARY || xpsret != null
            || (ipli == SwephData.SEI_MOON)) {
            /* && (iflag & (SEFLG_HELCTR | SEFLG_NOABERR)))) */
            do_sunbary = true;
        }
        if (ipli == SwephData.SEI_MOON) {
            ictr = SwephJPL.J_EARTH;
        }
        /* open ephemeris, if still closed */
        if (!swed.jpl_file_is_open) {
            retc = sj.swi_open_jpl_file(ss, swed.jplfnam, swed.ephepath, serr);
            swed.jpldenum = sj.swi_get_jpl_denum();
            if (retc != SweConst.OK) {
                throw new SwissephException(tjd, SwissephException.FILE_OPEN_FAILED,
                                            retc, serr);
            }
            swed.jpl_file_is_open = true;
        }
        if (do_earth) {
            /* barycentric earth */
            if (tjd != pedp.teval || tjd == 0) {
                retc = sj.swi_pleph(tjd, SwephJPL.J_EARTH, SwephJPL.J_SBARY, xpe, serr);
                if (retc != SweConst.OK) {
                    sj.swi_close_jpl_file();
                    swed.jpl_file_is_open = false;
                    return retc;
                }
                if (do_save) {
                    pedp.teval = tjd;
                    pedp.xflgs = -1;       /* new light-time etc. required */
                    pedp.iephe = SweConst.SEFLG_JPLEPH;
                }
            } else {
                xpe = pedp.x;
            }
            if (xperet != null) {
                for (i = 0; i <= 5; i++) {
                    xperet[i] = xpe[i];
                }
            }
  
        }
        if (do_sunbary) {
            /* barycentric sun */
            if (tjd != psdp.teval || tjd == 0) {
                retc = sj.swi_pleph(tjd, SwephJPL.J_SUN, SwephJPL.J_SBARY, xps, serr);
                if (retc != SweConst.OK) {
                    sj.swi_close_jpl_file();
                    swed.jpl_file_is_open = false;
                    return retc;
                }
                if (do_save) {
                    psdp.teval = tjd;
                    psdp.xflgs = -1;
                    psdp.iephe = SweConst.SEFLG_JPLEPH;
                }
            } else {
                xps = psdp.x;
            }
            if (xpsret != null) {
                for (i = 0; i <= 5; i++) {
                    xpsret[i] = xps[i];
                }
            }
        }
        /* earth is wanted */
        if (ipli == SwephData.SEI_EARTH) {
            for (i = 0; i <= 5; i++) {
                xp[i] = xpe[i];
            }
            /* sunbary is wanted */
        } if (ipli == SwephData.SEI_SUNBARY) {
            for (i = 0; i <= 5; i++) {
                xp[i] = xps[i];
            }
            /* other planet */
        } else {
            /* if planet already computed */
            if (tjd == pdp.teval && pdp.iephe == SweConst.SEFLG_JPLEPH) {
                xp = pdp.x;
            } else {
                retc = sj.swi_pleph(tjd, SwephData.pnoint2jpl[ipli], ictr, xp, serr);
                if (retc != SweConst.OK) {
                    sj.swi_close_jpl_file();
                    swed.jpl_file_is_open = false;
                    return retc;
                }
                if (do_save) {
                    pdp.teval = tjd;
                    pdp.xflgs = -1;
                    pdp.iephe = SweConst.SEFLG_JPLEPH;
                }
            }
        }
        if (xpret != null) {
            for (i = 0; i <= 5; i++) {
                xpret[i] = xp[i];
            }
        }
        return (SweConst.OK);
    }

    /*
     * this function looks for an ephemeris file,
     * opens it, if not yet open,
     * reads constants, if not yet read,
     * computes a planet, if not yet computed
     * attention: asteroids are heliocentric
     *            other planets barycentric
     *
     * tjd          julian date
     * ipli         SEI_ planet number
     * ifno         ephemeris file number
     * xsunb        INPUT (!) array of 6 doubles containing barycentric sun
     *              (must be given with asteroids)
     * do_save      boolean: save result in save area
     * xp           return array of 6 doubles for planet's position
     * serr         error string
     */
    int sweph(double tjd, int ipli, int ifno, int iflag, double xsunb[],
              boolean do_save, double xpret[], StringBuffer serr) {
        int i, ipl, retc, subdirlen;
        String s="", subdirnam, fname;
        double t, tsv;
        double xemb[]=new double[6], xx[]=new double[6], xp[];
        PlanData pdp;
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        FileData fdp = swed.fidat[ifno];
        int speedf1, speedf2;
        boolean need_speed;
        ipl = ipli;
        if (ipli > SweConst.SE_AST_OFFSET) {
            ipl = SwephData.SEI_ANYBODY;
        }
        pdp = swed.pldat[ipl];
        if (do_save) {
            xp = pdp.x;
        } else {
            xp = xx;
        }
        /* if planet has already been computed for this date, return.
         * if speed flag has been turned on, recompute planet */
        speedf1 = pdp.xflgs & SweConst.SEFLG_SPEED;
        speedf2 = iflag & SweConst.SEFLG_SPEED;
        if (tjd == pdp.teval
            && pdp.iephe == SweConst.SEFLG_SWIEPH
            && ((speedf2==0) || (speedf1!=0))
            && ipl < SwephData.SEI_ANYBODY) {
            if (xpret != null) {
                for (i = 0; i <= 5; i++) {
                    xpret[i] = pdp.x[i];
                }
            }
            return SweConst.OK;
        }
        
        if (fdp.fptr != null) {
            /* if tjd is beyond file range, close old file.
             * if new asteroid, close old file. */
            if (tjd < fdp.tfstart || tjd > fdp.tfend
                || (ipl == SwephData.SEI_ANYBODY && ipli != pdp.ibdy)) {
                try {
                    fdp.fptr.close();
                } catch (java.io.IOException e) {
                    // NBT
                }
                fdp.fptr = null;
                if (pdp.refep != null) {
                    pdp.refep = null;
                }
                if (pdp.segp != null) {
                    pdp.segp = null;
                }
            }
        }
        /* if sweph file not open, find and open it */
        if (fdp.fptr == null) {
            fname=sl.swi_gen_filename(new SweDate(tjd), ipli);
            subdirnam=fname;
            if (subdirnam.lastIndexOf(swed.DIR_GLUE)>0) {
                subdirnam=subdirnam.substring(0,subdirnam.indexOf(swed.DIR_GLUE));
                subdirlen=subdirnam.length();
            } else {
                subdirlen=0;
            }
            s=fname;

            while (fdp.fptr==null) {
                try {
                    fdp.fptr=swi_fopen(ifno,s,swed.ephepath, serr);
                } catch (SwissephException se) {
                }
                if (fdp.fptr == null ||
                    (fdp.fptr!=null && fdp.fptr.fp==null && fdp.fptr.sk==null)) {
                    /*
                     * if it is a numbered asteroid file, try also for short files (..s.se1)
                     * On the second try, the inserted 's' will be seen and not tried again.
                     */
                    if (ipli > SweConst.SE_AST_OFFSET) {
                        if (s.indexOf("s.")<=0) {
                            s=s.substring(0,s.indexOf("."))+"s."+SwephData.SE_FILE_SUFFIX;
                            continue;
                        } else {
                            /*
                             * if we still have 'ast0' etc. in front of the filename,
                             * we remove it now, remove the 's' also,
                             * and try in the main ephemeris directory instead of the
                             * asteroid subdirectory.
                             */
                            s=s.substring(0,s.indexOf("s."))+s.substring(s.indexOf("s.")+1);
                            if (subdirlen>0 &&
                                s.startsWith(subdirnam.substring(
                                                                 0,Math.min(subdirnam.length(),subdirlen)))) {
                                s=s.substring(subdirlen+1);
                                continue;
                            }
                        }
                    }
                    return(SwephData.NOT_AVAILABLE);
                }
                if (fdp.fptr!=null) { break; }
            }

            /* during the search error messages may have been built, delete them */
            if (serr != null) {
                serr.setLength(0);
            }
            retc = swed.fidat[ifno].read_const(ifno, serr, swed);
            if (retc != SweConst.OK) {
                return(retc);
            }
        }
        /* if first ephemeris file (J-3000), it might start a mars period
         * after -3000. if last ephemeris file (J3000), it might end a
         * 4000-day-period before 3000. */
        if (tjd < fdp.tfstart || tjd > fdp.tfend) {
            if (serr != null) {
                if (tjd < fdp.tfstart) {
                    s="jd "+tjd+" < Swiss Eph. lower limit "+fdp.tfstart+";";
                } else {
                    s="jd "+tjd+" > Swiss Eph. upper limit "+fdp.tfend+";";
                }
                if (serr.length()+s.length() < SwissData.AS_MAXCH) {
                    serr.append(s);
                }
            }
            return(SwephData.NOT_AVAILABLE);
        }
        
        /* get new segment, if necessary */
        if (pdp.segp == null || tjd < pdp.tseg0 || tjd > pdp.tseg1) {
            retc = swed.fidat[ifno].get_new_segment(swed, tjd, ipl, ifno, serr);
            if (retc != SweConst.OK) {
                return(retc);
            }
            /* rotate cheby coeffs back to equatorial system.
             * if necessary, add reference orbit. */
            if ((pdp.iflg & SwephData.SEI_FLG_ROTATE)!=0) {
                rot_back(ipl); 
            } else {
                pdp.neval = pdp.ncoe;
            }
        }
        /* evaluate chebyshew polynomial for tjd */
        t = (tjd - pdp.tseg0) / pdp.dseg;
        t = t * 2 - 1;
        /* speed is needed, if
         * 1. true position is being computed before applying light-time etc.
         *    this is the position saved in pdp->x.
         *    in this case, speed is needed for light-time correction.
         * 2. the speed flag has been specified.
         */
        need_speed = (do_save || ((iflag & SweConst.SEFLG_SPEED)!=0));
        for (i = 0; i <= 2; i++) {
            xp[i]  = sl.swi_echeb (t, pdp.segp, i*pdp.ncoe, pdp.neval);
            if (need_speed) {
                xp[i+3] = sl.swi_edcheb(t, pdp.segp, i*pdp.ncoe, pdp.neval) / pdp.dseg * 2;
            } else
                xp[i+3] = 0;      /* von Alois als billiger fix, evtl. illegal */
        }
        /* if planet wanted is barycentric sun and must be computed
         * from heliocentric earth and barycentric earth: the
         * computation above gives heliocentric earth, therefore we
         * have to compute barycentric earth and subtract heliocentric
         * earth from it. this may be necessary with calls from
         * sweplan() and from app_pos_etc_sun() (light-time). */
        if (ipl == SwephData.SEI_SUNBARY &&
            (pdp.iflg & SwephData.SEI_FLG_EMBHEL)!=0) {
            /* sweph() calls sweph() !!! for EMB.
             * Attention: a new calculation must be forced in any case.
             * Otherwise EARTH (instead of EMB) will possibly taken from
             * save area.
             * to force new computation, set pedp->teval = 0 and restore it
             * after call of sweph(EMB).
             */
            tsv = pedp.teval;
            pedp.teval = 0;
            retc = sweph(tjd, SwephData.SEI_EMB, ifno, iflag | SweConst.SEFLG_SPEED,
                         null, SwephData.NO_SAVE, xemb, serr);
            if (retc != SweConst.OK) {
                return(retc);
            }
            pedp.teval = tsv;
            for (i = 0; i <= 2; i++) {
                xp[i] = xemb[i] - xp[i];
            }
            if (need_speed) {
                for (i = 3; i <= 5; i++) {
                    xp[i] = xemb[i] - xp[i];
                }
            }
        }
        /* asteroids are heliocentric.
         * if JPL or SWISSEPH, convert to barycentric */
        if ((iflag & SweConst.SEFLG_JPLEPH)!=0 ||
            (iflag & SweConst.SEFLG_SWIEPH)!=0) {
            if (ipl >= SwephData.SEI_ANYBODY) {
                for (i = 0; i <= 2; i++) {
                    xp[i] += xsunb[i];
                }
                if (need_speed) {
                    for (i = 3; i <= 5; i++) {
                        xp[i] += xsunb[i];
                    }
                }
            }
        }
        if (do_save) {
            pdp.teval = tjd;
            pdp.xflgs = -1;    /* do new computation of light-time etc. */
            if (ifno == SwephData.SEI_FILE_PLANET ||
                ifno == SwephData.SEI_FILE_MOON) {
                pdp.iephe = SweConst.SEFLG_SWIEPH;
            } else {
                pdp.iephe = psdp.iephe;
            }
        }
        if (xpret != null) {
            for (i = 0; i <= 5; i++) {
                xpret[i] = xp[i];
            }
        }
        return SweConst.OK;
    }

    /*
     * Alois 2.12.98: inserted error message generation for file not found
     */
    FilePtr swi_fopen(int ifno, String fname, String ephepath,
                      StringBuffer serr) throws SwissephException {
        int np, i;
        java.io.RandomAccessFile fp = null;
        String fnamp;
        String[] cpos=new String[20];
        String path, s, s1;
        //s1=ephepath;
        s1=getTmp();
        
        np = sl.swi_cutstr(s1, SwissData.PATH_SEPARATOR, cpos, 20);
        for (i = 0; i < np; i++) {
            path=cpos[i];
            if ("".equals(path)) { path="."; }
            fnamp=path+swed.DIR_GLUE;

            if (fnamp.length() + fname.length() < SwissData.AS_MAXCH) {
                fnamp+=fname;
            } else {
                if (serr != null) {
                    serr.setLength(0);
                    serr.append("error: file path and name must be shorter than "+
                                SwissData.AS_MAXCH+".");
                }
                throw new SwissephException(1./0., SwissephException.INVALID_FILE_NAME,
                                            SweConst.ERR, serr);
            }
            try {          
                fp = new java.io.RandomAccessFile(fnamp, SwissData.BFILE_R_ACCESS);
                if (ifno >= 0) {
                    swed.fidat[ifno].fnam=fnamp;
                }
                FilePtr sfp = new FilePtr(fp,null,null,null,fnamp,-1,httpBufSize);
                return sfp;
            } catch (java.io.IOException ex) {
                // Maybe it is an URL...
                FilePtr f=tryFileAsURL(path+"/"+fname, ifno);
                if (f!=null) {
                    return f;
                }
            } catch (SecurityException ex) {
                // Probably an applet, we try fnamp as an URL:
                FilePtr f=tryFileAsURL(path+"/"+fname, ifno);
                if (f!=null) {
                    return f;
                }
            }
        }
//         //    s="SwissEph file '"+fname+"' not found in PATH '"+ephepath+"'";
//         s="SwissEph file '"+fname+"' not found in the paths of: ";
//         for (int n=0;n<cpos.length;n++) {
//             if (cpos[n]!=null && !"".equals(cpos[n])) { s+="'"+cpos[n]+"', "; }
//         }
//         /* s may be longer then AS_MAXCH */
//         // Who cares...
//         //    s=s.substring(0,Math.min(s.length(),SwissData.AS_MAXCH));
//         if (serr != null) {
//             serr.setLength(0);
//             serr.append(s);
//         }
//         ////#ifdef TRACE0
//         //    Trace.level--;
//         ////#endif /* TRACE0 */
//         throw new SwissephException(1./0., SwissephException.FILE_NOT_FOUND,
//                                     SwephData.NOT_AVAILABLE, serr);
        return null;
    }

    private FilePtr tryFileAsURL(String fnamp, int ifno) {
        ////#ifdef TRACE0
        //    Trace.level++;
        //    Trace.trace(Trace.level, "SwissEph.tryFileAsURL(String, int)");
        ////#ifdef TRACE1
        //    DevNull.println("    fnamp: " + fnamp + "\n    ifno: " + ifno);
        ////#endif /* TRACE1 */
        ////#endif /* TRACE0 */
        Socket sk=null;
        try {
            URL u=new URL(fnamp);
            sk=new Socket(u.getHost(),(u.getPort()<0?80:u.getPort()));
            String sht="HEAD "+fnamp+" HTTP/1.1\r\n"+
                "User-Agent: "+FilePtr.useragent+"\r\n"+
                "Host: "+u.getHost()+":"+(u.getPort()<0?80:u.getPort())+
                "\r\n\r\n";
            sk.setSoTimeout(5000);
            InputStream is=sk.getInputStream();
            BufferedOutputStream os=new BufferedOutputStream(sk.getOutputStream());
            for(int n=0; n<sht.length(); n++) {
                os.write((byte)sht.charAt(n));
            }
            os.flush();
            String sret=""+(char)is.read();
            while (is.available()>0) {
                sret+=(char)is.read();
            }
            int idx=sret.indexOf("Content-Length:");
            if (idx < 0) {
                sk.close();
                ////#ifdef TRACE0
                //        Trace.level--;
                ////#endif /* TRACE0 */
                return null;
            }
            // We need to query ranges, otherwise it will not make much sense...
            if (sret.indexOf("Accept-Ranges: none")>=0) {
                System.err.println("Server does not accept HTTP range requests. "+
                                   "Aborting!");
                sk.close();
                ////#ifdef TRACE0
                //        Trace.level--;
                ////#endif /* TRACE0 */
                return null;
            }
            sret=sret.substring(idx+"Content-Length:".length());
            sret=sret.substring(0,sret.indexOf("\n")).trim();
            // We might want to check for a minimum length?
            long len=Long.parseLong(sret);
            if (ifno >= 0) {
                swed.fidat[ifno].fnam=fnamp;
            }
            ////#ifdef TRACE0
            //      Trace.level--;
            ////#endif /* TRACE0 */
            return new FilePtr(null,sk,is,os,fnamp,len,httpBufSize);
        } catch (MalformedURLException m) {
        } catch (IOException ie) {
        } catch (NumberFormatException nf) {
            // Why this? Should not be able to happen...
        } catch (SecurityException se) {
        }
        try { sk.close(); }
        catch (IOException e) { }
        catch (NullPointerException np) { }
        ////#ifdef TRACE0
        //    Trace.level--;
        ////#endif /* TRACE0 */
        return null;
    }

    /* converts planets from barycentric to geocentric,
     * apparent positions
     * precession and nutation
     * according to flags
     * ipli         planet number
     * iflag        flags
     * serr         error string
     */
    int app_pos_etc_plan(int ipli, int iflag, StringBuffer serr) {
        int i, j, niter, retc = SweConst.OK;
        int ipl;
        int ifno, ibody;
        int flg1, flg2;
        double xx[]=new double[6], dx[]=new double[3], dt, t, dtsave_for_defl;
        double xobs[]=new double[6], xobs2[]=new double[6];
        double xearth[]=new double[6], xsun[]=new double[6];
        double xxsp[]=new double[6], xxsv[]=new double[6];
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData pdp;
        Epsilon oe = swed.oec2000;
        int epheflag = iflag & SweConst.SEFLG_EPHMASK;
        t = dtsave_for_defl = 0;      /* dummy assignment to silence gcc */
        /* ephemeris file */
        if (ipli > SweConst.SE_AST_OFFSET) {
            ifno = SwephData.SEI_FILE_ANY_AST;
            ibody = SwephData.IS_ANY_BODY;
            pdp = swed.pldat[SwephData.SEI_ANYBODY];
        } else if (ipli == SwephData.SEI_CHIRON
                   || ipli == SwephData.SEI_PHOLUS
                   || ipli == SwephData.SEI_CERES
                   || ipli == SwephData.SEI_PALLAS
                   || ipli == SwephData.SEI_JUNO
                   || ipli == SwephData.SEI_VESTA) {
            ifno = SwephData.SEI_FILE_MAIN_AST;
            ibody = SwephData.IS_MAIN_ASTEROID;
            pdp = swed.pldat[ipli];
        } else {
            ifno = SwephData.SEI_FILE_PLANET;
            ibody = SwephData.IS_PLANET;
            pdp = swed.pldat[ipli];
        }
        /* if the same conversions have already been done for the same
         * date, then return */
        flg1 = iflag & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        flg2 = pdp.xflgs & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        if (flg1 == flg2) {
            pdp.xflgs = iflag;
            pdp.iephe = iflag & SweConst.SEFLG_EPHMASK;
            return SweConst.OK;
        }
        /* the conversions will be done with xx[]. */
        for (i = 0; i <= 5; i++) {
            xx[i] = pdp.x[i];
        }
        /* if heliocentric position is wanted */
        if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
            if (pdp.iephe == SweConst.SEFLG_JPLEPH ||
                pdp.iephe == SweConst.SEFLG_SWIEPH) {
                for (i = 0; i <= 5; i++) {
                    xx[i] -= swed.pldat[SwephData.SEI_SUNBARY].x[i];
                }
            }
        }
        
        /* if topocentric position is wanted  */
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            if (swed.topd.teval != pedp.teval
                || pedp.teval == 0) {
                if (swi_get_observer(pedp.teval, iflag, SwephData.DO_SAVE, xobs, serr)
                    != SweConst.OK) {
                    return SweConst.ERR;
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = swed.topd.xobs[i];
                }
            }
            /* barycentric position of observer */
            for (i = 0; i <= 5; i++) {
                xobs[i] = xobs[i] + pedp.x[i];
            }
        } else {
            /* barycentric position of geocenter */
            for (i = 0; i <= 5; i++) {
                xobs[i] = pedp.x[i];
            }
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0) {
            /* number of iterations - 1 */
            if (pdp.iephe == SweConst.SEFLG_JPLEPH ||
                pdp.iephe == SweConst.SEFLG_SWIEPH) {
                niter = 1;
            } else {      /* SEFLG_MOSEPH or planet from osculating elements */
                niter = 0;
            }
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                /*
                 * Apparent speed is influenced by the fact that dt changes with
                 * motion. This makes a difference of several hundredths of an
                 * arc second. To take this into account, we compute
                 * 1. true position - apparent position at time t - 1.
                 * 2. true position - apparent position at time t.
                 * 3. the difference between the two is the part of the daily motion
                 * that results from the change of dt.
                 */
                for (i = 0; i <= 2; i++) {
                    xxsv[i] = xxsp[i] = xx[i] - xx[i+3];
                }
                for (j = 0; j <= niter; j++) {
                    for (i = 0; i <= 2; i++) {
                        dx[i] = xxsp[i];
                        if (((iflag & SweConst.SEFLG_HELCTR)==0) &&
                            (iflag & SweConst.SEFLG_BARYCTR)==0) {
                            dx[i] -= (xobs[i] - xobs[i+3]);
                        }
                    }
                    /* new dt */
                    dt = Math.sqrt(sl.square_sum(dx)) * SweConst.AUNIT / SwephData.CLIGHT /
                        86400.0;
                    for (i = 0; i <= 2; i++) {      /* rough apparent position at t-1 */
                        xxsp[i] = xxsv[i] - dt * pdp.x[i+3];
                    }
                }
                /* true position - apparent position at time t-1 */
                for (i = 0; i <= 2; i++) {
                    xxsp[i] = xxsv[i] - xxsp[i];
                }
            }
            /* dt and t(apparent) */
            for (j = 0; j <= niter; j++) {
                for (i = 0; i <= 2; i++) {
                    dx[i] = xx[i];
                    if ((iflag & SweConst.SEFLG_HELCTR)==0 &&
                        (iflag & SweConst.SEFLG_BARYCTR)==0) {
                        dx[i] -= xobs[i];
                    }
                }
                dt = Math.sqrt(sl.square_sum(dx)) *SweConst.AUNIT / SwephData.CLIGHT / 86400.0;
                /* new t */
                t = pdp.teval - dt;
                dtsave_for_defl = dt;
                for (i = 0; i <= 2; i++) {        /* rough apparent position at t*/
                    xx[i] = pdp.x[i] - dt * pdp.x[i+3];
                }
            }
            /* part of daily motion resulting from change of dt */
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                for (i = 0; i <= 2; i++) {
                    xxsp[i] = pdp.x[i] - xx[i] - xxsp[i];
                }
            }
            /* new position, accounting for light-time (accurate) */
            switch(epheflag) {
                case SweConst.SEFLG_JPLEPH:
                    if (ibody == SwephData.IS_PLANET) {
                        ipl = SwephData.pnoint2jpl[ipli];
                        retc = sj.swi_pleph(t, ipl, SwephJPL.J_SBARY, xx, serr);
                        if (retc != SweConst.OK) {
                            sj.swi_close_jpl_file();
                            swed.jpl_file_is_open = false;
                        }
                    } else {        /* asteroid */
                        /* first sun */
                        retc = sj.swi_pleph(t, SwephJPL.J_SUN, SwephJPL.J_SBARY, xsun, serr);
                        if (retc != SweConst.OK) {
                            sj.swi_close_jpl_file();
                            swed.jpl_file_is_open = false;
                        }
                        /* asteroid */
                        retc = sweph(t, ipli, ifno, iflag, xsun, SwephData.NO_SAVE, xx, serr);
                    }
                    if (retc != SweConst.OK) {
                        return(retc);
                    }
                    /* for accuracy in speed, we need earth as well */
                    if ((iflag & SweConst.SEFLG_SPEED)!=0
                        && (iflag & SweConst.SEFLG_HELCTR)==0
                        && (iflag & SweConst.SEFLG_BARYCTR)==0) {
                        retc = sj.swi_pleph(t, SwephJPL.J_EARTH, SwephJPL.J_SBARY, xearth, serr);
                        if (retc != SweConst.OK) {
                            sj.swi_close_jpl_file();
                            swed.jpl_file_is_open = false;
                            return(retc);
                        }
                    }
                    break;
                case SweConst.SEFLG_SWIEPH:
                    if (ibody == SwephData.IS_PLANET) {
                        retc = sweplan(t, ipli, ifno, iflag, SwephData.NO_SAVE, xx, xearth,
                                       xsun, null, serr);
                    } else {          /*asteroid*/
                        retc = sweplan(t, SwephData.SEI_EARTH, SwephData.SEI_FILE_PLANET,
                                       iflag, SwephData.NO_SAVE, xearth, null, xsun, null,
                                       serr);
                        if (retc == SweConst.OK) {
                            retc = sweph(t, ipli, ifno, iflag, xsun, SwephData.NO_SAVE, xx,
                                         serr);
                        }
                    }
                    if (retc != SweConst.OK) {
                        return(retc);
                    }
                    break;
                case SweConst.SEFLG_MOSEPH:
                default:
                    /*
                     * with moshier or other ephemerides, subtraction of dt * speed
                     * is sufficient (has been done in light-time iteration above)
                     */
                    /* if speed flag is true, we call swi_moshplan() for new t.
                     * this does not increase position precision,
                     * but speed precision, which becomes better than 0.01"/day.
                     * for precise speed, we need earth as well.
                     */
                    if ((iflag & SweConst.SEFLG_SPEED)!=0
                        && (iflag & (SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR))==0) {
                        if (ibody == SwephData.IS_PLANET) {
                            retc = smosh.swi_moshplan(t, ipli, SwephData.NO_SAVE, xxsv,
                                                      xearth, serr);
                        } else {                /* if asteroid */
                            retc = sweph(t, ipli, ifno, iflag, null, SwephData.NO_SAVE, xxsv,
                                         serr);
                            if (retc == SweConst.OK) {
                                retc = smosh.swi_moshplan(t, SwephData.SEI_EARTH,
                                                          SwephData.NO_SAVE, xearth, xearth,
                                                          serr);
                            }
                        }
                        if (retc != SweConst.OK) {
                            return(retc);
                        }
                        /* only speed is taken from this computation, otherwise position
                         * calculations with and without speed would not agree. The difference
                         * would be about 0.01", which is far below the intrinsic error of the
                         * moshier ephemeris.
                         */
                        for (i = 3; i <= 5; i++) {
                            xx[i] = xxsv[i];
                        }
                    }
                    break;
            }
            if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
                if (pdp.iephe == SweConst.SEFLG_JPLEPH ||
                    pdp.iephe == SweConst.SEFLG_SWIEPH) {
                    for (i = 0; i <= 5; i++) {
                        xx[i] -= swed.pldat[SwephData.SEI_SUNBARY].x[i];
                    }
                }
            }
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                /* observer position for t(light-time) */
                if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
                    if (swi_get_observer(t, iflag, SwephData.NO_SAVE, xobs2, serr) !=
                        SweConst.OK) {
                        return SweConst.ERR;
                    }
                    for (i = 0; i <= 5; i++) {
                        xobs2[i] += xearth[i];
                    }
                } else {
                    for (i = 0; i <= 5; i++) {
                        xobs2[i] = xearth[i];
                    }
                }
            }
        }
        
        if ((iflag & SweConst.SEFLG_HELCTR)==0 &&
            (iflag & SweConst.SEFLG_BARYCTR)==0) {
            /* subtract earth */
            for (i = 0; i <= 5; i++) {
                xx[i] -= xobs[i];
            }
            if ((iflag & SweConst.SEFLG_TRUEPOS) == 0 ) {
                /*
                 * Apparent speed is also influenced by
                 * the change of dt during motion.
                 * Neglect of this would result in an error of several 0.01"
                 */
                if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                    for (i = 3; i <= 5; i++) {
                        xx[i] -= xxsp[i-3];
                    }
                }
            }
        }
        if ((iflag & SweConst.SEFLG_SPEED)==0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0 &&
            (iflag & SweConst.SEFLG_NOGDEFL)==0) {
            /* SEFLG_NOGDEFL is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
            swi_deflect_light(xx, 0, dtsave_for_defl, iflag);
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0 &&
            (iflag & SweConst.SEFLG_NOABERR)==0) {
            /* SEFLG_NOABERR is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
            swi_aberr_light(xx, xobs, iflag);
            /*
             * Apparent speed is also influenced by
             * the difference of speed of the earth between t and t-dt.
             * Neglecting this would involve an error of several 0.1"
             */
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                for (i = 3; i <= 5; i++) {
                    xx[i] += xobs[i] - xobs2[i];
                }
            }
        }
        if ((iflag & SweConst.SEFLG_SPEED) == 0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        /* ICRS to J2000 */
        if ((iflag & SweConst.SEFLG_ICRS) == 0 && swed.jpldenum >= 403) {
            sl.swi_bias(xx, iflag, false);
        }
        /* save J2000 coordinates; required for sidereal positions */
        for (i = 0; i <= 5; i++) {
            xxsv[i] = xx[i];
        }
        
        if ((iflag & SweConst.SEFLG_J2000)==0) {
            sl.swi_precess(xx, pdp.teval, SwephData.J2000_TO_J);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(xx, pdp.teval, SwephData.J2000_TO_J);
            }
            oe = swed.oec;
        } else {
            oe = swed.oec2000;
        }
        return app_pos_rest(pdp, iflag, xx, xxsv, oe, serr);
    }

    int app_pos_rest(PlanData pdp, int iflag,
                     double[] xx, double[] x2000,
                     Epsilon oe, StringBuffer serr) {
        int i;
        
        if ((iflag & SweConst.SEFLG_NONUT)==0) {
            swi_nutate(xx, 0, iflag, false);
        }
        /* now we have equatorial cartesian coordinates; save them */
        for (i = 0; i <= 5; i++) {
            pdp.xreturn[18+i] = xx[i];
        }
        
        sl.swi_coortrf2(xx, xx, oe.seps, oe.ceps);
        if ((iflag & SweConst.SEFLG_SPEED) !=0) {
            sl.swi_coortrf2(xx, 3, xx, 3, oe.seps, oe.ceps);
        }
        if ((iflag & SweConst.SEFLG_NONUT)==0) {
            sl.swi_coortrf2(xx, xx, swed.nut.snut, swed.nut.cnut);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                sl.swi_coortrf2(xx, 3, xx, 3, swed.nut.snut, swed.nut.cnut);
            }
        }
        /* now we have ecliptic cartesian coordinates */
        for (i = 0; i <= 5; i++) {
            pdp.xreturn[6+i] = xx[i];
        }
        
        if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
            /* project onto ecliptic t0 */
            if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0) {
                if (swi_trop_ra2sid_lon(x2000, pdp.xreturn, 6, pdp.xreturn, 18, iflag,
                                        serr) != SweConst.OK) {
                    return SweConst.ERR;
                }
                /* project onto solar system equator */
            } else if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
                if (swi_trop_ra2sid_lon_sosy(x2000, pdp.xreturn, 6, pdp.xreturn, 18,
                                             iflag, serr) != SweConst.OK) {
                    return SweConst.ERR;
                }
            } else {
                /* traditional algorithm */
                sl.swi_cartpol_sp(pdp.xreturn, 6, pdp.xreturn, 0);
                pdp.xreturn[0] -= swe_get_ayanamsa(pdp.teval) * SwissData.DEGTORAD;
                sl.swi_polcart_sp(pdp.xreturn, 0, pdp.xreturn, 6);
            }
        }
        
        sl.swi_cartpol_sp(pdp.xreturn, 18, pdp.xreturn, 12);
        sl.swi_cartpol_sp(pdp.xreturn, 6, pdp.xreturn, 0);
        
        /*if ((iflag & SEFLG_RADIANS) == 0) {*/
        for (i = 0; i < 2; i++) {
            pdp.xreturn[i] *= SwissData.RADTODEG;                /* ecliptic */
            pdp.xreturn[i+3] *= SwissData.RADTODEG;
            pdp.xreturn[i+12] *= SwissData.RADTODEG;     /* equator */
            pdp.xreturn[i+15] *= SwissData.RADTODEG;
        }
        /*}*/
        /* save, what has been done */
        pdp.xflgs = iflag;
        pdp.iephe = iflag & SweConst.SEFLG_EPHMASK;
        return SweConst.OK;
    }

    /*
     * input coordinates are J2000, cartesian.
     * xout         ecliptical sidereal position
     * xoutr        equatorial sidereal position
     */
    int swi_trop_ra2sid_lon(double[] xin, double[] xout, double[] xoutr,
                            int iflag, StringBuffer serr) {
        return swi_trop_ra2sid_lon(xin, xout, 0, xoutr, 0, iflag, serr);
    }
    int swi_trop_ra2sid_lon(double[] xin, double[] xout, int xoOffs,
                            double[] xoutr, int xrOffs, int iflag,
                            StringBuffer serr) {
        double x[]=new double[6];
        int i;
        SidData sip = swed.sidd;
        Epsilon oectmp=new Epsilon();
        for (i = 0; i <= 5; i++) {
            x[i] = xin[i];
        }
        if (sip.t0 != SwephData.J2000) {
            sl.swi_precess(x, sip.t0, SwephData.J2000_TO_J);
            sl.swi_precess(x, 3, sip.t0, SwephData.J2000_TO_J);      /* speed */
        }
        for (i = 0; i <= 5; i++) {
            xoutr[i+xrOffs] = x[i];
        }
        calc_epsilon(swed.sidd.t0, oectmp);
        sl.swi_coortrf2(x, x, oectmp.seps, oectmp.ceps);
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            sl.swi_coortrf2(x, 3, x, 3, oectmp.seps, oectmp.ceps);
        }
        /* to polar coordinates */
        sl.swi_cartpol_sp(x, x);
        /* subtract ayan_t0 */
        x[0] -= sip.ayan_t0 * SwissData.DEGTORAD;
        /* back to cartesian */
        sl.swi_polcart_sp(x, 0, xout, xoOffs);
        return SweConst.OK;
    }

    /*
     * input coordinates are J2000, cartesian.
     * xout         ecliptical sidereal position
     * xoutr        equatorial sidereal position
     */
    int swi_trop_ra2sid_lon_sosy(double[] xin, double[] xout, double[] xoutr,
                                 int iflag, StringBuffer serr) {
        return swi_trop_ra2sid_lon_sosy(xin, xout, 0, xoutr, 0, iflag, serr);
    }
    int swi_trop_ra2sid_lon_sosy(double[] xin, double[] xout, int xoOffs,
                                 double[] xoutr, int xrOffs, int iflag,
                                 StringBuffer serr) {
        double x[]=new double[6], x0[]=new double[6];
        int i;
        SidData sip = swed.sidd;
        Epsilon oe = swed.oec2000;
        double plane_node = SwephData.SSY_PLANE_NODE_E2000;
        double plane_incl = SwephData.SSY_PLANE_INCL;
        for (i = 0; i <= 5; i++) {
            x[i] = xin[i];
        }
        /* planet to ecliptic 2000 */
        sl.swi_coortrf2(x, x, oe.seps, oe.ceps);
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            sl.swi_coortrf2(x, 3, x, 3, oe.seps, oe.ceps);
        }
        /* to polar coordinates */
        sl.swi_cartpol_sp(x, x);
        /* to solar system equator */
        x[0] -= plane_node;
        sl.swi_polcart_sp(x, x);
        sl.swi_coortrf(x, x, plane_incl);
        sl.swi_coortrf(x, 3, x, 3, plane_incl);
        sl.swi_cartpol_sp(x, x);
        /* zero point of t0 in J2000 system */
        x0[0] = 1;
        x0[1] = x0[2] = 0;
        if (sip.t0 != SwephData.J2000) {
            sl.swi_precess(x0, sip.t0, SwephData.J_TO_J2000);
        }
        /* zero point to ecliptic 2000 */
        sl.swi_coortrf2(x0, x0, oe.seps, oe.ceps);
        /* to polar coordinates */
        sl.swi_cartpol(x0, x0);
        /* to solar system equator */
        x0[0] -= plane_node;
        sl.swi_polcart(x0, x0);
        sl.swi_coortrf(x0, x0, plane_incl);
        sl.swi_cartpol(x0, x0);
        /* measure planet from zero point */
        x[0] -= x0[0];
        x[0] *= SwissData.RADTODEG;
        /* subtract ayan_t0 */
        x[0] -= sip.ayan_t0;
        x[0] = sl.swe_degnorm(x[0]) * SwissData.DEGTORAD;
        /* back to cartesian */
        sl.swi_polcart_sp(x, 0, xout, xoOffs);
        return SweConst.OK;
    }

    /* converts planets from barycentric to geocentric,
     * apparent positions
     * precession and nutation
     * according to flags
     * ipli         planet number
     * iflag        flags
     */
    int app_pos_etc_plan_osc(int ipl, int ipli, int iflag, StringBuffer serr) {
        int i, j, niter, retc;
        double xx[]=new double[6], dx[]=new double[3], dt, dtsave_for_defl;
        double xearth[]=new double[6], xsun[]=new double[6], xmoon[]=new double[6];
        double xxsv[]=new double[6], xxsp[]=new double[6],
            xobs[]=new double[6], xobs2[]=new double[6];
        double t;
        PlanData pdp = swed.pldat[ipli];
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        Epsilon oe = swed.oec2000;
        int epheflag = SweConst.SEFLG_DEFAULTEPH;
        dt = dtsave_for_defl = 0;     /* dummy assign to silence gcc */
        if ((iflag & SweConst.SEFLG_MOSEPH)!=0) {
            epheflag = SweConst.SEFLG_MOSEPH;
        } else if ((iflag & SweConst.SEFLG_SWIEPH)!=0) {
            epheflag = SweConst.SEFLG_SWIEPH;
        } else if ((iflag & SweConst.SEFLG_JPLEPH)!=0) {
            epheflag = SweConst.SEFLG_JPLEPH;
        }
        /* the conversions will be done with xx[]. */
        for (i = 0; i <= 5; i++) {
            xx[i] = pdp.x[i];
        }
        
        /* = heliocentric position with Moshier ephemeris */
        
        /* if topocentric position is wanted  */
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            if (swed.topd.teval != pedp.teval
                || swed.topd.teval != 0) {
                if (swi_get_observer(pedp.teval, iflag, SwephData.DO_SAVE, xobs, serr)
                    != SweConst.OK) {
                    return SweConst.ERR;
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = swed.topd.xobs[i];
                }
            }
            /* barycentric position of observer */
            for (i = 0; i <= 5; i++) {
                xobs[i] = xobs[i] + pedp.x[i];
            }
        } else if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
            for (i = 0; i <= 5; i++) {
                xobs[i] = 0;
            }
        } else if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
            if ((iflag & SweConst.SEFLG_MOSEPH)!=0) {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = 0;
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = psdp.x[i];
                }
            }
        } else {
            for (i = 0; i <= 5; i++) {
                xobs[i] = pedp.x[i];
            }
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0) {
            niter = 1;
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                /*
                 * Apparent speed is influenced by the fact that dt changes with
                 * motion. This makes a difference of several hundredths of an
                 * arc second. To take this into account, we compute
                 * 1. true position - apparent position at time t - 1.
                 * 2. true position - apparent position at time t.
                 * 3. the difference between the two is the daily motion resulting from
                 * the change of dt.
                 */
                for (i = 0; i <= 2; i++) {
                    xxsv[i] = xxsp[i] = xx[i] - xx[i+3];
                }
                for (j = 0; j <= niter; j++) {
                    for (i = 0; i <= 2; i++) {
                        dx[i] = xxsp[i];
                        if ((iflag & SweConst.SEFLG_HELCTR)==0 &&
                            (iflag & SweConst.SEFLG_BARYCTR)==0) {
                            dx[i] -= (xobs[i] - xobs[i+3]);
                        }
                    }
                    /* new dt */
                    dt = Math.sqrt(sl.square_sum(dx)) * SweConst.AUNIT / SwephData.CLIGHT /
                        86400.0;
                    for (i = 0; i <= 2; i++) {
                        xxsp[i] = xxsv[i] - dt * pdp.x[i+3];/* rough apparent position */
                    }
                }
                /* true position - apparent position at time t-1 */
                for (i = 0; i <= 2; i++) {
                    xxsp[i] = xxsv[i] - xxsp[i];
                }
            }
            /* dt and t(apparent) */
            for (j = 0; j <= niter; j++) {
                for (i = 0; i <= 2; i++) {
                    dx[i] = xx[i];
                    if ((iflag & SweConst.SEFLG_HELCTR)==0 &&
                        (iflag & SweConst.SEFLG_BARYCTR)==0) {
                        dx[i] -= xobs[i];
                    }
                }
                /* new dt */
                dt = Math.sqrt(sl.square_sum(dx)) *SweConst.AUNIT / SwephData.CLIGHT / 86400.0;
                dtsave_for_defl = dt;
                /* new position: subtract t * speed
                 */
                for (i = 0; i <= 2; i++) {
                    xx[i] = pdp.x[i] - dt * pdp.x[i+3];
                    xx[i+3] = pdp.x[i+3];
                }
            }
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                /* part of daily motion resulting from change of dt */
                for (i = 0; i <= 2; i++) {
                    xxsp[i] = pdp.x[i] - xx[i] - xxsp[i];
                }
                t = pdp.teval - dt;
                /* for accuracy in speed, we will need earth as well */
                retc = main_planet_bary(t, SwephData.SEI_EARTH, epheflag, iflag,
                                        SwephData.NO_SAVE, xearth, xearth, xsun,
                                        xmoon, serr);
                if (smosh.swi_osc_el_plan(t, xx, ipl-SweConst.SE_FICT_OFFSET, ipli,
                                          xearth, xsun, serr) != SweConst.OK) {
                    return(SweConst.ERR);
                }
                if (retc != SweConst.OK) {
                    return(retc);
                }
                if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
                    if (swi_get_observer(t, iflag, SwephData.NO_SAVE, xobs2, serr) !=
                        SweConst.OK) {
                        return SweConst.ERR;
                    }
                    for (i = 0; i <= 5; i++) {
                        xobs2[i] += xearth[i];
                    }
                } else {
                    for (i = 0; i <= 5; i++) {
                        xobs2[i] = xearth[i];
                    }
                }
            }
        }
        
        for (i = 0; i <= 5; i++) {
            xx[i] -= xobs[i];
        }
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0) {
            /*
             * Apparent speed is also influenced by
             * the change of dt during motion.
             * Neglect of this would result in an error of several 0.01"
             */
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                for (i = 3; i <= 5; i++) {
                    xx[i] -= xxsp[i-3];
                }
            }
        }
        if ((iflag & SweConst.SEFLG_SPEED)==0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0 &&
            (iflag & SweConst.SEFLG_NOGDEFL)==0) {
            /* SEFLG_NOGDEFL is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
            swi_deflect_light(xx, 0, dtsave_for_defl, iflag);
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0 &&
            (iflag & SweConst.SEFLG_NOABERR)==0) {
            /* SEFLG_NOABERR is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
            swi_aberr_light(xx, xobs, iflag);
            /*
             * Apparent speed is also influenced by
             * the difference of speed of the earth between t and t-dt.
             * Neglecting this would involve an error of several 0.1"
             */
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                for (i = 3; i <= 5; i++) {
                    xx[i] += xobs[i] - xobs2[i];
                }
            }
        }
        /* save J2000 coordinates; required for sidereal positions */
        for (i = 0; i <= 5; i++) {
            xxsv[i] = xx[i];
        }
        
        if ((iflag & SweConst.SEFLG_J2000)==0) {
            sl.swi_precess(xx, pdp.teval, SwephData.J2000_TO_J);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(xx, pdp.teval, SwephData.J2000_TO_J);
            }
            oe = swed.oec;
        } else
            oe = swed.oec2000;
        return app_pos_rest(pdp, iflag, xx, xxsv, oe, serr);
    }

    /* influence of precession on speed
     * xx           position and speed of planet in equatorial cartesian
     *              coordinates */
    void swi_precess_speed(double xx[], double t, int direction) {
        swi_precess_speed(xx, 0, t, direction);
    }
    void swi_precess_speed(double xx[], int xOffs, double t, int direction) {
        Epsilon oe;
        double fac;
        double tprec = (t - SwephData.J2000) / 36525.0;
        if (direction == SwephData.J2000_TO_J) {
            fac = 1;
            oe = swed.oec;
        } else {
            fac = -1;
            oe = swed.oec2000;
        }
        /* first correct rotation.
         * this costs some sines and cosines, but neglect might
         * involve an error > 1"/day */
        sl.swi_precess(xx, 3+xOffs, t, direction);
        /* then add 0.137"/day */
        sl.swi_coortrf2(xx, xOffs, xx, xOffs, oe.seps, oe.ceps);
        sl.swi_coortrf2(xx, 3+xOffs, xx, 3+xOffs, oe.seps, oe.ceps);
        sl.swi_cartpol_sp(xx, xOffs, xx, xOffs);
        xx[3+xOffs] += (50.290966 + 0.0222226 * tprec) /
            3600 / 365.25 * SwissData.DEGTORAD * fac;
        /* formula from Montenbruck, German 1994, p. 18 */
        sl.swi_polcart_sp(xx, xOffs, xx, xOffs);
        sl.swi_coortrf2(xx, xOffs, xx, xOffs, -oe.seps, oe.ceps);
        sl.swi_coortrf2(xx, 3+xOffs, xx, 3+xOffs, -oe.seps, oe.ceps);
    }

    /* multiplies cartesian equatorial coordinates with previously
     * calculated nutation matrix. also corrects speed.
     */
    void swi_nutate(double xx[], int offs, int iflag, boolean backward) {
        int i;
        double x[]=new double[6], xv[]=new double[6];
        for (i = 0; i <= 2; i++) {
            if (backward) {
                x[i] = xx[0+offs] * swed.nut.matrix[i][0] +
                    xx[1+offs] * swed.nut.matrix[i][1] +
                    xx[2+offs] * swed.nut.matrix[i][2];
            } else {
                x[i] = xx[0+offs] * swed.nut.matrix[0][i] +
                    xx[1+offs] * swed.nut.matrix[1][i] +
                    xx[2+offs] * swed.nut.matrix[2][i];
            }
        }
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            /* correct speed:
             * first correct rotation */
            for (i = 0; i <= 2; i++) {
                if (backward) {
                    x[i+3] = xx[3+offs] * swed.nut.matrix[i][0] +
                        xx[4+offs] * swed.nut.matrix[i][1] +
                        xx[5+offs] * swed.nut.matrix[i][2];
                } else {
                    x[i+3] = xx[3+offs] * swed.nut.matrix[0][i] +
                        xx[4+offs] * swed.nut.matrix[1][i] +
                        xx[5+offs] * swed.nut.matrix[2][i];
                }
            }
            /* then apparent motion due to change of nutation during day.
             * this makes a difference of 0.01" */
            for (i = 0; i <= 2; i++) {
                if (backward) {
                    xv[i] = xx[0+offs] * swed.nutv.matrix[i][0] +
                        xx[1+offs] * swed.nutv.matrix[i][1] +
                        xx[2+offs] * swed.nutv.matrix[i][2];
                } else {
                    xv[i] = xx[0+offs] * swed.nutv.matrix[0][i] +
                        xx[1+offs] * swed.nutv.matrix[1][i] +
                        xx[2+offs] * swed.nutv.matrix[2][i];
                }
                /* new speed */
                xx[3+i+offs] = x[3+i] + (x[i] - xv[i]) / SwephData.NUT_SPEED_INTV;
            }
        }
        /* new position */
        for (i = 0; i <= 2; i++) {
            xx[i+offs] = x[i];
        }
    }

    /* computes 'annual' aberration
     * xx           planet's position accounted for light-time
     *              and gravitational light deflection
     * xe           earth's position and speed
     */
    void swi_aberr_light(double xx[], double xe[], int iflag) {
        swi_aberr_light(xx, 0, xe, iflag);
    }
    void swi_aberr_light(double xx[], int xxOffs, double xe[], int iflag) {
        int i;
        double xxs[]=new double[6], v[]=new double[6], u[]=new double[6], ru;
        double xx2[]=new double[6], dx1, dx2;
        double b_1, f1, f2;
        double v2;
        double intv = SwephData.PLAN_SPEED_INTV;
        for (i = 0; i <= 5; i++) {
            u[i] = xxs[i] = xx[i+xxOffs];
        }
        ru = Math.sqrt(sl.square_sum(u));
        for (i = 0; i <= 2; i++) {
            v[i] = xe[i+3] / 24.0 / 3600.0 / SwephData.CLIGHT * SweConst.AUNIT;
        }
        v2 = sl.square_sum(v);
        b_1 = Math.sqrt(1 - v2);
        f1 = dot_prod(u, v) / ru;
        f2 = 1.0 + f1 / (1.0 + b_1);
        for (i = 0; i <= 2; i++) {
            xx[i+xxOffs] = (b_1*xx[i+xxOffs] + f2*ru*v[i]) / (1.0 + f1);
        }
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            /* correction of speed
             * the influence of aberration on apparent velocity can
             * reach 0.4"/day
             */
            for (i = 0; i <= 2; i++) {
                u[i] = xxs[i] - intv * xxs[i+3];
            }
            ru = Math.sqrt(sl.square_sum(u));
            f1 = dot_prod(u, v) / ru;
            f2 = 1.0 + f1 / (1.0 + b_1);
            for (i = 0; i <= 2; i++) {
                xx2[i] = (b_1*u[i] + f2*ru*v[i]) / (1.0 + f1);
            }
            for (i = 0; i <= 2; i++) {
                dx1 = xx[i+xxOffs] - xxs[i];
                dx2 = xx2[i] - u[i];
                dx1 -= dx2;
                xx[i+3+xxOffs] += dx1 / intv;
            }
        }
    }

    /* computes relativistic light deflection by the sun
     * ipli         sweph internal planet number
     * xx           planet's position accounted for light-time
     * dt           dt of light-time
     */
    void swi_deflect_light(double xx[], int offs, double dt, int iflag) {
        int i;
        double xx2[]=new double[6];
        double u[]=new double[6], e[]=new double[6], q[]=new double[6];
        double ru, re, rq, uq, ue, qe, g1, g2;
        double xx3[]=new double[6], dx1, dx2, dtsp;
        double xsun[]=new double[6], xearth[]=new double[6];
        double sina, sin_sunr, meff_fact;
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        int iephe = pedp.iephe;
        for (i = 0; i <= 5; i++) {
            xearth[i] = pedp.x[i];
        }
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            for (i = 0; i <= 5; i++) {
                xearth[i] += swed.topd.xobs[i];
            }
        }
        /* U = planetbary(t-tau) - earthbary(t) = planetgeo */
        for (i = 0; i <= 2; i++) {
            u[i] = xx[i+offs];
        }
        /* Eh = earthbary(t) - sunbary(t) = earthhel */
        if (iephe == SweConst.SEFLG_JPLEPH || iephe == SweConst.SEFLG_SWIEPH) {
            for (i = 0; i <= 2; i++) {
                e[i] = xearth[i] - psdp.x[i];
            }
        } else {
            for (i = 0; i <= 2; i++) {
                e[i] = xearth[i];
            }
        }
        /* Q = planetbary(t-tau) - sunbary(t-tau) = 'planethel' */
        /* first compute sunbary(t-tau) for */
        if (iephe == SweConst.SEFLG_JPLEPH || iephe == SweConst.SEFLG_SWIEPH) {
            for (i = 0; i <= 2; i++) {
                /* this is sufficient precision */
                xsun[i] = psdp.x[i] - dt * psdp.x[i+3];
            }
            for (i = 3; i <= 5; i++) {
                xsun[i] = psdp.x[i];
            }
        } else {
            for (i = 0; i <= 5; i++) {
                xsun[i] = psdp.x[i];
            }
        }
        for (i = 0; i <= 2; i++) {
            q[i] = xx[i+offs] + xearth[i] - xsun[i];
        }
        ru = Math.sqrt(sl.square_sum(u));
        rq = Math.sqrt(sl.square_sum(q));
        re = Math.sqrt(sl.square_sum(e));
        for (i = 0; i <= 2; i++) {
            u[i] /= ru;
            q[i] /= rq;
            e[i] /= re;
        }
        uq = dot_prod(u,q);
        ue = dot_prod(u,e);
        qe = dot_prod(q,e);
        /* When a planet approaches the center of the sun in superior
         * conjunction, the formula for the deflection angle as given
         * in Expl. Suppl. p. 136 cannot be used. The deflection seems
         * to increase rapidly towards infinity. The reason is that the
         * formula considers the sun as a point mass. AA recommends to
         * set deflection = 0 in such a case.
         * However, to get a continous motion, we modify the formula
         * for a non-point-mass, taking into account the mass distribution
         * within the sun. For more info, s. meff().
         */
        sina = Math.sqrt(1 - ue * ue);      /* sin(angle) between sun and planet */
        sin_sunr = SwephData.SUN_RADIUS / re;   /* sine of sun radius (= sun radius) */
        if (sina < sin_sunr) {
            meff_fact = meff(sina / sin_sunr);
        } else {
            meff_fact = 1;
        }
        g1 = 2.0 * SwephData.HELGRAVCONST * meff_fact / SwephData.CLIGHT / SwephData.CLIGHT / SweConst.AUNIT / re;
        g2 = 1.0 + qe;
        /* compute deflected position */
        for (i = 0; i <= 2; i++) {
            xx2[i] = ru * (u[i] + g1/g2 * (uq * e[i] - ue * q[i]));
        }
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            /* correction of speed
             * influence of light deflection on a planet's apparent speed:
             * for an outer planet at the solar limb with
             * |v(planet) - v(sun)| = 1 degree, this makes a difference of 7"/day.
             * if the planet is within the solar disc, the difference may increase
             * to 30" or more.
             * e.g. mercury at j2434871.45:
             *  distance from sun               45"
             *  1. speed without deflection     2\xb310'10".4034
             *    2. speed with deflection        2\xb310'42".8460 (-speed flag)
             *    3. speed with deflection        2\xb310'43".4824 (< 3 positions/
             *                                                     -speed3 flag)
             * 3. is not very precise. Smaller dt would give result closer to 2.,
             * but will probably never be as good as 2, unless long doubles are
             * used. (try also j2434871.46!!)
             * however, in such a case speed changes rapidly. before being
             * passed by the sun, the planet accelerates, and after the sun
             * has passed it slows down. some time later it regains 'normal'
             * speed.
             * to compute speed, we do the same calculation as above with
             * slightly different u, e, q, and find out the difference in
             * deflection.
             */
            dtsp = -SwephData.DEFL_SPEED_INTV;
            /* U = planetbary(t-tau) - earthbary(t) = planetgeo */
            for (i = 0; i <= 2; i++) {
                u[i] = xx[i+offs] - dtsp * xx[i+3+offs];
            }
            /* Eh = earthbary(t) - sunbary(t) = earthhel */
            if (iephe == SweConst.SEFLG_JPLEPH || iephe == SweConst.SEFLG_SWIEPH) {
                for (i = 0; i <= 2; i++) {
                    e[i] = xearth[i] - psdp.x[i] - dtsp * (xearth[i+3] - psdp.x[i+3]);
                }
            } else {
                for (i = 0; i <= 2; i++) {
                    e[i] = xearth[i] - dtsp * xearth[i+3];
                }
            }
            /* Q = planetbary(t-tau) - sunbary(t-tau) = 'planethel' */
            for (i = 0; i <= 2; i++) {
                q[i] = u[i] + xearth[i] - xsun[i] - dtsp * (xearth[i+3] - xsun[i+3]);
            }
            ru = Math.sqrt(sl.square_sum(u));
            rq = Math.sqrt(sl.square_sum(q));
            re = Math.sqrt(sl.square_sum(e));
            for (i = 0; i <= 2; i++) {
                u[i] /= ru;
                q[i] /= rq;
                e[i] /= re;
            }
            uq = dot_prod(u,q);
            ue = dot_prod(u,e);
            qe = dot_prod(q,e);
            sina = Math.sqrt(1 - ue * ue);    /* sin(angle) between sun and planet */
            sin_sunr = SwephData.SUN_RADIUS / re; /* sine of sun radius (= sun radius) */
            if (sina < sin_sunr) {
                meff_fact = meff(sina / sin_sunr);
            } else {
                meff_fact = 1;
            }
            g1 = 2.0 * SwephData.HELGRAVCONST * meff_fact / SwephData.CLIGHT /
                SwephData.CLIGHT / SweConst.AUNIT / re;
            g2 = 1.0 + qe;
            for (i = 0; i <= 2; i++) {
                xx3[i] = ru * (u[i] + g1/g2 * (uq * e[i] - ue * q[i]));
            }
            for (i = 0; i <= 2; i++) {
                dx1 = xx2[i] - xx[i+offs];
                dx2 = xx3[i] - u[i] * ru;
                dx1 -= dx2;
                xx[i+3+offs] += dx1 / dtsp;
            }
        } /* endif speed */
        /* deflected position */
        for (i = 0; i <= 2; i++) {
            xx[i+offs] = xx2[i];
        }
    }

    /* converts the sun from barycentric to geocentric,
     *          the earth from barycentric to heliocentric
     * computes
     * apparent position,
     * precession, and nutation
     * according to flags
     * iflag        flags
     * serr         error string
     */
    int app_pos_etc_sun(int iflag, StringBuffer serr) {
        int i, j, niter, retc = SweConst.OK;
        int flg1, flg2;
        double xx[]=new double[6], xxsv[]=new double[6], dx[]=new double[3], dt, t;
        double xearth[]=new double[6], xsun[]=new double[6], xobs[]=new double[6];
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        Epsilon oe = swed.oec2000;
        /* if the same conversions have already been done for the same
         * date, then return */
        flg1 = iflag & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        flg2 = pedp.xflgs & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        if (flg1 == flg2) {
            pedp.xflgs = iflag;
            pedp.iephe = iflag & SweConst.SEFLG_EPHMASK;
            return SweConst.OK;
        }
        
        /* if topocentric position is wanted  */
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            if (swed.topd.teval != pedp.teval
                || swed.topd.teval == 0) {
                if (swi_get_observer(pedp.teval, iflag, SwephData.DO_SAVE, xobs, serr)
                    != SweConst.OK) {
                    return SweConst.ERR;
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = swed.topd.xobs[i];
                }
            }
            /* barycentric position of observer */
            for (i = 0; i <= 5; i++) {
                xobs[i] = xobs[i] + pedp.x[i];
            }
        } else {
            /* barycentric position of geocenter */
            for (i = 0; i <= 5; i++) {
                xobs[i] = pedp.x[i];
            }
        }
        
        if (pedp.iephe == SweConst.SEFLG_MOSEPH ||
            (iflag & SweConst.SEFLG_BARYCTR)!=0) {
            for (i = 0; i <= 5; i++) {
                xx[i] = xobs[i];
            }
        } else {
            for (i = 0; i <= 5; i++) {
                xx[i] = xobs[i] - psdp.x[i];
            }
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0) {
            /* number of iterations - 1
             * the following if() does the following:
             * with jpl and swiss ephemeris:
             *   with geocentric computation of sun:
             *     light-time correction of barycentric sun position.
             *   with heliocentric or barycentric computation of earth:
             *     light-time correction of barycentric earth position.
             * with moshier ephemeris (heliocentric!!!):
             *   with geocentric computation of sun:
             *     nothing! (aberration will be done later)
             *   with heliocentric or barycentric computation of earth:
             *     light-time correction of heliocentric earth position.
             */
            if (pedp.iephe == SweConst.SEFLG_JPLEPH ||
                pedp.iephe == SweConst.SEFLG_SWIEPH ||
                (iflag & SweConst.SEFLG_HELCTR)!=0 ||
                (iflag & SweConst.SEFLG_BARYCTR)!=0) {
                for (i = 0; i <= 5; i++) {
                    xearth[i] = xobs[i];
                    if (pedp.iephe == SweConst.SEFLG_MOSEPH) {
                        xsun[i] = 0;
                    } else {
                        xsun[i] = psdp.x[i];
                    }
                }
                niter = 1;        /* # of iterations */
                for (j = 0; j <= niter; j++) {
                    /* distance earth-sun */
                    for (i = 0; i <= 2; i++) {
                        dx[i] = xearth[i];
                        if ((iflag & SweConst.SEFLG_BARYCTR)==0) {
                            dx[i] -= xsun[i];
                        }
                    }
                    /* new t */
                    dt = Math.sqrt(sl.square_sum(dx)) * SweConst.AUNIT / SwephData.CLIGHT /
                        86400.0;
                    t = pedp.teval - dt;
                    /* new position */
                    switch(pedp.iephe) {
                        /* if geocentric sun, new sun at t'
                         * if heliocentric or barycentric earth, new earth at t' */
                        case SweConst.SEFLG_JPLEPH:
                            if ((iflag & SweConst.SEFLG_HELCTR)!=0 ||
                                (iflag & SweConst.SEFLG_BARYCTR)!=0) {
                                retc = sj.swi_pleph(t, SwephJPL.J_EARTH, SwephJPL.J_SBARY, xearth, serr);
                            } else {
                                retc = sj.swi_pleph(t, SwephJPL.J_SUN, SwephJPL.J_SBARY, xsun, serr);
                            }
                            if (retc != SweConst.OK) {
                                sj.swi_close_jpl_file();
                                swed.jpl_file_is_open = false;
                                return(retc);
                            }
                            break;
                        case SweConst.SEFLG_SWIEPH:
                            /*
                              retc = sweph(t, SEI_SUN, SEI_FILE_PLANET, iflag, NULL, NO_SAVE, xearth, serr);
                            */
                            if ((iflag & SweConst.SEFLG_HELCTR)!=0 ||
                                (iflag & SweConst.SEFLG_BARYCTR)!=0) {
                                retc = sweplan(t, SwephData.SEI_EARTH,
                                               SwephData.SEI_FILE_PLANET, iflag,
                                               SwephData.NO_SAVE, xearth, null, xsun, null,
                                               serr);
                            } else {
                                retc = sweph(t, SwephData.SEI_SUNBARY,
                                             SwephData.SEI_FILE_PLANET, iflag, null,
                                             SwephData.NO_SAVE, xsun, serr);
                            }
                            break;
                        case SweConst.SEFLG_MOSEPH:
                            if ((iflag & SweConst.SEFLG_HELCTR)!=0 ||
                                (iflag & SweConst.SEFLG_BARYCTR)!=0) {
                                retc = smosh.swi_moshplan(t, SwephData.SEI_EARTH,
                                                          SwephData.NO_SAVE, xearth, xearth,
                                                          serr);
                            }
                            /* with moshier there is no barycentric sun */
                            break;
                        default:
                            retc = SweConst.ERR;
                            break;
                    }
                    if (retc != SweConst.OK) {
                        return(retc);
                    }
                }
                /* apparent heliocentric earth */
                for (i = 0; i <= 5; i++) {
                    xx[i] = xearth[i];
                    if ((iflag & SweConst.SEFLG_BARYCTR)==0) {
                        xx[i] -= xsun[i];
                    }
                }
            }
        }
        if ((iflag & SweConst.SEFLG_SPEED)==0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        
        if ((iflag & SweConst.SEFLG_HELCTR)==0 &&
            (iflag & SweConst.SEFLG_BARYCTR)==0) {
            for (i = 0; i <= 5; i++) {
                xx[i] = -xx[i];
            }
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0 &&
            (iflag & SweConst.SEFLG_NOABERR)==0) {
            /* SEFLG_NOABERR is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
            swi_aberr_light(xx, xobs, iflag);
        }
        if ((iflag & SweConst.SEFLG_SPEED) == 0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        /* ICRS to J2000 */
        if ((iflag & SweConst.SEFLG_ICRS) == 0 && swed.jpldenum >= 403) {
            sl.swi_bias(xx, iflag, false);
        }
        /* save J2000 coordinates; required for sidereal positions */
        for (i = 0; i <= 5; i++) {
            xxsv[i] = xx[i];
        }
        
        if ((iflag & SweConst.SEFLG_J2000)==0) {
            sl.swi_precess(xx, pedp.teval, SwephData.J2000_TO_J);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(xx, pedp.teval, SwephData.J2000_TO_J);
            }
            oe = swed.oec;
        } else
            oe = swed.oec2000;
        return app_pos_rest(pedp, iflag, xx, xxsv, oe, serr);
    }

    /* transforms the position of the moon:
     * heliocentric position
     * barycentric position
     * astrometric position
     * apparent position
     * precession and nutation
     *
     * note:
     * for apparent positions, we consider the earth-moon
     * system as independant.
     * for astrometric positions (SEFLG_NOABERR), we
     * consider the motions of the earth and the moon
     * related to the solar system barycenter.
     */
    int app_pos_etc_moon(int iflag, StringBuffer serr) {
        int i;
        int flg1, flg2;
        double xx[]=new double[6], xxsv[]=new double[6], xobs[]=new double[6],
            xxm[]=new double[6], xs[]=new double[6], xe[]=new double[6],
            xobs2[]=new double[6], dt;
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        PlanData pdp = swed.pldat[SwephData.SEI_MOON];
        Epsilon oe = swed.oec;
        double t;
        int retc;
        /* if the same conversions have already been done for the same
         * date, then return */
        flg1 = iflag & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        flg2 = pdp.xflgs & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        if (flg1 == flg2) {
            pdp.xflgs = iflag;
            pdp.iephe = (iflag & SweConst.SEFLG_EPHMASK);
            return SweConst.OK;
        }
        /* the conversions will be done with xx[]. */
        for (i = 0; i <= 5; i++) {
            xx[i] = pdp.x[i];
            xxm[i] = xx[i];
        }
        
        for (i = 0; i <= 5; i++) {
            xx[i] += pedp.x[i];
        }
        
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            if (swed.topd.teval != pdp.teval
                || swed.topd.teval == 0) {
                if (swi_get_observer(pdp.teval, iflag, SwephData.DO_SAVE, xobs, null) !=
                    SweConst.OK) {
                    return SweConst.ERR;
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = swed.topd.xobs[i];
                }
            }
            for (i = 0; i <= 5; i++) {
                xxm[i] -= xobs[i];
            }
            for (i = 0; i <= 5; i++) {
                xobs[i] += pedp.x[i];
            }
        } else if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
            for (i = 0; i <= 5; i++) {
                xobs[i] = 0;
            }
            for (i = 0; i <= 5; i++) {
                xxm[i] += pedp.x[i];
            }
        } else if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
            for (i = 0; i <= 5; i++) {
                xobs[i] = psdp.x[i];
            }
            for (i = 0; i <= 5; i++) {
                xxm[i] += pedp.x[i] - psdp.x[i];
            }
        } else {
            for (i = 0; i <= 5; i++) {
                xobs[i] = pedp.x[i];
            }
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS) == 0) {
            dt = Math.sqrt(sl.square_sum(xxm)) * SweConst.AUNIT /
                SwephData.CLIGHT / 86400.0;
            t = pdp.teval - dt;
            switch(pdp.iephe) {
                case SweConst.SEFLG_JPLEPH:
                    retc = sj.swi_pleph(t, SwephJPL.J_MOON, SwephJPL.J_EARTH, xx, serr);
                    if (retc == SweConst.OK) {
                        retc = sj.swi_pleph(t, SwephJPL.J_EARTH, SwephJPL.J_SBARY, xe, serr);
                    }
                    if (retc == SweConst.OK && (iflag & SweConst.SEFLG_HELCTR)!=0) {
                        retc = sj.swi_pleph(t, SwephJPL.J_SUN, SwephJPL.J_SBARY, xs, serr);
                    }
                    if (retc != SweConst.OK) {
                        sj.swi_close_jpl_file();
                        swed.jpl_file_is_open = false;
                    }
                    for (i = 0; i <= 5; i++) {
                        xx[i] += xe[i];
                    }
                    break;
                case SweConst.SEFLG_SWIEPH:
                    retc = sweplan(t, SwephData.SEI_MOON, SwephData.SEI_FILE_MOON, iflag, SwephData.NO_SAVE, xx, xe, xs, null, serr);
                    if (retc != SweConst.OK) {
                        return(retc);
                    }
                    for (i = 0; i <= 5; i++) {
                        xx[i] += xe[i];
                    }
                    break;
                case SweConst.SEFLG_MOSEPH:
                    /* this method results in an error of a milliarcsec in speed */
                    for (i = 0; i <= 2; i++) {
                        xx[i] -= dt * xx[i+3];
                        xe[i] = pedp.x[i] - dt * pedp.x[i+3];
                        xe[i+3] = pedp.x[i+3];
                        xs[i] = 0;
                        xs[i+3] = 0;
                    }
                    break;
            }
            if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
                if (swi_get_observer(t, iflag, SwephData.NO_SAVE, xobs2, null) !=
                    SweConst.OK) {
                    return SweConst.ERR;
                }
                for (i = 0; i <= 5; i++) {
                    xobs2[i] += xe[i];
                }
            } else if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
                for (i = 0; i <= 5; i++) {
                    xobs2[i] = 0;
                }
            } else if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
                for (i = 0; i <= 5; i++) {
                    xobs2[i] = xs[i];
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs2[i] = xe[i];
                }
            }
        }
        
        for (i = 0; i <= 5; i++) {
            xx[i] -= xobs[i];
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0 &&
            (iflag & SweConst.SEFLG_NOABERR)==0) {
            /* SEFLG_NOABERR is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
            swi_aberr_light(xx, xobs, iflag);
            /*
             * Apparent speed is also influenced by
             * the difference of speed of the earth between t and t-dt.
             * Neglecting this would lead to an error of several 0.1"
             */
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                for (i = 3; i <= 5; i++) {
                    xx[i] += xobs[i] - xobs2[i];
                }
            }
        }
        /* if !speedflag, speed = 0 */
        if ((iflag & SweConst.SEFLG_SPEED)==0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        /* ICRS to J2000 */
        if ((iflag & SweConst.SEFLG_ICRS) == 0 && swed.jpldenum >= 403) {
            sl.swi_bias(xx, iflag, false);
        }
        /* save J2000 coordinates; required for sidereal positions */
        for (i = 0; i <= 5; i++) {
            xxsv[i] = xx[i];
        }
        
        if ((iflag & SweConst.SEFLG_J2000) == 0) {
            sl.swi_precess(xx, pdp.teval, SwephData.J2000_TO_J);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(xx, pdp.teval, SwephData.J2000_TO_J);
            }
            oe = swed.oec;
        } else {
            oe = swed.oec2000;
        }
        return app_pos_rest(pdp, iflag, xx, xxsv, oe, serr);
    }

    /* transforms the position of the barycentric sun:
     * precession and nutation
     * according to flags
     * iflag        flags
     * serr         error string
     */
    int app_pos_etc_sbar(int iflag, StringBuffer serr) {
        int i;
        double xx[]=new double[6], xxsv[]=new double[6], dt;
        PlanData psdp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psbdp = swed.pldat[SwephData.SEI_SUNBARY];
        Epsilon oe = swed.oec;
        /* the conversions will be done with xx[]. */
        for (i = 0; i <= 5; i++) {
            xx[i] = psbdp.x[i];
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0) {
            dt = Math.sqrt(sl.square_sum(xx)) * SweConst.AUNIT / SwephData.CLIGHT / 86400.0;
            for (i = 0; i <= 2; i++) {
                xx[i] -= dt * xx[i+3];    /* apparent position */
            }
        }
        if ((iflag & SweConst.SEFLG_SPEED)==0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        /* ICRS to J2000 */
        if ((iflag & SweConst.SEFLG_ICRS) == 0 && swed.jpldenum >= 403) {
            sl.swi_bias(xx, iflag, false);
        }
        /* save J2000 coordinates; required for sidereal positions */
        for (i = 0; i <= 5; i++) {
            xxsv[i] = xx[i];
        }
        
        if ((iflag & SweConst.SEFLG_J2000)==0) {
            sl.swi_precess(xx, psbdp.teval, SwephData.J2000_TO_J);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(xx, psbdp.teval, SwephData.J2000_TO_J);
            }
            oe = swed.oec;
        } else {
            oe = swed.oec2000;
        }
        return app_pos_rest(psdp, iflag, xx, xxsv, oe, serr);
    }

    /* transforms position of mean lunar node or apogee:
     * input is polar coordinates in mean ecliptic of date.
     * output is, according to iflag:
     * position accounted for light-time
     * position referred to J2000 (i.e. precession subtracted)
     * position with nutation
     * equatorial coordinates
     * cartesian coordinates
     * heliocentric position is not allowed ??????????????
     *         DAS WAERE ZIEMLICH AUFWENDIG. SONNE UND ERDE MUESSTEN
     *         SCHON VORHANDEN SEIN!
     * ipl          bodynumber (SE_MEAN_NODE or SE_MEAN_APOG)
     * iflag        flags
     * serr         error string
     */
    int app_pos_etc_mean(int ipl, int iflag, StringBuffer serr) {
        int i;
        int flg1, flg2;
        double xx[]=new double[6], xxsv[]=new double[6];
        PlanData pdp = swed.nddat[ipl];
        Epsilon oe;
        /* if the same conversions have already been done for the same
         * date, then return */
        flg1 = iflag & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        flg2 = pdp.xflgs & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        if (flg1 == flg2) {
            pdp.xflgs = iflag;
            pdp.iephe = iflag & SweConst.SEFLG_EPHMASK;
            return SweConst.OK;
        }
        for (i = 0; i <= 5; i++) {
            xx[i] = pdp.x[i];
        }
        /* cartesian equatorial coordinates */
        sl.swi_polcart_sp(xx, xx);
        sl.swi_coortrf2(xx, xx, -swed.oec.seps, swed.oec.ceps);
        sl.swi_coortrf2(xx, 3, xx, 3, -swed.oec.seps, swed.oec.ceps);
        if ((iflag & SweConst.SEFLG_SPEED)==0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        /* J2000 coordinates; required for sidereal positions */
        if (((iflag & SweConst.SEFLG_SIDEREAL)!=0
             && (swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0)
            || (swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
            for (i = 0; i <= 5; i++) {
                xxsv[i] = xx[i];
            }
            /* xxsv is not J2000 yet! */
            if (pdp.teval != SwephData.J2000) {
                sl.swi_precess(xxsv, pdp.teval, SwephData.J_TO_J2000);
                if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                    swi_precess_speed(xxsv, pdp.teval, SwephData.J_TO_J2000);
                }
            }
        }
        
        if ((iflag & SweConst.SEFLG_J2000)!=0) {
            sl.swi_precess(xx, pdp.teval, SwephData.J_TO_J2000);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(xx, pdp.teval, SwephData.J_TO_J2000);
            }
            oe = swed.oec2000;
        } else {
            oe = swed.oec;
        }
        return app_pos_rest(pdp, iflag, xx, xxsv, oe, serr);
    }

    /* SWISSEPH
     * adds reference orbit to chebyshew series (if SEI_FLG_ELLIPSE),
     * rotates series to mean equinox of J2000
     *
     * ipli         planet number
     */
    void rot_back(int ipli) {
        int i;
        double t, tdiff;
        double qav, pav, dn;
        double omtild, com, som, cosih2;
        double x[][]=new double[SwephData.MAXORD+1][3];
        double uix[]=new double[3], uiy[]=new double[3], uiz[]=new double[3];
        double xrot, yrot, zrot;
        double chcfx[];
        double refepx[];
        double seps2000 = swed.oec2000.seps;
        double ceps2000 = swed.oec2000.ceps;
        PlanData pdp = swed.pldat[ipli];
        int nco = pdp.ncoe;
        int chcfyOffs;
        int chcfzOffs;
        int refepyOffs;
        t = pdp.tseg0 + pdp.dseg / 2;
        chcfx = pdp.segp;
        chcfyOffs = nco;
        chcfzOffs = 2 * nco;
        refepx = pdp.refep;
        refepyOffs = nco;
        tdiff= (t - pdp.telem) / 365250.0;
        if (ipli == SwephData.SEI_MOON) {
            dn = pdp.prot + tdiff * pdp.dprot;
            i = (int) (dn / SwephData.TWOPI);
            dn -= i * SwephData.TWOPI;
            qav = (pdp.qrot + tdiff * pdp.dqrot) * Math.cos(dn);
            pav = (pdp.qrot + tdiff * pdp.dqrot) * Math.sin(dn);
        } else {
            qav = pdp.qrot + tdiff * pdp.dqrot;
            pav = pdp.prot + tdiff * pdp.dprot;
        }
        /*calculate cosine and sine of average perihelion longitude. */
        for (i = 0; i < nco; i++) {
            x[i][0] = chcfx[i];
            x[i][1] = chcfx[i+chcfyOffs];
            x[i][2] = chcfx[i+chcfzOffs];
        }
        if ((pdp.iflg & SwephData.SEI_FLG_ELLIPSE)!=0) {
            omtild = pdp.peri + tdiff * pdp.dperi;
            i = (int) (omtild / SwephData.TWOPI);
            omtild -= i * SwephData.TWOPI;
            com = Math.cos(omtild);
            som = Math.sin(omtild);
            /*add reference orbit.  */
            for (i = 0; i < nco; i++) {
                x[i][0] = chcfx[i] + com * refepx[i] - som * refepx[i+refepyOffs];
                x[i][1] = chcfx[i+chcfyOffs] + com * refepx[i+refepyOffs] + som * refepx[i];
            }
        }
        /* construct right handed orthonormal system with first axis along
           origin of longitudes and third axis along angular momentum
           this uses the standard formulas for equinoctal variables
           (see papers by broucke and by cefola).      */
        cosih2 = 1.0 / (1.0 + qav * qav + pav * pav);
        /*     calculate orbit pole. */
        uiz[0] = 2.0 * pav * cosih2;
        uiz[1] = -2.0 * qav * cosih2;
        uiz[2] = (1.0 - qav * qav - pav * pav) * cosih2;
        /*     calculate origin of longitudes vector. */
        uix[0] = (1.0 + qav * qav - pav * pav) * cosih2;
        uix[1] = 2.0 * qav * pav * cosih2;
        uix[2] = -2.0 * pav * cosih2;
        /*     calculate vector in orbital plane orthogonal to origin of
               longitudes.                                               */
        uiy[0] =2.0 * qav * pav * cosih2;
        uiy[1] =(1.0 - qav * qav + pav * pav) * cosih2;
        uiy[2] =2.0 * qav * cosih2;
        /*     rotate to actual orientation in space.         */
        for (i = 0; i < nco; i++) {
            xrot = x[i][0] * uix[0] + x[i][1] * uiy[0] + x[i][2] * uiz[0];
            yrot = x[i][0] * uix[1] + x[i][1] * uiy[1] + x[i][2] * uiz[1];
            zrot = x[i][0] * uix[2] + x[i][1] * uiy[2] + x[i][2] * uiz[2];
            if (Math.abs(xrot) + Math.abs(yrot) + Math.abs(zrot) >= 1e-14) {
                pdp.neval = i;
            }
            x[i][0] = xrot;
            x[i][1] = yrot;
            x[i][2] = zrot;
            if (ipli == SwephData.SEI_MOON) {
                /* rotate to j2000 equator */
                x[i][1] = ceps2000 * yrot - seps2000 * zrot;
                x[i][2] = seps2000 * yrot + ceps2000 * zrot;
            }
        }
        for (i = 0; i < nco; i++) {
            chcfx[i] = x[i][0];
            chcfx[i+chcfyOffs] = x[i][1];
            chcfx[i+chcfzOffs] = x[i][2];
        }
    }

    /* Adjust position from Earth-Moon barycenter to Earth
     *
     * xemb = hel./bar. position or velocity vectors of emb (input)
     *                                                  earth (output)
     * xmoon= geocentric position or velocity vector of moon
     */
    void embofs(double xemb[], int eOffs, double xmoon[], int mOffs) {
        int i;
        for (i = 0; i <= 2; i++) {
            xemb[i+eOffs] -= xmoon[i+mOffs] / (SwephData.EARTH_MOON_MRAT + 1.0);
        }
    }

    /* calculates the nutation matrix
     * nu           pointer to nutation data structure
     * oe           pointer to epsilon data structure
     */
    void nut_matrix(Nut nu, Epsilon oe) {
        double psi, eps;
        double sinpsi, cospsi, sineps, coseps, sineps0, coseps0;
        psi = nu.nutlo[0];
        eps = oe.eps + nu.nutlo[1];
        sinpsi = Math.sin(psi);
        cospsi = Math.cos(psi);
        sineps0 = oe.seps;
        coseps0 = oe.ceps;
        sineps = Math.sin(eps);
        coseps = Math.cos(eps);
        nu.matrix[0][0] = cospsi;
        nu.matrix[0][1] = sinpsi * coseps;
        nu.matrix[0][2] = sinpsi * sineps;
        nu.matrix[1][0] = -sinpsi * coseps0;
        nu.matrix[1][1] = cospsi * coseps * coseps0 + sineps * sineps0;
        nu.matrix[1][2] = cospsi * sineps * coseps0 - coseps * sineps0;
        nu.matrix[2][0] = -sinpsi * sineps0;
        nu.matrix[2][1] = cospsi * coseps * sineps0 - sineps * coseps0;
        nu.matrix[2][2] = cospsi * sineps * sineps0 + coseps * coseps0;
    }

    /* lunar osculating elements, i.e.
     * osculating node ('true' node) and
     * osculating apogee ('black moon', 'lilith').
     * tjd          julian day
     * ipl          body number, i.e. SEI_TRUE_NODE or SEI_OSCU_APOG
     * iflag        flags (which ephemeris, nutation, etc.)
     * serr         error string
     *
     * definitions and remarks:
     * the osculating node and the osculating apogee are defined
     * as the orbital elements of the momentary lunar orbit.
     * their advantage is that when the moon crosses the ecliptic,
     * it is really at the osculating node, and when it passes
     * its greatest distance from earth it is really at the
     * osculating apogee. with the mean elements this is not
     * the case. (some define the apogee as the second focus of
     * the lunar ellipse. but, as seen from the geocenter, both
     * points are in the same direction.)
     * problems:
     * the osculating apogee is given in the 'New International
     * Ephemerides' (Editions St. Michel) as the 'True Lilith'.
     * however, this name is misleading. this point is based on
     * the idea that the lunar orbit can be approximated by an
     * ellipse.
     * arguments against this:
     * 1. this procedure considers celestial motions as two body
     *    problems. this is quite good for planets, but not for
     *    the moon. the strong gravitational attraction of the sun
     *    destroys the idea of an ellipse.
     * 2. the NIE 'True Lilith' has strong oscillations around the
     *    mean one with an amplitude of about 30 degrees. however,
     *    when the moon is in apogee, its distance from the mean
     *    apogee never exceeds 5 degrees.
     * besides, the computation of NIE is INACCURATE. the mistake
     * reaches 20 arc minutes.
     * According to Santoni, the point was calculated using 'les 58
     * premiers termes correctifs au Perigee moyen' published by
     * Chapront and Chapront-Touze. And he adds: "Nous constatons
     * que meme en utilisant ces 58 termes CORRECTIFS, l'erreur peut
     * atteindre 0,5d!" (p. 13) We avoid this error, computing the
     * orbital elements directly from the position and the speed vector.
     *
     * how about the node? it is less problematic, because we
     * we needn't derive it from an orbital ellipse. we can say:
     * the axis of the osculating nodes is the intersection line of
     * the actual orbital plane of the moon and the plane of the
     * ecliptic. or: the osculating nodes are the intersections of
     * the two great circles representing the momentary apparent
     * orbit of the moon and the ecliptic. in this way they make
     * some sense. then, the nodes are really an axis, and they
     * have no geocentric distance. however, in this routine
     * we give a distance derived from the osculating ellipse.
     * the node could also be defined as the intersection axis
     * of the lunar orbital plane and the solar orbital plane,
     * which is not precisely identical to the ecliptic. this
     * would make a difference of several arcseconds.
     *
     * is it possible to keep the idea of a continuously moving
     * apogee that is exact at the moment when the moon passes
     * its greatest distance from earth?
     * to achieve this, we would probably have to interpolate between
     * the actual apogees.
     * the nodes could also be computed by interpolation. the resulting
     * nodes would deviate from the so-called 'true node' by less than
     * 30 arc minutes.
     *
     * sidereal and j2000 true node are first computed for the ecliptic
     * of epoch and then precessed to ecliptic of t0(ayanamsa) or J2000.
     * there is another procedure that computes the node for the ecliptic
     * of t0(ayanamsa) or J2000. it is excluded by
     * #ifdef SID_TNODE_FROM_ECL_T0
     */
    private int lunar_osc_elem(double tjd, int ipl, int iflag, StringBuffer serr) {
        int i, j, istart;
        int ipli = SwephData.SEI_MOON;
        int epheflag = SweConst.SEFLG_DEFAULTEPH;
        int retc = SweConst.ERR;
        int flg1, flg2;
        PlanData ndp, ndnp, ndap;
        Epsilon oe;
        double speed_intv = SwephData.NODE_CALC_INTV;   /* to silence gcc warning */
        double a, b;
        double xpos[][]=new double[3][6], xx[][]=new double[3][6],
            xxa[][]=new double[3][6];
        double xp[];
        double xnorm[]=new double[6], r[]=new double[6];
        double rxy, rxyz, t, dt, fac, sgn;
        double sinnode, cosnode, sinincl, cosincl, sinu, cosu, sinE, cosE;
        double uu, ny, sema, ecce, Gmsm, c2, v2, pp;
        int speedf1, speedf2;
        oe = swed.oec;
        ndp = swed.nddat[ipl];
        /* if elements have already been computed for this date, return
         * if speed flag has been turned on, recompute */
        flg1 = iflag & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        flg2 = ndp.xflgs & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        speedf1 = ndp.xflgs & SweConst.SEFLG_SPEED;
        speedf2 = iflag & SweConst.SEFLG_SPEED;
        if (tjd == ndp.teval
            && tjd != 0
            && flg1 == flg2
            && ((speedf2==0) || (speedf1!=0))) {
            ndp.xflgs = iflag;
            ndp.iephe = iflag & SweConst.SEFLG_EPHMASK;
            return SweConst.OK;
        }
        /* the geocentric position vector and the speed vector of the
         * moon make up the lunar orbital plane. the position vector
         * of the node is along the intersection line of the orbital
         * plane and the plane of the ecliptic.
         * to calculate the osculating node, we need one lunar position
         * with speed.
         * to calculate the speed of the osculating node, we need
         * three lunar positions and the speed of each of them.
         * this is relatively cheap, if the jpl-moon or the swisseph
         * moon is used. with the moshier moon this is much more
         * expensive, because then we need 9 lunar positions for
         * three speeds. but one position and speed can normally
         * be taken from swed.pldat[moon], which corresponds to
         * three moshier moon calculations.
         * the same is also true for the osculating apogee: we need
         * three lunar positions and speeds.
         */
        
        if ((iflag & SweConst.SEFLG_MOSEPH)!=0) {
            epheflag = SweConst.SEFLG_MOSEPH;
        } else if ((iflag & SweConst.SEFLG_SWIEPH)!=0) {
            epheflag = SweConst.SEFLG_SWIEPH;
        } else if ((iflag & SweConst.SEFLG_JPLEPH)!=0) {
            epheflag = SweConst.SEFLG_JPLEPH;
        }
        /* there may be a moon of wrong ephemeris in save area
         * force new computation: */
        swed.pldat[SwephData.SEI_MOON].teval = 0;
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            istart = 0;
        } else {
            istart = 2;
        }
        if (serr != null) {
            serr.setLength(0);
        }
        //  three_positions:
        do {
            switch(epheflag) {
                case SweConst.SEFLG_JPLEPH:
                    speed_intv = SwephData.NODE_CALC_INTV;
                    for (i = istart; i <= 2; i++) {
                        if (i == 0) {
                            t = tjd - speed_intv;
                        } else if (i == 1) {
                            t = tjd + speed_intv;
                        } else {
                            t = tjd;
                        }
                        xp = xpos[i];
                        retc = jplplan(t, ipli, iflag, SwephData.NO_SAVE, xp, null, null,
                                       serr);
                        /* read error or corrupt file */
                        if (retc == SweConst.ERR) {
                            return(SweConst.ERR);
                        }
                        /* light-time-corrected moon for apparent node
                         * this makes a difference of several milliarcseconds with
                         * the node and 0.1" with the apogee.
                         * the simple formual 'x[j] -= dt * speed' should not be
                         * used here. the error would be greater than the advantage
                         * of computation speed. */
                        if ((iflag & SweConst.SEFLG_TRUEPOS) == 0 && retc >= SweConst.OK) {
                            dt = Math.sqrt(sl.square_sum(xpos[i])) * SweConst.AUNIT /
                                SwephData.CLIGHT / 86400.0;
                            retc = jplplan(t-dt, ipli, iflag, SwephData.NO_SAVE, xpos[i],
                                           null, null, serr); 
                            /* read error or corrupt file */
                            if (retc == SweConst.ERR) {
                                return(SweConst.ERR);
                            }
                        }
                        /* jpl ephemeris not on disk, or date beyond ephemeris range */
                        if (retc == SwephData.NOT_AVAILABLE) {
                            iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_SWIEPH;
                            epheflag = SweConst.SEFLG_SWIEPH;
                            if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                                serr.append(" \ntrying Swiss Eph; ");
                            }
                            break;
                        } else if (retc == SwephData.BEYOND_EPH_LIMITS) {
                            if (tjd > SwephData.MOSHLUEPH_START &&
                                tjd < SwephData.MOSHLUEPH_END) {
                                iflag = (iflag & ~SweConst.SEFLG_JPLEPH) |
                                    SweConst.SEFLG_MOSEPH;
                                epheflag = SweConst.SEFLG_MOSEPH;
                                if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                                    serr.append(" \nusing Moshier Eph; ");
                                }
                                break;
                            } else
                                return SweConst.ERR;
                        }
                        /* precession and nutation etc. */
                        retc = swi_plan_for_osc_elem(iflag|SweConst.SEFLG_SPEED, t, xpos[i]); /* retc is always ok */

                    }
                    break;
                case SweConst.SEFLG_SWIEPH:
                    speed_intv = SwephData.NODE_CALC_INTV;
                    for (i = istart; i <= 2; i++) {
                        if (i == 0) {
                            t = tjd - speed_intv;
                        } else if (i == 1) {
                            t = tjd + speed_intv;
                        } else {
                            t = tjd;
                        }
                        retc = swemoon(t, iflag | SweConst.SEFLG_SPEED, SwephData.NO_SAVE,
                                       xpos[i], serr);
                        if (retc == SweConst.ERR) {
                            return(SweConst.ERR);
                        }
                        /* light-time-corrected moon for apparent node (~ 0.006") */
                        if ((iflag & SweConst.SEFLG_TRUEPOS) == 0 && retc >= SweConst.OK) {
                            dt = Math.sqrt(sl.square_sum(xpos[i])) * SweConst.AUNIT /
                                SwephData.CLIGHT / 86400.0;
                            retc = swemoon(t-dt, iflag | SweConst.SEFLG_SPEED,
                                           SwephData.NO_SAVE, xpos[i], serr);
                            if (retc == SweConst.ERR) {
                                return(SweConst.ERR);
                            }
                        }
                        if (retc == SwephData.NOT_AVAILABLE) {
                            if (tjd > SwephData.MOSHPLEPH_START &&
                                tjd < SwephData.MOSHPLEPH_END) {
                                iflag = (iflag & ~SweConst.SEFLG_SWIEPH) | SweConst.SEFLG_MOSEPH;
                                epheflag = SweConst.SEFLG_MOSEPH;
                                if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                                    serr.append(" \nusing Moshier eph.; ");
                                }
                                break;
                            } else
                                return SweConst.ERR;
                        }
                        /* precession and nutation etc. */
                        retc = swi_plan_for_osc_elem(iflag|SweConst.SEFLG_SPEED, t, xpos[i]); /* retc is always ok */
                    }
                    break;
                case SweConst.SEFLG_MOSEPH:
                    /* with moshier moon, we need a greater speed_intv, because here the
                     * node and apogee oscillate wildly within small intervals */
                    speed_intv = SwephData.NODE_CALC_INTV_MOSH;
                    for (i = istart; i <= 2; i++) {
                        if (i == 0) {
                            t = tjd - speed_intv;
                        } else if (i == 1) {
                            t = tjd + speed_intv;
                        } else {
                            t = tjd;
                        }
                        retc = sm.swi_moshmoon(t, SwephData.NO_SAVE, xpos[i], serr);
                        if (retc == SweConst.ERR) {
                            return(retc);
                        }
                        /* precession and nutation etc. */
                        retc = swi_plan_for_osc_elem(iflag|SweConst.SEFLG_SPEED, t, xpos[i]); /* retc is always ok */

                    }
                    break;
                default:
                    break;
            }
        } while (retc == SwephData.NOT_AVAILABLE || retc == SwephData.BEYOND_EPH_LIMITS);
        //    goto three_positions;
        
        /* node is always needed, even if apogee is wanted */
        ndnp = swed.nddat[SwephData.SEI_TRUE_NODE];
        /* three nodes */
        for (i = istart; i <= 2; i++) {
            if (Math.abs(xpos[i][5]) < 1e-15) {
                xpos[i][5] = 1e-15;
            }
            fac = xpos[i][2] / xpos[i][5];
            sgn = xpos[i][5] / Math.abs(xpos[i][5]);
            for (j = 0; j <= 2; j++) {
                xx[i][j] = (xpos[i][j] - fac * xpos[i][j+3]) * sgn;
            }
        }
        /* now we have the correct direction of the node, the
         * intersection of the lunar plane and the ecliptic plane.
         * the distance is the distance of the point where the tangent
         * of the lunar motion penetrates the ecliptic plane.
         * this can be very large, e.g. j2415080.37372.
         * below, a new distance will be derived from the osculating
         * ellipse.
         */
        /* save position and speed */
        for (i = 0; i <= 2; i++) {
            ndnp.x[i] = xx[2][i];
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                b = (xx[1][i] - xx[0][i]) / 2;
                a = (xx[1][i] + xx[0][i]) / 2 - xx[2][i];
                ndnp.x[i+3] = (2 * a + b) / speed_intv;
            } else
                ndnp.x[i+3] = 0;
            ndnp.teval = tjd;
            ndnp.iephe = epheflag;
        }
        
        ndap = swed.nddat[SwephData.SEI_OSCU_APOG];
        Gmsm = SwephData.GEOGCONST * (1 + 1 / SwephData.EARTH_MOON_MRAT) /
            SweConst.AUNIT/SweConst.AUNIT/SweConst.AUNIT*86400.0*86400.0;
        /* three apogees */
        for (i = istart; i <= 2; i++) {
            /* node */
            rxy =  Math.sqrt(xx[i][0] * xx[i][0] + xx[i][1] * xx[i][1]);
            cosnode = xx[i][0] / rxy;
            sinnode = xx[i][1] / rxy;
            /* inclination */
            sl.swi_cross_prod(xpos[i], 0, xpos[i], 3, xnorm, 0);
            rxy =  xnorm[0] * xnorm[0] + xnorm[1] * xnorm[1];
            c2 = (rxy + xnorm[2] * xnorm[2]);
            rxyz = Math.sqrt(c2);
            rxy = Math.sqrt(rxy);
            sinincl = rxy / rxyz;
            cosincl = Math.sqrt(1 - sinincl * sinincl);
            /* argument of latitude */
            cosu = xpos[i][0] * cosnode + xpos[i][1] * sinnode;
            sinu = xpos[i][2] / sinincl;
            uu = Math.atan2(sinu, cosu);
            /* semi-axis */
            rxyz = Math.sqrt(sl.square_sum(xpos[i]));
            v2 = sl.square_sum(xpos[i], 3);
            sema = 1 / (2 / rxyz - v2 / Gmsm);
            /* eccentricity */
            pp = c2 / Gmsm;
            ecce = Math.sqrt(1 - pp / sema);
            /* eccentric anomaly */
            cosE = 1 / ecce * (1 - rxyz / sema);
            sinE = 1 / ecce / Math.sqrt(sema * Gmsm) * dot_prod(xpos[i], xpos[i], 3);
            /* true anomaly */
            ny = 2 * Math.atan(Math.sqrt((1+ecce)/(1-ecce)) * sinE / (1 + cosE));
            /* distance of apogee from ascending node */
            xxa[i][0] = sl.swi_mod2PI(uu - ny + SwephData.PI);
            xxa[i][1] = 0;                      /* latitude */
            xxa[i][2] = sema * (1 + ecce);      /* distance */
            /* transformation to ecliptic coordinates */
            sl.swi_polcart(xxa[i], xxa[i]);
            sl.swi_coortrf2(xxa[i], xxa[i], -sinincl, cosincl);
            sl.swi_cartpol(xxa[i], xxa[i]);
            /* adding node, we get apogee in ecl. coord. */
            xxa[i][0] += Math.atan2(sinnode, cosnode);
            sl.swi_polcart(xxa[i], xxa[i]);
            /* new distance of node from orbital ellipse:
             * true anomaly of node: */
            ny = sl.swi_mod2PI(ny - uu);
            /* eccentric anomaly */
            cosE = Math.cos(2 * Math.atan(Math.tan(ny / 2) / Math.sqrt((1+ecce) / (1-ecce))));
            /* new distance */
            r[0] = sema * (1 - ecce * cosE);
            /* old node distance */
            r[1] = Math.sqrt(sl.square_sum(xx[i]));
            /* correct length of position vector */
            for (j = 0; j <= 2; j++) {
                xx[i][j] *= r[0] / r[1];
            }
        }
        /* save position and speed */
        for (i = 0; i <= 2; i++) {
            /* apogee */
            ndap.x[i] = xxa[2][i];
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                ndap.x[i+3] = (xxa[1][i] - xxa[0][i]) / speed_intv / 2;
            } else {
                ndap.x[i+3] = 0;
            }
            ndap.teval = tjd;
            ndap.iephe = epheflag;
            /* node */
            ndnp.x[i] = xx[2][i];
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                ndnp.x[i+3] = (xx[1][i] - xx[0][i]) / speed_intv / 2;
            } else {
                ndnp.x[i+3] = 0;
            }
        }
        
        double[] x=new double[6];
        for (j = 0; j <= 1; j++) {
            if (j == 0) {
                ndp = swed.nddat[SwephData.SEI_TRUE_NODE];
            } else {
                ndp = swed.nddat[SwephData.SEI_OSCU_APOG];
            }
            //  memset((void *) ndp.xreturn, 0, 24 * sizeof(double));
            for (int z=0; z<ndp.xreturn.length; z++) { ndp.xreturn[z]=0.0; }
            /* cartesian ecliptic */
            for (i = 0; i <= 5; i++) {
                ndp.xreturn[6+i] = ndp.x[i];
            }
            /* polar ecliptic */
            sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
            /* cartesian equatorial */
            sl.swi_coortrf2(ndp.xreturn, 6, ndp.xreturn, 18, -oe.seps, oe.ceps);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                sl.swi_coortrf2(ndp.xreturn, 9, ndp.xreturn, 21, -oe.seps, oe.ceps);
            }
            if ((iflag & SweConst.SEFLG_NONUT) == 0) {
                sl.swi_coortrf2(ndp.xreturn, 18, ndp.xreturn, 18, -swed.nut.snut,
                                swed.nut.cnut);
                if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                    sl.swi_coortrf2(ndp.xreturn, 21, ndp.xreturn, 21, -swed.nut.snut,
                                    swed.nut.cnut);
                }
            }
            /* polar equatorial */
            sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
            ndp.xflgs = iflag;
            ndp.iephe = iflag & SweConst.SEFLG_EPHMASK;
            if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
                /* node and apogee are referred to t;
                 * the ecliptic position must be transformed to t0 */
                /* rigorous algorithm */
                if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0
                    || (swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
                    for (i = 0; i <= 5; i++) {
                        x[i] = ndp.xreturn[18+i];
                    }
                    /* remove nutation */
                    if ((iflag & SweConst.SEFLG_NONUT)==0) {
                        swi_nutate(x, 0, iflag, true);
                    }
                    /* precess to J2000 */
                    sl.swi_precess(x, tjd, SwephData.J_TO_J2000);
                    if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                        swi_precess_speed(x, tjd, SwephData.J_TO_J2000);
                    }
                    if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0) {
                        swi_trop_ra2sid_lon(x, ndp.xreturn, 6, ndp.xreturn, 18, iflag,
                                            null);
                        /* project onto solar system equator */
                    } else if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
                        swi_trop_ra2sid_lon_sosy(x, ndp.xreturn, 6, ndp.xreturn, 18, iflag,
                                                 null);
                    }
                    /* to polar */
                    sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
                    sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
                    /* traditional algorithm;
                     * this is a bit clumsy, but allows us to keep the
                     * sidereal code together */
                } else {
                    sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
                    ndp.xreturn[0] -= swe_get_ayanamsa(ndp.teval) * SwissData.DEGTORAD;
                    sl.swi_polcart_sp(ndp.xreturn, 0, ndp.xreturn, 6);
                }
            } else if ((iflag & SweConst.SEFLG_J2000)!=0) {
                /* node and apogee are referred to t;
                 * the ecliptic position must be transformed to J2000 */
                for (i = 0; i <= 5; i++) {
                    x[i] = ndp.xreturn[18+i];
                }
                /* precess to J2000 */
                sl.swi_precess(x, tjd, SwephData.J_TO_J2000);
                if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                    swi_precess_speed(x, tjd, SwephData.J_TO_J2000);
                }
                for (i = 0; i <= 5; i++) {
                    ndp.xreturn[18+i] = x[i];
                }
                sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
                sl.swi_coortrf2(ndp.xreturn, 18, ndp.xreturn, 6, swed.oec2000.seps,
                                swed.oec2000.ceps);
                if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                    sl.swi_coortrf2(ndp.xreturn, 21, ndp.xreturn, 9, swed.oec2000.seps,
                                    swed.oec2000.ceps);
                }
                sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
            }
            
            /*if (!(iflag & SEFLG_RADIANS)) {*/
            for (i = 0; i < 2; i++) {
                ndp.xreturn[i] *= SwissData.RADTODEG;              /* ecliptic */
                ndp.xreturn[i+3] *= SwissData.RADTODEG;
                ndp.xreturn[i+12] *= SwissData.RADTODEG;   /* equator */
                ndp.xreturn[i+15] *= SwissData.RADTODEG;
            }
            ndp.xreturn[0] = sl.swe_degnorm(ndp.xreturn[0]);
            ndp.xreturn[12] = sl.swe_degnorm(ndp.xreturn[12]);
            /*}*/
        }
        return SweConst.OK;
    }

    /* lunar osculating elements, i.e.
     */ 
    private int intp_apsides(double tjd, int ipl, int iflag, StringBuffer serr) {
        int i;
        int flg1, flg2;
        PlanData ndp;
        Epsilon oe;
        Nut nut;
        double speed_intv = 0.1;
        double t, dt;
        double xpos[][] = new double[3][6], xx[] = new double[6], x[] = new double[6];
        int speedf1, speedf2;
        oe = swed.oec;
        nut = swed.nut;
        ndp = swed.nddat[ipl];
        /* if same calculation was done before, return
         * if speed flag has been turned on, recompute */
        flg1 = iflag & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        flg2 = ndp.xflgs & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        speedf1 = ndp.xflgs & SweConst.SEFLG_SPEED;
        speedf2 = iflag & SweConst.SEFLG_SPEED;
        if (tjd == ndp.teval 
            && tjd != 0 
            && flg1 == flg2
            && ((speedf2==0) || (speedf1!=0))) {
            ndp.xflgs = iflag;
            ndp.iephe = iflag & SweConst.SEFLG_MOSEPH;
            return SweConst.OK;
        }
        
        for (t = tjd - speed_intv, i = 0; i < 3; t += speed_intv, i++) {
            if ( ((iflag & SweConst.SEFLG_SPEED)==0) && i != 1) continue;
            sm.swi_intp_apsides(t, xpos[i], ipl);
        }
        
        for (i = 0; i < 3; i++) {
            xx[i] = xpos[1][i];
            xx[i+3] = 0;
        }
        if ((iflag & SweConst.SEFLG_SPEED) != 0) {
            xx[3] = sl.swe_difrad2n(xpos[2][0], xpos[0][0]) / speed_intv / 2.0;
            xx[4] = (xpos[2][1] - xpos[0][1]) / speed_intv / 2.0;
            xx[5] = (xpos[2][2] - xpos[0][2]) / speed_intv / 2.0;
        }
        // memset((void *) ndp.xreturn, 0, 24 * sizeof(double));
        for(int p=0;p<24;p++) { ndp.xreturn[p]=0.; }
        /* ecliptic polar to cartesian */
        sl.swi_polcart_sp(xx, xx);
        /* light-time */
        if ((iflag & SweConst.SEFLG_TRUEPOS) == 0) {
            dt = Math.sqrt(sl.square_sum(xx)) * SweConst.AUNIT / SwephData.CLIGHT / 86400.0;     
            for (i = 1; i < 3; i++)
                xx[i] -= dt * xx[i+3];
        }
        for (i = 0; i <= 5; i++) {
            ndp.xreturn[i+6] = xx[i];
        }
        /*printf("%.10f, %.10f, %.10f, %.10f\n", xx[0] /DEGTORAD, xx[1] / DEGTORAD, xx [2], xx[3] /DEGTORAD);*/
        /* equatorial cartesian */
        sl.swi_coortrf2(ndp.xreturn, 6, ndp.xreturn, 18, -oe.seps, oe.ceps);
        if ((iflag & SweConst.SEFLG_SPEED) != 0)
            sl.swi_coortrf2(ndp.xreturn, 9, ndp.xreturn, 21, -oe.seps, oe.ceps);
        ndp.teval = tjd;
        ndp.xflgs = iflag;
        ndp.iephe = iflag & SweConst.SEFLG_EPHMASK;
        if ((iflag & SweConst.SEFLG_SIDEREAL) != 0) {
            /* apogee is referred to t; 
             * the ecliptic position must be transformed to t0 */
            /* rigorous algorithm */
            if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0) != 0
                || (swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE) != 0) {
                for (i = 0; i <= 5; i++)
                    x[i] = ndp.xreturn[18+i];
                /* precess to J2000 */
                sl.swi_precess(x, tjd, SwephData.J_TO_J2000);
                if ((iflag & SweConst.SEFLG_SPEED) != 0)
                    swi_precess_speed(x, tjd, SwephData.J_TO_J2000);
                if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0) != 0) 
                    swi_trop_ra2sid_lon(x, ndp.xreturn, 6, ndp.xreturn, 18, iflag, null);
                /* project onto solar system equator */
                else if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE) != 0)
                    swi_trop_ra2sid_lon_sosy(x, ndp.xreturn, 6, ndp.xreturn, 18, iflag, null);
                /* to polar */
                sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
                sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
            } else {
                /* traditional algorithm */
                sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0); 
                ndp.xreturn[0] -= swe_get_ayanamsa(ndp.teval) * SwissData.DEGTORAD;
                sl.swi_polcart_sp(ndp.xreturn, 0, ndp.xreturn, 6); 
                sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
            }
        } else if ((iflag & SweConst.SEFLG_J2000) != 0) {
            /* node and apogee are referred to t; 
             * the ecliptic position must be transformed to J2000 */
            for (i = 0; i <= 5; i++)
                x[i] = ndp.xreturn[18+i];
            /* precess to J2000 */
            sl.swi_precess(x, tjd, SwephData.J_TO_J2000);
            if ((iflag & SweConst.SEFLG_SPEED) != 0)
                swi_precess_speed(x, tjd, SwephData.J_TO_J2000);
            for (i = 0; i <= 5; i++)
                ndp.xreturn[18+i] = x[i];
            sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
            sl.swi_coortrf2(ndp.xreturn, 18, ndp.xreturn, 6, swed.oec2000.seps, swed.oec2000.ceps);
            if ((iflag & SweConst.SEFLG_SPEED) != 0)
                sl.swi_coortrf2(ndp.xreturn, 21, ndp.xreturn, 9, swed.oec2000.seps, swed.oec2000.ceps);
            sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
        } else {
            /* tropical ecliptic positions */
            /* precession has already been taken into account, but not nutation */
            if ((iflag & SweConst.SEFLG_NONUT) == 0) {
                swi_nutate(ndp.xreturn, 18, iflag, false);
            }
            /* equatorial polar */
            sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
            /* ecliptic cartesian */
            sl.swi_coortrf2(ndp.xreturn, 18, ndp.xreturn, 6, oe.seps, oe.ceps);
            if ((iflag & SweConst.SEFLG_SPEED) != 0)
                sl.swi_coortrf2(ndp.xreturn, 21, ndp.xreturn, 9, oe.seps, oe.ceps);
            if ((iflag & SweConst.SEFLG_NONUT) == 0) {
                sl.swi_coortrf2(ndp.xreturn, 6, ndp.xreturn, 6, nut.snut, nut.cnut);
                if ((iflag & SweConst.SEFLG_SPEED) != 0)
                    sl.swi_coortrf2(ndp.xreturn, 9, ndp.xreturn, 9, nut.snut, nut.cnut);
            }
            /* ecliptic polar */
            sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
        }
        
        /*if ((iflag & SweConst.SEFLG_RADIANS)==0) {*/
        for (i = 0; i < 2; i++) {
            ndp.xreturn[i] *= SwissData.RADTODEG;		/* ecliptic */
            ndp.xreturn[i+3] *= SwissData.RADTODEG;
            ndp.xreturn[i+12] *= SwissData.RADTODEG;	/* equator */
            ndp.xreturn[i+15] *= SwissData.RADTODEG;
        }
        ndp.xreturn[0] = sl.swe_degnorm(ndp.xreturn[0]);
        ndp.xreturn[12] = sl.swe_degnorm(ndp.xreturn[12]);
        /*}*/
        return SweConst.OK;
    }
  
    /* transforms the position of the moon in a way we can use it
     * for calculation of osculating node and apogee:
     * precession and nutation (attention to speed vector!)
     * according to flags
     * iflag        flags
     * tjd          time for which the element is computed
     *              i.e. date of ecliptic
     * xx           array equatorial cartesian position and speed
     * serr         error string
     */
    int swi_plan_for_osc_elem(int iflag, double tjd, double xx[]) {
        int i;
        double x[]=new double[6];
        Nut nuttmp=new Nut();
        Nut nutp = nuttmp;   /* dummy assign, to silence gcc warning */
        Epsilon oe = swed.oec;
        Epsilon oectmp=new Epsilon();
        /* ICRS to J2000 */
        if ((iflag & SweConst.SEFLG_ICRS)==0 && swed.jpldenum >= 403) {
            sl.swi_bias(xx, iflag, false);
        }
        
        sl.swi_precess(xx, tjd, SwephData.J2000_TO_J);
        sl.swi_precess(xx, 3, tjd, SwephData.J2000_TO_J);
        /* epsilon */
        if (tjd == swed.oec.teps) {
            oe = swed.oec;
        } else if (tjd == SwephData.J2000) {
            oe = swed.oec2000;
        } else {
            calc_epsilon(tjd, oectmp);
            oe = oectmp;
        }
        
        if ((iflag & SweConst.SEFLG_NONUT) == 0) {
            if (tjd == swed.nut.tnut) {
                nutp = swed.nut;
            } else if (tjd == SwephData.J2000) {
                nutp = swed.nut2000;
            } else if (tjd == swed.nutv.tnut) {
                nutp = swed.nutv;
            } else {
                nutp = nuttmp;
                sl.swi_nutation(tjd, nutp.nutlo);
                nutp.tnut = tjd;
                nutp.snut = Math.sin(nutp.nutlo[1]);
                nutp.cnut = Math.cos(nutp.nutlo[1]);
                nut_matrix(nutp, oe);
            }
            for (i = 0; i <= 2; i++) {
                x[i] = xx[0] * nutp.matrix[0][i] +
                    xx[1] * nutp.matrix[1][i] +
                    xx[2] * nutp.matrix[2][i];
            }
            /* speed:
             * rotation only */
            for (i = 0; i <= 2; i++) {
                x[i+3] = xx[3] * nutp.matrix[0][i] +
                    xx[4] * nutp.matrix[1][i] +
                    xx[5] * nutp.matrix[2][i];
            }
            for (i = 0; i <= 5; i++) {
                xx[i] = x[i];
            }
        }
        
        sl.swi_coortrf2(xx, xx, oe.seps, oe.ceps);
        sl.swi_coortrf2(xx, 3, xx, 3, oe.seps, oe.ceps);
        if ((iflag & SweConst.SEFLG_NONUT) == 0) {
            sl.swi_coortrf2(xx, xx, nutp.snut, nutp.cnut);
            sl.swi_coortrf2(xx, 3, xx, 3, nutp.snut, nutp.cnut);
        }
        return SweConst.OK;
    }

    static final MeffEle eff_arr[] = {
        /*
         * r , m_eff for photon passing the sun at min distance r (fraction of Rsun)
         * the values where computed with sun_model.c, which is a classic
         * treatment of a photon passing a gravity field, multiplied by 2.
         * The sun mass distribution m(r) is from Michael Stix, The Sun, p. 47.
         */
        new MeffEle(1.000, 1.000000),
        new MeffEle(0.990, 0.999979),
        new MeffEle(0.980, 0.999940),
        new MeffEle(0.970, 0.999881),
        new MeffEle(0.960, 0.999811),
        new MeffEle(0.950, 0.999724),
        new MeffEle(0.940, 0.999622),
        new MeffEle(0.930, 0.999497),
        new MeffEle(0.920, 0.999354),
        new MeffEle(0.910, 0.999192),
        new MeffEle(0.900, 0.999000),
        new MeffEle(0.890, 0.998786),
        new MeffEle(0.880, 0.998535),
        new MeffEle(0.870, 0.998242),
        new MeffEle(0.860, 0.997919),
        new MeffEle(0.850, 0.997571),
        new MeffEle(0.840, 0.997198),
        new MeffEle(0.830, 0.996792),
        new MeffEle(0.820, 0.996316),
        new MeffEle(0.810, 0.995791),
        new MeffEle(0.800, 0.995226),
        new MeffEle(0.790, 0.994625),
        new MeffEle(0.780, 0.993991),
        new MeffEle(0.770, 0.993326),
        new MeffEle(0.760, 0.992598),
        new MeffEle(0.750, 0.991770),
        new MeffEle(0.740, 0.990873),
        new MeffEle(0.730, 0.989919),
        new MeffEle(0.720, 0.988912),
        new MeffEle(0.710, 0.987856),
        new MeffEle(0.700, 0.986755),
        new MeffEle(0.690, 0.985610),
        new MeffEle(0.680, 0.984398),
        new MeffEle(0.670, 0.982986),
        new MeffEle(0.660, 0.981437),
        new MeffEle(0.650, 0.979779),
        new MeffEle(0.640, 0.978024),
        new MeffEle(0.630, 0.976182),
        new MeffEle(0.620, 0.974256),
        new MeffEle(0.610, 0.972253),
        new MeffEle(0.600, 0.970174),
        new MeffEle(0.590, 0.968024),
        new MeffEle(0.580, 0.965594),
        new MeffEle(0.570, 0.962797),
        new MeffEle(0.560, 0.959758),
        new MeffEle(0.550, 0.956515),
        new MeffEle(0.540, 0.953088),
        new MeffEle(0.530, 0.949495),
        new MeffEle(0.520, 0.945741),
        new MeffEle(0.510, 0.941838),
        new MeffEle(0.500, 0.937790),
        new MeffEle(0.490, 0.933563),
        new MeffEle(0.480, 0.928668),
        new MeffEle(0.470, 0.923288),
        new MeffEle(0.460, 0.917527),
        new MeffEle(0.450, 0.911432),
        new MeffEle(0.440, 0.905035),
        new MeffEle(0.430, 0.898353),
        new MeffEle(0.420, 0.891022),
        new MeffEle(0.410, 0.882940),
        new MeffEle(0.400, 0.874312),
        new MeffEle(0.390, 0.865206),
        new MeffEle(0.380, 0.855423),
        new MeffEle(0.370, 0.844619),
        new MeffEle(0.360, 0.833074),
        new MeffEle(0.350, 0.820876),
        new MeffEle(0.340, 0.808031),
        new MeffEle(0.330, 0.793962),
        new MeffEle(0.320, 0.778931),
        new MeffEle(0.310, 0.763021),
        new MeffEle(0.300, 0.745815),
        new MeffEle(0.290, 0.727557),
        new MeffEle(0.280, 0.708234),
        new MeffEle(0.270, 0.687583),
        new MeffEle(0.260, 0.665741),
        new MeffEle(0.250, 0.642597),
        new MeffEle(0.240, 0.618252),
        new MeffEle(0.230, 0.592586),
        new MeffEle(0.220, 0.565747),
        new MeffEle(0.210, 0.537697),
        new MeffEle(0.200, 0.508554),
        new MeffEle(0.190, 0.478420),
        new MeffEle(0.180, 0.447322),
        new MeffEle(0.170, 0.415454),
        new MeffEle(0.160, 0.382892),
        new MeffEle(0.150, 0.349955),
        new MeffEle(0.140, 0.316691),
        new MeffEle(0.130, 0.283565),
        new MeffEle(0.120, 0.250431),
        new MeffEle(0.110, 0.218327),
        new MeffEle(0.100, 0.186794),
        new MeffEle(0.090, 0.156287),
        new MeffEle(0.080, 0.128421),
        new MeffEle(0.070, 0.102237),
        new MeffEle(0.060, 0.077393),
        new MeffEle(0.050, 0.054833),
        new MeffEle(0.040, 0.036361),
        new MeffEle(0.030, 0.020953),
        new MeffEle(0.020, 0.009645),
        new MeffEle(0.010, 0.002767),
        new MeffEle(0.000, 0.000000)
    };
    double meff(double r) {
        double f, m;
        int i;
        if (r <= 0) {
            return 0.0;
        } else if (r >= 1) {
            return 1.0;
        }
        for (i = 0; eff_arr[i].r > r; i++) {
            ; /* empty body */
        }
        f = (r - eff_arr[i-1].r) / (eff_arr[i].r - eff_arr[i-1].r);
        m = eff_arr[i-1].m + f * (eff_arr[i].m - eff_arr[i-1].m);
        return m;
    }

    // Only used with SEFLG_SPEED3
    void denormalize_positions(double[] x0, double[] x1, double[] x2) {
        int i;
        /* x*[0] = ecliptic longitude, x*[12] = rectascension */
        for (i = 0; i <= 12; i += 12) {
            if (x1[i] - x0[i] < -180) {
                x0[i] -= 360;
            }
            if (x1[i] - x0[i] > 180) {
                x0[i] += 360;
            }
            if (x1[i] - x2[i] < -180) {
                x2[i] -= 360;
            }
            if (x1[i] - x2[i] > 180) {
                x2[i] += 360;
            }
        }
    }

    // Only used with SEFLG_SPEED3
    void calc_speed(double[] x0, double[] x1, double[] x2, double dt) {
        int i, j, k;
        double a, b;
        for (j = 0; j <= 18; j += 6) {
            for (i = 0; i < 3; i++) {
                k = j + i;
                b = (x2[k] - x0[k]) / 2;
                a = (x2[k] + x0[k]) / 2 - x1[k];
                x1[k+3] = (2 * a + b) / dt;
            }
        }
    }

    void swi_check_ecliptic(double tjd) {
        if (swed.oec2000.teps != SwephData.J2000) {
            calc_epsilon(SwephData.J2000, swed.oec2000);
        }
        if (tjd == SwephData.J2000) {
            swed.oec.teps = swed.oec2000.teps;
            swed.oec.eps = swed.oec2000.eps;
            swed.oec.seps = swed.oec2000.seps;
            swed.oec.ceps = swed.oec2000.ceps;
            return;
        }
        if (swed.oec.teps != tjd || tjd == 0) {
            calc_epsilon(tjd, swed.oec);
        }
    }

    /* computes nutation, if it is wanted and has not yet been computed.
     * if speed flag has been turned on since last computation,
     * nutation is recomputed */
    int chck_nut_nutflag = 0;
    void swi_check_nutation(double tjd, int iflag) {
        int speedf1, speedf2;
        double t;
        speedf1 = chck_nut_nutflag & SweConst.SEFLG_SPEED;
        speedf2 = iflag & SweConst.SEFLG_SPEED;
        if ((iflag & SweConst.SEFLG_NONUT) == 0
            && (tjd != swed.nut.tnut || tjd == 0
                || ((speedf1==0) && (speedf2!=0)))) {
            sl.swi_nutation(tjd, swed.nut.nutlo);
            swed.nut.tnut = tjd;
            swed.nut.snut = Math.sin(swed.nut.nutlo[1]);
            swed.nut.cnut = Math.cos(swed.nut.nutlo[1]);
            chck_nut_nutflag = iflag;
            nut_matrix(swed.nut, swed.oec);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                /* once more for 'speed' of nutation, which is needed for
                 * planetary speeds */
                t = tjd - SwephData.NUT_SPEED_INTV;
                sl.swi_nutation(t, swed.nutv.nutlo);
                swed.nutv.tnut = t;
                swed.nutv.snut = Math.sin(swed.nutv.nutlo[1]);
                swed.nutv.cnut = Math.cos(swed.nutv.nutlo[1]);
                nut_matrix(swed.nutv, swed.oec);
            }
        }
    }

    int plaus_iflag(int iflag) {
        int epheflag = 0;
        /* if topocentric bit, turn helio- and barycentric bits off */
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            iflag = iflag & ~(SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR);
        }
        /* if heliocentric bit, turn aberration and deflection off */
        if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
            iflag |= SweConst.SEFLG_NOABERR | SweConst.SEFLG_NOGDEFL;
            /*iflag |= SEFLG_TRUEPOS;*/
        }
        /* same, if barycentric bit */
        if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
            iflag |= SweConst.SEFLG_NOABERR | SweConst.SEFLG_NOGDEFL;
            /*iflag |= SEFLG_TRUEPOS;*/
        }
        /* if no_precession bit is set, set also no_nutation bit */
        if ((iflag & SweConst.SEFLG_J2000)!=0) {
            iflag |= SweConst.SEFLG_NONUT;
        }
        /* if truepos is set, turn off grav. defl. and aberration */
        if ((iflag & SweConst.SEFLG_TRUEPOS)!=0) {
            iflag |= (SweConst.SEFLG_NOGDEFL | SweConst.SEFLG_NOABERR);
        }
        /* if sidereal bit is set, set also no_nutation bit */
        if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
            iflag |= SweConst.SEFLG_NONUT;
        }
        if ((iflag & SweConst.SEFLG_MOSEPH)!=0) {
            epheflag = SweConst.SEFLG_MOSEPH;
        }
        if ((iflag & SweConst.SEFLG_SWIEPH)!=0) {
            epheflag = SweConst.SEFLG_SWIEPH;
        }
        if ((iflag & SweConst.SEFLG_JPLEPH)!=0) {
            epheflag = SweConst.SEFLG_JPLEPH;
        }
        if (epheflag == 0) {
            epheflag = SweConst.SEFLG_DEFAULTEPH;
        }
        /* delete wrong ephe bits from flag */
        iflag = (iflag & ~SweConst.SEFLG_EPHMASK) | epheflag;

        return iflag;
    }

    int swe_fixstar_found(StringBuffer serr, String s, StringBuffer star,
                          double tjd, int iflag, int iflgsave, int epheflag,
                          double[] xx) {
        double xpo[] = null;
        double ra_s, ra_pm, de_pm, ra, de, t, cosra, cosde, sinra, sinde;
        double ra_h, ra_m, de_d, de_m, de_s;
        String sde_d;
        double epoch, radv, parall, u;
        double x[]=new double[6];
        double xxsv[]=new double[6];
        double xobs[]=new double[6];
        int retc;
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        Epsilon oe = swed.oec2000;

        String[] cpos=new String[20];
        StringTokenizer tk=new StringTokenizer(s,",");
        int i=tk.countTokens();
        int n=0;
        while(tk.hasMoreTokens() && n<20) {
            cpos[n++]=tk.nextToken();
        }
        cpos[0]=cpos[0].trim();
        cpos[1]=cpos[1].trim();
        if (i < 13) {
            if (serr!=null) {
                serr.setLength(0);
                serr.append("data of star '"+cpos[0]+","+cpos[1]+"' incomplete");
            }
            return swe_fixstar_error(xx,SweConst.ERR);
        }
        // JAVA: Grrr: zumindest cpos[2] muss keine Zahl sein, aber es FAENGT
        // moeglicherweise mit einer Zahl AN!!!
        int idx=cpos[2].length();
        while(true) {
            try {
                epoch = Double.valueOf(cpos[2].substring(0,idx)).doubleValue();
                break;
            } catch (NumberFormatException nf) {
                idx--;
                if (idx==0) { epoch=0.; break; }
            }
        }
        ra_h = new Double(cpos[3]).doubleValue();
        ra_m = new Double(cpos[4]).doubleValue();
        ra_s = new Double(cpos[5]).doubleValue();
        de_d = new Double(cpos[6]).doubleValue();
        sde_d = cpos[6];
        de_m = new Double(cpos[7]).doubleValue();
        de_s = new Double(cpos[8]).doubleValue();
        ra_pm = new Double(cpos[9]).doubleValue();
        de_pm = new Double(cpos[10]).doubleValue();
        radv = new Double(cpos[11]).doubleValue();
        parall = new Double(cpos[12]).doubleValue();
        /* return trad. name, nomeclature name */
        if (cpos[0].length() > SweConst.SE_MAX_STNAME) {
            cpos[0]=cpos[0].substring(0,SweConst.SE_MAX_STNAME);
        }
        if (cpos[1].length() > SweConst.SE_MAX_STNAME-1) {
            cpos[1]=cpos[1].substring(0,SweConst.SE_MAX_STNAME-1);
        }
        star.setLength(0);
        star.append(cpos[0]+","+cpos[1]);
        
        /* ra and de in degrees */
        ra = (ra_s / 3600.0 + ra_m / 60.0 + ra_h) * 15.0;
        if (sde_d.indexOf('-') < 0) {
            de = de_s / 3600.0 + de_m / 60.0 + de_d;
        } else {
            de = -de_s / 3600.0 - de_m / 60.0 + de_d;
        }
        /* speed in ra and de, degrees per century */
        ra_pm = ra_pm * 15 / 3600.0;
        de_pm /= 3600.0;
        /* parallax, degrees */
        if (parall > 1) {
            parall = (1 / parall / 3600);
        } else {
            parall /= 3600;
        }
        /* radial velocity in AU per century */
        radv *= SwephData.KM_S_TO_AU_CTY;
        /* radians */
        ra *= SwissData.DEGTORAD;
        de *= SwissData.DEGTORAD;
        ra_pm *= SwissData.DEGTORAD;
        de_pm *= SwissData.DEGTORAD;
        parall *= SwissData.DEGTORAD;
        x[0] = ra;
        x[1] = de;
        x[2] = 1;     /* -> unit vector */
        /* cartesian */
        sl.swi_polcart(x, x);
        /*space motion vector */
        cosra = Math.cos(ra);
        cosde = Math.cos(de);
        sinra = Math.sin(ra);
        sinde = Math.sin(de);
        x[3] = -ra_pm * cosde * sinra - de_pm * sinde * cosra
            + radv * parall * cosde * cosra;
        x[4] = ra_pm * cosde * cosra - de_pm * sinde * sinra
            + radv * parall * cosde * sinra;
        x[5] = de_pm * cosde + radv * parall * sinde;
        x[3] /= 36525;
        x[4] /= 36525;
        x[5] /= 36525;
        
        if (epoch == 1950) {
            sl.swi_FK4_FK5(x, SwephData.B1950);
            sl.swi_precess(x, SwephData.B1950, SwephData.J_TO_J2000);
            sl.swi_precess(x, 3, SwephData.B1950, SwephData.J_TO_J2000);
        }
        /* FK5 to ICRS, if jpl ephemeris is referred to ICRS 
         * With data that are already ICRS, epoch = 0 */
        if (epoch != 0) {
            sl.swi_icrs2fk5(x, iflag, true);
            /* with ephemerides < DE403, we now convert to J2000 */
            if (swed.jpldenum < 403)
                sl.swi_bias(x, iflag, false);
        }
        
        retc = main_planet(tjd, SwephData.SEI_EARTH, epheflag, iflag, serr);
        if (retc != SweConst.OK) {
            return swe_fixstar_error(xx,SweConst.ERR);
        }
        /* iflag (ephemeris bit) may have changed in main_planet() */
        iflag = swed.pldat[SwephData.SEI_EARTH].xflgs;
        
        /* if topocentric position is wanted  */
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            if (swed.topd.teval != pedp.teval
                || swed.topd.teval == 0) {
                if (swi_get_observer(pedp.teval, iflag, SwephData.DO_SAVE, xobs, serr)!=
                    SweConst.OK) {
                    return SweConst.ERR;
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = swed.topd.xobs[i];
                }
            }
            /* barycentric position of observer */
            for (i = 0; i <= 5; i++) {
                xobs[i] = xobs[i] + pedp.x[i];
            }
        } else {
            /* barycentric position of geocenter */
            for (i = 0; i <= 5; i++) {
                xobs[i] = pedp.x[i];
            }
        }
        
        if (epoch == 1950) {
            t= (tjd - SwephData.B1950);   /* days since 1950.0 */
        } else { /* epoch == 2000 */
            t= (tjd - SwephData.J2000);   /* days since 2000.0 */
        }
        /* for parallax */
        if ((iflag & SweConst.SEFLG_HELCTR)!=0 &&
            (iflag & SweConst.SEFLG_MOSEPH)!=0) {
            xpo = null;         /* no parallax, if moshier and heliocentric */
        } else if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
            xpo = psdp.x;
        } else if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
            xpo = null;         /* no parallax, if barycentric */
        } else {
            xpo = xobs;
        }
        if (xpo == null) {
            for (i = 0; i <= 2; i++) {
                x[i] += t * x[i+3];
            }
        } else {
            for (i = 0; i <= 2; i++) {
                x[i] += t * x[i+3] - parall * xpo[i];
                x[i+3] -= parall * xpo[i+3];
            }
        }
        
        for (i = 0; i <= 5; i++) {
            x[i] *= 10000;      /* great distance, to allow
                                 * algorithm used with planets */
        }
        if ((iflag & SweConst.SEFLG_TRUEPOS) == 0 &&
            (iflag & SweConst.SEFLG_NOGDEFL) == 0) {
            swi_deflect_light(x, 0, 0, iflag & SweConst.SEFLG_SPEED);
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS) == 0 &&
            (iflag & SweConst.SEFLG_NOABERR) == 0) {
            swi_aberr_light(x, xpo, iflag & SweConst.SEFLG_SPEED);
        }
        /* ICRS to J2000 */
        if ((iflag & SweConst.SEFLG_ICRS) == 0 && swed.jpldenum >= 403) {
            sl.swi_bias(x, iflag, false);
        }
        /* save J2000 coordinates; required for sidereal positions */
        for (i = 0; i <= 5; i++) {
            xxsv[i] = x[i];
        }
        
        /*x[0] = -0.374018403; x[1] = -0.312548592; x[2] = -0.873168719;*/
        if ((iflag & SweConst.SEFLG_J2000) == 0) {
            sl.swi_precess(x, tjd, SwephData.J2000_TO_J);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(x, tjd, SwephData.J2000_TO_J);
            }
            oe = swed.oec;
        } else {
            oe = swed.oec2000;
        }
        
        if ((iflag & SweConst.SEFLG_NONUT) == 0) {
            swi_nutate(x, 0, 0, false);
        }
        
        u = Math.sqrt(sl.square_sum(x));
        for (i = 0; i <= 5; i++) {
            x[i] /= u;
        }
        u = Math.sqrt(sl.square_sum(xxsv));
        for (i = 0; i <= 5; i++) {
            xxsv[i] /= u;
        }
        
        for (i = 3; i <= 5; i++) {
            x[i] = xxsv[i] = 0;
        }
        
        if ((iflag & SweConst.SEFLG_EQUATORIAL) == 0) {
            sl.swi_coortrf2(x, x, oe.seps, oe.ceps);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                sl.swi_coortrf2(x, 3, x, 3, oe.seps, oe.ceps);
            }
            if ((iflag & SweConst.SEFLG_NONUT) == 0) {
                sl.swi_coortrf2(x, x, swed.nut.snut, swed.nut.cnut);
                if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                    sl.swi_coortrf2(x, 3, x, 3, swed.nut.snut, swed.nut.cnut);
                }
            }
        }
        
        if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
            /* rigorous algorithm */
            if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0) {
                if (swi_trop_ra2sid_lon(xxsv, x, xxsv, iflag, serr) != SweConst.OK) {
                    return SweConst.ERR;
                }
                if ((iflag & SweConst.SEFLG_EQUATORIAL)!=0) {
                    for (i = 0; i <= 5; i++) {
                        x[i] = xxsv[i];
                    }
                }
                /* project onto solar system equator */
            } else if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
                if (swi_trop_ra2sid_lon_sosy(xxsv, x, xxsv, iflag, serr) !=
                    SweConst.OK) {
                    return SweConst.ERR;
                }
                if ((iflag & SweConst.SEFLG_EQUATORIAL)!=0) {
                    for (i = 0; i <= 5; i++) {
                        x[i] = xxsv[i];
                    }
                }
                /* traditional algorithm */
            } else {
                sl.swi_cartpol_sp(x, x);
                x[0] -= swe_get_ayanamsa(tjd) * SwissData.DEGTORAD;
                sl.swi_polcart_sp(x, x);
            }
        }
        
        if ((iflag & SweConst.SEFLG_XYZ) == 0) {
            sl.swi_cartpol_sp(x, x);
        }
        
        if ((iflag & SweConst.SEFLG_RADIANS) == 0 &&
            (iflag & SweConst.SEFLG_XYZ) == 0) {
            for (i = 0; i < 2; i++) {
                x[i] *= SwissData.RADTODEG;
                x[i+3] *= SwissData.RADTODEG;
            }
        }
        for (i = 0; i <= 5; i++) {
            xx[i] = x[i];
        }
        /* if no ephemeris has been specified, do not return chosen ephemeris */
        if ((iflgsave & SweConst.SEFLG_EPHMASK) == 0) {
            iflag = iflag & ~SweConst.SEFLG_DEFAULTEPH;
        }
        iflag = iflag & ~SweConst.SEFLG_SPEED;
        return iflag;
    }

    int swe_fixstar_error(double[] xx, int retc) {
        for (int i = 0; i <= 5; i++) {
            xx[i] = 0;
        }
        return retc;
    }



    void swi_force_app_pos_etc() {
        int i;
        for (i = 0; i < SwephData.SEI_NPLANETS; i++) {
            swed.pldat[i].xflgs = -1;
        }
        for (i = 0; i < SwephData.SEI_NNODE_ETC; i++) {
            swed.nddat[i].xflgs = -1;
        }
        for (i = 0; i < SweConst.SE_NPLANETS; i++) {
            swed.savedat[i].tsave = 0;
            swed.savedat[i].iflgsave = -1;
        }
    }

    int swi_get_observer(double tjd, int iflag, boolean do_save, double xobs[],
                         StringBuffer serr) {
        int i;
        double sidt, delt, tjd_ut, eps, nut, nutlo[]=new double[2];
        double f = SwephData.EARTH_OBLATENESS;
        double re = SwephData.EARTH_RADIUS;
        double cosfi, sinfi, cc, ss, cosl, sinl, h;
        if (!swed.geopos_is_set) {
            if (serr != null) {
                serr.setLength(0);
                serr.append("geographic position has not been set");
            }
            return SweConst.ERR;
        }
        /* geocentric position of observer depends on sidereal time,
         * which depends on UT.
         * compute UT from ET. this UT will be slightly different
         * from the user's UT, but this difference is extremely small.
         */
        delt = SweDate.getDeltaT(tjd);
        tjd_ut = tjd - delt;
        if (swed.oec.teps == tjd && swed.nut.tnut == tjd) {
            eps = swed.oec.eps;
            nutlo[1] = swed.nut.nutlo[1];
            nutlo[0] = swed.nut.nutlo[0];
        } else {
            eps = sl.swi_epsiln(tjd);
            if ((iflag & SweConst.SEFLG_NONUT)==0) {
                sl.swi_nutation(tjd, nutlo);
            }
        }
        if ((iflag & SweConst.SEFLG_NONUT)!=0) {
            nut = 0;
        } else {
            eps += nutlo[1];
            nut = nutlo[0];
        }
        /* mean or apparent sidereal time, depending on whether or
         * not SEFLG_NONUT is set */
        sidt = sl.swe_sidtime0(tjd_ut, eps, nut);
        sidt *= 15;   /* in degrees */
        /* length of position and speed vectors;
         * the height above sea level must be taken into account.
         * with the moon, an altitude of 3000 m makes a difference
         * of about 2 arc seconds.
         * height is referred to the average sea level. however,
         * the spheroid (geoid), which is defined by the average
         * sea level (or rather by all points of same gravitational
         * potential), is of irregular shape and cannot easily
         * be taken into account. therefore, we refer height to
         * the surface of the ellipsoid. the resulting error
         * is below 500 m, i.e. 0.2 - 0.3 arc seconds with the moon.
         */
        cosfi = Math.cos(swed.topd.geolat * SwissData.DEGTORAD);
        sinfi = Math.sin(swed.topd.geolat * SwissData.DEGTORAD);
        cc= 1 / Math.sqrt(cosfi * cosfi + (1-f) * (1-f) * sinfi * sinfi);
        ss= (1-f) * (1-f) * cc;
        /* neglect polar motion (displacement of a few meters), as long as 
         * we use the earth ellipsoid */
        /* ... */
        /* add sidereal time */
        cosl = Math.cos((swed.topd.geolon + sidt) * SwissData.DEGTORAD);
        sinl = Math.sin((swed.topd.geolon + sidt) * SwissData.DEGTORAD);
        h = swed.topd.geoalt;
        xobs[0] = (re * cc + h) * cosfi * cosl;
        xobs[1] = (re * cc + h) * cosfi * sinl;
        xobs[2] = (re * ss + h) * sinfi;
        /* polar coordinates */
        sl.swi_cartpol(xobs, xobs);
        /* speed */
        xobs[3] = SwephData.EARTH_ROT_SPEED;
        xobs[4] = xobs[5] = 0;
        sl.swi_polcart_sp(xobs, xobs);
        /* to AUNIT */
        for (i = 0; i <= 5; i++) {
            xobs[i] /= SweConst.AUNIT;
        }
        /* subtract nutation, set backward flag */
        if ((iflag & SweConst.SEFLG_NONUT)==0) {
            sl.swi_coortrf2(xobs, xobs, -swed.nut.snut, swed.nut.cnut);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                sl.swi_coortrf2(xobs, 3, xobs, 3, -swed.nut.snut, swed.nut.cnut);
            }
            swi_nutate(xobs, 0, iflag, true);
        }
        /* precess to J2000 */
        sl.swi_precess(xobs, tjd, SwephData.J_TO_J2000);
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            swi_precess_speed(xobs, tjd, SwephData.J_TO_J2000);
        }
        /* neglect frame bias (displacement of 45cm) */
        /* ... */
        /* save */
        if (do_save) {
            for (i = 0; i <= 5; i++) {
                swed.topd.xobs[i] = xobs[i];
            }
            swed.topd.teval = tjd;
            swed.topd.tjd_ut = tjd_ut;  /* -> save area */
        }
        return SweConst.OK;
    }

    /* Equation of Time
     *
     * The function returns the difference between
     * local apparent and local mean time in days.
     * E = LAT - LMT
     * Input variable tjd is ET.
     * Algorithm according to Meeus, German, p. 190ff.
     */
    
    public int swe_time_equ(double tjd, DblObj E, StringBuffer serr) {
        double L0, dpsi, eps, x[]=new double[6], nutlo[]=new double[2];
        double tau = (tjd - SwephData.J2000) / 365250;
        double tau2 = tau * tau;
        double tau3 = tau * tau2;
        double tau4 = tau * tau3;
        double tau5 = tau * tau4;
        L0 = 280.4664567 + sl.swe_degnorm(tau * 360007.6982779)
            + tau2 * 0.03032028
            + tau3 * 1 / 49931
            - tau4 * 1 / 15299
            - tau5 * 1 / 1988000;
        sl.swi_nutation(tjd, nutlo);
        eps = (sl.swi_epsiln(tjd) + nutlo[1]) * SwissData.RADTODEG;
        dpsi = nutlo[0] * SwissData.RADTODEG;
        if (swe_calc(tjd, SweConst.SE_SUN, SweConst.SEFLG_EQUATORIAL, x, serr) ==
            SweConst.ERR) {
            return SweConst.ERR;
        }
        E.val = sl.swe_degnorm(L0 - 0.0057183 - x[0] + dpsi *
                               Math.cos(eps * SwissData.DEGTORAD));
        if (E.val > 180) {
            E.val -= 360;
        }
        E.val *= 4 / 1440.0;
        return SweConst.OK;
    }

    double dot_prod(double x[], double y[]) {
        ////#ifdef TRACE0
        //    Trace.level++;
        //    Trace.trace(Trace.level, "SwissEph.dot_prod(double[], double[])");
        ////#ifdef TRACE1
        //    Trace.printDblArr("x", x);
        //    Trace.printDblArr("y", y);
        ////#endif /* TRACE1 */
        //    Trace.level--;
        ////#endif /* TRACE0 */
        return x[0]*y[0]+x[1]*y[1]+x[2]*y[2];
    }
    double dot_prod(double x[], double y[], int yOffs) {
        ////#ifdef TRACE0
        //    Trace.level++;
        //    Trace.trace(Trace.level, "SwissEph.dot_prod(double[], double[], int)");
        ////#ifdef TRACE1
        //    Trace.printDblArr("x", x);
        //    Trace.printDblArr("y", y);
        //    DevNull.println("    yOffs: " + yOffs);
        ////#endif /* TRACE1 */
        //    Trace.level--;
        ////#endif /* TRACE0 */
        return x[0]*y[yOffs]+x[1]*y[1+yOffs]+x[2]*y[2+yOffs];
    }

    
} // Ende class SwissEph

class MeffEle {
    double r;
    double m;

    MeffEle(double r, double m) {
        ////#ifdef TRACE0
        //    Trace.level++;
        //    Trace.trace(Trace.level, "MeffEle(double, double)");
        ////#ifdef TRACE1
        //    DevNull.println("    r: " + Trace.fmtDbl(r) + "\n    m: " + Trace.fmtDbl(m));
        ////#endif /* TRACE1 */
        ////#endif /* TRACE0 */
        this.r=r; this.m=m;
        ////#ifdef TRACE0
        //    Trace.level--;
        ////#endif /* TRACE0 */
    }

}



class SwissLib {

/* Set TRUE, to include Herring's (1987) corrections to IAU 1980
 * nutation series. AA (1996) neglects them.  */

/* Precession coefficients for remote past and future.
 * One of the following four defines must be true.
 */
/* Make PREC_WILLIAMS_1994 the default: */

/* used by Moshier for DE404: */
static final boolean PREC_WILLIAMS_1994  = true;
static final boolean PREC_SIMON_1994     = false;
static final boolean PREC_LASKAR_1986    = false;
static final boolean PREC_BRETAGNON_2003 = false;
/* IAU precession 1976 or 2003 for recent centuries.
 * only one of the following two defines may be TRUE */
static final boolean PREC_IAU_1976       = false;
/* precession model P03: */
static final boolean PREC_IAU_2003       = true;

/* choose between the following nutation models */
/* Make NUT_IAU_2000B the default: */
static final boolean NUT_IAU_1980        = false;
static final boolean NUT_IAU_2000A       = false;   /* very time consuming ! */
static final boolean NUT_IAU_2000B       = true;  /* fast, but precision of milli-arcsec */

  /* J2000 +/- two centuries: */
  static final double PREC_IAU_1976_CTIES=2.0;
  /* we use P03 for whole ephemeris */
  /* J2000 +/- 75 centuries: */
  static final double PREC_IAU_2003_CTIES=75.0;


  SwissData swed;

  // Konstruktor(en):
  public SwissLib() {
    this(null);
  }

  public SwissLib(SwissData swed) {
    this.swed=swed;
    if (this.swed ==null) { this.swed=new SwissData(); }
  }


//////////////////////////////////////////////////////////////////////////////
// Public methods: ///////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
  public double square_sum(double x[]) {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "SwissLib.square_sum(double[])");
////#ifdef TRACE1
//    Trace.printDblArr("x", x);
////#endif /* TRACE1 */
//    Trace.level--;
////#endif /* TRACE0 */
    return x[0]*x[0]+x[1]*x[1]+x[2]*x[2];
  }

  public double square_sum(double x[], int offset) {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "SwissLib.square_sum(double[], int)");
////#ifdef TRACE1
//    Trace.printDblArr("x", x);
//    DevNull.println("    offset: " + offset);
////#endif /* TRACE1 */
//    Trace.level--;
////#endif /* TRACE0 */
    return x[offset]*x[offset]+x[1+offset]*x[1+offset]+x[2+offset]*x[2+offset];
  }



  /* Reduce x modulo 360 degrees
   */
  
  public double swe_degnorm(double x) {
if (Double.doubleToLongBits(x) == 0xc11cd9d69f7e189dL) {
  x = Double.longBitsToDouble(0xc11cd9d69f7e189eL);  // Zeile 66: keine Verñnderung...
} else if (Double.doubleToLongBits(x) == 0xc11d376e20594b20L) {
  x = Double.longBitsToDouble(0xc11d376e20594b21L);  // Zeile 68: keine Verñnderung...
} else if (Double.doubleToLongBits(x) == 0xc11ae8edd4666694L) {
  x = Double.longBitsToDouble(0xc11ae8edd4666695L);  // Zeile 70: keine Verñnderung...
} else if (Double.doubleToLongBits(x) == 0x409fe5e10f4cc528L) {
  x = Double.longBitsToDouble(0x409fe5e10f4cc527L);  // Zeile 79: keine Verñnderung...
}
    double y;
    y = x%360.0;
    if (Math.abs(y) < 1e-13) {
      y = 0;   /* Alois fix 11-dec-1999 */
    }
    if( y < 0.0 ) {
      y += 360.0;
    }
    return(y);
  }

// Well: used by Swetest.java... //#ifndef ASTROLOGY
  /* Reduce x modulo TWOPI degrees
   */
  
  public double swe_radnorm(double x) {
    double y;
    y = x % SwephData.TWOPI;
    if (Math.abs(y) < 1e-13) {
      y = 0;   /* Alois fix 11-dec-1999 */
    }
    if( y < 0.0 ) {
      y += SwephData.TWOPI;
    }
    return(y);
  }
// Well: used by Swetest.java... //#endif /* ASTROLOGY */

// Well: used by Swetest.java... //#ifndef ASTROLOGY
  public double swe_deg_midp(double x1, double x0) {
    double y;
// This is completely blown up for nothing:
//    d = swe_difdeg2n(x1, x0);     /* arc from x0 to x1 */
//    y = swe_degnorm(x0 + d / 2);
    y = swe_degnorm((x1 + x0)/2);
    return(y);
  }
// Well: used by Swetest.java... //#endif /* ASTROLOGY */

// Well: used by Swetest.java... //#ifndef ASTROLOGY
  public double swe_rad_midp(double x1, double x0) {
    return SwissData.DEGTORAD * swe_deg_midp(x1 * SwissData.RADTODEG, x0 * SwissData.RADTODEG);
  }
// Well: used by Swetest.java... //#endif /* ASTROLOGY */

  /* Reduce x modulo 2*PI
   */
  public double swi_mod2PI(double x) {
    double y;
    y = x%SwephData.TWOPI;
    if( y < 0.0 ) {
      y += SwephData.TWOPI;
    }
    return(y);
  }


  public double swi_angnorm(double x) {
    if (x < 0.0 ) {
      return x + SwephData.TWOPI;
    } else if (x >= SwephData.TWOPI) {
      return x - SwephData.TWOPI;
    } else {
      return x;
    }
  }

  public void swi_cross_prod(double a[], int aOffs, double b[], int bOffs,
                             double x[], int xOffs) {
    x[0+xOffs] = a[1+aOffs]*b[2+bOffs] - a[2+aOffs]*b[1+bOffs];
    x[1+xOffs] = a[2+aOffs]*b[0+bOffs] - a[0+aOffs]*b[2+bOffs];
    x[2+xOffs] = a[0+aOffs]*b[1+bOffs] - a[1+aOffs]*b[0+bOffs];
  }

  /*  Evaluates a given chebyshev series coef[0..ncf-1]
   *  with ncf terms at x in [-1,1]. Communications of the ACM, algorithm 446,
   *  April 1973 (vol. 16 no.4) by Dr. Roger Broucke.
   */
  public double swi_echeb(double x, double coef[], int offs, int ncf) {
if (Double.doubleToLongBits(coef[0]) == 0xbfbf6c9bdfa87a8eL) {
  coef[0] = Double.longBitsToDouble(0xbfbf6c9bdfa87a8dL);  // Zeile 3456: keine Verñnderung...
}
if (Double.doubleToLongBits(coef[5]) == 0x3FB87AA86131C716L) {
  coef[5] = Double.longBitsToDouble(0x3fb87aa86131c717L);  // Zeile 3461: keine Verñnderung...
}
if (Double.doubleToLongBits(coef[6]) == 0xBF75E01D9A8A9A34L) {
  coef[6] = Double.longBitsToDouble(0xBF75E01D9A8A9A35L);  // Zeile 3462: keine Verñnderung...
}
if (Double.doubleToLongBits(coef[10]) == 0x3EF5D0AE131F86EEL) {
  coef[10] = Double.longBitsToDouble(0x3EF5D0AE131F86EDL);  // Zeile 3466: keine Verñnderung...
}
    int j;
    double x2, br, brp2, brpp;

    x2 = x * 2.;
    br = 0.;
    brp2 = 0.;    /* dummy assign to silence gcc warning */
    brpp = 0.;
    for (j = ncf - 1; j >= 0; j--) {
      brp2 = brpp;
      brpp = br;
      br = x2 * brpp - brp2 + coef[j+offs];
    }
    return (br - brp2) * .5;
  }

  /*
   * evaluates derivative of chebyshev series, see echeb
   */
  public double swi_edcheb(double x, double coef[], int offs, int ncf) {
    double bjpl, xjpl;
    int j;
    double x2, bf, bj, dj, xj, bjp2, xjp2;
    x2 = x * 2.;
    bf = 0.;      /* dummy assign to silence gcc warning */
    bj = 0.;      /* dummy assign to silence gcc warning */
    xjp2 = 0.;
    xjpl = 0.;
    bjp2 = 0.;
    bjpl = 0.;
    for (j = ncf - 1; j >= 1; j--) {
      dj = (double) (j + j);
      xj = coef[j+offs] * dj + xjp2;
      bj = x2 * bjpl - bjp2 + xj;
      bf = bjp2;
      bjp2 = bjpl;
      bjpl = bj;
      xjp2 = xjpl;
      xjpl = xj;
    }
    return (bj - bf) * .5;
  }

  /*
   * conversion between ecliptical and equatorial polar coordinates.
   * for users of SWISSEPH, not used by our routines.
   * for ecl. to equ.  eps must be negative.
   * for equ. to ecl.  eps must be positive.
   * xpo, xpn are arrays of 3 doubles containing position.
   * attention: input must be in degrees!
   */
  public void swe_cotrans(double xpo[],double xpn[],double eps) {
    swe_cotrans(xpo, 0, xpn, 0, eps);
  }
  public void swe_cotrans(double xpo[],int oOffs, double xpn[],
                          int nOffs, double eps) {
    int i;
    double x[]=new double[6], e = eps * SwissData.DEGTORAD;
    for(i = 0; i <= 1; i++)
      x[i] = xpo[i+oOffs];
    x[0] *= SwissData.DEGTORAD;
    x[1] *= SwissData.DEGTORAD;
    x[2] = 1;
    for(i = 3; i <= 5; i++)
      x[i] = 0;
    swi_polcart(x, x);
    swi_coortrf(x, x, e);
    swi_cartpol(x, x);
    xpn[  nOffs] = x[0] * SwissData.RADTODEG;
    xpn[1+nOffs] = x[1] * SwissData.RADTODEG;
    xpn[2+nOffs] = xpo[2+oOffs];
  }

  /*
   * conversion between ecliptical and equatorial polar coordinates
   * with speed.
   * for users of SWISSEPH, not used by our routines.
   * for ecl. to equ.  eps must be negative.
   * for equ. to ecl.  eps must be positive.
   * xpo, xpn are arrays of 6 doubles containing position and speed.
   * attention: input must be in degrees!
   */
  public void swe_cotrans_sp(double xpo[], double xpn[], double eps) {
    int i;
    double x[]=new double[6], e = eps * SwissData.DEGTORAD;
    for (i = 0; i <= 5; i++)
      x[i] = xpo[i];
    x[0] *= SwissData.DEGTORAD;
    x[1] *= SwissData.DEGTORAD;
    x[2] = 1;     /* avoids problems with polcart(), if x[2] = 0 */
    x[3] *= SwissData.DEGTORAD;
    x[4] *= SwissData.DEGTORAD;
    swi_polcart_sp(x, x);
    swi_coortrf(x, x, e);
    swi_coortrf(x, 3, x, 3, e);
    swi_cartpol_sp(x, xpn);
    xpn[0] *= SwissData.RADTODEG;
    xpn[1] *= SwissData.RADTODEG;
    xpn[2] = xpo[2];
    xpn[3] *= SwissData.RADTODEG;
    xpn[4] *= SwissData.RADTODEG;
    xpn[5] = xpo[5];
  }

  /*
   * conversion between ecliptical and equatorial cartesian coordinates
   * for ecl. to equ.  eps must be negative
   * for equ. to ecl.  eps must be positive
   */
  public void swi_coortrf(double xpo[], double xpn[], double eps) {
    swi_coortrf(xpo, 0, xpn, 0, eps);
  }

  public void swi_coortrf(double xpo[], int oOffs, double xpn[],
                          int nOffs, double eps) {
    double sineps, coseps;
    double x[]=new double[3];
    sineps = Math.sin(eps);
    coseps = Math.cos(eps);
    x[0] = xpo[oOffs];
    x[1] = xpo[1+oOffs] * coseps + xpo[2+oOffs] * sineps;
    x[2] = -xpo[1+oOffs] * sineps + xpo[2+oOffs] * coseps;
    xpn[0+nOffs] = x[0];
    xpn[1+nOffs] = x[1];
    xpn[2+nOffs] = x[2];
  }

  /*
   * conversion between ecliptical and equatorial cartesian coordinates
   * sineps            sin(eps)
   * coseps            cos(eps)
   * for ecl. to equ.  sineps must be -sin(eps)
   */
  public void swi_coortrf2(double xpo[], double xpn[], double sineps,
                           double coseps) {
    swi_coortrf2(xpo, 0, xpn, 0, sineps, coseps);
  }
  public void swi_coortrf2(double xpo[], int oOffs, double xpn[], int nOffs,
                    double sineps, double coseps) {
    double x[]=new double[3];
    x[0] = xpo[0+oOffs];
    x[1] = xpo[1+oOffs] * coseps + xpo[2+oOffs] * sineps;
    x[2] = -xpo[1+oOffs] * sineps + xpo[2+oOffs] * coseps;
    xpn[0+nOffs] = x[0];
    xpn[1+nOffs] = x[1];
    xpn[2+nOffs] = x[2];
  }

  /* conversion of cartesian (x[3]) to polar coordinates (l[3]).
   * x = l is allowed.
   * if |x| = 0, then lon, lat and rad := 0.
   */
  public void swi_cartpol(double x[], double l[]) {
    swi_cartpol(x, 0, l, 0);
  }

  public void swi_cartpol(double x[], int xOffs, double l[], int lOffs) {
    double rxy;
    double ll[]=new double[3];
    if (x[0+xOffs] == 0 && x[1+xOffs] == 0 && x[2+xOffs] == 0) {
      l[0+lOffs] = l[1+lOffs] = l[2+lOffs] = 0;
      return;
    }
    rxy = x[0+xOffs]*x[0+xOffs] + x[1+xOffs]*x[1+xOffs];
    ll[2] = Math.sqrt(rxy + x[2+xOffs]*x[2+xOffs]);
    rxy = Math.sqrt(rxy);
    ll[0] = Math.atan2(x[1+xOffs], x[0+xOffs]);
    if (ll[0] < 0.0) {
      ll[0] += SwephData.TWOPI;
    }
    ll[1] = Math.atan(x[2+xOffs] / rxy);
    l[0+lOffs] = ll[0];
    l[1+lOffs] = ll[1];
    l[2+lOffs] = ll[2];
  }

  /* conversion from polar (l[3]) to cartesian coordinates (x[3]).
   * x = l is allowed.
   */
  public void swi_polcart(double l[], double x[]) {
    swi_polcart(l, 0, x, 0);
  }
  public void swi_polcart(double l[], int lOffs, double x[], int xOffs) {
    double xx[]=new double[3];
    double cosl1;
    cosl1 = Math.cos(l[lOffs+1]);
    xx[0] = l[lOffs+2] * cosl1 * Math.cos(l[lOffs]);
    xx[1] = l[lOffs+2] * cosl1 * Math.sin(l[lOffs]);
    xx[2] = l[lOffs+2] * Math.sin(l[lOffs+1]);
    x[xOffs] = xx[0];
    x[xOffs+1] = xx[1];
    x[xOffs+2] = xx[2];
  }

  /* conversion of position and speed.
   * from cartesian (x[6]) to polar coordinates (l[6]).
   * x = l is allowed.
   * if position is 0, function returns direction of
   * motion.
   */
  public void swi_cartpol_sp(double x[], double l[]) {
    swi_cartpol_sp(x, 0, l, 0);
  }
  public void swi_cartpol_sp(double x[], int xOffs, double l[], int lOffs) {
    double xx[]=new double[6], ll[]=new double[6];
    double rxy, coslon, sinlon, coslat, sinlat;
    /* zero position */
    if (x[0+xOffs] == 0 && x[1+xOffs] == 0 && x[2+xOffs] == 0) {
      l[0+lOffs] = l[1+lOffs] = l[3+lOffs] = l[4+lOffs] = 0;
      l[5+lOffs] = Math.sqrt(square_sum(x, 3+xOffs));
      swi_cartpol(x, 3+xOffs, l, 0+lOffs);
      l[2+lOffs] = 0;
      return;
    }
    /* zero speed */
    if (x[3+xOffs] == 0 && x[4+xOffs] == 0 && x[5+xOffs] == 0) {
      l[3+lOffs] = l[4+lOffs] = l[5+lOffs] = 0;
      swi_cartpol(x, xOffs, l, lOffs);
      return;
    }
    /* position */
    rxy = x[0+xOffs]*x[0+xOffs] + x[1+xOffs]*x[1+xOffs];
    ll[2] = Math.sqrt(rxy + x[2+xOffs]*x[2+xOffs]);
    rxy = Math.sqrt(rxy);
    ll[0] = Math.atan2(x[1+xOffs], x[0+xOffs]);
    if (ll[0] < 0.0) {
      ll[0] += SwephData.TWOPI;
    }
    ll[1] = Math.atan(x[2+xOffs] / rxy);
    /* speed:
     * 1. rotate coordinate system by longitude of position about z-axis,
     *    so that new x-axis = position radius projected onto x-y-plane.
     *    in the new coordinate system
     *    vy'/r = dlong/dt, where r = sqrt(x^2 +y^2).
     * 2. rotate coordinate system by latitude about new y-axis.
     *    vz"/r = dlat/dt, where r = position radius.
     *    vx" = dr/dt
     */
    coslon = x[0+xOffs] / rxy;          /* cos(l[0]); */
    sinlon = x[1+xOffs] / rxy;          /* sin(l[0]); */
    coslat = rxy / ll[2];         /* cos(l[1]); */
    sinlat = x[2+xOffs] / ll[2];        /* sin(ll[1]); */
    xx[3] = x[3+xOffs] * coslon + x[4+xOffs] * sinlon;
    xx[4] = -x[3+xOffs] * sinlon + x[4+xOffs] * coslon;
    l[3+lOffs] = xx[4] / rxy;           /* speed in longitude */
    xx[4] = -sinlat * xx[3] + coslat * x[5+xOffs];
    xx[5] =  coslat * xx[3] + sinlat * x[5+xOffs];
    l[4+lOffs] = xx[4] / ll[2];         /* speed in latitude */
    l[5+lOffs] = xx[5];                 /* speed in radius */
    l[0+lOffs] = ll[0];                 /* return position */
    l[1+lOffs] = ll[1];
    l[2+lOffs] = ll[2];
  }

  /* conversion of position and speed
   * from polar (l[6]) to cartesian coordinates (x[6])
   * x = l is allowed
   * explanation s. swi_cartpol_sp()
   */
  public void swi_polcart_sp(double l[], double x[]) {
    swi_polcart_sp(l, 0, x, 0);
  }
  public void swi_polcart_sp(double l[], int lOffs, double x[], int xOffs) {
    double sinlon, coslon, sinlat, coslat;
    double xx[]=new double[6], rxy, rxyz;
    /* zero speed */
    if (l[3+lOffs] == 0 && l[4+lOffs] == 0 && l[5+lOffs] == 0) {
      x[3+xOffs] = x[4+xOffs] = x[5+xOffs] = 0;
      swi_polcart(l, lOffs, x, xOffs);
      return;
    }
    /* position */
    coslon = Math.cos(l[0+lOffs]);
    sinlon = Math.sin(l[0+lOffs]);
    coslat = Math.cos(l[1+lOffs]);
    sinlat = Math.sin(l[1+lOffs]);
    xx[0] = l[2+lOffs] * coslat * coslon;
    xx[1] = l[2+lOffs] * coslat * sinlon;
    xx[2] = l[2+lOffs] * sinlat;
    /* speed; explanation s. swi_cartpol_sp(), same method the other way round*/
    rxyz = l[2+lOffs];
    rxy = Math.sqrt(xx[0] * xx[0] + xx[1] * xx[1]);
    xx[5] = l[5+lOffs];
    xx[4] = l[4+lOffs] * rxyz;
    x[5+xOffs] = sinlat * xx[5] + coslat * xx[4];       /* speed z */
    xx[3] = coslat * xx[5] - sinlat * xx[4];
    xx[4] = l[3+lOffs] * rxy;
    x[3+xOffs] = coslon * xx[3] - sinlon * xx[4];       /* speed x */
    x[4+xOffs] = sinlon * xx[3] + coslon * xx[4];       /* speed y */
    x[0+xOffs] = xx[0];                                 /* return position */
    x[1+xOffs] = xx[1];
    x[2+xOffs] = xx[2];
  }

  public double swi_dot_prod_unit(double[] x, double[] y) {
    double dop = x[0]*y[0]+x[1]*y[1]+x[2]*y[2];
    double e1 = Math.sqrt(x[0]*x[0]+x[1]*x[1]+x[2]*x[2]);
    double e2 = Math.sqrt(y[0]*y[0]+y[1]*y[1]+y[2]*y[2]);
    dop /= e1;
    dop /= e2;
    if (dop > 1) {
      dop = 1;
    }
    if (dop < -1) {
      dop = -1;
    }
    return dop;
  }


  /* Obliquity of the ecliptic at Julian date J
   *
   * IAU Coefficients are from:
   * J. H. Lieske, T. Lederle, W. Fricke, and B. Morando,
   * "Expressions for the Precession Quantities Based upon the IAU
   * (1976) System of Astronomical Constants,"  Astronomy and Astrophysics
   * 58, 1-16 (1977).
   *
   * Before or after 200 years from J2000, the formula used is from:
   * J. Laskar, "Secular terms of classical planetary theories
   * using the results of general theory," Astronomy and Astrophysics
   * 157, 59070 (1986).
   *
   * Bretagnon, P. et al.: 2003, "Expressions for Precession Consistent with 
   * the IAU 2000A Model". A&A 400,785
   *
   *  See precess and page B18 of the Astronomical Almanac.
   */
  public double swi_epsiln(double J) {
    double T, eps;
    T = (J - 2451545.0)/36525.0;
    if (PREC_IAU_1976 && Math.abs(T) <= PREC_IAU_1976_CTIES ) {
      eps = (((1.813e-3*T-5.9e-4)*T-46.8150)*T+84381.448)*SwissData.DEGTORAD/3600;
    } else if (PREC_IAU_2003 && Math.abs(T) <= PREC_IAU_2003_CTIES) {
      eps =  (((((-4.34e-8 * T -5.76e-7) * T +2.0034e-3) * T -1.831e-4) * T -46.836769) * T + 84381.406) * SwissData.DEGTORAD / 3600.0;
    } else if (PREC_BRETAGNON_2003) {
      eps =  ((((((-3e-11 * T - 2.48e-8) * T -5.23e-7) * T +1.99911e-3) * T -1.667e-4) * T -46.836051) * T + 84381.40880) * SwissData.DEGTORAD / 3600.0;/* */
    } else if (PREC_SIMON_1994) {
      eps =  (((((2.5e-8 * T -5.1e-7) * T +1.9989e-3) * T -1.52e-4) * T -46.80927) * T + 84381.412) * SwissData.DEGTORAD / 3600.0;/* */
    } else if (PREC_WILLIAMS_1994) {
      eps =  ((((-1.0e-6 * T +2.0e-3) * T -1.74e-4) * T -46.833960) * T + 84381.409) * SwissData.DEGTORAD / 3600.0;/* */
    } else { /* PREC_LASKAR_1986 */
      T /= 10.0;
      eps = ((((((((( 2.45e-10*T + 5.79e-9)*T + 2.787e-7)*T
      + 7.12e-7)*T - 3.905e-5)*T - 2.4967e-3)*T
      - 5.138e-3)*T + 1.99925)*T - 0.0155)*T - 468.093)*T
      + 84381.448;
      eps *= SwissData.DEGTORAD/3600;
    }
    return(eps);
  }

  /* Precession of the equinox and ecliptic
   * from epoch Julian date J to or from J2000.0
   *
   * Program by Steve Moshier.
   * Changes in program structure by Dieter Koch.
   *
   * #define PREC_WILLIAMS_1994 1
   * James G. Williams, "Contributions to the Earth's obliquity rate,
   * precession, and nutation,"  Astron. J. 108, 711-724 (1994).
   *
   * #define PREC_SIMON_1994 0
   * J. L. Simon, P. Bretagnon, J. Chapront, M. Chapront-Touze', G. Francou,
   * and J. Laskar, "Numerical Expressions for precession formulae and
   * mean elements for the Moon and the planets," Astronomy and Astrophysics
   * 282, 663-683 (1994).
   *
   * #define PREC_IAU_1976 0
   * IAU Coefficients are from:
   * J. H. Lieske, T. Lederle, W. Fricke, and B. Morando,
   * "Expressions for the Precession Quantities Based upon the IAU
   * (1976) System of Astronomical Constants,"  Astronomy and
   * Astrophysics 58, 1-16 (1977).
   *
   * #define PREC_LASKAR_1986 0
   * Newer formulas that cover a much longer time span are from:
   * J. Laskar, "Secular terms of classical planetary theories
   * using the results of general theory," Astronomy and Astrophysics
   * 157, 59070 (1986).
   *
   * See also:
   * P. Bretagnon and G. Francou, "Planetary theories in rectangular
   * and spherical variables. VSOP87 solutions," Astronomy and
   * Astrophysics 202, 309-315 (1988).
   *
   * Laskar's expansions are said by Bretagnon and Francou
   * to have "a precision of about 1" over 10000 years before
   * and after J2000.0 in so far as the precession constants p^0_A
   * and epsilon^0_A are perfectly known."
   *
   * Bretagnon and Francou's expansions for the node and inclination
   * of the ecliptic were derived from Laskar's data but were truncated
   * after the term in T**6. I have recomputed these expansions from
   * Laskar's data, retaining powers up to T**10 in the result.
   *
   * The following table indicates the differences between the result
   * of the IAU formula and Laskar's formula using four different test
   * vectors, checking at J2000 plus and minus the indicated number
   * of years.
   *
   *   Years       Arc
   * from J2000  Seconds
   * ----------  -------
   *        0       0
   *      100     .006
   *      200     .006
   *      500     .015
   *     1000     .28
   *     2000    6.4
   *     3000   38.
   *    10000 9400.
   */
  /* In WILLIAMS and SIMON, Laskar's terms of order higher than t^4
     have been retained, because Simon et al mention that the solution
     is the same except for the lower order terms.  */

  static final double pAcof[] = {
   -8.66e-10, -4.759e-8, 2.424e-7, 1.3095e-5, 1.7451e-4, -1.8055e-3,
   -0.235316, 0.076, 110.5407, 50287.70000 };
  static final double nodecof[] = {
    6.6402e-16, -2.69151e-15, -1.547021e-12, 7.521313e-12, 1.9e-10,
    -3.54e-9, -1.8103e-7,  1.26e-7,  7.436169e-5,
    -0.04207794833,  3.052115282424};
  static final double inclcof[] = {
    1.2147e-16, 7.3759e-17, -8.26287e-14, 2.503410e-13, 2.4650839e-11,
    -5.4000441e-11, 1.32115526e-9, -6.012e-7, -1.62442e-5,
    0.00227850649, 0.0 };
  



  /* Subroutine arguments:
   *
   * R = rectangular equatorial coordinate vector to be precessed.
   *     The result is written back into the input vector.
   * J = Julian date
   * direction =
   *      Precess from J to J2000: direction = 1
   *      Precess from J2000 to J: direction = -1
   * Note that if you want to precess from J1 to J2, you would
   * first go from J1 to J2000, then call the program again
   * to go from J2000 to J2.
   */
  public int swi_precess(double R[], double J, int direction ) {
    return swi_precess(R, 0, J, direction);
  }
  public int swi_precess(double R[], int rOffs, double J, int direction ) {
    double sinth, costh, sinZ, cosZ, sinz, cosz;
    double eps, sineps, coseps;
    double A, B, T, Z, z, TH, pA, W;
    double x[]=new double[3];
    int pn;
    int i;
    if( J == SwephData.J2000 ) {
      return(0);
    }
    /* Each precession angle is specified by a polynomial in
     * T = Julian centuries from J2000.0.  See AA page B18.
     */
    T = (J - SwephData.J2000)/36525.0;
    /* Use IAU formula for a few centuries.  */
    if (PREC_IAU_1976 && Math.abs(T) <= PREC_IAU_1976_CTIES) {
      Z =  (( 0.017998*T + 0.30188)*T + 2306.2181)*T*SwissData.DEGTORAD/3600;
      z =  (( 0.018203*T + 1.09468)*T + 2306.2181)*T*SwissData.DEGTORAD/3600;
      TH = ((-0.041833*T - 0.42665)*T + 2004.3109)*T*SwissData.DEGTORAD/3600;
    } else if (PREC_IAU_2003 && Math.abs(T) <= PREC_IAU_2003_CTIES) {
      Z =  (((((- 0.0000003173*T - 0.000005971)*T + 0.01801828)*T + 0.2988499)*T + 2306.083227)*T + 2.650545)*SwissData.DEGTORAD/3600;
      z =  (((((- 0.0000002904*T - 0.000028596)*T + 0.01826837)*T + 1.0927348)*T + 2306.077181)*T - 2.650545)*SwissData.DEGTORAD/3600;
      TH = ((((-0.00000011274*T - 0.000007089)*T - 0.04182264)*T - 0.4294934)*T + 2004.191903)*T*SwissData.DEGTORAD/3600;
      /* AA 2006 B28:
      Z =  (((((- 0.0000002*T - 0.0000327)*T + 0.0179663)*T + 0.3019015)*T + 2306.0809506)*T + 2.5976176)*SwissData.DEGTORAD/3600;
      z =  (((((- 0.0000003*T - 0.000047)*T + 0.0182237)*T + 1.0947790)*T + 2306.0803226)*T - 2.5976176)*SwissData.DEGTORAD/3600;
      TH = ((((-0.0000001*T - 0.0000601)*T - 0.0418251)*T - 0.4269353)*T + 2004.1917476)*T*SwissData.DEGTORAD/3600;
      */
    } else if (PREC_BRETAGNON_2003) {
      Z =  ((((((-0.00000000013*T - 0.0000003040)*T - 0.000005708)*T + 0.01801752)*T + 0.3023262)*T + 2306.080472)*T + 2.72767)*SwissData.DEGTORAD/3600;
      z =  ((((((-0.00000000005*T - 0.0000002486)*T - 0.000028276)*T + 0.01826676)*T + 1.0956768)*T + 2306.076070)*T - 2.72767)*SwissData.DEGTORAD/3600;
      TH = ((((((0.000000000009*T + 0.00000000036)*T -0.0000001127)*T - 0.000007291)*T - 0.04182364)*T - 0.4266980)*T + 2004.190936)*T*SwissData.DEGTORAD/3600;
    } else {
      /* Implementation by elementary rotations using Laskar's expansions.
       * First rotate about the x axis from the initial equator
       * to the ecliptic. (The input is equatorial.)
       */
      if( direction == 1 ) {
        eps = swi_epsiln(J); /* To J2000 */
      } else {
        eps = swi_epsiln(SwephData.J2000); /* From J2000 */
      }
      sineps = Math.sin(eps);
      coseps = Math.cos(eps);
      x[0] = R[0+rOffs];
      z = coseps*R[1+rOffs] + sineps*R[2+rOffs];
      x[2] = -sineps*R[1+rOffs] + coseps*R[2+rOffs];
      x[1] = z;
      /* Precession in longitude */
      T /= 10.0; /* thousands of years */
      pn=0; //p = pAcof;
      pA = pAcof[pn]; pn++;
      for( i=0; i<9; i++ ) {
        pA = pA * T + pAcof[pn]; pn++;
      }
      pA *= SwissData.DEGTORAD/3600 * T;
      /* Node of the moving ecliptic on the J2000 ecliptic.
       */
      pn=0; // p = nodecof;
      W = nodecof[pn]; pn++;
      for( i=0; i<10; i++ ) {
        W = W * T + nodecof[pn]; pn++;
      }
      /* Rotate about z axis to the node.
       */
      if( direction == 1 ) {
        z = W + pA;
      } else {
        z = W;
      }
      B = Math.cos(z);
      A = Math.sin(z);
      z = B * x[0] + A * x[1];
      x[1] = -A * x[0] + B * x[1];
      x[0] = z;
      /* Rotate about new x axis by the inclination of the moving
       * ecliptic on the J2000 ecliptic.
       */
      pn=0; // p = inclcof;
      z = inclcof[pn]; pn++;
      for( i=0; i<10; i++ ) {
        z = z * T + inclcof[pn]; pn++;
      }
      if( direction == 1 ) {
        z = -z;
      }
      B = Math.cos(z);
      A = Math.sin(z);
      z = B * x[1] + A * x[2];
      x[2] = -A * x[1] + B * x[2];
      x[1] = z;
      /* Rotate about new z axis back from the node.
       */
      if( direction == 1 ) {
        z = -W;
      } else {
        z = -W - pA;
      }
      B = Math.cos(z);
      A = Math.sin(z);
      z = B * x[0] + A * x[1];
      x[1] = -A * x[0] + B * x[1];
      x[0] = z;
      /* Rotate about x axis to final equator.
       */
      if( direction == 1 ) {
        eps = swi_epsiln(SwephData.J2000);
      } else {
        eps = swi_epsiln(J);
      }
      sineps = Math.sin(eps);
      coseps = Math.cos(eps);
      z = coseps * x[1] - sineps * x[2];
      x[2] = sineps * x[1] + coseps * x[2];
      x[1] = z;
      for( i=0; i<3; i++ )
        R[i+rOffs] = x[i];
      return(0);
    }
    sinth = Math.sin(TH);
    costh = Math.cos(TH);
    sinZ = Math.sin(Z);
    cosZ = Math.cos(Z);
    sinz = Math.sin(z);
    cosz = Math.cos(z);
    A = cosZ*costh;
    B = sinZ*costh;
    if( direction < 0 ) { /* From J2000.0 to J */
      x[0] =    (A*cosz - sinZ*sinz)*R[0+rOffs]
              - (B*cosz + cosZ*sinz)*R[1+rOffs]
                        - sinth*cosz*R[2+rOffs];
      x[1] =    (A*sinz + sinZ*cosz)*R[0+rOffs]
              - (B*sinz - cosZ*cosz)*R[1+rOffs]
                        - sinth*sinz*R[2+rOffs];
      x[2] =              cosZ*sinth*R[0+rOffs]
                        - sinZ*sinth*R[1+rOffs]
                        + costh*R[2+rOffs];
    }
    else { /* From J to J2000.0 */
      x[0] =    (A*cosz - sinZ*sinz)*R[0+rOffs]
              + (A*sinz + sinZ*cosz)*R[1+rOffs]
                        + cosZ*sinth*R[2+rOffs];
      x[1] =  - (B*cosz + cosZ*sinz)*R[0+rOffs]
              - (B*sinz - cosZ*cosz)*R[1+rOffs]
                        - sinZ*sinth*R[2+rOffs];
      x[2] =            - sinth*cosz*R[0+rOffs]
                        - sinth*sinz*R[1+rOffs]
                        + costh*R[2+rOffs];
    }
    for( i=0; i<3; i++ )
      R[i+rOffs] = x[i];
    return(0);
  }




  /* Nutation IAU 2000A model
   * (MHB2000 luni-solar and planetary nutation, without free core nutation)
   *
   * Function returns nutation in longitude and obliquity in radians with
   * respect to the equinox of date. For the obliquity of the ecliptic
   * the calculation of Lieske & al. (1977) must be used.
   *
   * The precision in recent years is about 0.001 arc seconds.
   *
   * The calculation includes luni-solar and planetary nutation.
   * Free core nutation, which cannot be predicted, is omitted,
   * the error being of the order of a few 0.0001 arc seconds.
   *
   * References:
   *
   * Capitaine, N., Wallace, P.T., Chapront, J., A & A 432, 366 (2005).
   *
   * Chapront, J., Chapront-Touze, M. & Francou, G., A & A 387, 700 (2002).
   *
   * Lieske, J.H., Lederle, T., Fricke, W. & Morando, B., "Expressions
   * for the precession quantities based upon the IAU (1976) System of
   * Astronomical Constants", A & A 58, 1-16 (1977).
   *
   * Mathews, P.M., Herring, T.A., Buffet, B.A., "Modeling of nutation
   * and precession   New nutation series for nonrigid Earth and
   * insights into the Earth's interior", J.Geophys.Res., 107, B4,
   * 2002.
   *
   * Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,
   * Francou, G., Laskar, J., A & A 282, 663-683 (1994).
   *
   * Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M., A & A Supp.
   * Ser. 135, 111 (1999).
   *
   * Wallace, P.T., "Software for Implementing the IAU 2000
   * Resolutions", in IERS Workshop 5.1 (2002).
   *
   * Nutation IAU 2000A series in:
   * Kaplan, G.H., United States Naval Observatory Circular No. 179 (Oct. 2005)
   * aa.usno.navy.mil/publications/docs/Circular_179.html
   *
   * MHB2000 code at
   * - ftp://maia.usno.navy.mil/conv2000/chapter5/IAU2000A.
   * - http://www.iau-sofa.rl.ac.uk/2005_0901/Downloads.html
   */
  int swi_nutation(double J, double nutlo[]) {
    int i, j, k, inls;
    double M, SM, F, D, OM;
    double darg, sinarg, cosarg;
    double dpsi = 0, deps = 0;
    double T = (J - SwephData.J2000 ) / 36525.0;
    /* luni-solar nutation */
    /* Fundamental arguments, Simon & al. (1994) */
    /* Mean anomaly of the Moon. */
    M  = swe_degnorm(( 485868.249036 +
                T*( 1717915923.2178 +
                T*(         31.8792 +
                T*(          0.051635 +
                T*(        - 0.00024470 ))))) / 3600.0) * SwissData.DEGTORAD;
    /* Mean anomaly of the Sun */
    SM = swe_degnorm((1287104.79305 +
                T*(  129596581.0481 +
                T*(        - 0.5532 +
                T*(          0.000136 +
                T*(        - 0.00001149 ))))) / 3600.0) * SwissData.DEGTORAD;
    /* Mean argument of the latitude of the Moon. */
    F   = swe_degnorm(( 335779.526232 +
                T*( 1739527262.8478 +
                T*(       - 12.7512 +
                T*(       -  0.001037 +
                T*(          0.00000417 ))))) / 3600.0) * SwissData.DEGTORAD;
    /* Mean elongation of the Moon from the Sun. */
    D   = swe_degnorm((1072260.70369 +
                T*( 1602961601.2090 +
                T*(        - 6.3706 +
                T*(          0.006593 +
                T*(        - 0.00003169 ))))) / 3600.0) * SwissData.DEGTORAD;
    /* Mean longitude of the ascending node of the Moon. */
    OM  = swe_degnorm(( 450160.398036 +
                T*(  - 6962890.5431 +
                T*(          7.4722 +
                T*(          0.007702 +
                T*(        - 0.00005939 ))))) / 3600.0) * SwissData.DEGTORAD;
    /* luni-solar nutation series, in reverse order, starting with small terms */
    inls = Swenut2000a.NLS_2000B;
    for (i = inls - 1; i >= 0; i--) {
      j = i * 5;
      darg = swe_radnorm((double) Swenut2000a.nls[j + 0] * M  +
                         (double) Swenut2000a.nls[j + 1] * SM +
                         (double) Swenut2000a.nls[j + 2] * F   +
                         (double) Swenut2000a.nls[j + 3] * D   +
                         (double) Swenut2000a.nls[j + 4] * OM);
      sinarg = Math.sin(darg);
      cosarg = Math.cos(darg);
      k = i * 6;
      dpsi += (Swenut2000a.cls[k+0] + Swenut2000a.cls[k+1] * T) * sinarg + Swenut2000a.cls[k+2] * cosarg;
      deps += (Swenut2000a.cls[k+3] + Swenut2000a.cls[k+4] * T) * cosarg + Swenut2000a.cls[k+5] * sinarg;
    }
    nutlo[0] = dpsi * Swenut2000a.O1MAS2DEG;
    nutlo[1] = deps * Swenut2000a.O1MAS2DEG;
    nutlo[0] *= SwissData.DEGTORAD;
    nutlo[1] *= SwissData.DEGTORAD;
    return 0;
  }

  /* GCRS to J2000 */
  void swi_bias(double[] x, int iflag, boolean backward) {
    double xx[]=new double[6], rb[][]=new double[3][3];
    int i;
    rb[0][0] = +0.9999999999999942;
    rb[0][1] = +0.0000000707827948;
    rb[0][2] = -0.0000000805621738;
    rb[1][0] = -0.0000000707827974;
    rb[1][1] = +0.9999999999999969;
    rb[1][2] = -0.0000000330604088;
    rb[2][0] = +0.0000000805621715;
    rb[2][1] = +0.0000000330604145;
    rb[2][2] = +0.9999999999999962;
    if (backward) {
      for (i = 0; i <= 2; i++) {
        xx[i] = x[0] * rb[i][0] +
                x[1] * rb[i][1] +
                x[2] * rb[i][2];
        if ((iflag & SweConst.SEFLG_SPEED) != 0)
          xx[i+3] = x[3] * rb[i][0] +
                x[4] * rb[i][1] +
                x[5] * rb[i][2];
      }
    } else {
      for (i = 0; i <= 2; i++) {
        xx[i] = x[0] * rb[0][i] +
                x[1] * rb[1][i] +
                x[2] * rb[2][i];
        if ((iflag & SweConst.SEFLG_SPEED) != 0)
          xx[i+3] = x[3] * rb[0][i] +
                x[4] * rb[1][i] +
                x[5] * rb[2][i];
      }
    }
    for (i = 0; i <= 2; i++) x[i] = xx[i];
    if ((iflag & SweConst.SEFLG_SPEED) != 0) {
      for (i = 3; i <= 5; i++) x[i] = xx[i];
    }
  }


  /* GCRS to FK5 */
  void swi_icrs2fk5(double[] x, int iflag, boolean backward) {
    double xx[]=new double[6], rb[][]=new double[3][3];
    int i;
    rb[0][0] = +0.9999999999999928;
    rb[0][1] = +0.0000001110223287;
    rb[0][2] = +0.0000000441180557;
    rb[1][0] = -0.0000001110223330;
    rb[1][1] = +0.9999999999999891;
    rb[1][2] = +0.0000000964779176;
    rb[2][0] = -0.0000000441180450;
    rb[2][1] = -0.0000000964779225;
    rb[2][2] = +0.9999999999999943;
    if (backward) {
      for (i = 0; i <= 2; i++) {
        xx[i] = x[0] * rb[i][0] +
                x[1] * rb[i][1] +
                x[2] * rb[i][2];
        if ((iflag & SweConst.SEFLG_SPEED) != 0)
          xx[i+3] = x[3] * rb[i][0] +
                x[4] * rb[i][1] +
                x[5] * rb[i][2];
      }
    } else {
      for (i = 0; i <= 2; i++) {
        xx[i] = x[0] * rb[0][i] +
                x[1] * rb[1][i] +
                x[2] * rb[2][i];
        if ((iflag & SweConst.SEFLG_SPEED) != 0)
          xx[i+3] = x[3] * rb[0][i] +
                x[4] * rb[1][i] +
                x[5] * rb[2][i];
      }
    }
    for (i = 0; i <= 5; i++) x[i] = xx[i];
  }

  /* ************************************************************
  cut the string s at any char in cutlist; put pointers to partial strings
  into cpos[0..n-1], return number of partial strings;
  if less than nmax fields are found, the first empty pointer is
  set to NULL.
  More than one character of cutlist in direct sequence count as one
  separator only! cut_str_any("word,,,word2",","..) cuts only two parts,
  cpos[0] = "word" and cpos[1] = "word2".
  If more than nmax fields are found, nmax is returned and the
  last field nmax-1 rmains un-cut.
  **************************************************************/
  
  public int swi_cutstr(String s, String cutlist, String cpos[], int nmax) {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "SwissLib.swi_cutstr(String, String, String[], int)");
////#ifdef TRACE1
//    DevNull.println("    s: " + s + "\n    cutlist: " + cutlist);
//    for(int z = 0; z < cpos.length; z++) {
//      DevNull.println("    cpos[" + z + "]: " + cpos[z]);
//    }
//    DevNull.println("    nmax: " + nmax);
////#endif /* TRACE1 */
////#endif /* TRACE0 */
    s=s.trim();
    if (s.indexOf('\n')>=0) { s=s.substring(0,s.indexOf('\n')); }
    if (s.indexOf('\r')>=0) { s=s.substring(0,s.indexOf('\r')); }
    java.util.StringTokenizer tk=new java.util.StringTokenizer(s,cutlist,true);
    int n=0;
    while(tk.hasMoreTokens() && n<20) {
      String g=tk.nextToken();
      // Characters in cutlist can be valid characters of the String. If
      // escaped with "\\", join together, what the StringTokenizer separated
// Well, well: 'while g.endsWith("\\\\")', then obviously not, but
// while 'g.endsWith("\\\\\\")', then yes, etc. pp.... So I would have to
// do something about this one "sometime"...
      while (g.endsWith("\\") && tk.hasMoreTokens()) {
        g=g.substring(0,g.length()-1)+tk.nextToken();
        if (tk.hasMoreTokens()) {
          g+=tk.nextToken();
        }
      }
      cpos[n]=g;
      n++;
      if (tk.hasMoreTokens()) { tk.nextToken(); }
    }
    cpos[19]="";
    while(tk.hasMoreTokens()) {
      cpos[19]+=tk.nextToken();
    }
    if (n < nmax) {
      cpos[n] = null;
    }
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
    return n;
  }       /* cutstr */

  /* Apparent Sidereal Time at Greenwich with equation of the equinoxes
   * AA page B6
   *
   * returns sidereal time in hours.
   *
   * Caution. At epoch J2000.0, the 16 decimal precision
   * of IEEE double precision numbers
   * limits time resolution measured by Julian date
   * to approximately 24 microseconds.
   *
   * program returns sidereal hours since sidereal midnight
   * tjd          julian day UT
   * eps          obliquity of ecliptic, degrees
   * nut          nutation, degrees
   */
  
  public double swe_sidtime0( double tjd, double eps, double nut ) {
    double jd0;           /* Julian day at midnight Universal Time */
    double secs;          /* Time of day, UT seconds since UT midnight */
    double eqeq, jd, tu, tt, msday;
    double gmst;
    /* Julian day at given UT */
    jd = tjd;
    jd0 = Math.floor(jd);
    secs = tjd - jd0;
    if( secs < 0.5 ) {
      jd0 -= 0.5;
      secs += 0.5;
    } else {
      jd0 += 0.5;
      secs -= 0.5;
    }
    secs *= 86400.0;
    tu = (jd0 - SwephData.J2000)/36525.0; /* UT1 in centuries after J2000 */
    if (PREC_IAU_2003) {
      tt = (jd0 + SweDate.getDeltaT(jd0) - SwephData.J2000)/36525.0; /* TT in centuries after J2000 */
      gmst = (((-0.000000002454*tt - 0.00000199708)*tt - 0.0000002926)*tt + 0.092772110)*tt*tt + 307.4771013*(tt-tu) + 8640184.79447825*tu + 24110.5493771;
      /* mean solar days per sidereal day at date tu;
       * for the derivative of gmst, we can assume UT1 =~ TT */
      msday = 1 + ((((-0.000000012270*tt - 0.00000798832)*tt - 0.0000008778)*tt + 0.185544220)*tt + 8640184.79447825)/(86400.*36525.);
    } else {
      /* Greenwich Mean Sidereal Time at 0h UT of date */
      gmst = (( -6.2e-6*tu + 9.3104e-2)*tu + 8640184.812866)*tu + 24110.54841;
      /* mean solar days per sidereal day at date tu, = 1.00273790934 in 1986 */
      msday = 1.0 + ((-1.86e-5*tu + 0.186208)*tu + 8640184.812866)/(86400.*36525.);
    }
    /* Local apparent sidereal time at given UT at Greenwich */
    eqeq = 240.0 * nut * Math.cos(eps * SwissData.DEGTORAD);
    gmst = gmst + msday*secs + eqeq  /* + 240.0*tlong */;
    /* Sidereal seconds modulo 1 sidereal day */
    gmst = gmst - 86400.0 * Math.floor( gmst/86400.0 );
    /* return in hours */
    gmst /= 3600;
    return gmst;
  }


  /* sidereal time, without eps and nut as parameters.
   * tjd must be UT !!!
   * for more informsation, see comment with swe_sidtime0()
   */
  
  public double swe_sidtime(double tjd_ut) {
    int i;
    double eps, nutlo[]=new double[2], tsid;
    double tjde = tjd_ut + SweDate.getDeltaT(tjd_ut);
    eps = swi_epsiln(tjde) * SwissData.RADTODEG;
    swi_nutation(tjde, nutlo);
    for (i = 0; i < 2; i++)
      nutlo[i] *= SwissData.RADTODEG;
    tsid = swe_sidtime0(tjd_ut, eps + nutlo[1], nutlo[0]);
    return tsid;
  }


  /* SWISSEPH
   * generates name of ephemeris file
   * file name looks as follows:
   * swephpl.m30, where
   *
   * "sweph"                      "swiss ephemeris"
   * "pl","mo","as"               planet, moon, or asteroid
   * "m"  or "_"                  BC or AD
   *
   * "30"                         start century
   * tjd          = ephemeris file for which julian day
   * ipli         = number of planet
   * fname        = ephemeris file name
   */
//  String swi_gen_filename(double tjd, int ipli, String fname)
  public String swi_gen_filename(SweDate sd, int ipli) {
////#ifdef TRACE0
//    Trace.level++;
//    Trace.trace(Trace.level, "SwissLib.swi_gen_filename(SweDate, int)");
////#ifdef TRACE1
//    DevNull.println("    sd: " + sd + "\n    ipli: " + ipli);
////#endif /* TRACE1 */
////#endif /* TRACE0 */
    int icty;
    int ncties = (int) SwephData.NCTIES;
    int sgn;
    String fname;
////#ifdef ORIGINAL
//    CFmt cv=new CFmt();
////#endif /* ORIGINAL */

    switch(ipli) {
      case SwephData.SEI_MOON:
        fname="semo";
        break;
      case SwephData.SEI_EMB:
      case SwephData.SEI_MERCURY:
      case SwephData.SEI_VENUS:
      case SwephData.SEI_MARS:
      case SwephData.SEI_JUPITER:
      case SwephData.SEI_SATURN:
      case SwephData.SEI_URANUS:
      case SwephData.SEI_NEPTUNE:
      case SwephData.SEI_PLUTO:
      case SwephData.SEI_SUNBARY:
        fname="sepl";
        break;
      case SwephData.SEI_CERES:
      case SwephData.SEI_PALLAS:
      case SwephData.SEI_JUNO:
      case SwephData.SEI_VESTA:
      case SwephData.SEI_CHIRON:
      case SwephData.SEI_PHOLUS:
        fname="seas";
        break;
      default:    /* asteroid */
        String iplNr="00000" + (ipli - SweConst.SE_AST_OFFSET);
        iplNr = iplNr.substring(iplNr.length()-6);
        if ((ipli - SweConst.SE_AST_OFFSET <= 99999)) {
          iplNr = iplNr.substring(1);
        }
        fname = "ast" + ((ipli - SweConst.SE_AST_OFFSET) / 1000) +
                swed.DIR_GLUE + "se" + iplNr + "." + SwephData.SE_FILE_SUFFIX;
////#ifdef TRACE0
//        Trace.level--;
////#endif /* TRACE0 */
        return fname;   /* asteroids: only one file 3000 bc - 3000 ad */
        /* break; */
    }
    /* century of tjd */
    /* if sd.tjd > 1600 then gregorian calendar */
    if (sd.getJulDay() >= 2305447.5) {
      sd.setCalendarType(SweDate.SE_GREG_CAL, SweDate.SE_KEEP_JD);
    /* else julian calendar */
    } else {
      sd.setCalendarType(SweDate.SE_JUL_CAL, SweDate.SE_KEEP_JD);
    }
    /* start century of file containing tjd */
    int year = sd.getYear();
    if (year < 0) {
      sgn = -1;
    } else {
      sgn = 1;
    }
    icty = year / 100;
    if (sgn < 0 && year % 100 != 0) {
      icty -=1;
    }
    while(icty % ncties != 0) {
      icty--;
    }
    /* B.C. or A.D. */
    if (icty < 0) {
      fname+="m";
    } else {
      fname+="_";
    }
    icty = Math.abs(icty);
//  sprintf(fname + strlen(fname), "%02d.%s", icty, SE_FILE_SUFFIX);
    fname+=(icty<10?"0":"")+icty+"."+SwephData.SE_FILE_SUFFIX;
////#ifdef TRACE0
//    Trace.level--;
////#endif /* TRACE0 */
    return fname;
  }

  
  public void swe_split_deg(double ddeg, int roundflag, IntObj ideg,
                            IntObj imin, IntObj isec, DblObj dsecfr,
                            IntObj isgn) {
    double dadd = 0;
    isgn.val = 1;
    if (ddeg < 0) {
      isgn.val = -1;
      ddeg = -ddeg;
    }
    if ((roundflag & SweConst.SE_SPLIT_DEG_ROUND_DEG)!=0) {
      dadd = 0.5;
    } else if ((roundflag & SweConst.SE_SPLIT_DEG_ROUND_MIN)!=0) {
      dadd = 0.5 / 60;
    } else if ((roundflag & SweConst.SE_SPLIT_DEG_ROUND_SEC)!=0) {
      dadd = 0.5 / 3600;
    }
    if ((roundflag & SweConst.SE_SPLIT_DEG_KEEP_DEG)!=0) {
      if ((int) (ddeg + dadd) - (int) ddeg > 0) {
        dadd = 0;
      }
    } else if ((roundflag & SweConst.SE_SPLIT_DEG_KEEP_SIGN)!=0) {
      if ((ddeg % 30) + dadd >= 30) {
        dadd = 0;
      }
    }
    ddeg += dadd;
    if ((roundflag & SweConst.SE_SPLIT_DEG_ZODIACAL)!=0) {
      isgn.val = (int) (ddeg / 30);
      ddeg = ddeg % 30;
    }
    ideg.val = (int) ddeg;
    ddeg -= ideg.val;
    imin.val = (int) (ddeg * 60);
    ddeg -= imin.val / 60.0;
    isec.val = (int) (ddeg * 3600);
    if ((roundflag & (SweConst.SE_SPLIT_DEG_ROUND_DEG | SweConst.SE_SPLIT_DEG_ROUND_MIN | SweConst.SE_SPLIT_DEG_ROUND_SEC))==0) {
      dsecfr.val = ddeg * 3600 - isec.val;
    }
  }  /* end split_deg */

  public double swi_kepler(double E, double M, double ecce) {
    double dE = 1, E0;
    double x;
    /* simple formula for small eccentricities */
    if (ecce < 0.4) {
      while(dE > 1e-12) {
        E0 = E;
        E = M + ecce * Math.sin(E0);
        dE = Math.abs(E - E0);
      }
    /* complicated formula for high eccentricities */
    } else {
      while(dE > 1e-12) {
        E0 = E;
        /*
         * Alois 21-jul-2000: workaround an optimizer problem in gcc
         * swi_mod2PI sees very small negative argument e-322 and returns +2PI;
         * we avoid swi_mod2PI for small x.
         */
        x = (M + ecce * Math.sin(E0) - E0) / (1 - ecce * Math.cos(E0));
        dE = Math.abs(x);
        if (dE < 1e-2) {
          E = E0 + x;
        } else {
          E = swi_mod2PI(E0 + x);
          dE = Math.abs(E - E0);
        }
      }
    }
    return E;
  }

  public void swi_FK4_FK5(double xp[], double tjd) {
    if (xp[0] == 0 && xp[1] == 0 && xp[2] == 0) {
      return;
    }
    swi_cartpol(xp, xp);
    /* according to Expl.Suppl., p. 167f. */
    xp[0] += (0.035 + 0.085 * (tjd - SwephData.B1950) / 36524.2198782) / 3600 * 15 * SwissData.DEGTORAD;
    xp[3] += (0.085 / 36524.2198782) / 3600 * 15 * SwissData.DEGTORAD;
    swi_polcart(xp, xp);
  }

  public void swi_FK5_FK4(double[] xp, double tjd) {
    if (xp[0] == 0 && xp[1] == 0 && xp[2] == 0) {
      return;
    }
    swi_cartpol(xp, xp);
    /* according to Expl.Suppl., p. 167f. */
    xp[0] -= (0.035 + 0.085 * (tjd - SwephData.B1950) / 36524.2198782) / 3600 * 15 * SwissData.DEGTORAD;
    xp[3] -= (0.085 / 36524.2198782) / 3600 * 15 * SwissData.DEGTORAD;
    swi_polcart(xp, xp);
  }

//////////////////////////////////////////////////////////////////////////////
// swejpl.c: /////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

  
  public int swe_d2l(double x) {
    if (x >=0.) {
      return ((int) (x + 0.5));
    } else {
      return (- (int) (0.5 - x));
    }
  }

  
  public double swe_difdeg2n(double p1, double p2) {
    double dif;
    dif = swe_degnorm(p1 - p2);
    if (dif  >= 180.0) {
      return (dif - 360.0);
    }
    return (dif);
  }

// Well: used by Swetest.java... //#ifndef ASTROLOGY
  public double swe_difrad2n(double p1, double p2) {
    double dif;
    dif = swe_radnorm(p1 - p2);
    if (dif  >= SwephData.TWOPI / 2) {
      return (dif - SwephData.TWOPI);
    }
    return (dif);
  }
// Well: used by Swetest.java... //#endif /* ASTROLOGY */

//////////////////////////////////////////////////////////////////////////////
// In this Java port only: ///////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
  
  public static synchronized double atof(String src) {
    // atof() (in C) allows extra strings after the number, and even no number
    // at all, so we have to work around this...
    int idx=0;
    src=src.trim();
    while(idx<src.length() &&
         (Character.isDigit(src.charAt(idx)) || src.charAt(idx)=='.')) {
      idx++;
    }
    String sout=src.substring(0,idx).trim();
    if (sout.length()==0 || sout.replace('.',' ').trim().length()==0) {
      return 0.;
    }
    return Double.valueOf(sout).doubleValue();
  }

  
  public static synchronized int atoi(String src) {
    // atoi() (in C) allows extra strings after the number, and even no number
    // at all, so we have to work around this...
    int idx=0;
    src=src.trim();
    while(idx<src.length() && Character.isDigit(src.charAt(idx))) {
      idx++;
    }
    String sout=src.substring(0,idx).trim();
    if (sout.length()==0 || sout.replace('.',' ').trim().length()==0) {
      return 0;
    }
    return Integer.valueOf(sout).intValue();
  }

static final double PREC_IAU_CTIES=2.0; // J2000 +/- two centuries

} // End of class SwissLib.



class TCPlanet extends TransitCalculator {


  private int planet;
  private int idx = 0; // The index into the xx[] array in swe_calc() to use:
  private int tflags = 0; // The transit flags
  private  int flags = 0;  // The calculation flags for swe_calc()
  private  double min = 0;
  private  double max = 0;
  // The y = f(x) value to reach, speaking mathematically...
  private double offset = 0.;



double minVal = 0., maxVal = 0.;  // Thinking about it...


  
  public TCPlanet(SwissEph sw, int planet, int flags, double offset) {
    // Check parameter: //////////////////////////////////////////////////////
    // List of all valid flags:
    this.tflags = flags;
    int vFlags = SweConst.SEFLG_EPHMASK |
                 SweConst.SEFLG_TOPOCTR |
                 SweConst.SEFLG_HELCTR |
                 SweConst.SEFLG_NOABERR |
                 SweConst.SEFLG_NOGDEFL |
                 SweConst.SEFLG_SIDEREAL |
                 SweConst.SEFLG_TRANSIT_LONGITUDE |
                 SweConst.SEFLG_TRANSIT_LATITUDE |
                 SweConst.SEFLG_TRANSIT_DISTANCE |
                 SweConst.SEFLG_TRANSIT_SPEED;
    // NOABERR and NOGDEFL is allowed for HELCTR, as they get set
    // anyway.
    if ((flags & SweConst.SEFLG_HELCTR) != 0) {
      vFlags |= SweConst.SEFLG_NOABERR | SweConst.SEFLG_NOGDEFL;
    }
    if ((flags&~vFlags) != 0) {
      throw new IllegalArgumentException("Invalid flag(s): "+(flags&~vFlags));
    }

    // Allow only one of SEFLG_TRANSIT_LONGITUDE, SEFLG_TRANSIT_LATITUDE, SEFLG_TRANSIT_DISTANCE:
    int type = flags&(SweConst.SEFLG_TRANSIT_LONGITUDE |
                      SweConst.SEFLG_TRANSIT_LATITUDE |
                      SweConst.SEFLG_TRANSIT_DISTANCE);
    if (type != SweConst.SEFLG_TRANSIT_LONGITUDE &&
        type != SweConst.SEFLG_TRANSIT_LATITUDE &&
        type != SweConst.SEFLG_TRANSIT_DISTANCE) {
      throw new IllegalArgumentException("Invalid flag combination '" + flags +
        "': specify at least exactly one of SEFLG_TRANSIT_LONGITUDE (" +
        SweConst.SEFLG_TRANSIT_LONGITUDE + "), SEFLG_TRANSIT_LATITUDE (" +
        SweConst.SEFLG_TRANSIT_LATITUDE + "), SEFLG_TRANSIT_DISTANCE (" +
        SweConst.SEFLG_TRANSIT_DISTANCE + ").");
    }
    if (planet<SweConst.SE_SUN ||
        planet>SweConst.SE_INTP_PERG ||
        planet==SweConst.SE_EARTH) {
      throw new IllegalArgumentException(
          "Unsupported planet number " + planet + " ("+
              sw.swe_get_planet_name(planet) + ")");
    }
    if ((flags & SweConst.SEFLG_HELCTR) != 0 &&
        (planet == SweConst.SE_MEAN_APOG ||
         planet == SweConst.SE_OSCU_APOG ||
         planet == SweConst.SE_MEAN_NODE ||
         planet == SweConst.SE_TRUE_NODE)) {
      throw new IllegalArgumentException(
          "Unsupported planet number " + planet + " (" +
              sw.swe_get_planet_name(planet) + ") for heliocentric " +
              "calculations");
    }

    this.planet = planet;

    this.sw = sw;
    if (this.sw == null) {
      this.sw = new SwissEph();
    }


    // The index into the xx[] array in swe_calc() to use:
    if ((flags&SweConst.SEFLG_TRANSIT_LATITUDE) != 0) { // Calculate latitudinal transits
      idx = 1;
    } else if ((flags&SweConst.SEFLG_TRANSIT_DISTANCE) != 0) { // Calculate distance transits
      idx = 2;
    }
    if ((flags&SweConst.SEFLG_TRANSIT_SPEED) != 0) { // Calculate speed transits
      idx += 3;
      flags |= SweConst.SEFLG_SPEED;
    }

    // Eliminate SEFLG_TRANSIT_* flags for use in swe_calc():
    flags &= ~(SweConst.SEFLG_TRANSIT_LONGITUDE |
               SweConst.SEFLG_TRANSIT_LATITUDE |
               SweConst.SEFLG_TRANSIT_DISTANCE |
               SweConst.SEFLG_TRANSIT_SPEED);
    this.flags = flags;


    rollover = (idx == 0);

    this.offset = checkOffset(offset);

    max = getSpeed(false);
    min = getSpeed(true);
  }

  
  public boolean getRollover() {
    return rollover;
  }
  
  public void setOffset(double value) {
    offset = checkOffset(value);
  }
  
  public double getOffset() {
    return offset;
  }
  
  public Object[] getObjectIdentifiers() {
    return new Object[]{"" + planet};
  }




  //////////////////////////////////////////////////////////////////////////////

  protected double calc(double jdET) {
    StringBuffer serr = new StringBuffer();
    double[] xx = new double[6];

    int ret = sw.swe_calc(jdET, planet, flags, xx, serr);
    if (ret<0) {
      throw new SwissephException(jdET, SwissephException.UNDEFINED,
          "Calculation failed with return code "+ret+":\n"+serr.toString());
    }

    return xx[idx];
  }


  protected double getMaxSpeed() {
    return max;
  }
  protected double getMinSpeed() {
    return min;
  }


  protected double getTimePrecision(double degPrec) {
    // Recalculate degPrec to mean the minimum  time, in which the planet can
    // possibly move that degree:
    double maxTimePerDeg = Math.max(Math.abs(min),Math.abs(max));
    if (maxTimePerDeg != 0.) {
      return degPrec / maxTimePerDeg;
    }
    return 1E-9;
  }

  protected double getDegreePrecision(double jd) {
    // Calculate the planet's minimum movement regarding the maximum available
    // precision.
    //
    // For all calculations, we assume the following minimum exactnesses
    // based on the discussions on http://www.astro.com/swisseph, even though
    // these values are nothing more than very crude estimations which should
    // leave us on the save side always, even more, when seeing that we always
    // consider the maximum possible speed / acceleration of a planet in the
    // transit calculations and not the real speed.
    //
    // Take degPrec to be the minimum exact degree in longitude
    double degPrec = 0.005;
    if (idx>2) { // Speed
      // "The speed precision is now better than 0.002" for all planets"
      degPrec = 0.002;
    } else { // Degrees
      // years 1980 to 2099:              0.005"
      // years before 1980:               0.08"   (from sun to jupiter)
      // years 1900 to 1980:              0.08"   (from saturn to neptune) (added: nodes)
      // years before 1900:               1"      (from saturn to neptune) (added: nodes)
      // years after 2099:                same as before 1900
      //
      if (planet>=SweConst.SE_SUN && planet<=SweConst.SE_JUPITER) {
        if (jd<1980 || jd>2099) {
          degPrec = 0.08;
        }
      } else {
        if (jd>=1900 && jd<1980) {
          degPrec = 0.08;
        } else if (jd<1900 || jd>2099) { // Unclear about true nodes...
          degPrec = 1;
        }
      }
    }
    degPrec/=3600.;
    degPrec*=0.5; // We take the precision to BETTER THAN ... as it is stated somewhere

    // We recalculate these degrees to the minimum time difference that CAN
    // possibly give us data differing more than the above given precision.
    switch (idx) {
      case 0: // Longitude
      case 1: // Latitude
      case 3: // Speed in longitude
      case 4: // Speed in latitude
        break;
      case 2: // Distance
      case 5: // Speed in distance
        // We need to recalculate the precision in degrees to a distance value.
        // For this we need the maximum distance to the centre of calculation,
        // which is the barycentre for the main planets.
        degPrec *= sw.ext.maxBaryDist[planet];
    }

    return degPrec;

    // Barycentre:
    //            0.981683040      1.017099581  (Barycenter of the earth!)
    // Sun:       0.982747149 AU   1.017261973 AU
    // Moon:      0.980136691 AU   1.019846623 AU
    // Mercury:   0.307590579 AU   0.466604085 AU
    // Venus:     0.717960758 AU   0.728698831 AU
    // Mars:      1.382830768 AU   0.728698831 AU
    // Jupiter:   5.448547595 AU   4.955912195 AU
    // Saturn:   10.117683425 AU   8.968685733 AU
    // Uranus:   18.327870391 AU  19.893326756 AU
    // Neptune:  29.935653168 AU  30.326750627 AU
    // Pluto:    29.830132096 AU  41.499626899 AU
    // MeanNode:  0.002569555 AU   0.002569555 AU
    // TrueNode:  0.002361814 AU   0.002774851 AU

    //
    // Minimum and maximum (barycentric) distances:
    // Sun:       0.000095 AU      0.01034 AU
    // Moon:      0.972939 AU      1.02625 AU
    // Mercury:   0.298782 AU      0.47569 AU
    // Venus:     0.709190 AU      0.73723 AU
    // Mars:      1.370003 AU      1.67685 AU
    // Jupiter:   4.912031 AU      5.47705 AU
    // Saturn:    8.948669 AU     10.13792 AU
    // Uranus:   18.257511 AU     20.12033 AU
    // Neptune:  29.780622 AU     30.36938 AU
    // Pluto:    29.636944 AU     49.43648 AU
    // MeanNode:  -        AU      -       AU ?
    // TrueNode:  -        AU      -       AU ?


    // Maximum and minimum (geocentric) distances:
    // Sun:        1.016688129 AU   0.983320477 AU
    // Moon:       0.002710279 AU   0.002439921 AU
    // Mercury:    0.549188094 AU   1.448731236 AU

    // Saturn:     7.84 / 7.85 AU  11.25/11.26  AU
    // Uranus:    21.147/21.148 AU              AU

  }


  //////////////////////////////////////////////////////////////////////////////

  private double checkOffset(double val) {
    // Similar rollover considerations for the latitude will be necessary, if
    // swe_calc() would return latitudinal values beyond -90 and +90 degrees.

    if (rollover) {        // Longitude from 0 to 360 degrees:
      while (val < 0.) { val += 360.; }
      val %= 360.;
      minVal = 0.;
      maxVal = 360.;
    } else if (idx == 1) { // Latitude from -90 to +90 degrees:
      while (val < -90.) { val += 180.; }
      while (val >  90.) { val -= 180.; }
      minVal = -90.;
      maxVal = +90.;
    }
    return val;
  }


  private double getSpeed(boolean min) {
    boolean lat = ((tflags&SweConst.SEFLG_TRANSIT_LATITUDE) != 0);
    boolean dist = ((tflags&SweConst.SEFLG_TRANSIT_DISTANCE) != 0);
    boolean speed = ((tflags&SweConst.SEFLG_TRANSIT_SPEED) != 0);
    boolean topo = ((tflags&SweConst.SEFLG_TOPOCTR) != 0);
    boolean helio = ((tflags&SweConst.SEFLG_HELCTR) != 0);

    // Some topocentric speeds are very different to the geocentric
    // speeds, so we use other values than for geocentric calculations:
    if (topo) {
      if (!sw.swed.geopos_is_set) {
        throw new IllegalArgumentException("Geographic position is not set for "+
                                           "requested topocentric calculations.");
      }
      if (sw.swed.topd.geoalt>50000.) {
        throw new IllegalArgumentException("Topocentric transit calculations "+
                                           "are restricted to a maximum "+
                                           "altitude of 50km so far.");
      } else if (sw.swed.topd.geoalt<-12000000) {
        throw new IllegalArgumentException("Topocentric transit calculations "+
                                           "are restricted to a minimum "+
                                           "altitude of -12000km so far.");
      }
      if (speed) {
        if (lat) {
          return (min?SwephData.minTopoLatAccel[planet]:SwephData.maxTopoLatAccel[planet]);
        } else if (dist) {
          return (min?SwephData.minTopoDistAccel[planet]:SwephData.maxTopoDistAccel[planet]);
        } else {
          return (min?SwephData.minTopoLonAccel[planet]:SwephData.maxTopoLonAccel[planet]);
        }
      } else {
        if (lat) {
          return (min?SwephData.minTopoLatSpeed[planet]:SwephData.maxTopoLatSpeed[planet]);
        } else if (dist) {
          return (min?SwephData.minTopoDistSpeed[planet]:SwephData.maxTopoDistSpeed[planet]);
        } else {
          return (min?SwephData.minTopoLonSpeed[planet]:SwephData.maxTopoLonSpeed[planet]);
        }
      }
    }

    // Heliocentric speeds are very different to the geocentric speeds, so
    // we use other values than for geocentric calculations:
    if (helio) {
      if (speed) {
        if (lat) {
          return (min?SwephData.minHelioLatAccel[planet]:SwephData.maxHelioLatAccel[planet]);
        } else if (dist) {
          return (min?SwephData.minHelioDistAccel[planet]:SwephData.maxHelioDistAccel[planet]);
        } else {
          return (min?SwephData.minHelioLonAccel[planet]:SwephData.maxHelioLonAccel[planet]);
        }
      } else {
        if (lat) {
          return (min?SwephData.minHelioLatSpeed[planet]:SwephData.maxHelioLatSpeed[planet]);
        } else if (dist) {
          return (min?SwephData.minHelioDistSpeed[planet]:SwephData.maxHelioDistSpeed[planet]);
        } else {
          return (min?SwephData.minHelioLonSpeed[planet]:SwephData.maxHelioLonSpeed[planet]);
        }
      }
    }


    // Geocentric:
    if (speed) {
      if (lat) {
        return (min?SwephData.minLatAccel[planet]:SwephData.maxLatAccel[planet]);
      } else if (dist) {
        return (min?SwephData.minDistAccel[planet]:SwephData.maxDistAccel[planet]);
      } else {
        return (min?SwephData.minLonAccel[planet]:SwephData.maxLonAccel[planet]);
      }
    } else {
      if (lat) {
        return (min?SwephData.minLatSpeed[planet]:SwephData.maxLatSpeed[planet]);
      } else if (dist) {
        return (min?SwephData.minDistSpeed[planet]:SwephData.maxDistSpeed[planet]);
      } else {
        return (min?SwephData.minLonSpeed[planet]:SwephData.maxLonSpeed[planet]);
      }
    }
  }

  public String toString() {
    return "[Planet:" + planet + "];Offset:" + getOffset();
  }
}



class TCPlanetPlanet extends TransitCalculator {


  private int pl1, pl2;
  private int idx = 0; // The index into the xx[] array in swe_calc() to use:
  private int tflags = 0; // The transit flags
  private int flags = 0;  // The calculation flags for swe_calc()
  private boolean calcYoga = false;
  private double maxSpeed1;
  private double minSpeed1;
  private double maxSpeed2;
  private double minSpeed2;
  private double minSpeed, maxSpeed;
  // The y = f(x) value to reach, speaking mathematically...
  private double offset = 0.;



double minVal = 0., maxVal = 0.;  // Thinking about it...


  
  public TCPlanetPlanet(SwissEph sw, int pl1, int pl2, int flags, double offset) {
    this.sw = sw;
    if (this.sw == null) {
      this.sw = new SwissEph();
    }

    // Check parameter: //////////////////////////////////////////////////////
    // List of all valid flags:
    this.tflags = flags;
    int vFlags = SweConst.SEFLG_EPHMASK |
                 SweConst.SEFLG_TOPOCTR |
                 SweConst.SEFLG_HELCTR |
                 SweConst.SEFLG_NOABERR |
                 SweConst.SEFLG_NOGDEFL |
                 SweConst.SEFLG_SIDEREAL |
                 SweConst.SEFLG_YOGA_TRANSIT |
                 SweConst.SEFLG_TRANSIT_LONGITUDE |
                 SweConst.SEFLG_TRANSIT_LATITUDE |
                 SweConst.SEFLG_TRANSIT_DISTANCE |
                 SweConst.SEFLG_TRANSIT_SPEED;
    // NOABERR and NOGDEFL is allowed for HELCTR, as they get set
    // anyway.
    if ((flags & SweConst.SEFLG_HELCTR) != 0) {
      vFlags |= SweConst.SEFLG_NOABERR | SweConst.SEFLG_NOGDEFL;
    }
    if ((flags&~vFlags) != 0) {
      throw new IllegalArgumentException("Invalid flag(s): "+(flags&~vFlags));
    }

    // Allow only one of SEFLG_TRANSIT_LONGITUDE, SEFLG_TRANSIT_LATITUDE, SEFLG_TRANSIT_DISTANCE:
    int type = flags&(SweConst.SEFLG_TRANSIT_LONGITUDE |
                      SweConst.SEFLG_TRANSIT_LATITUDE |
                      SweConst.SEFLG_TRANSIT_DISTANCE);
    if (type != SweConst.SEFLG_TRANSIT_LONGITUDE &&
        type != SweConst.SEFLG_TRANSIT_LATITUDE &&
        type != SweConst.SEFLG_TRANSIT_DISTANCE) {
      throw new IllegalArgumentException("Invalid flag combination '" + flags +
        "': specify at least exactly one of SEFLG_TRANSIT_LONGITUDE (" +
        SweConst.SEFLG_TRANSIT_LONGITUDE + "), SEFLG_TRANSIT_LATITUDE (" +
        SweConst.SEFLG_TRANSIT_LATITUDE + "), SEFLG_TRANSIT_DISTANCE (" +
        SweConst.SEFLG_TRANSIT_DISTANCE + ").");
    }
    if (pl1<SweConst.SE_SUN ||
        pl1>SweConst.SE_INTP_PERG ||
        pl1==SweConst.SE_EARTH) {
      throw new IllegalArgumentException(
          "Unsupported planet number " + pl1 + " ("+
              sw.swe_get_planet_name(pl1) + ")");
    }
    if (pl2<SweConst.SE_SUN ||
        pl2>SweConst.SE_INTP_PERG ||
        pl2==SweConst.SE_EARTH) {
      throw new IllegalArgumentException(
          "Unsupported planet number " + pl1 + " ("+
              sw.swe_get_planet_name(pl1) + ")");
    }
    if ((flags & SweConst.SEFLG_HELCTR) != 0 &&
        (pl1 == SweConst.SE_MEAN_APOG ||
         pl1 == SweConst.SE_OSCU_APOG ||
         pl1 == SweConst.SE_MEAN_NODE ||
         pl1 == SweConst.SE_TRUE_NODE)) {
      throw new IllegalArgumentException(
          "Unsupported planet number " + pl1 + " (" +
              sw.swe_get_planet_name(pl1) + ") for heliocentric " +
              "calculations");
    }
    if ((flags & SweConst.SEFLG_HELCTR) != 0 &&
        (pl2 == SweConst.SE_MEAN_APOG ||
         pl2 == SweConst.SE_OSCU_APOG ||
         pl2 == SweConst.SE_MEAN_NODE ||
         pl2 == SweConst.SE_TRUE_NODE)) {
      throw new IllegalArgumentException(
          "Unsupported planet number " + pl2 + " (" +
              sw.swe_get_planet_name(pl2) + ") for heliocentric " +
              "calculations");
    }
    if (pl1 == pl2) {
      throw new IllegalArgumentException(
                   "Transiting and referred planet have to be different!");
    }

    this.pl1 = pl1;
    this.pl2 = pl2;

    calcYoga = ((flags & SweConst.SEFLG_YOGA_TRANSIT) != 0);


    // The index into the xx[] array in swe_calc() to use:
    if ((flags&SweConst.SEFLG_TRANSIT_LATITUDE) != 0) { // Calculate latitudinal transits
      idx = 1;
    } else if ((flags&SweConst.SEFLG_TRANSIT_DISTANCE) != 0) { // Calculate distance transits
      idx = 2;
    }
    if ((flags&SweConst.SEFLG_TRANSIT_SPEED) != 0) { // Calculate speed transits
      idx += 3;
      flags |= SweConst.SEFLG_SPEED;
    }

    // Eliminate SEFLG_TRANSIT_* flags for use in swe_calc():
    flags &= ~(SweConst.SEFLG_TRANSIT_LONGITUDE |
               SweConst.SEFLG_TRANSIT_LATITUDE |
               SweConst.SEFLG_TRANSIT_DISTANCE |
               SweConst.SEFLG_YOGA_TRANSIT |
               SweConst.SEFLG_TRANSIT_SPEED);
    this.flags = flags;

    // Calculate basic parameters: ///////////////////////////////////////////
    rollover = (idx == 0);

    this.offset = checkOffset(offset);


    maxSpeed1=getSpeed(false,pl1);
    minSpeed1=getSpeed(true,pl1);
    maxSpeed2=getSpeed(false,pl2);
    minSpeed2=getSpeed(true,pl2);

    if (calcYoga) {
      minSpeed = minSpeed1+minSpeed2;
      maxSpeed = maxSpeed1+maxSpeed2;
    } else {
      if (rollover) {
        minSpeed = (maxSpeed1>maxSpeed2)?minSpeed1-maxSpeed2:minSpeed2-maxSpeed1;
        maxSpeed = (maxSpeed1>maxSpeed2)?maxSpeed1-minSpeed2:maxSpeed2-minSpeed1;
      } else {
        minSpeed = Math.max(minSpeed1-maxSpeed2, minSpeed2-maxSpeed1);
        maxSpeed = Math.max(maxSpeed1-minSpeed2, maxSpeed2-minSpeed1);
      }
    }

  }

  
  public boolean getRollover() {
    return rollover;
  }
  
  public void setOffset(double value) {
    offset = checkOffset(value);
  }
  
  public double getOffset() {
    return offset;
  }
  
  public Object[] getObjectIdentifiers() {
    return new Object[]{"" + pl1, "" + pl2};
  }




  ///////////////////////////////////////////////////////////////////////////////
  protected double getMaxSpeed() {
    return maxSpeed;
  }
  protected double getMinSpeed() {
    return minSpeed;
  }

  protected double calc(double jdET) {
    StringBuffer serr = new StringBuffer();
    double[] xx1 = new double[6];
    double[] xx2 = new double[6];

    int ret = sw.swe_calc(jdET, pl1, flags, xx1, serr);
    if (ret<0) {
      throw new SwissephException(jdET, SwissephException.UNDEFINED,
          "Calculation failed with return code " + ret + ":\n" +
          serr.toString());
    }

    ret = sw.swe_calc(jdET, pl2, flags, xx2, serr);
    if (ret<0) {
      throw new SwissephException(jdET, SwissephException.UNDEFINED,
          "Calculation failed with return code " + ret + ":\n" +
          serr.toString());
    }

    return xx1[idx] + (calcYoga?xx2[idx]:-xx2[idx]);
  }



  protected double getTimePrecision(double degPrec) {
    // Recalculate degPrec to mean the minimum  time, in which the planet can
    // possibly move that degree:
    double amin = Math.min(Math.abs(minSpeed1),Math.abs(minSpeed2));
    double amax = Math.min(Math.abs(maxSpeed1),Math.abs(maxSpeed2));

    double maxVal = Math.max(Math.abs(amin),Math.abs(amax));
    if (maxVal != 0.) {
      return degPrec / maxVal;
    }
    return 1E-9;
  }

  protected double getDegreePrecision(double jd) {
    // Calculate the planet's minimum movement regarding the maximum available
    // precision.
    //
    // For all calculations, we assume the following minimum exactnesses
    // based on the discussions on http://www.astro.com/swisseph, even though
    // these values are nothing more than very crude estimations which should
    // leave us on the save side always, even more, when seeing that we always
    // consider the maximum possible speed / acceleration of a planet in the
    // transit calculations and not the real speed.
    //
    // Take degPrec to be the minimum exact degree in longitude
    double degPrec = 0.005;
    if (idx>2) { // Speed
      // "The speed precision is now better than 0.002" for all planets"
      degPrec = 0.002;
    } else { // Degrees
      // years 1980 to 2099:              0.005"
      // years before 1980:               0.08"   (from sun to jupiter)
      // years 1900 to 1980:              0.08"   (from saturn to neptune) (added: nodes)
      // years before 1900:               1"      (from saturn to neptune) (added: nodes)
      // years after 2099:                same as before 1900
      //
      if (pl1>=SweConst.SE_SUN && pl1<=SweConst.SE_JUPITER) {
        if (jd<1980 || jd>2099) {
          degPrec = 0.08;
        }
      } else {
        if (jd>=1900 && jd<1980) {
          degPrec = 0.08;
        } else if (jd<1900 || jd>2099) { // Unclear about true nodes...
          degPrec = 1;
        }
      }
      if (pl2>=SweConst.SE_SUN && pl2<=SweConst.SE_JUPITER) {
        if (jd<1980 || jd>2099) {
          degPrec = Math.max(0.08,degPrec);
        }
      } else {
        if (jd>=1900 && jd<1980) {
          degPrec = Math.max(0.08,degPrec);
        } else if (jd<1900 || jd>2099) { // Unclear about true nodes...
          degPrec = Math.max(1,degPrec);
        }
      }
    }
    degPrec/=3600.;
    degPrec*=0.5; // We take the precision to be BETTER THAN ... as it is stated somewhere

    // We recalculate these degrees to the minimum time difference that CAN
    // possibly give us data differing more than the above given precision.
    switch (idx) {
      case 0: // Longitude
      case 1: // Latitude
      case 3: // Speed in longitude
      case 4: // Speed in latitude
        break;
      case 2: // Distance
      case 5: // Speed in distance
        // We need to recalculate the precision in degrees to a distance value.
        // For this we need the maximum distance to the centre of calculation,
        // which is the barycentre for the main planets.
        degPrec *= Math.max(sw.ext.maxBaryDist[pl1],
                            sw.ext.maxBaryDist[pl2]);
    }

    return degPrec;

    // Barycentre:
    //            0.981683040      1.017099581  (Barycenter of the earth!)
    // Sun:       0.982747149 AU   1.017261973 AU
    // Moon:      0.980136691 AU   1.019846623 AU
    // Mercury:   0.307590579 AU   0.466604085 AU
    // Venus:     0.717960758 AU   0.728698831 AU
    // Mars:      1.382830768 AU   0.728698831 AU
    // Jupiter:   5.448547595 AU   4.955912195 AU
    // Saturn:   10.117683425 AU   8.968685733 AU
    // Uranus:   18.327870391 AU  19.893326756 AU
    // Neptune:  29.935653168 AU  30.326750627 AU
    // Pluto:    29.830132096 AU  41.499626899 AU
    // MeanNode:  0.002569555 AU   0.002569555 AU
    // TrueNode:  0.002361814 AU   0.002774851 AU

    //
    // Minimum and maximum (barycentric) distances:
    // Sun:       0.000095 AU      0.01034 AU
    // Moon:      0.972939 AU      1.02625 AU
    // Mercury:   0.298782 AU      0.47569 AU
    // Venus:     0.709190 AU      0.73723 AU
    // Mars:      1.370003 AU      1.67685 AU
    // Jupiter:   4.912031 AU      5.47705 AU
    // Saturn:    8.948669 AU     10.13792 AU
    // Uranus:   18.257511 AU     20.12033 AU
    // Neptune:  29.780622 AU     30.36938 AU
    // Pluto:    29.636944 AU     49.43648 AU
    // MeanNode:  -        AU      -       AU ?
    // TrueNode:  -        AU      -       AU ?


    // Maximum and minimum (geocentric) distances:
    // Sun:        1.016688129 AU   0.983320477 AU
    // Moon:       0.002710279 AU   0.002439921 AU
    // Mercury:    0.549188094 AU   1.448731236 AU

    // Saturn:     7.84 / 7.85 AU  11.25/11.26  AU
    // Uranus:    21.147/21.148 AU              AU

  }


  //////////////////////////////////////////////////////////////////////////////

  private double checkOffset(double val) {
    // Similar rollover considerations for the latitude will be necessary, if
    // swe_calc() would return latitudinal values beyond -90 and +90 degrees.

    if (rollover) {        // Longitude from 0 to 360 degrees:
      while (val < 0.) { val += 360.; }
      val %= 360.;
      minVal = 0.;
      maxVal = 360.;
    } else if (idx == 1) { // Latitude from -90 to +90 degrees:
      while (val < -90.) { val += 180.; }
      while (val >  90.) { val -= 180.; }
      minVal = -90.;
      maxVal = +90.;
    }
    return val;
  }


  private double getSpeed(boolean min, int planet) {
    boolean lat = ((tflags&SweConst.SEFLG_TRANSIT_LATITUDE) != 0);
    boolean dist = ((tflags&SweConst.SEFLG_TRANSIT_DISTANCE) != 0);
    boolean speed = ((tflags&SweConst.SEFLG_TRANSIT_SPEED) != 0);
    boolean topo = ((tflags&SweConst.SEFLG_TOPOCTR) != 0);
    boolean helio = ((tflags&SweConst.SEFLG_HELCTR) != 0);

    // Some topocentric speeds are very different to the geocentric
    // speeds, so we use other values than for geocentric calculations:
    if (topo) {
      if (!sw.swed.geopos_is_set) {
        throw new IllegalArgumentException("Geographic position is not set for "+
                                           "requested topocentric calculations.");
      }
      if (sw.swed.topd.geoalt>50000.) {
        throw new IllegalArgumentException("Topocentric transit calculations "+
                                           "are restricted to a maximum "+
                                           "altitude of 50km so far.");
      } else if (sw.swed.topd.geoalt<-12000000) {
        throw new IllegalArgumentException("Topocentric transit calculations "+
                                           "are restricted to a minimum "+
                                           "altitude of -12000km so far.");
      }
      if (speed) {
        if (lat) {
          return (min?SwephData.minTopoLatAccel[planet]:SwephData.maxTopoLatAccel[planet]);
        } else if (dist) {
          return (min?SwephData.minTopoDistAccel[planet]:SwephData.maxTopoDistAccel[planet]);
        } else {
          return (min?SwephData.minTopoLonAccel[planet]:SwephData.maxTopoLonAccel[planet]);
        }
      } else {
        if (lat) {
          return (min?SwephData.minTopoLatSpeed[planet]:SwephData.maxTopoLatSpeed[planet]);
        } else if (dist) {
          return (min?SwephData.minTopoDistSpeed[planet]:SwephData.maxTopoDistSpeed[planet]);
        } else {
          return (min?SwephData.minTopoLonSpeed[planet]:SwephData.maxTopoLonSpeed[planet]);
        }
      }
    }

    // Heliocentric speeds are very different to the geocentric speeds, so
    // we use other values than for geocentric calculations:
    if (helio) {
      if (speed) {
        if (lat) {
          return (min?SwephData.minHelioLatAccel[planet]:SwephData.maxHelioLatAccel[planet]);
        } else if (dist) {
          return (min?SwephData.minHelioDistAccel[planet]:SwephData.maxHelioDistAccel[planet]);
        } else {
          return (min?SwephData.minHelioLonAccel[planet]:SwephData.maxHelioLonAccel[planet]);
        }
      } else {
        if (lat) {
          return (min?SwephData.minHelioLatSpeed[planet]:SwephData.maxHelioLatSpeed[planet]);
        } else if (dist) {
          return (min?SwephData.minHelioDistSpeed[planet]:SwephData.maxHelioDistSpeed[planet]);
        } else {
          return (min?SwephData.minHelioLonSpeed[planet]:SwephData.maxHelioLonSpeed[planet]);
        }
      }
    }

    // Geocentric:
    if (speed) {
      if (lat) {
        return (min?SwephData.minLatAccel[planet]:SwephData.maxLatAccel[planet]);
      } else if (dist) {
        return (min?SwephData.minDistAccel[planet]:SwephData.maxDistAccel[planet]);
      } else {
        return (min?SwephData.minLonAccel[planet]:SwephData.maxLonAccel[planet]);
      }
    } else {
      if (lat) {
        return (min?SwephData.minLatSpeed[planet]:SwephData.maxLatSpeed[planet]);
      } else if (dist) {
        return (min?SwephData.minDistSpeed[planet]:SwephData.maxDistSpeed[planet]);
      } else {
        return (min?SwephData.minLonSpeed[planet]:SwephData.maxLonSpeed[planet]);
      }
    }
  }

  public String toString() {
    return "[Planets:" + pl1 + "/" + pl2 + "];Offset:" + getOffset();
  }
}


class TopoData {
  double geolon, geolat, geoalt;
  double teval;
  double tjd_ut;
  double xobs[]=new double[6];

}


abstract class TransitCalculator {
  SwissEph sw;

  // This method changes the offset value for the transit
  
  public abstract boolean getRollover();
  
  public abstract void setOffset(double value);
  
  public abstract double getOffset();
  
  public Object[] getObjectIdentifiers() {
    return null;
  }





  //////////////////////////////////////////////////////////////////////////////


  // Rollover from 360 degrees to 0 degrees for planetary longitudinal positions
  // or similar, or continuous and unlimited values:
  protected boolean rollover = false; // We need a rollover of 360 degrees being
                                      // equal to 0 degrees for longitudinal
                                      // position transits only.
  protected double rolloverVal = 360.; // if rollover, we roll over from 360 to 0
                                       // as default. Other values than 0.0 for the
                                       // minimum values are not supported for now.

  // These methods have to return the maxima of the first derivative of the
  // function, mathematically spoken...
  protected abstract double getMaxSpeed();
  protected abstract double getMinSpeed();

  // This method returns the precision in x-direction in an x-y-coordinate
  // system for the transit calculation routine.
  protected abstract double getDegreePrecision(double jdET);

  // This method returns the precision in y-direction in an x-y-coordinate
  // system from the x-direction precision.
  protected abstract double getTimePrecision(double degPrec);

  // This is the main routine, mathematically speaking: returning f(x):
  protected abstract double calc(double jdET);
}

/*
   The swisseph package used herein is a Java port of the Swiss Ephemeris
   of Astrodienst Zuerich, Switzerland. For copyright notices see the file
   LICENSE or - if not included - see at http://www.astro.com for license
   information.

   This small program is heavily based upon sweclips.c from the original
   Swiss Ephemeris package.

   Thomas Mack, mack@ifis.cs.tu-bs.de, 25th of November 2001
*/



class TransitValues {
  TransitCalculator tc = null;
  int tcIndex = 0; // Keep track of which tc is saved to jdET

  double transitVal = 0./0.;
  double jdStart = 0./0.;
  double jdEnd = 0./0.;
  double tvOffset = 0./0.;

  double zTmp = 0./0.;
  double z0 = 0./0.; // The final minimum value
  double zm = 0./0.;
  double zp = 0./0.;

  boolean varyingTransitPoints = false;  // e.g. -lon60+10 with -n, -N, -b -b, -b -B
  boolean duplicateTransitPoints = false; // e.g. -lon60+10 -N / -B only
  boolean outOfTimeRange = false;
  boolean back = false;
  boolean rollover = false;
}


class TransitOffsets {
  int idxOffset = 0;           // The index into the xx[] array in swe_calc*()
                               // 0 to 5: lon / lat / dist / speed in lon /
                               //         lat / dist
  Double[] values = null;      // The transit values, over which the
                               // the transits should be calculated
  double offset = 0.;          // An optional offset to be added to
                               // the transit values on each calculation
                               // iteration
}


class ObjFormatter {
  String postfix = "";
  Object[] arr = null;
  ObjFormatter(Object[] arr, String postfix) {
    this.arr = arr;
    this.postfix = postfix;
  }
  String format(int idx) {
    return arr[idx].toString() + postfix;
  }
}




class TransitArguments {
  // CH-Zuerich:
  double top_long = 8.55;
  double top_lat = 47.38;
  double top_elev = 400;

  // Default values for optional parameter:
  boolean withHeader = true;
  boolean back = false;
  boolean isUt = false; // Time of starting date
  boolean isUT = false; // Time of end date
  boolean calcSpeed = false;
  int sidmode=-1;                 // Means: tropical mode
  int whicheph = SweConst.SEFLG_SWIEPH;
  String ephepath = SweConst.SE_EPHE_PATH;
  String sBeginhour = "";
  double beginhour = 0;
  String pls2 = null;
  int pl2 = -2;                   // Means: not set
  double count = 1;
  // JPL:
  String fname=SweConst.SE_FNAME_DE406;
  String topoS = null;
  boolean convert = false;



  // Derived values:
  boolean countIsSet = false;
  // duplicateTransitPoints, e.g. -lat0+0.01 with -N / -B only
  boolean duplicateTransitPoints = false;   // multiple transit points
  // varyingTransitPoints, e.g. -lat0+0.01 with -N, -n / -b -B, -b -b
  boolean varyingTransitPoints = false;
  boolean yogaTransit = true;
  boolean helio = false;
  int iflag = 0;  // Flags to be used for transit calculations
  int cflag = 0;  // Flags to be used for pure calculations

  boolean outputFormatIsSet = false;
  String outputFormat = "dt";
  double zm = 0;
  double zp = 0;

  // A string containing the type and value of the transit point, e.g.:
  //    +lon0         for yoga transits over 0 degrees in longitude.
  //    -lat0+0.01    for transits over 0 degrees in latitude with 0.01 degree
  //                  increment.
  //    -lon30/45/60/90/120/180/270
  //                  for transits over any of these longitudinal degrees
  String transitValString="";

  // Required parameters:
  int pl1 = -2;
  String pls1 = null;
  String begindate = null;
  String enddate = null;
  String sEndhour = "";
  double endhour = 1./0.;         // Means: not set
  boolean endTimeIsSet = false;


  // Intermediate or other derived parameters:
  TransitOffsets to = null;
  boolean mp1 = false; // More than one planet
  boolean mp2 = false; // More than one planet on relative or yoga transits

  double tjde1 = 0.;
  double tjde2 = 0.;
  int[][] plNumbers = null;
  SweDate   sde1 = new SweDate();
  SweDate   sde2 = new SweDate();
  boolean rollover = false;
  TransitValues v = new TransitValues();
  int idxDuplicates = 0;
  boolean withDuplicates = true;

  double jdET2 = 0.;
}

class TransitResult {
  // The index in the array of all TransitCalculators returning the
  // nearest transit point:
  public int tcsNo = 0;

  // The nearest transit point found, Double.MAX_VALUE or Double.MIN_VALUE,
  // if no transit found:
  public double jdET = 0./0.;

  // The planet numbers:
  public int pl1 = 0;
  public int pl2 = 0;

  public double transitValue = 0./0.;

  public String toString() {
    return "tcs[" + tcsNo + "];pl:" + pl1 + "/" + pl2 + ";" + jdET;
  }
}



class Vedic {
    
    public String getReading(int day, int month, int year, double latitude, double longitude, double time, double greenwichOffset) {

	int SID_METHOD = SweConst.SE_SIDM_LAHIRI;
	String[] signNames = { "Aries","Taurus","Gemini","Cancer","Leo","Virgo",
			       "Libra","Scorpio","Sagittarius","Capricorn","Aquarius",
			       "Pisces"};

	
	double hour = time + (0. / 60.) + greenwichOffset; // IST				
	SwissEph sw = new SwissEph();
	SweDate sd = new SweDate(year, month, day, hour);
	sw.swe_set_sid_mode(SID_METHOD, 0, 0);

	double[] cusps = new double[13];
	double[] acsc = new double[10];
	double[] xp = new double[6];
	StringBuffer serr = new StringBuffer();

	double ayanamsa = sw.swe_get_ayanamsa_ut(sd.getJulDay());
	int flags = SweConst.SEFLG_SIDEREAL;
	int result = sw.swe_houses(sd.getJulDay(), flags, latitude, longitude, 'P', cusps, acsc);

	int ascSign = (int) (acsc[0] / 30) + 1;
	String ascOut = signNames[ascSign-1];
	
	flags = SweConst.SEFLG_SWIEPH | 
	    SweConst.SEFLG_SIDEREAL | 
	    SweConst.SEFLG_NONUT | 
	    SweConst.SEFLG_SPEED;

	int sign;
	int house;
	boolean retrograde = false;
	String output = "{";

	output += "'Ascending': ['" + ascOut + "'],";
	
	int[] planets = { SweConst.SE_SUN, SweConst.SE_MOON, SweConst.SE_MARS, SweConst.SE_MERCURY, SweConst.SE_JUPITER,
			  SweConst.SE_VENUS, SweConst.SE_SATURN, SweConst.SE_TRUE_NODE }; // Some

	for (int p = 0; p < planets.length; p++) {
	    int planet = planets[p];
	    String planetName = sw.swe_get_planet_name(planet);
	    int ret = sw.swe_calc_ut(sd.getJulDay(), planet, flags, xp, serr);
	    sign = (int) (xp[0] / 30) + 1;
	    house = (sign + 12 - ascSign) % 12 + 1;
	    retrograde = (xp[3] < 0);
	    output += String.format("'%s': ['%s',%d],", planetName,signNames[sign-1],house);
	}

	xp[0] = (xp[0] + 180.0) % 360;
	String planetName = "Ketu (true)";
	sign = (int) (xp[0] / 30) + 1;
	house = (sign + 12 - ascSign) % 12 + 1;
	output += String.format("'%s': ['%s',%d]", planetName,signNames[sign-1],house);

	output += "}";	
	return output;
    }

    public void test() {
	int year = 1973;
	int month = 4;
	int day = 24;
	double longitude = 32.85646943314241;
	double latitude = 39.941139297390365;
	double time = 10;
	double greenwichOffset = -3;
	String res = getReading(day, month, year, latitude, longitude, time, greenwichOffset);
	System.out.println(res);		
    }

    public String getReading(String[] args) {
	int day = Integer.valueOf(args[0]);
	int mon = Integer.valueOf(args[1]);
	int year = Integer.valueOf(args[2]);
	double time = Double.valueOf(args[3]);
	double latitude = Double.valueOf(args[4]);
	double longitude = Double.valueOf(args[5]);
	double greenwichOffset = -1 * Double.valueOf(args[6]);
	//System.out.printf("Java received %d %d %d %f %f %f %f", day,mon,year,time,latitude,longitude,offset);
	String res = getReading(day, mon, year, latitude, longitude, time, greenwichOffset);
	//System.out.println(res);		
	return res;
    }
    
    public static void main(String[] args) {
	Vedic v = new Vedic();
	//v.test();
	String res = v.getReading(args);
	System.out.println(res); 
    }
}




class VedicTest {

    
    private static final int SID_METHOD = SweConst.SE_SIDM_LAHIRI;
    private static final String[] signNames = { "Aries","Taurus","Gemini","Cancer","Leo","Virgo",
						"Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"};
    
    public static void main(String[] args) {
	System.out.println((int)'P');
				
	int year = 1973;
	int month = 4;
	int day = 24;
	double longitude = 32.85646943314241;
	double latitude = 39.941139297390365;
	double hour = 10 + (0. / 60.) - 3; // IST
				
	SwissEph sw = new SwissEph();
	SweDate sd = new SweDate(year, month, day, hour);
	System.out.println(sd.getDate(0).toString());
	// Set sidereal mode:
	sw.swe_set_sid_mode(SID_METHOD, 0, 0);

	// Some required variables:
	double[] cusps = new double[13];
	double[] acsc = new double[10];
	double[] xp = new double[6];
	StringBuffer serr = new StringBuffer();

	// Print input details:
	System.out.println("Date (YYYY/MM/DD): " + sd.getYear() + "/" + sd.getMonth() + "/" + sd.getDay() + ", "
			   + toHMS(sd.getHour()));
	System.out.println("Jul. day:  " + sd.getJulDay());
	System.out.println("DeltaT:    " + sd.getDeltaT() * 24 * 3600 + " sec.");
	System.out.println("Location:  " + toDMS(Math.abs(longitude)) + (longitude > 0 ? "E" : "W") + " / "
			   + toDMS(Math.abs(latitude)) + (latitude > 0 ? "N" : "S"));

	// Get and print ayanamsa value for info:
	double ayanamsa = sw.swe_get_ayanamsa_ut(sd.getJulDay());
	System.out.println("Ayanamsa:  " + toDMS(ayanamsa) + " (" + sw.swe_get_ayanamsa_name(SID_METHOD) + ")");

	// Get and print lagna:
	int flags = SweConst.SEFLG_SIDEREAL;
	int result = sw.swe_houses(sd.getJulDay(), flags, latitude, longitude, 'P', cusps, acsc);
	System.out.println("Ascendant: " + toDMS(acsc[0]) + "\n");

	int ascSign = (int) (acsc[0] / 30) + 1;
	System.out.println("Ascendant Sign: " + signNames[ascSign-1] + "\n");

	// Calculate all planets:
	int[] planets = { SweConst.SE_SUN, SweConst.SE_MOON, SweConst.SE_MARS, SweConst.SE_MERCURY, SweConst.SE_JUPITER,
			  SweConst.SE_VENUS, SweConst.SE_SATURN, SweConst.SE_TRUE_NODE }; // Some
	// systems
	// prefer
	// SE_MEAN_NODE

	flags = SweConst.SEFLG_SWIEPH | // fastest method, requires data files
	    SweConst.SEFLG_SIDEREAL | // sidereal zodiac
	    SweConst.SEFLG_NONUT | // will be set automatically for sidereal
	    // calculations, if not set here
	    SweConst.SEFLG_SPEED; // to determine retrograde vs. direct
	// motion
	int sign;
	int house;
	boolean retrograde = false;

	for (int p = 0; p < planets.length; p++) {
	    int planet = planets[p];
	    String planetName = sw.swe_get_planet_name(planet);
	    int ret = sw.swe_calc_ut(sd.getJulDay(), planet, flags, xp, serr);

	    if (ret != flags) {
		if (serr.length() > 0) {
		    System.err.println("Warning: " + serr);
		} else {
		    System.err.println(String.format("Warning, different flags used (0x%x)", ret));
		}
	    }

	    sign = (int) (xp[0] / 30) + 1;
	    System.out.println(planetName);
	    System.out.println(signNames[sign-1]);
	    house = (sign + 12 - ascSign) % 12 + 1;
	    retrograde = (xp[3] < 0);

	    System.out.printf("%-12s: %s %c; sign: %2d; %s in house %2d\n", planetName, toDMS(xp[0]),
			      (retrograde ? 'R' : 'D'), sign, toDMS(xp[0] % 30), house);
	}
	// KETU
	xp[0] = (xp[0] + 180.0) % 360;
	String planetName = "Ketu (true)";

	sign = (int) (xp[0] / 30) + 1;
	house = (sign + 12 - ascSign) % 12 + 1;

	System.out.printf("%-12s: %s %c; sign: %2d; %s in house %2d\n", planetName, toDMS(xp[0]),
			  (retrograde ? 'R' : 'D'), sign, toDMS(xp[0] % 30), house);
    }

    static String toHMS(double d) {
	d += 0.5 / 3600.; // round to one second
	int h = (int) d;
	d = (d - h) * 60;
	int min = (int) d;
	int sec = (int) ((d - min) * 60);


		
	return String.format("%2d:%02d:%02d", h, min, sec);
    }

    static String toDMS(double d) {
	d += 0.5 / 3600. / 10000.; // round to 1/1000 of a second
	int deg = (int) d;
	d = (d - deg) * 60;
	int min = (int) d;
	d = (d - min) * 60;
	double sec = d;

	return String.format("%3d°%02d'%07.4f\"", deg, min, sec);
    }
	
}
